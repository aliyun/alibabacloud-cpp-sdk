// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_DCDN20180115_H_
#define ALIBABACLOUD_DCDN20180115_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Dcdn20180115 {
class AddDcdnDomainRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  AddDcdnDomainRequestTag() {}

  explicit AddDcdnDomainRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~AddDcdnDomainRequestTag() = default;
};
class AddDcdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkUrl{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> scene{};
  shared_ptr<string> scope{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sources{};
  shared_ptr<vector<AddDcdnDomainRequestTag>> tag{};
  shared_ptr<string> topLevelDomain{};

  AddDcdnDomainRequest() {}

  explicit AddDcdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkUrl) {
      res["CheckUrl"] = boost::any(*checkUrl);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckUrl") != m.end() && !m["CheckUrl"].empty()) {
      checkUrl = make_shared<string>(boost::any_cast<string>(m["CheckUrl"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<AddDcdnDomainRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddDcdnDomainRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<AddDcdnDomainRequestTag>>(expect1);
      }
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~AddDcdnDomainRequest() = default;
};
class AddDcdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddDcdnDomainResponseBody() {}

  explicit AddDcdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddDcdnDomainResponseBody() = default;
};
class AddDcdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDcdnDomainResponseBody> body{};

  AddDcdnDomainResponse() {}

  explicit AddDcdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDcdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDcdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~AddDcdnDomainResponse() = default;
};
class AddDcdnIpaDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkUrl{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> protocol{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> scope{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sources{};
  shared_ptr<string> topLevelDomain{};

  AddDcdnIpaDomainRequest() {}

  explicit AddDcdnIpaDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkUrl) {
      res["CheckUrl"] = boost::any(*checkUrl);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckUrl") != m.end() && !m["CheckUrl"].empty()) {
      checkUrl = make_shared<string>(boost::any_cast<string>(m["CheckUrl"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~AddDcdnIpaDomainRequest() = default;
};
class AddDcdnIpaDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddDcdnIpaDomainResponseBody() {}

  explicit AddDcdnIpaDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddDcdnIpaDomainResponseBody() = default;
};
class AddDcdnIpaDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDcdnIpaDomainResponseBody> body{};

  AddDcdnIpaDomainResponse() {}

  explicit AddDcdnIpaDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDcdnIpaDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDcdnIpaDomainResponseBody>(model1);
      }
    }
  }


  virtual ~AddDcdnIpaDomainResponse() = default;
};
class BatchAddDcdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkUrl{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> scope{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sources{};
  shared_ptr<string> topLevelDomain{};

  BatchAddDcdnDomainRequest() {}

  explicit BatchAddDcdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkUrl) {
      res["CheckUrl"] = boost::any(*checkUrl);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckUrl") != m.end() && !m["CheckUrl"].empty()) {
      checkUrl = make_shared<string>(boost::any_cast<string>(m["CheckUrl"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~BatchAddDcdnDomainRequest() = default;
};
class BatchAddDcdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchAddDcdnDomainResponseBody() {}

  explicit BatchAddDcdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchAddDcdnDomainResponseBody() = default;
};
class BatchAddDcdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchAddDcdnDomainResponseBody> body{};

  BatchAddDcdnDomainResponse() {}

  explicit BatchAddDcdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchAddDcdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchAddDcdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~BatchAddDcdnDomainResponse() = default;
};
class BatchCreateDcdnWafRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};
  shared_ptr<string> ruleConfigs{};

  BatchCreateDcdnWafRulesRequest() {}

  explicit BatchCreateDcdnWafRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (ruleConfigs) {
      res["RuleConfigs"] = boost::any(*ruleConfigs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("RuleConfigs") != m.end() && !m["RuleConfigs"].empty()) {
      ruleConfigs = make_shared<string>(boost::any_cast<string>(m["RuleConfigs"]));
    }
  }


  virtual ~BatchCreateDcdnWafRulesRequest() = default;
};
class BatchCreateDcdnWafRulesResponseBodyRuleIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ruleId{};

  BatchCreateDcdnWafRulesResponseBodyRuleIds() {}

  explicit BatchCreateDcdnWafRulesResponseBodyRuleIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RuleId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ruleId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchCreateDcdnWafRulesResponseBodyRuleIds() = default;
};
class BatchCreateDcdnWafRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<BatchCreateDcdnWafRulesResponseBodyRuleIds> ruleIds{};

  BatchCreateDcdnWafRulesResponseBody() {}

  explicit BatchCreateDcdnWafRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleIds) {
      res["RuleIds"] = ruleIds ? boost::any(ruleIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuleIds"].type()) {
        BatchCreateDcdnWafRulesResponseBodyRuleIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuleIds"]));
        ruleIds = make_shared<BatchCreateDcdnWafRulesResponseBodyRuleIds>(model1);
      }
    }
  }


  virtual ~BatchCreateDcdnWafRulesResponseBody() = default;
};
class BatchCreateDcdnWafRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchCreateDcdnWafRulesResponseBody> body{};

  BatchCreateDcdnWafRulesResponse() {}

  explicit BatchCreateDcdnWafRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchCreateDcdnWafRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchCreateDcdnWafRulesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchCreateDcdnWafRulesResponse() = default;
};
class BatchDeleteDcdnDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> functionNames{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  BatchDeleteDcdnDomainConfigsRequest() {}

  explicit BatchDeleteDcdnDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchDeleteDcdnDomainConfigsRequest() = default;
};
class BatchDeleteDcdnDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchDeleteDcdnDomainConfigsResponseBody() {}

  explicit BatchDeleteDcdnDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchDeleteDcdnDomainConfigsResponseBody() = default;
};
class BatchDeleteDcdnDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchDeleteDcdnDomainConfigsResponseBody> body{};

  BatchDeleteDcdnDomainConfigsResponse() {}

  explicit BatchDeleteDcdnDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteDcdnDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteDcdnDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteDcdnDomainConfigsResponse() = default;
};
class BatchDeleteDcdnWafRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ruleIds{};

  BatchDeleteDcdnWafRulesRequest() {}

  explicit BatchDeleteDcdnWafRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleIds) {
      res["RuleIds"] = boost::any(*ruleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      ruleIds = make_shared<string>(boost::any_cast<string>(m["RuleIds"]));
    }
  }


  virtual ~BatchDeleteDcdnWafRulesRequest() = default;
};
class BatchDeleteDcdnWafRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchDeleteDcdnWafRulesResponseBody() {}

  explicit BatchDeleteDcdnWafRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchDeleteDcdnWafRulesResponseBody() = default;
};
class BatchDeleteDcdnWafRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchDeleteDcdnWafRulesResponseBody> body{};

  BatchDeleteDcdnWafRulesResponse() {}

  explicit BatchDeleteDcdnWafRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteDcdnWafRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteDcdnWafRulesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteDcdnWafRulesResponse() = default;
};
class BatchModifyDcdnWafRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};
  shared_ptr<string> ruleConfigs{};

  BatchModifyDcdnWafRulesRequest() {}

  explicit BatchModifyDcdnWafRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (ruleConfigs) {
      res["RuleConfigs"] = boost::any(*ruleConfigs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("RuleConfigs") != m.end() && !m["RuleConfigs"].empty()) {
      ruleConfigs = make_shared<string>(boost::any_cast<string>(m["RuleConfigs"]));
    }
  }


  virtual ~BatchModifyDcdnWafRulesRequest() = default;
};
class BatchModifyDcdnWafRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchModifyDcdnWafRulesResponseBody() {}

  explicit BatchModifyDcdnWafRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchModifyDcdnWafRulesResponseBody() = default;
};
class BatchModifyDcdnWafRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchModifyDcdnWafRulesResponseBody> body{};

  BatchModifyDcdnWafRulesResponse() {}

  explicit BatchModifyDcdnWafRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchModifyDcdnWafRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchModifyDcdnWafRulesResponseBody>(model1);
      }
    }
  }


  virtual ~BatchModifyDcdnWafRulesResponse() = default;
};
class BatchSetDcdnDomainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> SSLPri{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> securityToken{};

  BatchSetDcdnDomainCertificateRequest() {}

  explicit BatchSetDcdnDomainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (SSLPri) {
      res["SSLPri"] = boost::any(*SSLPri);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SSLPri") != m.end() && !m["SSLPri"].empty()) {
      SSLPri = make_shared<string>(boost::any_cast<string>(m["SSLPri"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchSetDcdnDomainCertificateRequest() = default;
};
class BatchSetDcdnDomainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchSetDcdnDomainCertificateResponseBody() {}

  explicit BatchSetDcdnDomainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchSetDcdnDomainCertificateResponseBody() = default;
};
class BatchSetDcdnDomainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchSetDcdnDomainCertificateResponseBody> body{};

  BatchSetDcdnDomainCertificateResponse() {}

  explicit BatchSetDcdnDomainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetDcdnDomainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetDcdnDomainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetDcdnDomainCertificateResponse() = default;
};
class BatchSetDcdnDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> functions{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  BatchSetDcdnDomainConfigsRequest() {}

  explicit BatchSetDcdnDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (functions) {
      res["Functions"] = boost::any(*functions);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      functions = make_shared<string>(boost::any_cast<string>(m["Functions"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchSetDcdnDomainConfigsRequest() = default;
};
class BatchSetDcdnDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchSetDcdnDomainConfigsResponseBody() {}

  explicit BatchSetDcdnDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchSetDcdnDomainConfigsResponseBody() = default;
};
class BatchSetDcdnDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchSetDcdnDomainConfigsResponseBody> body{};

  BatchSetDcdnDomainConfigsResponse() {}

  explicit BatchSetDcdnDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetDcdnDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetDcdnDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetDcdnDomainConfigsResponse() = default;
};
class BatchSetDcdnIpaDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> functions{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  BatchSetDcdnIpaDomainConfigsRequest() {}

  explicit BatchSetDcdnIpaDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (functions) {
      res["Functions"] = boost::any(*functions);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      functions = make_shared<string>(boost::any_cast<string>(m["Functions"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchSetDcdnIpaDomainConfigsRequest() = default;
};
class BatchSetDcdnIpaDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchSetDcdnIpaDomainConfigsResponseBody() {}

  explicit BatchSetDcdnIpaDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchSetDcdnIpaDomainConfigsResponseBody() = default;
};
class BatchSetDcdnIpaDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchSetDcdnIpaDomainConfigsResponseBody> body{};

  BatchSetDcdnIpaDomainConfigsResponse() {}

  explicit BatchSetDcdnIpaDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetDcdnIpaDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetDcdnIpaDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetDcdnIpaDomainConfigsResponse() = default;
};
class BatchSetDcdnWafDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientIpTag{};
  shared_ptr<string> defenseStatus{};
  shared_ptr<string> domainNames{};

  BatchSetDcdnWafDomainConfigsRequest() {}

  explicit BatchSetDcdnWafDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIpTag) {
      res["ClientIpTag"] = boost::any(*clientIpTag);
    }
    if (defenseStatus) {
      res["DefenseStatus"] = boost::any(*defenseStatus);
    }
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientIpTag") != m.end() && !m["ClientIpTag"].empty()) {
      clientIpTag = make_shared<string>(boost::any_cast<string>(m["ClientIpTag"]));
    }
    if (m.find("DefenseStatus") != m.end() && !m["DefenseStatus"].empty()) {
      defenseStatus = make_shared<string>(boost::any_cast<string>(m["DefenseStatus"]));
    }
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
  }


  virtual ~BatchSetDcdnWafDomainConfigsRequest() = default;
};
class BatchSetDcdnWafDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchSetDcdnWafDomainConfigsResponseBody() {}

  explicit BatchSetDcdnWafDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchSetDcdnWafDomainConfigsResponseBody() = default;
};
class BatchSetDcdnWafDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchSetDcdnWafDomainConfigsResponseBody> body{};

  BatchSetDcdnWafDomainConfigsResponse() {}

  explicit BatchSetDcdnWafDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetDcdnWafDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetDcdnWafDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetDcdnWafDomainConfigsResponse() = default;
};
class BatchStartDcdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  BatchStartDcdnDomainRequest() {}

  explicit BatchStartDcdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchStartDcdnDomainRequest() = default;
};
class BatchStartDcdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchStartDcdnDomainResponseBody() {}

  explicit BatchStartDcdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchStartDcdnDomainResponseBody() = default;
};
class BatchStartDcdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchStartDcdnDomainResponseBody> body{};

  BatchStartDcdnDomainResponse() {}

  explicit BatchStartDcdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchStartDcdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchStartDcdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~BatchStartDcdnDomainResponse() = default;
};
class BatchStopDcdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  BatchStopDcdnDomainRequest() {}

  explicit BatchStopDcdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchStopDcdnDomainRequest() = default;
};
class BatchStopDcdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchStopDcdnDomainResponseBody() {}

  explicit BatchStopDcdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchStopDcdnDomainResponseBody() = default;
};
class BatchStopDcdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchStopDcdnDomainResponseBody> body{};

  BatchStopDcdnDomainResponse() {}

  explicit BatchStopDcdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchStopDcdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchStopDcdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~BatchStopDcdnDomainResponse() = default;
};
class CheckDcdnProjectExistRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};

  CheckDcdnProjectExistRequest() {}

  explicit CheckDcdnProjectExistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~CheckDcdnProjectExistRequest() = default;
};
class CheckDcdnProjectExistResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> exist{};

  CheckDcdnProjectExistResponseBodyContent() {}

  explicit CheckDcdnProjectExistResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exist) {
      res["Exist"] = boost::any(*exist);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Exist") != m.end() && !m["Exist"].empty()) {
      exist = make_shared<string>(boost::any_cast<string>(m["Exist"]));
    }
  }


  virtual ~CheckDcdnProjectExistResponseBodyContent() = default;
};
class CheckDcdnProjectExistResponseBody : public Darabonba::Model {
public:
  shared_ptr<CheckDcdnProjectExistResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  CheckDcdnProjectExistResponseBody() {}

  explicit CheckDcdnProjectExistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        CheckDcdnProjectExistResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<CheckDcdnProjectExistResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CheckDcdnProjectExistResponseBody() = default;
};
class CheckDcdnProjectExistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckDcdnProjectExistResponseBody> body{};

  CheckDcdnProjectExistResponse() {}

  explicit CheckDcdnProjectExistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckDcdnProjectExistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckDcdnProjectExistResponseBody>(model1);
      }
    }
  }


  virtual ~CheckDcdnProjectExistResponse() = default;
};
class CommitStagingRoutineCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> codeDescription{};
  shared_ptr<string> name{};

  CommitStagingRoutineCodeRequest() {}

  explicit CommitStagingRoutineCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeDescription) {
      res["CodeDescription"] = boost::any(*codeDescription);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeDescription") != m.end() && !m["CodeDescription"].empty()) {
      codeDescription = make_shared<string>(boost::any_cast<string>(m["CodeDescription"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CommitStagingRoutineCodeRequest() = default;
};
class CommitStagingRoutineCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  CommitStagingRoutineCodeResponseBody() {}

  explicit CommitStagingRoutineCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CommitStagingRoutineCodeResponseBody() = default;
};
class CommitStagingRoutineCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CommitStagingRoutineCodeResponseBody> body{};

  CommitStagingRoutineCodeResponse() {}

  explicit CommitStagingRoutineCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CommitStagingRoutineCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CommitStagingRoutineCodeResponseBody>(model1);
      }
    }
  }


  virtual ~CommitStagingRoutineCodeResponse() = default;
};
class CreateDcdnDeliverTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> deliver{};
  shared_ptr<string> domainName{};
  shared_ptr<string> name{};
  shared_ptr<string> reports{};
  shared_ptr<string> schedule{};

  CreateDcdnDeliverTaskRequest() {}

  explicit CreateDcdnDeliverTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliver) {
      res["Deliver"] = boost::any(*deliver);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (reports) {
      res["Reports"] = boost::any(*reports);
    }
    if (schedule) {
      res["Schedule"] = boost::any(*schedule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Deliver") != m.end() && !m["Deliver"].empty()) {
      deliver = make_shared<string>(boost::any_cast<string>(m["Deliver"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Reports") != m.end() && !m["Reports"].empty()) {
      reports = make_shared<string>(boost::any_cast<string>(m["Reports"]));
    }
    if (m.find("Schedule") != m.end() && !m["Schedule"].empty()) {
      schedule = make_shared<string>(boost::any_cast<string>(m["Schedule"]));
    }
  }


  virtual ~CreateDcdnDeliverTaskRequest() = default;
};
class CreateDcdnDeliverTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deliverId{};
  shared_ptr<string> requestId{};

  CreateDcdnDeliverTaskResponseBody() {}

  explicit CreateDcdnDeliverTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliverId) {
      res["DeliverId"] = boost::any(*deliverId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliverId") != m.end() && !m["DeliverId"].empty()) {
      deliverId = make_shared<string>(boost::any_cast<string>(m["DeliverId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDcdnDeliverTaskResponseBody() = default;
};
class CreateDcdnDeliverTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDcdnDeliverTaskResponseBody> body{};

  CreateDcdnDeliverTaskResponse() {}

  explicit CreateDcdnDeliverTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDcdnDeliverTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDcdnDeliverTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDcdnDeliverTaskResponse() = default;
};
class CreateDcdnSLSRealTimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> domainName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> SLSLogStore{};
  shared_ptr<string> SLSProject{};
  shared_ptr<string> SLSRegion{};
  shared_ptr<string> samplingRate{};

  CreateDcdnSLSRealTimeLogDeliveryRequest() {}

  explicit CreateDcdnSLSRealTimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (SLSLogStore) {
      res["SLSLogStore"] = boost::any(*SLSLogStore);
    }
    if (SLSProject) {
      res["SLSProject"] = boost::any(*SLSProject);
    }
    if (SLSRegion) {
      res["SLSRegion"] = boost::any(*SLSRegion);
    }
    if (samplingRate) {
      res["SamplingRate"] = boost::any(*samplingRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SLSLogStore") != m.end() && !m["SLSLogStore"].empty()) {
      SLSLogStore = make_shared<string>(boost::any_cast<string>(m["SLSLogStore"]));
    }
    if (m.find("SLSProject") != m.end() && !m["SLSProject"].empty()) {
      SLSProject = make_shared<string>(boost::any_cast<string>(m["SLSProject"]));
    }
    if (m.find("SLSRegion") != m.end() && !m["SLSRegion"].empty()) {
      SLSRegion = make_shared<string>(boost::any_cast<string>(m["SLSRegion"]));
    }
    if (m.find("SamplingRate") != m.end() && !m["SamplingRate"].empty()) {
      samplingRate = make_shared<string>(boost::any_cast<string>(m["SamplingRate"]));
    }
  }


  virtual ~CreateDcdnSLSRealTimeLogDeliveryRequest() = default;
};
class CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> domainName{};
  shared_ptr<string> region{};
  shared_ptr<string> status{};

  CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains() {}

  explicit CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains() = default;
};
class CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains>> domains{};

  CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent() {}

  explicit CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      vector<boost::any> temp1;
      for(auto item1:*domains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Domains"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Domains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domains = make_shared<vector<CreateDcdnSLSRealTimeLogDeliveryResponseBodyContentDomains>>(expect1);
      }
    }
  }


  virtual ~CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent() = default;
};
class CreateDcdnSLSRealTimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  CreateDcdnSLSRealTimeLogDeliveryResponseBody() {}

  explicit CreateDcdnSLSRealTimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<CreateDcdnSLSRealTimeLogDeliveryResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDcdnSLSRealTimeLogDeliveryResponseBody() = default;
};
class CreateDcdnSLSRealTimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDcdnSLSRealTimeLogDeliveryResponseBody> body{};

  CreateDcdnSLSRealTimeLogDeliveryResponse() {}

  explicit CreateDcdnSLSRealTimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDcdnSLSRealTimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDcdnSLSRealTimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDcdnSLSRealTimeLogDeliveryResponse() = default;
};
class CreateDcdnSubTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> reportIds{};

  CreateDcdnSubTaskRequest() {}

  explicit CreateDcdnSubTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (reportIds) {
      res["ReportIds"] = boost::any(*reportIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ReportIds") != m.end() && !m["ReportIds"].empty()) {
      reportIds = make_shared<string>(boost::any_cast<string>(m["ReportIds"]));
    }
  }


  virtual ~CreateDcdnSubTaskRequest() = default;
};
class CreateDcdnSubTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateDcdnSubTaskResponseBody() {}

  explicit CreateDcdnSubTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDcdnSubTaskResponseBody() = default;
};
class CreateDcdnSubTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDcdnSubTaskResponseBody> body{};

  CreateDcdnSubTaskResponse() {}

  explicit CreateDcdnSubTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDcdnSubTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDcdnSubTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDcdnSubTaskResponse() = default;
};
class CreateDcdnWafGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> subscribe{};
  shared_ptr<long> templateId{};

  CreateDcdnWafGroupRequest() {}

  explicit CreateDcdnWafGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (subscribe) {
      res["Subscribe"] = boost::any(*subscribe);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Subscribe") != m.end() && !m["Subscribe"].empty()) {
      subscribe = make_shared<string>(boost::any_cast<string>(m["Subscribe"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~CreateDcdnWafGroupRequest() = default;
};
class CreateDcdnWafGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> requestId{};

  CreateDcdnWafGroupResponseBody() {}

  explicit CreateDcdnWafGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDcdnWafGroupResponseBody() = default;
};
class CreateDcdnWafGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDcdnWafGroupResponseBody> body{};

  CreateDcdnWafGroupResponse() {}

  explicit CreateDcdnWafGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDcdnWafGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDcdnWafGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDcdnWafGroupResponse() = default;
};
class CreateDcdnWafPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<string> policyName{};
  shared_ptr<string> policyStatus{};
  shared_ptr<string> policyType{};

  CreateDcdnWafPolicyRequest() {}

  explicit CreateDcdnWafPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (policyStatus) {
      res["PolicyStatus"] = boost::any(*policyStatus);
    }
    if (policyType) {
      res["PolicyType"] = boost::any(*policyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("PolicyStatus") != m.end() && !m["PolicyStatus"].empty()) {
      policyStatus = make_shared<string>(boost::any_cast<string>(m["PolicyStatus"]));
    }
    if (m.find("PolicyType") != m.end() && !m["PolicyType"].empty()) {
      policyType = make_shared<string>(boost::any_cast<string>(m["PolicyType"]));
    }
  }


  virtual ~CreateDcdnWafPolicyRequest() = default;
};
class CreateDcdnWafPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};
  shared_ptr<string> requestId{};

  CreateDcdnWafPolicyResponseBody() {}

  explicit CreateDcdnWafPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDcdnWafPolicyResponseBody() = default;
};
class CreateDcdnWafPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDcdnWafPolicyResponseBody> body{};

  CreateDcdnWafPolicyResponse() {}

  explicit CreateDcdnWafPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDcdnWafPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDcdnWafPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDcdnWafPolicyResponse() = default;
};
class CreateRoutineRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> envConf{};
  shared_ptr<string> name{};

  CreateRoutineRequest() {}

  explicit CreateRoutineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envConf) {
      res["EnvConf"] = boost::any(*envConf);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["EnvConf"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      envConf = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateRoutineRequest() = default;
};
class CreateRoutineShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> envConfShrink{};
  shared_ptr<string> name{};

  CreateRoutineShrinkRequest() {}

  explicit CreateRoutineShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envConfShrink) {
      res["EnvConf"] = boost::any(*envConfShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      envConfShrink = make_shared<string>(boost::any_cast<string>(m["EnvConf"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateRoutineShrinkRequest() = default;
};
class CreateRoutineResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  CreateRoutineResponseBody() {}

  explicit CreateRoutineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateRoutineResponseBody() = default;
};
class CreateRoutineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRoutineResponseBody> body{};

  CreateRoutineResponse() {}

  explicit CreateRoutineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRoutineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRoutineResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRoutineResponse() = default;
};
class CreateSlrAndSlsProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> region{};

  CreateSlrAndSlsProjectRequest() {}

  explicit CreateSlrAndSlsProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~CreateSlrAndSlsProjectRequest() = default;
};
class CreateSlrAndSlsProjectResponseBodySlsInfo : public Darabonba::Model {
public:
  shared_ptr<string> endPoint{};
  shared_ptr<string> logStore{};
  shared_ptr<string> project{};
  shared_ptr<string> region{};

  CreateSlrAndSlsProjectResponseBodySlsInfo() {}

  explicit CreateSlrAndSlsProjectResponseBodySlsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endPoint) {
      res["EndPoint"] = boost::any(*endPoint);
    }
    if (logStore) {
      res["LogStore"] = boost::any(*logStore);
    }
    if (project) {
      res["Project"] = boost::any(*project);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndPoint") != m.end() && !m["EndPoint"].empty()) {
      endPoint = make_shared<string>(boost::any_cast<string>(m["EndPoint"]));
    }
    if (m.find("LogStore") != m.end() && !m["LogStore"].empty()) {
      logStore = make_shared<string>(boost::any_cast<string>(m["LogStore"]));
    }
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      project = make_shared<string>(boost::any_cast<string>(m["Project"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~CreateSlrAndSlsProjectResponseBodySlsInfo() = default;
};
class CreateSlrAndSlsProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateSlrAndSlsProjectResponseBodySlsInfo> slsInfo{};

  CreateSlrAndSlsProjectResponseBody() {}

  explicit CreateSlrAndSlsProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (slsInfo) {
      res["SlsInfo"] = slsInfo ? boost::any(slsInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SlsInfo") != m.end() && !m["SlsInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SlsInfo"].type()) {
        CreateSlrAndSlsProjectResponseBodySlsInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SlsInfo"]));
        slsInfo = make_shared<CreateSlrAndSlsProjectResponseBodySlsInfo>(model1);
      }
    }
  }


  virtual ~CreateSlrAndSlsProjectResponseBody() = default;
};
class CreateSlrAndSlsProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSlrAndSlsProjectResponseBody> body{};

  CreateSlrAndSlsProjectResponse() {}

  explicit CreateSlrAndSlsProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSlrAndSlsProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSlrAndSlsProjectResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSlrAndSlsProjectResponse() = default;
};
class DeleteDcdnDeliverTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> deliverId{};

  DeleteDcdnDeliverTaskRequest() {}

  explicit DeleteDcdnDeliverTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliverId) {
      res["DeliverId"] = boost::any(*deliverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliverId") != m.end() && !m["DeliverId"].empty()) {
      deliverId = make_shared<long>(boost::any_cast<long>(m["DeliverId"]));
    }
  }


  virtual ~DeleteDcdnDeliverTaskRequest() = default;
};
class DeleteDcdnDeliverTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnDeliverTaskResponseBody() {}

  explicit DeleteDcdnDeliverTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnDeliverTaskResponseBody() = default;
};
class DeleteDcdnDeliverTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDcdnDeliverTaskResponseBody> body{};

  DeleteDcdnDeliverTaskResponse() {}

  explicit DeleteDcdnDeliverTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnDeliverTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnDeliverTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnDeliverTaskResponse() = default;
};
class DeleteDcdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteDcdnDomainRequest() {}

  explicit DeleteDcdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteDcdnDomainRequest() = default;
};
class DeleteDcdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnDomainResponseBody() {}

  explicit DeleteDcdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnDomainResponseBody() = default;
};
class DeleteDcdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDcdnDomainResponseBody> body{};

  DeleteDcdnDomainResponse() {}

  explicit DeleteDcdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnDomainResponse() = default;
};
class DeleteDcdnIpaDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteDcdnIpaDomainRequest() {}

  explicit DeleteDcdnIpaDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteDcdnIpaDomainRequest() = default;
};
class DeleteDcdnIpaDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnIpaDomainResponseBody() {}

  explicit DeleteDcdnIpaDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnIpaDomainResponseBody() = default;
};
class DeleteDcdnIpaDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDcdnIpaDomainResponseBody> body{};

  DeleteDcdnIpaDomainResponse() {}

  explicit DeleteDcdnIpaDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnIpaDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnIpaDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnIpaDomainResponse() = default;
};
class DeleteDcdnIpaSpecificConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteDcdnIpaSpecificConfigRequest() {}

  explicit DeleteDcdnIpaSpecificConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteDcdnIpaSpecificConfigRequest() = default;
};
class DeleteDcdnIpaSpecificConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnIpaSpecificConfigResponseBody() {}

  explicit DeleteDcdnIpaSpecificConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnIpaSpecificConfigResponseBody() = default;
};
class DeleteDcdnIpaSpecificConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDcdnIpaSpecificConfigResponseBody> body{};

  DeleteDcdnIpaSpecificConfigResponse() {}

  explicit DeleteDcdnIpaSpecificConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnIpaSpecificConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnIpaSpecificConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnIpaSpecificConfigResponse() = default;
};
class DeleteDcdnKvRequest : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> namespace_{};

  DeleteDcdnKvRequest() {}

  explicit DeleteDcdnKvRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DeleteDcdnKvRequest() = default;
};
class DeleteDcdnKvResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnKvResponseBody() {}

  explicit DeleteDcdnKvResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnKvResponseBody() = default;
};
class DeleteDcdnKvResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDcdnKvResponseBody> body{};

  DeleteDcdnKvResponse() {}

  explicit DeleteDcdnKvResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnKvResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnKvResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnKvResponse() = default;
};
class DeleteDcdnKvNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};

  DeleteDcdnKvNamespaceRequest() {}

  explicit DeleteDcdnKvNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DeleteDcdnKvNamespaceRequest() = default;
};
class DeleteDcdnKvNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnKvNamespaceResponseBody() {}

  explicit DeleteDcdnKvNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnKvNamespaceResponseBody() = default;
};
class DeleteDcdnKvNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDcdnKvNamespaceResponseBody> body{};

  DeleteDcdnKvNamespaceResponse() {}

  explicit DeleteDcdnKvNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnKvNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnKvNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnKvNamespaceResponse() = default;
};
class DeleteDcdnRealTimeLogProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};

  DeleteDcdnRealTimeLogProjectRequest() {}

  explicit DeleteDcdnRealTimeLogProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~DeleteDcdnRealTimeLogProjectRequest() = default;
};
class DeleteDcdnRealTimeLogProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnRealTimeLogProjectResponseBody() {}

  explicit DeleteDcdnRealTimeLogProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnRealTimeLogProjectResponseBody() = default;
};
class DeleteDcdnRealTimeLogProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDcdnRealTimeLogProjectResponseBody> body{};

  DeleteDcdnRealTimeLogProjectResponse() {}

  explicit DeleteDcdnRealTimeLogProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnRealTimeLogProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnRealTimeLogProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnRealTimeLogProjectResponse() = default;
};
class DeleteDcdnSpecificConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteDcdnSpecificConfigRequest() {}

  explicit DeleteDcdnSpecificConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteDcdnSpecificConfigRequest() = default;
};
class DeleteDcdnSpecificConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnSpecificConfigResponseBody() {}

  explicit DeleteDcdnSpecificConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnSpecificConfigResponseBody() = default;
};
class DeleteDcdnSpecificConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDcdnSpecificConfigResponseBody> body{};

  DeleteDcdnSpecificConfigResponse() {}

  explicit DeleteDcdnSpecificConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnSpecificConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnSpecificConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnSpecificConfigResponse() = default;
};
class DeleteDcdnSpecificStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DeleteDcdnSpecificStagingConfigRequest() {}

  explicit DeleteDcdnSpecificStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteDcdnSpecificStagingConfigRequest() = default;
};
class DeleteDcdnSpecificStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnSpecificStagingConfigResponseBody() {}

  explicit DeleteDcdnSpecificStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnSpecificStagingConfigResponseBody() = default;
};
class DeleteDcdnSpecificStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDcdnSpecificStagingConfigResponseBody> body{};

  DeleteDcdnSpecificStagingConfigResponse() {}

  explicit DeleteDcdnSpecificStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnSpecificStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnSpecificStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnSpecificStagingConfigResponse() = default;
};
class DeleteDcdnSubTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnSubTaskResponseBody() {}

  explicit DeleteDcdnSubTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnSubTaskResponseBody() = default;
};
class DeleteDcdnSubTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDcdnSubTaskResponseBody> body{};

  DeleteDcdnSubTaskResponse() {}

  explicit DeleteDcdnSubTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnSubTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnSubTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnSubTaskResponse() = default;
};
class DeleteDcdnWafGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  DeleteDcdnWafGroupRequest() {}

  explicit DeleteDcdnWafGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteDcdnWafGroupRequest() = default;
};
class DeleteDcdnWafGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnWafGroupResponseBody() {}

  explicit DeleteDcdnWafGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnWafGroupResponseBody() = default;
};
class DeleteDcdnWafGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDcdnWafGroupResponseBody> body{};

  DeleteDcdnWafGroupResponse() {}

  explicit DeleteDcdnWafGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnWafGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnWafGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnWafGroupResponse() = default;
};
class DeleteDcdnWafPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};

  DeleteDcdnWafPolicyRequest() {}

  explicit DeleteDcdnWafPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
  }


  virtual ~DeleteDcdnWafPolicyRequest() = default;
};
class DeleteDcdnWafPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnWafPolicyResponseBody() {}

  explicit DeleteDcdnWafPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnWafPolicyResponseBody() = default;
};
class DeleteDcdnWafPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDcdnWafPolicyResponseBody> body{};

  DeleteDcdnWafPolicyResponse() {}

  explicit DeleteDcdnWafPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnWafPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnWafPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnWafPolicyResponse() = default;
};
class DeleteRoutineRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  DeleteRoutineRequest() {}

  explicit DeleteRoutineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DeleteRoutineRequest() = default;
};
class DeleteRoutineResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DeleteRoutineResponseBody() {}

  explicit DeleteRoutineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRoutineResponseBody() = default;
};
class DeleteRoutineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRoutineResponseBody> body{};

  DeleteRoutineResponse() {}

  explicit DeleteRoutineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRoutineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRoutineResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRoutineResponse() = default;
};
class DeleteRoutineCodeRevisionRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> selectCodeRevision{};

  DeleteRoutineCodeRevisionRequest() {}

  explicit DeleteRoutineCodeRevisionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (selectCodeRevision) {
      res["SelectCodeRevision"] = boost::any(*selectCodeRevision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SelectCodeRevision") != m.end() && !m["SelectCodeRevision"].empty()) {
      selectCodeRevision = make_shared<string>(boost::any_cast<string>(m["SelectCodeRevision"]));
    }
  }


  virtual ~DeleteRoutineCodeRevisionRequest() = default;
};
class DeleteRoutineCodeRevisionResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DeleteRoutineCodeRevisionResponseBody() {}

  explicit DeleteRoutineCodeRevisionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRoutineCodeRevisionResponseBody() = default;
};
class DeleteRoutineCodeRevisionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRoutineCodeRevisionResponseBody> body{};

  DeleteRoutineCodeRevisionResponse() {}

  explicit DeleteRoutineCodeRevisionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRoutineCodeRevisionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRoutineCodeRevisionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRoutineCodeRevisionResponse() = default;
};
class DeleteRoutineConfEnvsRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> envs{};
  shared_ptr<string> name{};

  DeleteRoutineConfEnvsRequest() {}

  explicit DeleteRoutineConfEnvsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Envs"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      envs = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DeleteRoutineConfEnvsRequest() = default;
};
class DeleteRoutineConfEnvsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> envsShrink{};
  shared_ptr<string> name{};

  DeleteRoutineConfEnvsShrinkRequest() {}

  explicit DeleteRoutineConfEnvsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envsShrink) {
      res["Envs"] = boost::any(*envsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envsShrink = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DeleteRoutineConfEnvsShrinkRequest() = default;
};
class DeleteRoutineConfEnvsResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DeleteRoutineConfEnvsResponseBody() {}

  explicit DeleteRoutineConfEnvsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRoutineConfEnvsResponseBody() = default;
};
class DeleteRoutineConfEnvsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRoutineConfEnvsResponseBody> body{};

  DeleteRoutineConfEnvsResponse() {}

  explicit DeleteRoutineConfEnvsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRoutineConfEnvsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRoutineConfEnvsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRoutineConfEnvsResponse() = default;
};
class DescribeDcdnAclFieldsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeDcdnAclFieldsRequest() {}

  explicit DescribeDcdnAclFieldsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeDcdnAclFieldsRequest() = default;
};
class DescribeDcdnAclFieldsResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> fields{};

  DescribeDcdnAclFieldsResponseBodyContent() {}

  explicit DescribeDcdnAclFieldsResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fields) {
      res["Fields"] = boost::any(*fields);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      fields = make_shared<string>(boost::any_cast<string>(m["Fields"]));
    }
  }


  virtual ~DescribeDcdnAclFieldsResponseBodyContent() = default;
};
class DescribeDcdnAclFieldsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnAclFieldsResponseBodyContent>> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnAclFieldsResponseBody() {}

  explicit DescribeDcdnAclFieldsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<DescribeDcdnAclFieldsResponseBodyContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnAclFieldsResponseBodyContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<DescribeDcdnAclFieldsResponseBodyContent>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnAclFieldsResponseBody() = default;
};
class DescribeDcdnAclFieldsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnAclFieldsResponseBody> body{};

  DescribeDcdnAclFieldsResponse() {}

  explicit DescribeDcdnAclFieldsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnAclFieldsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnAclFieldsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnAclFieldsResponse() = default;
};
class DescribeDcdnBgpBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceName{};
  shared_ptr<string> devicePort{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> isp{};
  shared_ptr<string> startTime{};

  DescribeDcdnBgpBpsDataRequest() {}

  explicit DescribeDcdnBgpBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (devicePort) {
      res["DevicePort"] = boost::any(*devicePort);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DevicePort") != m.end() && !m["DevicePort"].empty()) {
      devicePort = make_shared<string>(boost::any_cast<string>(m["DevicePort"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnBgpBpsDataRequest() = default;
};
class DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval : public Darabonba::Model {
public:
  shared_ptr<double> in{};
  shared_ptr<double> out{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval() {}

  explicit DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (in) {
      res["In"] = boost::any(*in);
    }
    if (out) {
      res["Out"] = boost::any(*out);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("In") != m.end() && !m["In"].empty()) {
      in = make_shared<double>(boost::any_cast<double>(m["In"]));
    }
    if (m.find("Out") != m.end() && !m["Out"].empty()) {
      out = make_shared<double>(boost::any_cast<double>(m["Out"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval() = default;
};
class DescribeDcdnBgpBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval>> bgpDataInterval{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnBgpBpsDataResponseBody() {}

  explicit DescribeDcdnBgpBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpDataInterval) {
      vector<boost::any> temp1;
      for(auto item1:*bgpDataInterval){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BgpDataInterval"] = boost::any(temp1);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpDataInterval") != m.end() && !m["BgpDataInterval"].empty()) {
      if (typeid(vector<boost::any>) == m["BgpDataInterval"].type()) {
        vector<DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BgpDataInterval"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bgpDataInterval = make_shared<vector<DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval>>(expect1);
      }
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnBgpBpsDataResponseBody() = default;
};
class DescribeDcdnBgpBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnBgpBpsDataResponseBody> body{};

  DescribeDcdnBgpBpsDataResponse() {}

  explicit DescribeDcdnBgpBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnBgpBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnBgpBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnBgpBpsDataResponse() = default;
};
class DescribeDcdnBgpTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> isp{};
  shared_ptr<string> startTime{};

  DescribeDcdnBgpTrafficDataRequest() {}

  explicit DescribeDcdnBgpTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnBgpTrafficDataRequest() = default;
};
class DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval : public Darabonba::Model {
public:
  shared_ptr<long> in{};
  shared_ptr<long> out{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval() {}

  explicit DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (in) {
      res["In"] = boost::any(*in);
    }
    if (out) {
      res["Out"] = boost::any(*out);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("In") != m.end() && !m["In"].empty()) {
      in = make_shared<long>(boost::any_cast<long>(m["In"]));
    }
    if (m.find("Out") != m.end() && !m["Out"].empty()) {
      out = make_shared<long>(boost::any_cast<long>(m["Out"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval() = default;
};
class DescribeDcdnBgpTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval>> bgpDataInterval{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnBgpTrafficDataResponseBody() {}

  explicit DescribeDcdnBgpTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bgpDataInterval) {
      vector<boost::any> temp1;
      for(auto item1:*bgpDataInterval){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BgpDataInterval"] = boost::any(temp1);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BgpDataInterval") != m.end() && !m["BgpDataInterval"].empty()) {
      if (typeid(vector<boost::any>) == m["BgpDataInterval"].type()) {
        vector<DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BgpDataInterval"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bgpDataInterval = make_shared<vector<DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval>>(expect1);
      }
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnBgpTrafficDataResponseBody() = default;
};
class DescribeDcdnBgpTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnBgpTrafficDataResponseBody> body{};

  DescribeDcdnBgpTrafficDataResponse() {}

  explicit DescribeDcdnBgpTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnBgpTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnBgpTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnBgpTrafficDataResponse() = default;
};
class DescribeDcdnBlockedRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> language{};

  DescribeDcdnBlockedRegionsRequest() {}

  explicit DescribeDcdnBlockedRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["Language"] = boost::any(*language);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
  }


  virtual ~DescribeDcdnBlockedRegionsRequest() = default;
};
class DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem : public Darabonba::Model {
public:
  shared_ptr<string> continent{};
  shared_ptr<string> countriesAndRegions{};
  shared_ptr<string> countriesAndRegionsName{};

  DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem() {}

  explicit DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (continent) {
      res["Continent"] = boost::any(*continent);
    }
    if (countriesAndRegions) {
      res["CountriesAndRegions"] = boost::any(*countriesAndRegions);
    }
    if (countriesAndRegionsName) {
      res["CountriesAndRegionsName"] = boost::any(*countriesAndRegionsName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Continent") != m.end() && !m["Continent"].empty()) {
      continent = make_shared<string>(boost::any_cast<string>(m["Continent"]));
    }
    if (m.find("CountriesAndRegions") != m.end() && !m["CountriesAndRegions"].empty()) {
      countriesAndRegions = make_shared<string>(boost::any_cast<string>(m["CountriesAndRegions"]));
    }
    if (m.find("CountriesAndRegionsName") != m.end() && !m["CountriesAndRegionsName"].empty()) {
      countriesAndRegionsName = make_shared<string>(boost::any_cast<string>(m["CountriesAndRegionsName"]));
    }
  }


  virtual ~DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem() = default;
};
class DescribeDcdnBlockedRegionsResponseBodyInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem>> infoItem{};

  DescribeDcdnBlockedRegionsResponseBodyInfoList() {}

  explicit DescribeDcdnBlockedRegionsResponseBodyInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (infoItem) {
      vector<boost::any> temp1;
      for(auto item1:*infoItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InfoItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InfoItem") != m.end() && !m["InfoItem"].empty()) {
      if (typeid(vector<boost::any>) == m["InfoItem"].type()) {
        vector<DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InfoItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        infoItem = make_shared<vector<DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnBlockedRegionsResponseBodyInfoList() = default;
};
class DescribeDcdnBlockedRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnBlockedRegionsResponseBodyInfoList> infoList{};
  shared_ptr<string> requestId{};

  DescribeDcdnBlockedRegionsResponseBody() {}

  explicit DescribeDcdnBlockedRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (infoList) {
      res["InfoList"] = infoList ? boost::any(infoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InfoList") != m.end() && !m["InfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InfoList"].type()) {
        DescribeDcdnBlockedRegionsResponseBodyInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InfoList"]));
        infoList = make_shared<DescribeDcdnBlockedRegionsResponseBodyInfoList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnBlockedRegionsResponseBody() = default;
};
class DescribeDcdnBlockedRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnBlockedRegionsResponseBody> body{};

  DescribeDcdnBlockedRegionsResponse() {}

  explicit DescribeDcdnBlockedRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnBlockedRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnBlockedRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnBlockedRegionsResponse() = default;
};
class DescribeDcdnCertificateDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnCertificateDetailRequest() {}

  explicit DescribeDcdnCertificateDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnCertificateDetailRequest() = default;
};
class DescribeDcdnCertificateDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cert{};
  shared_ptr<long> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> key{};
  shared_ptr<string> requestId{};

  DescribeDcdnCertificateDetailResponseBody() {}

  explicit DescribeDcdnCertificateDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      res["Cert"] = boost::any(*cert);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cert") != m.end() && !m["Cert"].empty()) {
      cert = make_shared<string>(boost::any_cast<string>(m["Cert"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnCertificateDetailResponseBody() = default;
};
class DescribeDcdnCertificateDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnCertificateDetailResponseBody> body{};

  DescribeDcdnCertificateDetailResponse() {}

  explicit DescribeDcdnCertificateDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnCertificateDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnCertificateDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnCertificateDetailResponse() = default;
};
class DescribeDcdnCertificateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnCertificateListRequest() {}

  explicit DescribeDcdnCertificateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnCertificateListRequest() = default;
};
class DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert : public Darabonba::Model {
public:
  shared_ptr<long> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> common{};
  shared_ptr<string> fingerprint{};
  shared_ptr<string> issuer{};
  shared_ptr<long> lastTime{};

  DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert() {}

  explicit DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (common) {
      res["Common"] = boost::any(*common);
    }
    if (fingerprint) {
      res["Fingerprint"] = boost::any(*fingerprint);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Common") != m.end() && !m["Common"].empty()) {
      common = make_shared<string>(boost::any_cast<string>(m["Common"]));
    }
    if (m.find("Fingerprint") != m.end() && !m["Fingerprint"].empty()) {
      fingerprint = make_shared<string>(boost::any_cast<string>(m["Fingerprint"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<long>(boost::any_cast<long>(m["LastTime"]));
    }
  }


  virtual ~DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert() = default;
};
class DescribeDcdnCertificateListResponseBodyCertificateListModelCertList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert>> cert{};

  DescribeDcdnCertificateListResponseBodyCertificateListModelCertList() {}

  explicit DescribeDcdnCertificateListResponseBodyCertificateListModelCertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      vector<boost::any> temp1;
      for(auto item1:*cert){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cert"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cert") != m.end() && !m["Cert"].empty()) {
      if (typeid(vector<boost::any>) == m["Cert"].type()) {
        vector<DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cert"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cert = make_shared<vector<DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnCertificateListResponseBodyCertificateListModelCertList() = default;
};
class DescribeDcdnCertificateListResponseBodyCertificateListModel : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnCertificateListResponseBodyCertificateListModelCertList> certList{};
  shared_ptr<long> count{};

  DescribeDcdnCertificateListResponseBodyCertificateListModel() {}

  explicit DescribeDcdnCertificateListResponseBodyCertificateListModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certList) {
      res["CertList"] = certList ? boost::any(certList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertList") != m.end() && !m["CertList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertList"].type()) {
        DescribeDcdnCertificateListResponseBodyCertificateListModelCertList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertList"]));
        certList = make_shared<DescribeDcdnCertificateListResponseBodyCertificateListModelCertList>(model1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeDcdnCertificateListResponseBodyCertificateListModel() = default;
};
class DescribeDcdnCertificateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnCertificateListResponseBodyCertificateListModel> certificateListModel{};
  shared_ptr<string> requestId{};

  DescribeDcdnCertificateListResponseBody() {}

  explicit DescribeDcdnCertificateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateListModel) {
      res["CertificateListModel"] = certificateListModel ? boost::any(certificateListModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateListModel") != m.end() && !m["CertificateListModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertificateListModel"].type()) {
        DescribeDcdnCertificateListResponseBodyCertificateListModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertificateListModel"]));
        certificateListModel = make_shared<DescribeDcdnCertificateListResponseBodyCertificateListModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnCertificateListResponseBody() = default;
};
class DescribeDcdnCertificateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnCertificateListResponseBody> body{};

  DescribeDcdnCertificateListResponse() {}

  explicit DescribeDcdnCertificateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnCertificateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnCertificateListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnCertificateListResponse() = default;
};
class DescribeDcdnDdosServiceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnDdosServiceRequest() {}

  explicit DescribeDcdnDdosServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnDdosServiceRequest() = default;
};
class DescribeDcdnDdosServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changingAffectTime{};
  shared_ptr<string> changingChargeType{};
  shared_ptr<long> changingDomianNum{};
  shared_ptr<string> changingEdition{};
  shared_ptr<long> changingProtectNum{};
  shared_ptr<string> chargeType{};
  shared_ptr<long> domianNum{};
  shared_ptr<string> edition{};
  shared_ptr<string> enabled{};
  shared_ptr<string> endingTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> openingTime{};
  shared_ptr<long> protectNum{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribeDcdnDdosServiceResponseBody() {}

  explicit DescribeDcdnDdosServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changingAffectTime) {
      res["ChangingAffectTime"] = boost::any(*changingAffectTime);
    }
    if (changingChargeType) {
      res["ChangingChargeType"] = boost::any(*changingChargeType);
    }
    if (changingDomianNum) {
      res["ChangingDomianNum"] = boost::any(*changingDomianNum);
    }
    if (changingEdition) {
      res["ChangingEdition"] = boost::any(*changingEdition);
    }
    if (changingProtectNum) {
      res["ChangingProtectNum"] = boost::any(*changingProtectNum);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (domianNum) {
      res["DomianNum"] = boost::any(*domianNum);
    }
    if (edition) {
      res["Edition"] = boost::any(*edition);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (endingTime) {
      res["EndingTime"] = boost::any(*endingTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (openingTime) {
      res["OpeningTime"] = boost::any(*openingTime);
    }
    if (protectNum) {
      res["ProtectNum"] = boost::any(*protectNum);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangingAffectTime") != m.end() && !m["ChangingAffectTime"].empty()) {
      changingAffectTime = make_shared<string>(boost::any_cast<string>(m["ChangingAffectTime"]));
    }
    if (m.find("ChangingChargeType") != m.end() && !m["ChangingChargeType"].empty()) {
      changingChargeType = make_shared<string>(boost::any_cast<string>(m["ChangingChargeType"]));
    }
    if (m.find("ChangingDomianNum") != m.end() && !m["ChangingDomianNum"].empty()) {
      changingDomianNum = make_shared<long>(boost::any_cast<long>(m["ChangingDomianNum"]));
    }
    if (m.find("ChangingEdition") != m.end() && !m["ChangingEdition"].empty()) {
      changingEdition = make_shared<string>(boost::any_cast<string>(m["ChangingEdition"]));
    }
    if (m.find("ChangingProtectNum") != m.end() && !m["ChangingProtectNum"].empty()) {
      changingProtectNum = make_shared<long>(boost::any_cast<long>(m["ChangingProtectNum"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DomianNum") != m.end() && !m["DomianNum"].empty()) {
      domianNum = make_shared<long>(boost::any_cast<long>(m["DomianNum"]));
    }
    if (m.find("Edition") != m.end() && !m["Edition"].empty()) {
      edition = make_shared<string>(boost::any_cast<string>(m["Edition"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<string>(boost::any_cast<string>(m["Enabled"]));
    }
    if (m.find("EndingTime") != m.end() && !m["EndingTime"].empty()) {
      endingTime = make_shared<string>(boost::any_cast<string>(m["EndingTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OpeningTime") != m.end() && !m["OpeningTime"].empty()) {
      openingTime = make_shared<string>(boost::any_cast<string>(m["OpeningTime"]));
    }
    if (m.find("ProtectNum") != m.end() && !m["ProtectNum"].empty()) {
      protectNum = make_shared<long>(boost::any_cast<long>(m["ProtectNum"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDcdnDdosServiceResponseBody() = default;
};
class DescribeDcdnDdosServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDdosServiceResponseBody> body{};

  DescribeDcdnDdosServiceResponse() {}

  explicit DescribeDcdnDdosServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDdosServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDdosServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDdosServiceResponse() = default;
};
class DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> expr{};
  shared_ptr<string> value{};

  DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs() {}

  explicit DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (expr) {
      res["Expr"] = boost::any(*expr);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Expr") != m.end() && !m["Expr"].empty()) {
      expr = make_shared<string>(boost::any_cast<string>(m["Expr"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs() = default;
};
class DescribeDcdnDdosSpecInfoResponseBodySpecInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs>> configs{};
  shared_ptr<string> rule{};

  DescribeDcdnDdosSpecInfoResponseBodySpecInfos() {}

  explicit DescribeDcdnDdosSpecInfoResponseBodySpecInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<DescribeDcdnDdosSpecInfoResponseBodySpecInfosConfigs>>(expect1);
      }
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
  }


  virtual ~DescribeDcdnDdosSpecInfoResponseBodySpecInfos() = default;
};
class DescribeDcdnDdosSpecInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthLimit{};
  shared_ptr<string> edition{};
  shared_ptr<string> enable{};
  shared_ptr<string> protectedArea{};
  shared_ptr<string> qpsLimit{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnDdosSpecInfoResponseBodySpecInfos>> specInfos{};

  DescribeDcdnDdosSpecInfoResponseBody() {}

  explicit DescribeDcdnDdosSpecInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthLimit) {
      res["BandwidthLimit"] = boost::any(*bandwidthLimit);
    }
    if (edition) {
      res["Edition"] = boost::any(*edition);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (protectedArea) {
      res["ProtectedArea"] = boost::any(*protectedArea);
    }
    if (qpsLimit) {
      res["QpsLimit"] = boost::any(*qpsLimit);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (specInfos) {
      vector<boost::any> temp1;
      for(auto item1:*specInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthLimit") != m.end() && !m["BandwidthLimit"].empty()) {
      bandwidthLimit = make_shared<string>(boost::any_cast<string>(m["BandwidthLimit"]));
    }
    if (m.find("Edition") != m.end() && !m["Edition"].empty()) {
      edition = make_shared<string>(boost::any_cast<string>(m["Edition"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("ProtectedArea") != m.end() && !m["ProtectedArea"].empty()) {
      protectedArea = make_shared<string>(boost::any_cast<string>(m["ProtectedArea"]));
    }
    if (m.find("QpsLimit") != m.end() && !m["QpsLimit"].empty()) {
      qpsLimit = make_shared<string>(boost::any_cast<string>(m["QpsLimit"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpecInfos") != m.end() && !m["SpecInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecInfos"].type()) {
        vector<DescribeDcdnDdosSpecInfoResponseBodySpecInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDdosSpecInfoResponseBodySpecInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specInfos = make_shared<vector<DescribeDcdnDdosSpecInfoResponseBodySpecInfos>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDdosSpecInfoResponseBody() = default;
};
class DescribeDcdnDdosSpecInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDdosSpecInfoResponseBody> body{};

  DescribeDcdnDdosSpecInfoResponse() {}

  explicit DescribeDcdnDdosSpecInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDdosSpecInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDdosSpecInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDdosSpecInfoResponse() = default;
};
class DescribeDcdnDeletedDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeDcdnDeletedDomainsRequest() {}

  explicit DescribeDcdnDeletedDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeDcdnDeletedDomainsRequest() = default;
};
class DescribeDcdnDeletedDomainsResponseBodyDomainsPageData : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> gmtModified{};

  DescribeDcdnDeletedDomainsResponseBodyDomainsPageData() {}

  explicit DescribeDcdnDeletedDomainsResponseBodyDomainsPageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
  }


  virtual ~DescribeDcdnDeletedDomainsResponseBodyDomainsPageData() = default;
};
class DescribeDcdnDeletedDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDeletedDomainsResponseBodyDomainsPageData>> pageData{};

  DescribeDcdnDeletedDomainsResponseBodyDomains() {}

  explicit DescribeDcdnDeletedDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageData) {
      vector<boost::any> temp1;
      for(auto item1:*pageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageData") != m.end() && !m["PageData"].empty()) {
      if (typeid(vector<boost::any>) == m["PageData"].type()) {
        vector<DescribeDcdnDeletedDomainsResponseBodyDomainsPageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDeletedDomainsResponseBodyDomainsPageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pageData = make_shared<vector<DescribeDcdnDeletedDomainsResponseBodyDomainsPageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDeletedDomainsResponseBodyDomains() = default;
};
class DescribeDcdnDeletedDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDeletedDomainsResponseBodyDomains> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDcdnDeletedDomainsResponseBody() {}

  explicit DescribeDcdnDeletedDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribeDcdnDeletedDomainsResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribeDcdnDeletedDomainsResponseBodyDomains>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDcdnDeletedDomainsResponseBody() = default;
};
class DescribeDcdnDeletedDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDeletedDomainsResponseBody> body{};

  DescribeDcdnDeletedDomainsResponse() {}

  explicit DescribeDcdnDeletedDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDeletedDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDeletedDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDeletedDomainsResponse() = default;
};
class DescribeDcdnDeliverListRequest : public Darabonba::Model {
public:
  shared_ptr<long> deliverId{};

  DescribeDcdnDeliverListRequest() {}

  explicit DescribeDcdnDeliverListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliverId) {
      res["DeliverId"] = boost::any(*deliverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliverId") != m.end() && !m["DeliverId"].empty()) {
      deliverId = make_shared<long>(boost::any_cast<long>(m["DeliverId"]));
    }
  }


  virtual ~DescribeDcdnDeliverListRequest() = default;
};
class DescribeDcdnDeliverListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnDeliverListResponseBody() {}

  explicit DescribeDcdnDeliverListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDeliverListResponseBody() = default;
};
class DescribeDcdnDeliverListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDeliverListResponseBody> body{};

  DescribeDcdnDeliverListResponse() {}

  explicit DescribeDcdnDeliverListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDeliverListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDeliverListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDeliverListResponse() = default;
};
class DescribeDcdnDomainBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainBpsDataRequest() {}

  explicit DescribeDcdnDomainBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainBpsDataRequest() = default;
};
class DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<double> bps{};
  shared_ptr<double> dynamicHttpBps{};
  shared_ptr<double> dynamicHttpsBps{};
  shared_ptr<double> staticHttpBps{};
  shared_ptr<double> staticHttpsBps{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (dynamicHttpBps) {
      res["DynamicHttpBps"] = boost::any(*dynamicHttpBps);
    }
    if (dynamicHttpsBps) {
      res["DynamicHttpsBps"] = boost::any(*dynamicHttpsBps);
    }
    if (staticHttpBps) {
      res["StaticHttpBps"] = boost::any(*staticHttpBps);
    }
    if (staticHttpsBps) {
      res["StaticHttpsBps"] = boost::any(*staticHttpsBps);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<double>(boost::any_cast<double>(m["Bps"]));
    }
    if (m.find("DynamicHttpBps") != m.end() && !m["DynamicHttpBps"].empty()) {
      dynamicHttpBps = make_shared<double>(boost::any_cast<double>(m["DynamicHttpBps"]));
    }
    if (m.find("DynamicHttpsBps") != m.end() && !m["DynamicHttpsBps"].empty()) {
      dynamicHttpsBps = make_shared<double>(boost::any_cast<double>(m["DynamicHttpsBps"]));
    }
    if (m.find("StaticHttpBps") != m.end() && !m["StaticHttpBps"].empty()) {
      staticHttpBps = make_shared<double>(boost::any_cast<double>(m["StaticHttpBps"]));
    }
    if (m.find("StaticHttpsBps") != m.end() && !m["StaticHttpsBps"].empty()) {
      staticHttpsBps = make_shared<double>(boost::any_cast<double>(m["StaticHttpsBps"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval() {}

  explicit DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval() = default;
};
class DescribeDcdnDomainBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval> bpsDataPerInterval{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainBpsDataResponseBody() {}

  explicit DescribeDcdnDomainBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataPerInterval) {
      res["BpsDataPerInterval"] = bpsDataPerInterval ? boost::any(bpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataPerInterval") != m.end() && !m["BpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataPerInterval"].type()) {
        DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataPerInterval"]));
        bpsDataPerInterval = make_shared<DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval>(model1);
      }
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainBpsDataResponseBody() = default;
};
class DescribeDcdnDomainBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainBpsDataResponseBody> body{};

  DescribeDcdnDomainBpsDataResponse() {}

  explicit DescribeDcdnDomainBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainBpsDataResponse() = default;
};
class DescribeDcdnDomainBpsDataByLayerRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> layer{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainBpsDataByLayerRequest() {}

  explicit DescribeDcdnDomainBpsDataByLayerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<string>(boost::any_cast<string>(m["Layer"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainBpsDataByLayerRequest() = default;
};
class DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> dynamicTrafficValue{};
  shared_ptr<string> dynamicValue{};
  shared_ptr<string> staticTrafficValue{};
  shared_ptr<string> staticValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> trafficValue{};
  shared_ptr<string> value{};

  DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule() {}

  explicit DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicTrafficValue) {
      res["DynamicTrafficValue"] = boost::any(*dynamicTrafficValue);
    }
    if (dynamicValue) {
      res["DynamicValue"] = boost::any(*dynamicValue);
    }
    if (staticTrafficValue) {
      res["StaticTrafficValue"] = boost::any(*staticTrafficValue);
    }
    if (staticValue) {
      res["StaticValue"] = boost::any(*staticValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (trafficValue) {
      res["TrafficValue"] = boost::any(*trafficValue);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicTrafficValue") != m.end() && !m["DynamicTrafficValue"].empty()) {
      dynamicTrafficValue = make_shared<string>(boost::any_cast<string>(m["DynamicTrafficValue"]));
    }
    if (m.find("DynamicValue") != m.end() && !m["DynamicValue"].empty()) {
      dynamicValue = make_shared<string>(boost::any_cast<string>(m["DynamicValue"]));
    }
    if (m.find("StaticTrafficValue") != m.end() && !m["StaticTrafficValue"].empty()) {
      staticTrafficValue = make_shared<string>(boost::any_cast<string>(m["StaticTrafficValue"]));
    }
    if (m.find("StaticValue") != m.end() && !m["StaticValue"].empty()) {
      staticValue = make_shared<string>(boost::any_cast<string>(m["StaticValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TrafficValue") != m.end() && !m["TrafficValue"].empty()) {
      trafficValue = make_shared<string>(boost::any_cast<string>(m["TrafficValue"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule() = default;
};
class DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule>> dataModule{};

  DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval() {}

  explicit DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval() = default;
};
class DescribeDcdnDomainBpsDataByLayerResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval> bpsDataInterval{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> requestId{};

  DescribeDcdnDomainBpsDataByLayerResponseBody() {}

  explicit DescribeDcdnDomainBpsDataByLayerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataInterval) {
      res["BpsDataInterval"] = bpsDataInterval ? boost::any(bpsDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataInterval") != m.end() && !m["BpsDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataInterval"].type()) {
        DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataInterval"]));
        bpsDataInterval = make_shared<DescribeDcdnDomainBpsDataByLayerResponseBodyBpsDataInterval>(model1);
      }
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDomainBpsDataByLayerResponseBody() = default;
};
class DescribeDcdnDomainBpsDataByLayerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainBpsDataByLayerResponseBody> body{};

  DescribeDcdnDomainBpsDataByLayerResponse() {}

  explicit DescribeDcdnDomainBpsDataByLayerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainBpsDataByLayerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainBpsDataByLayerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainBpsDataByLayerResponse() = default;
};
class DescribeDcdnDomainByCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<bool> exact{};
  shared_ptr<string> SSLPub{};
  shared_ptr<bool> SSLStatus{};

  DescribeDcdnDomainByCertificateRequest() {}

  explicit DescribeDcdnDomainByCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exact) {
      res["Exact"] = boost::any(*exact);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (SSLStatus) {
      res["SSLStatus"] = boost::any(*SSLStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Exact") != m.end() && !m["Exact"].empty()) {
      exact = make_shared<bool>(boost::any_cast<bool>(m["Exact"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("SSLStatus") != m.end() && !m["SSLStatus"].empty()) {
      SSLStatus = make_shared<bool>(boost::any_cast<bool>(m["SSLStatus"]));
    }
  }


  virtual ~DescribeDcdnDomainByCertificateRequest() = default;
};
class DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> certCaIsLegacy{};
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certExpired{};
  shared_ptr<string> certStartTime{};
  shared_ptr<string> certSubjectCommonName{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainList{};
  shared_ptr<string> domainNames{};
  shared_ptr<string> issuer{};

  DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo() {}

  explicit DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certCaIsLegacy) {
      res["CertCaIsLegacy"] = boost::any(*certCaIsLegacy);
    }
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certExpired) {
      res["CertExpired"] = boost::any(*certExpired);
    }
    if (certStartTime) {
      res["CertStartTime"] = boost::any(*certStartTime);
    }
    if (certSubjectCommonName) {
      res["CertSubjectCommonName"] = boost::any(*certSubjectCommonName);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainList) {
      res["DomainList"] = boost::any(*domainList);
    }
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertCaIsLegacy") != m.end() && !m["CertCaIsLegacy"].empty()) {
      certCaIsLegacy = make_shared<string>(boost::any_cast<string>(m["CertCaIsLegacy"]));
    }
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertExpired") != m.end() && !m["CertExpired"].empty()) {
      certExpired = make_shared<string>(boost::any_cast<string>(m["CertExpired"]));
    }
    if (m.find("CertStartTime") != m.end() && !m["CertStartTime"].empty()) {
      certStartTime = make_shared<string>(boost::any_cast<string>(m["CertStartTime"]));
    }
    if (m.find("CertSubjectCommonName") != m.end() && !m["CertSubjectCommonName"].empty()) {
      certSubjectCommonName = make_shared<string>(boost::any_cast<string>(m["CertSubjectCommonName"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainList") != m.end() && !m["DomainList"].empty()) {
      domainList = make_shared<string>(boost::any_cast<string>(m["DomainList"]));
    }
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
  }


  virtual ~DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo() = default;
};
class DescribeDcdnDomainByCertificateResponseBodyCertInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo>> certInfo{};

  DescribeDcdnDomainByCertificateResponseBodyCertInfos() {}

  explicit DescribeDcdnDomainByCertificateResponseBodyCertInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfo) {
      vector<boost::any> temp1;
      for(auto item1:*certInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CertInfo"].type()) {
        vector<DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certInfo = make_shared<vector<DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainByCertificateResponseBodyCertInfos() = default;
};
class DescribeDcdnDomainByCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainByCertificateResponseBodyCertInfos> certInfos{};
  shared_ptr<string> requestId{};

  DescribeDcdnDomainByCertificateResponseBody() {}

  explicit DescribeDcdnDomainByCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfos) {
      res["CertInfos"] = certInfos ? boost::any(certInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfos") != m.end() && !m["CertInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertInfos"].type()) {
        DescribeDcdnDomainByCertificateResponseBodyCertInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertInfos"]));
        certInfos = make_shared<DescribeDcdnDomainByCertificateResponseBodyCertInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDomainByCertificateResponseBody() = default;
};
class DescribeDcdnDomainByCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainByCertificateResponseBody> body{};

  DescribeDcdnDomainByCertificateResponse() {}

  explicit DescribeDcdnDomainByCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainByCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainByCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainByCertificateResponse() = default;
};
class DescribeDcdnDomainCcActivityLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> triggerObject{};
  shared_ptr<string> value{};

  DescribeDcdnDomainCcActivityLogRequest() {}

  explicit DescribeDcdnDomainCcActivityLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (triggerObject) {
      res["TriggerObject"] = boost::any(*triggerObject);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TriggerObject") != m.end() && !m["TriggerObject"].empty()) {
      triggerObject = make_shared<string>(boost::any_cast<string>(m["TriggerObject"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnDomainCcActivityLogRequest() = default;
};
class DescribeDcdnDomainCcActivityLogResponseBodyActivityLog : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> triggerObject{};
  shared_ptr<long> ttl{};
  shared_ptr<string> value{};

  DescribeDcdnDomainCcActivityLogResponseBodyActivityLog() {}

  explicit DescribeDcdnDomainCcActivityLogResponseBodyActivityLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (triggerObject) {
      res["TriggerObject"] = boost::any(*triggerObject);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TriggerObject") != m.end() && !m["TriggerObject"].empty()) {
      triggerObject = make_shared<string>(boost::any_cast<string>(m["TriggerObject"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnDomainCcActivityLogResponseBodyActivityLog() = default;
};
class DescribeDcdnDomainCcActivityLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainCcActivityLogResponseBodyActivityLog>> activityLog{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeDcdnDomainCcActivityLogResponseBody() {}

  explicit DescribeDcdnDomainCcActivityLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityLog) {
      vector<boost::any> temp1;
      for(auto item1:*activityLog){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ActivityLog"] = boost::any(temp1);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityLog") != m.end() && !m["ActivityLog"].empty()) {
      if (typeid(vector<boost::any>) == m["ActivityLog"].type()) {
        vector<DescribeDcdnDomainCcActivityLogResponseBodyActivityLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ActivityLog"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainCcActivityLogResponseBodyActivityLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        activityLog = make_shared<vector<DescribeDcdnDomainCcActivityLogResponseBodyActivityLog>>(expect1);
      }
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeDcdnDomainCcActivityLogResponseBody() = default;
};
class DescribeDcdnDomainCcActivityLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainCcActivityLogResponseBody> body{};

  DescribeDcdnDomainCcActivityLogResponse() {}

  explicit DescribeDcdnDomainCcActivityLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainCcActivityLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainCcActivityLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainCcActivityLogResponse() = default;
};
class DescribeDcdnDomainCertificateInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  DescribeDcdnDomainCertificateInfoRequest() {}

  explicit DescribeDcdnDomainCertificateInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnDomainCertificateInfoRequest() = default;
};
class DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> certDomainName{};
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certId{};
  shared_ptr<string> certLife{};
  shared_ptr<string> certName{};
  shared_ptr<string> certOrg{};
  shared_ptr<string> certRegion{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> status{};

  DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo() {}

  explicit DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certDomainName) {
      res["CertDomainName"] = boost::any(*certDomainName);
    }
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certLife) {
      res["CertLife"] = boost::any(*certLife);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certOrg) {
      res["CertOrg"] = boost::any(*certOrg);
    }
    if (certRegion) {
      res["CertRegion"] = boost::any(*certRegion);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertDomainName") != m.end() && !m["CertDomainName"].empty()) {
      certDomainName = make_shared<string>(boost::any_cast<string>(m["CertDomainName"]));
    }
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CertLife") != m.end() && !m["CertLife"].empty()) {
      certLife = make_shared<string>(boost::any_cast<string>(m["CertLife"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertOrg") != m.end() && !m["CertOrg"].empty()) {
      certOrg = make_shared<string>(boost::any_cast<string>(m["CertOrg"]));
    }
    if (m.find("CertRegion") != m.end() && !m["CertRegion"].empty()) {
      certRegion = make_shared<string>(boost::any_cast<string>(m["CertRegion"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo() = default;
};
class DescribeDcdnDomainCertificateInfoResponseBodyCertInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo>> certInfo{};

  DescribeDcdnDomainCertificateInfoResponseBodyCertInfos() {}

  explicit DescribeDcdnDomainCertificateInfoResponseBodyCertInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfo) {
      vector<boost::any> temp1;
      for(auto item1:*certInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CertInfo"].type()) {
        vector<DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certInfo = make_shared<vector<DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainCertificateInfoResponseBodyCertInfos() = default;
};
class DescribeDcdnDomainCertificateInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainCertificateInfoResponseBodyCertInfos> certInfos{};
  shared_ptr<string> requestId{};

  DescribeDcdnDomainCertificateInfoResponseBody() {}

  explicit DescribeDcdnDomainCertificateInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfos) {
      res["CertInfos"] = certInfos ? boost::any(certInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfos") != m.end() && !m["CertInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertInfos"].type()) {
        DescribeDcdnDomainCertificateInfoResponseBodyCertInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertInfos"]));
        certInfos = make_shared<DescribeDcdnDomainCertificateInfoResponseBodyCertInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDomainCertificateInfoResponseBody() = default;
};
class DescribeDcdnDomainCertificateInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainCertificateInfoResponseBody> body{};

  DescribeDcdnDomainCertificateInfoResponse() {}

  explicit DescribeDcdnDomainCertificateInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainCertificateInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainCertificateInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainCertificateInfoResponse() = default;
};
class DescribeDcdnDomainCnameRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  DescribeDcdnDomainCnameRequest() {}

  explicit DescribeDcdnDomainCnameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnDomainCnameRequest() = default;
};
class DescribeDcdnDomainCnameResponseBodyCnameDatasData : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> domain{};
  shared_ptr<long> status{};

  DescribeDcdnDomainCnameResponseBodyCnameDatasData() {}

  explicit DescribeDcdnDomainCnameResponseBodyCnameDatasData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeDcdnDomainCnameResponseBodyCnameDatasData() = default;
};
class DescribeDcdnDomainCnameResponseBodyCnameDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainCnameResponseBodyCnameDatasData>> data{};

  DescribeDcdnDomainCnameResponseBodyCnameDatas() {}

  explicit DescribeDcdnDomainCnameResponseBodyCnameDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeDcdnDomainCnameResponseBodyCnameDatasData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainCnameResponseBodyCnameDatasData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeDcdnDomainCnameResponseBodyCnameDatasData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainCnameResponseBodyCnameDatas() = default;
};
class DescribeDcdnDomainCnameResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainCnameResponseBodyCnameDatas> cnameDatas{};
  shared_ptr<string> requestId{};

  DescribeDcdnDomainCnameResponseBody() {}

  explicit DescribeDcdnDomainCnameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cnameDatas) {
      res["CnameDatas"] = cnameDatas ? boost::any(cnameDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CnameDatas") != m.end() && !m["CnameDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["CnameDatas"].type()) {
        DescribeDcdnDomainCnameResponseBodyCnameDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CnameDatas"]));
        cnameDatas = make_shared<DescribeDcdnDomainCnameResponseBodyCnameDatas>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDomainCnameResponseBody() = default;
};
class DescribeDcdnDomainCnameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainCnameResponseBody> body{};

  DescribeDcdnDomainCnameResponse() {}

  explicit DescribeDcdnDomainCnameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainCnameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainCnameResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainCnameResponse() = default;
};
class DescribeDcdnDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> functionNames{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnDomainConfigsRequest() {}

  explicit DescribeDcdnDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnDomainConfigsRequest() = default;
};
class DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};

  DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg() {}

  explicit DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
  }


  virtual ~DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg() = default;
};
class DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg>> functionArg{};

  DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs() {}

  explicit DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionArg) {
      vector<boost::any> temp1;
      for(auto item1:*functionArg){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FunctionArg"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionArg") != m.end() && !m["FunctionArg"].empty()) {
      if (typeid(vector<boost::any>) == m["FunctionArg"].type()) {
        vector<DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FunctionArg"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functionArg = make_shared<vector<DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs() = default;
};
class DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs> functionArgs{};
  shared_ptr<string> functionName{};
  shared_ptr<string> parentId{};
  shared_ptr<string> status{};

  DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig() {}

  explicit DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionArgs) {
      res["FunctionArgs"] = functionArgs ? boost::any(functionArgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionArgs"].type()) {
        DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionArgs"]));
        functionArgs = make_shared<DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs>(model1);
      }
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig() = default;
};
class DescribeDcdnDomainConfigsResponseBodyDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig>> domainConfig{};

  DescribeDcdnDomainConfigsResponseBodyDomainConfigs() {}

  explicit DescribeDcdnDomainConfigsResponseBodyDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfig) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfig") != m.end() && !m["DomainConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfig"].type()) {
        vector<DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfig = make_shared<vector<DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainConfigsResponseBodyDomainConfigs() = default;
};
class DescribeDcdnDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainConfigsResponseBodyDomainConfigs> domainConfigs{};
  shared_ptr<string> requestId{};

  DescribeDcdnDomainConfigsResponseBody() {}

  explicit DescribeDcdnDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfigs) {
      res["DomainConfigs"] = domainConfigs ? boost::any(domainConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfigs") != m.end() && !m["DomainConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainConfigs"].type()) {
        DescribeDcdnDomainConfigsResponseBodyDomainConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainConfigs"]));
        domainConfigs = make_shared<DescribeDcdnDomainConfigsResponseBodyDomainConfigs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDomainConfigsResponseBody() = default;
};
class DescribeDcdnDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainConfigsResponseBody> body{};

  DescribeDcdnDomainConfigsResponse() {}

  explicit DescribeDcdnDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainConfigsResponse() = default;
};
class DescribeDcdnDomainDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnDomainDetailRequest() {}

  explicit DescribeDcdnDomainDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnDomainDetailRequest() = default;
};
class DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> enabled{};
  shared_ptr<long> port{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};
  shared_ptr<string> weight{};

  DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource() {}

  explicit DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<string>(boost::any_cast<string>(m["Enabled"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
  }


  virtual ~DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource() = default;
};
class DescribeDcdnDomainDetailResponseBodyDomainDetailSources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource>> source{};

  DescribeDcdnDomainDetailResponseBodyDomainDetailSources() {}

  explicit DescribeDcdnDomainDetailResponseBodyDomainDetailSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      vector<boost::any> temp1;
      for(auto item1:*source){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Source"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(vector<boost::any>) == m["Source"].type()) {
        vector<DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Source"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        source = make_shared<vector<DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainDetailResponseBodyDomainDetailSources() = default;
};
class DescribeDcdnDomainDetailResponseBodyDomainDetail : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> scene{};
  shared_ptr<string> scope{};
  shared_ptr<DescribeDcdnDomainDetailResponseBodyDomainDetailSources> sources{};

  DescribeDcdnDomainDetailResponseBodyDomainDetail() {}

  explicit DescribeDcdnDomainDetailResponseBodyDomainDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (sources) {
      res["Sources"] = sources ? boost::any(sources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sources"].type()) {
        DescribeDcdnDomainDetailResponseBodyDomainDetailSources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sources"]));
        sources = make_shared<DescribeDcdnDomainDetailResponseBodyDomainDetailSources>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainDetailResponseBodyDomainDetail() = default;
};
class DescribeDcdnDomainDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainDetailResponseBodyDomainDetail> domainDetail{};
  shared_ptr<string> requestId{};

  DescribeDcdnDomainDetailResponseBody() {}

  explicit DescribeDcdnDomainDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainDetail) {
      res["DomainDetail"] = domainDetail ? boost::any(domainDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainDetail") != m.end() && !m["DomainDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainDetail"].type()) {
        DescribeDcdnDomainDetailResponseBodyDomainDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainDetail"]));
        domainDetail = make_shared<DescribeDcdnDomainDetailResponseBodyDomainDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDomainDetailResponseBody() = default;
};
class DescribeDcdnDomainDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainDetailResponseBody> body{};

  DescribeDcdnDomainDetailResponse() {}

  explicit DescribeDcdnDomainDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainDetailResponse() = default;
};
class DescribeDcdnDomainHitRateDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainHitRateDataRequest() {}

  explicit DescribeDcdnDomainHitRateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainHitRateDataRequest() = default;
};
class DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<double> byteHitRate{};
  shared_ptr<double> reqHitRate{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule() {}

  explicit DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (byteHitRate) {
      res["ByteHitRate"] = boost::any(*byteHitRate);
    }
    if (reqHitRate) {
      res["ReqHitRate"] = boost::any(*reqHitRate);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ByteHitRate") != m.end() && !m["ByteHitRate"].empty()) {
      byteHitRate = make_shared<double>(boost::any_cast<double>(m["ByteHitRate"]));
    }
    if (m.find("ReqHitRate") != m.end() && !m["ReqHitRate"].empty()) {
      reqHitRate = make_shared<double>(boost::any_cast<double>(m["ReqHitRate"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule() = default;
};
class DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval() {}

  explicit DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval() = default;
};
class DescribeDcdnDomainHitRateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval> hitRatePerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainHitRateDataResponseBody() {}

  explicit DescribeDcdnDomainHitRateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (hitRatePerInterval) {
      res["HitRatePerInterval"] = hitRatePerInterval ? boost::any(hitRatePerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("HitRatePerInterval") != m.end() && !m["HitRatePerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["HitRatePerInterval"].type()) {
        DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HitRatePerInterval"]));
        hitRatePerInterval = make_shared<DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainHitRateDataResponseBody() = default;
};
class DescribeDcdnDomainHitRateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainHitRateDataResponseBody> body{};

  DescribeDcdnDomainHitRateDataResponse() {}

  explicit DescribeDcdnDomainHitRateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainHitRateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainHitRateDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainHitRateDataResponse() = default;
};
class DescribeDcdnDomainHttpCodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainHttpCodeDataRequest() {}

  explicit DescribeDcdnDomainHttpCodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataRequest() = default;
};
class DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<double> count{};
  shared_ptr<double> proportion{};

  DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule() {}

  explicit DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<double>(boost::any_cast<double>(m["Count"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<double>(boost::any_cast<double>(m["Proportion"]));
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule() = default;
};
class DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule>> httpCodeDataModule{};

  DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval() {}

  explicit DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpCodeDataModule) {
      vector<boost::any> temp1;
      for(auto item1:*httpCodeDataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpCodeDataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpCodeDataModule") != m.end() && !m["HttpCodeDataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpCodeDataModule"].type()) {
        vector<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpCodeDataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpCodeDataModule = make_shared<vector<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval() = default;
};
class DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval> httpCodeDataPerInterval{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpCodeDataPerInterval) {
      res["HttpCodeDataPerInterval"] = httpCodeDataPerInterval ? boost::any(httpCodeDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpCodeDataPerInterval") != m.end() && !m["HttpCodeDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpCodeDataPerInterval"].type()) {
        DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpCodeDataPerInterval"]));
        httpCodeDataPerInterval = make_shared<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval>(model1);
      }
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval() {}

  explicit DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval() = default;
};
class DescribeDcdnDomainHttpCodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval> dataPerInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainHttpCodeDataResponseBody() {}

  explicit DescribeDcdnDomainHttpCodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (dataPerInterval) {
      res["DataPerInterval"] = dataPerInterval ? boost::any(dataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DataPerInterval") != m.end() && !m["DataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataPerInterval"].type()) {
        DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataPerInterval"]));
        dataPerInterval = make_shared<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval>(model1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataResponseBody() = default;
};
class DescribeDcdnDomainHttpCodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainHttpCodeDataResponseBody> body{};

  DescribeDcdnDomainHttpCodeDataResponse() {}

  explicit DescribeDcdnDomainHttpCodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainHttpCodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainHttpCodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataResponse() = default;
};
class DescribeDcdnDomainHttpCodeDataByLayerRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> layer{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainHttpCodeDataByLayerRequest() {}

  explicit DescribeDcdnDomainHttpCodeDataByLayerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<string>(boost::any_cast<string>(m["Layer"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataByLayerRequest() = default;
};
class DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> totalValue{};
  shared_ptr<map<string, boost::any>> value{};

  DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule() {}

  explicit DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (totalValue) {
      res["TotalValue"] = boost::any(*totalValue);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("TotalValue") != m.end() && !m["TotalValue"].empty()) {
      totalValue = make_shared<string>(boost::any_cast<string>(m["TotalValue"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Value"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      value = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule() = default;
};
class DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule>> dataModule{};

  DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval() {}

  explicit DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval() = default;
};
class DescribeDcdnDomainHttpCodeDataByLayerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval> httpCodeDataInterval{};
  shared_ptr<string> requestId{};

  DescribeDcdnDomainHttpCodeDataByLayerResponseBody() {}

  explicit DescribeDcdnDomainHttpCodeDataByLayerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (httpCodeDataInterval) {
      res["HttpCodeDataInterval"] = httpCodeDataInterval ? boost::any(httpCodeDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("HttpCodeDataInterval") != m.end() && !m["HttpCodeDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpCodeDataInterval"].type()) {
        DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpCodeDataInterval"]));
        httpCodeDataInterval = make_shared<DescribeDcdnDomainHttpCodeDataByLayerResponseBodyHttpCodeDataInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataByLayerResponseBody() = default;
};
class DescribeDcdnDomainHttpCodeDataByLayerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainHttpCodeDataByLayerResponseBody> body{};

  DescribeDcdnDomainHttpCodeDataByLayerResponse() {}

  explicit DescribeDcdnDomainHttpCodeDataByLayerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainHttpCodeDataByLayerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainHttpCodeDataByLayerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataByLayerResponse() = default;
};
class DescribeDcdnDomainIpaBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> fixTimeGap{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeMerge{};

  DescribeDcdnDomainIpaBpsDataRequest() {}

  explicit DescribeDcdnDomainIpaBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fixTimeGap) {
      res["FixTimeGap"] = boost::any(*fixTimeGap);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timeMerge) {
      res["TimeMerge"] = boost::any(*timeMerge);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FixTimeGap") != m.end() && !m["FixTimeGap"].empty()) {
      fixTimeGap = make_shared<string>(boost::any_cast<string>(m["FixTimeGap"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TimeMerge") != m.end() && !m["TimeMerge"].empty()) {
      timeMerge = make_shared<string>(boost::any_cast<string>(m["TimeMerge"]));
    }
  }


  virtual ~DescribeDcdnDomainIpaBpsDataRequest() = default;
};
class DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<double> ipaBps{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipaBps) {
      res["IpaBps"] = boost::any(*ipaBps);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpaBps") != m.end() && !m["IpaBps"].empty()) {
      ipaBps = make_shared<double>(boost::any_cast<double>(m["IpaBps"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval() {}

  explicit DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval() = default;
};
class DescribeDcdnDomainIpaBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval> bpsDataPerInterval{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainIpaBpsDataResponseBody() {}

  explicit DescribeDcdnDomainIpaBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataPerInterval) {
      res["BpsDataPerInterval"] = bpsDataPerInterval ? boost::any(bpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataPerInterval") != m.end() && !m["BpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataPerInterval"].type()) {
        DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataPerInterval"]));
        bpsDataPerInterval = make_shared<DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval>(model1);
      }
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainIpaBpsDataResponseBody() = default;
};
class DescribeDcdnDomainIpaBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainIpaBpsDataResponseBody> body{};

  DescribeDcdnDomainIpaBpsDataResponse() {}

  explicit DescribeDcdnDomainIpaBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainIpaBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainIpaBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIpaBpsDataResponse() = default;
};
class DescribeDcdnDomainIpaConnDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> splitBy{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainIpaConnDataRequest() {}

  explicit DescribeDcdnDomainIpaConnDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (splitBy) {
      res["SplitBy"] = boost::any(*splitBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("SplitBy") != m.end() && !m["SplitBy"].empty()) {
      splitBy = make_shared<string>(boost::any_cast<string>(m["SplitBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainIpaConnDataRequest() = default;
};
class DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<long> connections{};
  shared_ptr<string> domain{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connections) {
      res["Connections"] = boost::any(*connections);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Connections") != m.end() && !m["Connections"].empty()) {
      connections = make_shared<long>(boost::any_cast<long>(m["Connections"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval() {}

  explicit DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval() = default;
};
class DescribeDcdnDomainIpaConnDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval> connectionDataPerInterval{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainIpaConnDataResponseBody() {}

  explicit DescribeDcdnDomainIpaConnDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionDataPerInterval) {
      res["ConnectionDataPerInterval"] = connectionDataPerInterval ? boost::any(connectionDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionDataPerInterval") != m.end() && !m["ConnectionDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConnectionDataPerInterval"].type()) {
        DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConnectionDataPerInterval"]));
        connectionDataPerInterval = make_shared<DescribeDcdnDomainIpaConnDataResponseBodyConnectionDataPerInterval>(model1);
      }
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainIpaConnDataResponseBody() = default;
};
class DescribeDcdnDomainIpaConnDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainIpaConnDataResponseBody> body{};

  DescribeDcdnDomainIpaConnDataResponse() {}

  explicit DescribeDcdnDomainIpaConnDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainIpaConnDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainIpaConnDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIpaConnDataResponse() = default;
};
class DescribeDcdnDomainIpaTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> fixTimeGap{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeMerge{};

  DescribeDcdnDomainIpaTrafficDataRequest() {}

  explicit DescribeDcdnDomainIpaTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (fixTimeGap) {
      res["FixTimeGap"] = boost::any(*fixTimeGap);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timeMerge) {
      res["TimeMerge"] = boost::any(*timeMerge);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FixTimeGap") != m.end() && !m["FixTimeGap"].empty()) {
      fixTimeGap = make_shared<string>(boost::any_cast<string>(m["FixTimeGap"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TimeMerge") != m.end() && !m["TimeMerge"].empty()) {
      timeMerge = make_shared<string>(boost::any_cast<string>(m["TimeMerge"]));
    }
  }


  virtual ~DescribeDcdnDomainIpaTrafficDataRequest() = default;
};
class DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<double> ipaTraffic{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipaTraffic) {
      res["IpaTraffic"] = boost::any(*ipaTraffic);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpaTraffic") != m.end() && !m["IpaTraffic"].empty()) {
      ipaTraffic = make_shared<double>(boost::any_cast<double>(m["IpaTraffic"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval() {}

  explicit DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval() = default;
};
class DescribeDcdnDomainIpaTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval> trafficDataPerInterval{};

  DescribeDcdnDomainIpaTrafficDataResponseBody() {}

  explicit DescribeDcdnDomainIpaTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (trafficDataPerInterval) {
      res["TrafficDataPerInterval"] = trafficDataPerInterval ? boost::any(trafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TrafficDataPerInterval") != m.end() && !m["TrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficDataPerInterval"].type()) {
        DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficDataPerInterval"]));
        trafficDataPerInterval = make_shared<DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIpaTrafficDataResponseBody() = default;
};
class DescribeDcdnDomainIpaTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainIpaTrafficDataResponseBody> body{};

  DescribeDcdnDomainIpaTrafficDataResponse() {}

  explicit DescribeDcdnDomainIpaTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainIpaTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainIpaTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIpaTrafficDataResponse() = default;
};
class DescribeDcdnDomainIspDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainIspDataRequest() {}

  explicit DescribeDcdnDomainIspDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainIspDataRequest() = default;
};
class DescribeDcdnDomainIspDataResponseBodyValueIspProportionData : public Darabonba::Model {
public:
  shared_ptr<string> avgObjectSize{};
  shared_ptr<string> avgResponseRate{};
  shared_ptr<string> avgResponseTime{};
  shared_ptr<string> bps{};
  shared_ptr<string> bytesProportion{};
  shared_ptr<string> isp{};
  shared_ptr<string> ispEname{};
  shared_ptr<string> proportion{};
  shared_ptr<string> qps{};
  shared_ptr<string> totalBytes{};
  shared_ptr<string> totalQuery{};

  DescribeDcdnDomainIspDataResponseBodyValueIspProportionData() {}

  explicit DescribeDcdnDomainIspDataResponseBodyValueIspProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgObjectSize) {
      res["AvgObjectSize"] = boost::any(*avgObjectSize);
    }
    if (avgResponseRate) {
      res["AvgResponseRate"] = boost::any(*avgResponseRate);
    }
    if (avgResponseTime) {
      res["AvgResponseTime"] = boost::any(*avgResponseTime);
    }
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (bytesProportion) {
      res["BytesProportion"] = boost::any(*bytesProportion);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (ispEname) {
      res["IspEname"] = boost::any(*ispEname);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (totalBytes) {
      res["TotalBytes"] = boost::any(*totalBytes);
    }
    if (totalQuery) {
      res["TotalQuery"] = boost::any(*totalQuery);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgObjectSize") != m.end() && !m["AvgObjectSize"].empty()) {
      avgObjectSize = make_shared<string>(boost::any_cast<string>(m["AvgObjectSize"]));
    }
    if (m.find("AvgResponseRate") != m.end() && !m["AvgResponseRate"].empty()) {
      avgResponseRate = make_shared<string>(boost::any_cast<string>(m["AvgResponseRate"]));
    }
    if (m.find("AvgResponseTime") != m.end() && !m["AvgResponseTime"].empty()) {
      avgResponseTime = make_shared<string>(boost::any_cast<string>(m["AvgResponseTime"]));
    }
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<string>(boost::any_cast<string>(m["Bps"]));
    }
    if (m.find("BytesProportion") != m.end() && !m["BytesProportion"].empty()) {
      bytesProportion = make_shared<string>(boost::any_cast<string>(m["BytesProportion"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("IspEname") != m.end() && !m["IspEname"].empty()) {
      ispEname = make_shared<string>(boost::any_cast<string>(m["IspEname"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<string>(boost::any_cast<string>(m["Qps"]));
    }
    if (m.find("TotalBytes") != m.end() && !m["TotalBytes"].empty()) {
      totalBytes = make_shared<string>(boost::any_cast<string>(m["TotalBytes"]));
    }
    if (m.find("TotalQuery") != m.end() && !m["TotalQuery"].empty()) {
      totalQuery = make_shared<string>(boost::any_cast<string>(m["TotalQuery"]));
    }
  }


  virtual ~DescribeDcdnDomainIspDataResponseBodyValueIspProportionData() = default;
};
class DescribeDcdnDomainIspDataResponseBodyValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainIspDataResponseBodyValueIspProportionData>> ispProportionData{};

  DescribeDcdnDomainIspDataResponseBodyValue() {}

  explicit DescribeDcdnDomainIspDataResponseBodyValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ispProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*ispProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IspProportionData") != m.end() && !m["IspProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["IspProportionData"].type()) {
        vector<DescribeDcdnDomainIspDataResponseBodyValueIspProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainIspDataResponseBodyValueIspProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispProportionData = make_shared<vector<DescribeDcdnDomainIspDataResponseBodyValueIspProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIspDataResponseBodyValue() = default;
};
class DescribeDcdnDomainIspDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDcdnDomainIspDataResponseBodyValue> value{};

  DescribeDcdnDomainIspDataResponseBody() {}

  explicit DescribeDcdnDomainIspDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeDcdnDomainIspDataResponseBodyValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeDcdnDomainIspDataResponseBodyValue>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIspDataResponseBody() = default;
};
class DescribeDcdnDomainIspDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainIspDataResponseBody> body{};

  DescribeDcdnDomainIspDataResponse() {}

  explicit DescribeDcdnDomainIspDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainIspDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainIspDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIspDataResponse() = default;
};
class DescribeDcdnDomainLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainLogRequest() {}

  explicit DescribeDcdnDomainLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainLogRequest() = default;
};
class DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> logName{};
  shared_ptr<string> logPath{};
  shared_ptr<long> logSize{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() {}

  explicit DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (logName) {
      res["LogName"] = boost::any(*logName);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (logSize) {
      res["LogSize"] = boost::any(*logSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("LogName") != m.end() && !m["LogName"].empty()) {
      logName = make_shared<string>(boost::any_cast<string>(m["LogName"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("LogSize") != m.end() && !m["LogSize"].empty()) {
      logSize = make_shared<long>(boost::any_cast<long>(m["LogSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() = default;
};
class DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>> logInfoDetail{};

  DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() {}

  explicit DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfoDetail) {
      vector<boost::any> temp1;
      for(auto item1:*logInfoDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfoDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfoDetail") != m.end() && !m["LogInfoDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfoDetail"].type()) {
        vector<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfoDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfoDetail = make_shared<vector<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() = default;
};
class DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() {}

  explicit DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() = default;
};
class DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail : public Darabonba::Model {
public:
  shared_ptr<long> logCount{};
  shared_ptr<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos> logInfos{};
  shared_ptr<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos> pageInfos{};

  DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail() {}

  explicit DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logCount) {
      res["LogCount"] = boost::any(*logCount);
    }
    if (logInfos) {
      res["LogInfos"] = logInfos ? boost::any(logInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageInfos) {
      res["PageInfos"] = pageInfos ? boost::any(pageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogCount") != m.end() && !m["LogCount"].empty()) {
      logCount = make_shared<long>(boost::any_cast<long>(m["LogCount"]));
    }
    if (m.find("LogInfos") != m.end() && !m["LogInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogInfos"].type()) {
        DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogInfos"]));
        logInfos = make_shared<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos>(model1);
      }
    }
    if (m.find("PageInfos") != m.end() && !m["PageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfos"].type()) {
        DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfos"]));
        pageInfos = make_shared<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail() = default;
};
class DescribeDcdnDomainLogResponseBodyDomainLogDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail>> domainLogDetail{};

  DescribeDcdnDomainLogResponseBodyDomainLogDetails() {}

  explicit DescribeDcdnDomainLogResponseBodyDomainLogDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetail) {
      vector<boost::any> temp1;
      for(auto item1:*domainLogDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainLogDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetail") != m.end() && !m["DomainLogDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainLogDetail"].type()) {
        vector<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainLogDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainLogDetail = make_shared<vector<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainLogResponseBodyDomainLogDetails() = default;
};
class DescribeDcdnDomainLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainLogResponseBodyDomainLogDetails> domainLogDetails{};
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};

  DescribeDcdnDomainLogResponseBody() {}

  explicit DescribeDcdnDomainLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetails) {
      res["DomainLogDetails"] = domainLogDetails ? boost::any(domainLogDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetails") != m.end() && !m["DomainLogDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainLogDetails"].type()) {
        DescribeDcdnDomainLogResponseBodyDomainLogDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainLogDetails"]));
        domainLogDetails = make_shared<DescribeDcdnDomainLogResponseBodyDomainLogDetails>(model1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDomainLogResponseBody() = default;
};
class DescribeDcdnDomainLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainLogResponseBody> body{};

  DescribeDcdnDomainLogResponse() {}

  explicit DescribeDcdnDomainLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainLogResponse() = default;
};
class DescribeDcdnDomainMultiUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainMultiUsageDataRequest() {}

  explicit DescribeDcdnDomainMultiUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainMultiUsageDataRequest() = default;
};
class DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> request{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> type{};

  DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule() {}

  explicit DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (request) {
      res["Request"] = boost::any(*request);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      request = make_shared<long>(boost::any_cast<long>(m["Request"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule() = default;
};
class DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule>> requestDataModule{};

  DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval() {}

  explicit DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestDataModule) {
      vector<boost::any> temp1;
      for(auto item1:*requestDataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestDataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestDataModule") != m.end() && !m["RequestDataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestDataModule"].type()) {
        vector<DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestDataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestDataModule = make_shared<vector<DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval() = default;
};
class DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<double> bps{};
  shared_ptr<string> domain{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> type{};

  DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule() {}

  explicit DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<double>(boost::any_cast<double>(m["Bps"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule() = default;
};
class DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule>> trafficDataModule{};

  DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval() {}

  explicit DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trafficDataModule) {
      vector<boost::any> temp1;
      for(auto item1:*trafficDataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TrafficDataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrafficDataModule") != m.end() && !m["TrafficDataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["TrafficDataModule"].type()) {
        vector<DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TrafficDataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trafficDataModule = make_shared<vector<DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval() = default;
};
class DescribeDcdnDomainMultiUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval> requestPerInterval{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval> trafficPerInterval{};

  DescribeDcdnDomainMultiUsageDataResponseBody() {}

  explicit DescribeDcdnDomainMultiUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestPerInterval) {
      res["RequestPerInterval"] = requestPerInterval ? boost::any(requestPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (trafficPerInterval) {
      res["TrafficPerInterval"] = trafficPerInterval ? boost::any(trafficPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestPerInterval") != m.end() && !m["RequestPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestPerInterval"].type()) {
        DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestPerInterval"]));
        requestPerInterval = make_shared<DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TrafficPerInterval") != m.end() && !m["TrafficPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficPerInterval"].type()) {
        DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficPerInterval"]));
        trafficPerInterval = make_shared<DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainMultiUsageDataResponseBody() = default;
};
class DescribeDcdnDomainMultiUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainMultiUsageDataResponseBody> body{};

  DescribeDcdnDomainMultiUsageDataResponse() {}

  explicit DescribeDcdnDomainMultiUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainMultiUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainMultiUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainMultiUsageDataResponse() = default;
};
class DescribeDcdnDomainOriginBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainOriginBpsDataRequest() {}

  explicit DescribeDcdnDomainOriginBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainOriginBpsDataRequest() = default;
};
class DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<double> dynamicHttpOriginBps{};
  shared_ptr<double> dynamicHttpsOriginBps{};
  shared_ptr<double> originBps{};
  shared_ptr<double> staticHttpOriginBps{};
  shared_ptr<double> staticHttpsOriginBps{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicHttpOriginBps) {
      res["DynamicHttpOriginBps"] = boost::any(*dynamicHttpOriginBps);
    }
    if (dynamicHttpsOriginBps) {
      res["DynamicHttpsOriginBps"] = boost::any(*dynamicHttpsOriginBps);
    }
    if (originBps) {
      res["OriginBps"] = boost::any(*originBps);
    }
    if (staticHttpOriginBps) {
      res["StaticHttpOriginBps"] = boost::any(*staticHttpOriginBps);
    }
    if (staticHttpsOriginBps) {
      res["StaticHttpsOriginBps"] = boost::any(*staticHttpsOriginBps);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicHttpOriginBps") != m.end() && !m["DynamicHttpOriginBps"].empty()) {
      dynamicHttpOriginBps = make_shared<double>(boost::any_cast<double>(m["DynamicHttpOriginBps"]));
    }
    if (m.find("DynamicHttpsOriginBps") != m.end() && !m["DynamicHttpsOriginBps"].empty()) {
      dynamicHttpsOriginBps = make_shared<double>(boost::any_cast<double>(m["DynamicHttpsOriginBps"]));
    }
    if (m.find("OriginBps") != m.end() && !m["OriginBps"].empty()) {
      originBps = make_shared<double>(boost::any_cast<double>(m["OriginBps"]));
    }
    if (m.find("StaticHttpOriginBps") != m.end() && !m["StaticHttpOriginBps"].empty()) {
      staticHttpOriginBps = make_shared<double>(boost::any_cast<double>(m["StaticHttpOriginBps"]));
    }
    if (m.find("StaticHttpsOriginBps") != m.end() && !m["StaticHttpsOriginBps"].empty()) {
      staticHttpsOriginBps = make_shared<double>(boost::any_cast<double>(m["StaticHttpsOriginBps"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval() {}

  explicit DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval() = default;
};
class DescribeDcdnDomainOriginBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval> originBpsDataPerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainOriginBpsDataResponseBody() {}

  explicit DescribeDcdnDomainOriginBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (originBpsDataPerInterval) {
      res["OriginBpsDataPerInterval"] = originBpsDataPerInterval ? boost::any(originBpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OriginBpsDataPerInterval") != m.end() && !m["OriginBpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["OriginBpsDataPerInterval"].type()) {
        DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OriginBpsDataPerInterval"]));
        originBpsDataPerInterval = make_shared<DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainOriginBpsDataResponseBody() = default;
};
class DescribeDcdnDomainOriginBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainOriginBpsDataResponseBody> body{};

  DescribeDcdnDomainOriginBpsDataResponse() {}

  explicit DescribeDcdnDomainOriginBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainOriginBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainOriginBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainOriginBpsDataResponse() = default;
};
class DescribeDcdnDomainOriginTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainOriginTrafficDataRequest() {}

  explicit DescribeDcdnDomainOriginTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainOriginTrafficDataRequest() = default;
};
class DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<double> dynamicHttpOriginTraffic{};
  shared_ptr<double> dynamicHttpsOriginTraffic{};
  shared_ptr<double> originTraffic{};
  shared_ptr<double> staticHttpOriginTraffic{};
  shared_ptr<double> staticHttpsOriginTraffic{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicHttpOriginTraffic) {
      res["DynamicHttpOriginTraffic"] = boost::any(*dynamicHttpOriginTraffic);
    }
    if (dynamicHttpsOriginTraffic) {
      res["DynamicHttpsOriginTraffic"] = boost::any(*dynamicHttpsOriginTraffic);
    }
    if (originTraffic) {
      res["OriginTraffic"] = boost::any(*originTraffic);
    }
    if (staticHttpOriginTraffic) {
      res["StaticHttpOriginTraffic"] = boost::any(*staticHttpOriginTraffic);
    }
    if (staticHttpsOriginTraffic) {
      res["StaticHttpsOriginTraffic"] = boost::any(*staticHttpsOriginTraffic);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicHttpOriginTraffic") != m.end() && !m["DynamicHttpOriginTraffic"].empty()) {
      dynamicHttpOriginTraffic = make_shared<double>(boost::any_cast<double>(m["DynamicHttpOriginTraffic"]));
    }
    if (m.find("DynamicHttpsOriginTraffic") != m.end() && !m["DynamicHttpsOriginTraffic"].empty()) {
      dynamicHttpsOriginTraffic = make_shared<double>(boost::any_cast<double>(m["DynamicHttpsOriginTraffic"]));
    }
    if (m.find("OriginTraffic") != m.end() && !m["OriginTraffic"].empty()) {
      originTraffic = make_shared<double>(boost::any_cast<double>(m["OriginTraffic"]));
    }
    if (m.find("StaticHttpOriginTraffic") != m.end() && !m["StaticHttpOriginTraffic"].empty()) {
      staticHttpOriginTraffic = make_shared<double>(boost::any_cast<double>(m["StaticHttpOriginTraffic"]));
    }
    if (m.find("StaticHttpsOriginTraffic") != m.end() && !m["StaticHttpsOriginTraffic"].empty()) {
      staticHttpsOriginTraffic = make_shared<double>(boost::any_cast<double>(m["StaticHttpsOriginTraffic"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval() {}

  explicit DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval() = default;
};
class DescribeDcdnDomainOriginTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval> originTrafficDataPerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainOriginTrafficDataResponseBody() {}

  explicit DescribeDcdnDomainOriginTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (originTrafficDataPerInterval) {
      res["OriginTrafficDataPerInterval"] = originTrafficDataPerInterval ? boost::any(originTrafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("OriginTrafficDataPerInterval") != m.end() && !m["OriginTrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["OriginTrafficDataPerInterval"].type()) {
        DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OriginTrafficDataPerInterval"]));
        originTrafficDataPerInterval = make_shared<DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainOriginTrafficDataResponseBody() = default;
};
class DescribeDcdnDomainOriginTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainOriginTrafficDataResponseBody> body{};

  DescribeDcdnDomainOriginTrafficDataResponse() {}

  explicit DescribeDcdnDomainOriginTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainOriginTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainOriginTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainOriginTrafficDataResponse() = default;
};
class DescribeDcdnDomainPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  DescribeDcdnDomainPropertyRequest() {}

  explicit DescribeDcdnDomainPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnDomainPropertyRequest() = default;
};
class DescribeDcdnDomainPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> protocol{};
  shared_ptr<string> requestId{};

  DescribeDcdnDomainPropertyResponseBody() {}

  explicit DescribeDcdnDomainPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDomainPropertyResponseBody() = default;
};
class DescribeDcdnDomainPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainPropertyResponseBody> body{};

  DescribeDcdnDomainPropertyResponse() {}

  explicit DescribeDcdnDomainPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainPropertyResponse() = default;
};
class DescribeDcdnDomainPvDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainPvDataRequest() {}

  explicit DescribeDcdnDomainPvDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainPvDataRequest() = default;
};
class DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData() {}

  explicit DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData() = default;
};
class DescribeDcdnDomainPvDataResponseBodyPvDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData>> usageData{};

  DescribeDcdnDomainPvDataResponseBodyPvDataInterval() {}

  explicit DescribeDcdnDomainPvDataResponseBodyPvDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainPvDataResponseBodyPvDataInterval() = default;
};
class DescribeDcdnDomainPvDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDcdnDomainPvDataResponseBodyPvDataInterval> pvDataInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainPvDataResponseBody() {}

  explicit DescribeDcdnDomainPvDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pvDataInterval) {
      res["PvDataInterval"] = pvDataInterval ? boost::any(pvDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PvDataInterval") != m.end() && !m["PvDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["PvDataInterval"].type()) {
        DescribeDcdnDomainPvDataResponseBodyPvDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PvDataInterval"]));
        pvDataInterval = make_shared<DescribeDcdnDomainPvDataResponseBodyPvDataInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainPvDataResponseBody() = default;
};
class DescribeDcdnDomainPvDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainPvDataResponseBody> body{};

  DescribeDcdnDomainPvDataResponse() {}

  explicit DescribeDcdnDomainPvDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainPvDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainPvDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainPvDataResponse() = default;
};
class DescribeDcdnDomainQpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainQpsDataRequest() {}

  explicit DescribeDcdnDomainQpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainQpsDataRequest() = default;
};
class DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<double> acc{};
  shared_ptr<double> dynamicHttpAcc{};
  shared_ptr<double> dynamicHttpQps{};
  shared_ptr<double> dynamicHttpsAcc{};
  shared_ptr<double> dynamicHttpsQps{};
  shared_ptr<double> qps{};
  shared_ptr<double> staticHttpAcc{};
  shared_ptr<double> staticHttpQps{};
  shared_ptr<double> staticHttpsAcc{};
  shared_ptr<double> staticHttpsQps{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acc) {
      res["Acc"] = boost::any(*acc);
    }
    if (dynamicHttpAcc) {
      res["DynamicHttpAcc"] = boost::any(*dynamicHttpAcc);
    }
    if (dynamicHttpQps) {
      res["DynamicHttpQps"] = boost::any(*dynamicHttpQps);
    }
    if (dynamicHttpsAcc) {
      res["DynamicHttpsAcc"] = boost::any(*dynamicHttpsAcc);
    }
    if (dynamicHttpsQps) {
      res["DynamicHttpsQps"] = boost::any(*dynamicHttpsQps);
    }
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (staticHttpAcc) {
      res["StaticHttpAcc"] = boost::any(*staticHttpAcc);
    }
    if (staticHttpQps) {
      res["StaticHttpQps"] = boost::any(*staticHttpQps);
    }
    if (staticHttpsAcc) {
      res["StaticHttpsAcc"] = boost::any(*staticHttpsAcc);
    }
    if (staticHttpsQps) {
      res["StaticHttpsQps"] = boost::any(*staticHttpsQps);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acc") != m.end() && !m["Acc"].empty()) {
      acc = make_shared<double>(boost::any_cast<double>(m["Acc"]));
    }
    if (m.find("DynamicHttpAcc") != m.end() && !m["DynamicHttpAcc"].empty()) {
      dynamicHttpAcc = make_shared<double>(boost::any_cast<double>(m["DynamicHttpAcc"]));
    }
    if (m.find("DynamicHttpQps") != m.end() && !m["DynamicHttpQps"].empty()) {
      dynamicHttpQps = make_shared<double>(boost::any_cast<double>(m["DynamicHttpQps"]));
    }
    if (m.find("DynamicHttpsAcc") != m.end() && !m["DynamicHttpsAcc"].empty()) {
      dynamicHttpsAcc = make_shared<double>(boost::any_cast<double>(m["DynamicHttpsAcc"]));
    }
    if (m.find("DynamicHttpsQps") != m.end() && !m["DynamicHttpsQps"].empty()) {
      dynamicHttpsQps = make_shared<double>(boost::any_cast<double>(m["DynamicHttpsQps"]));
    }
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<double>(boost::any_cast<double>(m["Qps"]));
    }
    if (m.find("StaticHttpAcc") != m.end() && !m["StaticHttpAcc"].empty()) {
      staticHttpAcc = make_shared<double>(boost::any_cast<double>(m["StaticHttpAcc"]));
    }
    if (m.find("StaticHttpQps") != m.end() && !m["StaticHttpQps"].empty()) {
      staticHttpQps = make_shared<double>(boost::any_cast<double>(m["StaticHttpQps"]));
    }
    if (m.find("StaticHttpsAcc") != m.end() && !m["StaticHttpsAcc"].empty()) {
      staticHttpsAcc = make_shared<double>(boost::any_cast<double>(m["StaticHttpsAcc"]));
    }
    if (m.find("StaticHttpsQps") != m.end() && !m["StaticHttpsQps"].empty()) {
      staticHttpsQps = make_shared<double>(boost::any_cast<double>(m["StaticHttpsQps"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval() {}

  explicit DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval() = default;
};
class DescribeDcdnDomainQpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval> qpsDataPerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainQpsDataResponseBody() {}

  explicit DescribeDcdnDomainQpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (qpsDataPerInterval) {
      res["QpsDataPerInterval"] = qpsDataPerInterval ? boost::any(qpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("QpsDataPerInterval") != m.end() && !m["QpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["QpsDataPerInterval"].type()) {
        DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QpsDataPerInterval"]));
        qpsDataPerInterval = make_shared<DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainQpsDataResponseBody() = default;
};
class DescribeDcdnDomainQpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainQpsDataResponseBody> body{};

  DescribeDcdnDomainQpsDataResponse() {}

  explicit DescribeDcdnDomainQpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainQpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainQpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainQpsDataResponse() = default;
};
class DescribeDcdnDomainQpsDataByLayerRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> layer{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainQpsDataByLayerRequest() {}

  explicit DescribeDcdnDomainQpsDataByLayerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<string>(boost::any_cast<string>(m["Layer"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainQpsDataByLayerRequest() = default;
};
class DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> accDomesticValue{};
  shared_ptr<string> accOverseasValue{};
  shared_ptr<string> accValue{};
  shared_ptr<string> domesticValue{};
  shared_ptr<string> overseasValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule() {}

  explicit DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accDomesticValue) {
      res["AccDomesticValue"] = boost::any(*accDomesticValue);
    }
    if (accOverseasValue) {
      res["AccOverseasValue"] = boost::any(*accOverseasValue);
    }
    if (accValue) {
      res["AccValue"] = boost::any(*accValue);
    }
    if (domesticValue) {
      res["DomesticValue"] = boost::any(*domesticValue);
    }
    if (overseasValue) {
      res["OverseasValue"] = boost::any(*overseasValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccDomesticValue") != m.end() && !m["AccDomesticValue"].empty()) {
      accDomesticValue = make_shared<string>(boost::any_cast<string>(m["AccDomesticValue"]));
    }
    if (m.find("AccOverseasValue") != m.end() && !m["AccOverseasValue"].empty()) {
      accOverseasValue = make_shared<string>(boost::any_cast<string>(m["AccOverseasValue"]));
    }
    if (m.find("AccValue") != m.end() && !m["AccValue"].empty()) {
      accValue = make_shared<string>(boost::any_cast<string>(m["AccValue"]));
    }
    if (m.find("DomesticValue") != m.end() && !m["DomesticValue"].empty()) {
      domesticValue = make_shared<string>(boost::any_cast<string>(m["DomesticValue"]));
    }
    if (m.find("OverseasValue") != m.end() && !m["OverseasValue"].empty()) {
      overseasValue = make_shared<string>(boost::any_cast<string>(m["OverseasValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule() = default;
};
class DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule>> dataModule{};

  DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval() {}

  explicit DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval() = default;
};
class DescribeDcdnDomainQpsDataByLayerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> layer{};
  shared_ptr<DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval> qpsDataInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainQpsDataByLayerResponseBody() {}

  explicit DescribeDcdnDomainQpsDataByLayerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (layer) {
      res["Layer"] = boost::any(*layer);
    }
    if (qpsDataInterval) {
      res["QpsDataInterval"] = qpsDataInterval ? boost::any(qpsDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Layer") != m.end() && !m["Layer"].empty()) {
      layer = make_shared<string>(boost::any_cast<string>(m["Layer"]));
    }
    if (m.find("QpsDataInterval") != m.end() && !m["QpsDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["QpsDataInterval"].type()) {
        DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QpsDataInterval"]));
        qpsDataInterval = make_shared<DescribeDcdnDomainQpsDataByLayerResponseBodyQpsDataInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainQpsDataByLayerResponseBody() = default;
};
class DescribeDcdnDomainQpsDataByLayerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainQpsDataByLayerResponseBody> body{};

  DescribeDcdnDomainQpsDataByLayerResponse() {}

  explicit DescribeDcdnDomainQpsDataByLayerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainQpsDataByLayerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainQpsDataByLayerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainQpsDataByLayerResponse() = default;
};
class DescribeDcdnDomainRealTimeBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainRealTimeBpsDataRequest() {}

  explicit DescribeDcdnDomainRealTimeBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeBpsDataRequest() = default;
};
class DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel : public Darabonba::Model {
public:
  shared_ptr<double> bps{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel() {}

  explicit DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<double>(boost::any_cast<double>(m["Bps"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel() = default;
};
class DescribeDcdnDomainRealTimeBpsDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel>> bpsModel{};

  DescribeDcdnDomainRealTimeBpsDataResponseBodyData() {}

  explicit DescribeDcdnDomainRealTimeBpsDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsModel) {
      vector<boost::any> temp1;
      for(auto item1:*bpsModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BpsModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsModel") != m.end() && !m["BpsModel"].empty()) {
      if (typeid(vector<boost::any>) == m["BpsModel"].type()) {
        vector<DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BpsModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bpsModel = make_shared<vector<DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeBpsDataResponseBodyData() = default;
};
class DescribeDcdnDomainRealTimeBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainRealTimeBpsDataResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeDcdnDomainRealTimeBpsDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeDcdnDomainRealTimeBpsDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeDcdnDomainRealTimeBpsDataResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeBpsDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainRealTimeBpsDataResponseBody> body{};

  DescribeDcdnDomainRealTimeBpsDataResponse() {}

  explicit DescribeDcdnDomainRealTimeBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeBpsDataResponse() = default;
};
class DescribeDcdnDomainRealTimeByteHitRateDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainRealTimeByteHitRateDataRequest() {}

  explicit DescribeDcdnDomainRealTimeByteHitRateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeByteHitRateDataRequest() = default;
};
class DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel : public Darabonba::Model {
public:
  shared_ptr<double> byteHitRate{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel() {}

  explicit DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (byteHitRate) {
      res["ByteHitRate"] = boost::any(*byteHitRate);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ByteHitRate") != m.end() && !m["ByteHitRate"].empty()) {
      byteHitRate = make_shared<double>(boost::any_cast<double>(m["ByteHitRate"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel() = default;
};
class DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel>> byteHitRateDataModel{};

  DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData() {}

  explicit DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (byteHitRateDataModel) {
      vector<boost::any> temp1;
      for(auto item1:*byteHitRateDataModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ByteHitRateDataModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ByteHitRateDataModel") != m.end() && !m["ByteHitRateDataModel"].empty()) {
      if (typeid(vector<boost::any>) == m["ByteHitRateDataModel"].type()) {
        vector<DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ByteHitRateDataModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        byteHitRateDataModel = make_shared<vector<DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData() = default;
};
class DescribeDcdnDomainRealTimeByteHitRateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeDcdnDomainRealTimeByteHitRateDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeByteHitRateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeByteHitRateDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeByteHitRateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainRealTimeByteHitRateDataResponseBody> body{};

  DescribeDcdnDomainRealTimeByteHitRateDataResponse() {}

  explicit DescribeDcdnDomainRealTimeByteHitRateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeByteHitRateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeByteHitRateDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeByteHitRateDataResponse() = default;
};
class DescribeDcdnDomainRealTimeDetailDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> field{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> merge{};
  shared_ptr<string> mergeLocIsp{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainRealTimeDetailDataRequest() {}

  explicit DescribeDcdnDomainRealTimeDetailDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (merge) {
      res["Merge"] = boost::any(*merge);
    }
    if (mergeLocIsp) {
      res["MergeLocIsp"] = boost::any(*mergeLocIsp);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      merge = make_shared<string>(boost::any_cast<string>(m["Merge"]));
    }
    if (m.find("MergeLocIsp") != m.end() && !m["MergeLocIsp"].empty()) {
      mergeLocIsp = make_shared<string>(boost::any_cast<string>(m["MergeLocIsp"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeDetailDataRequest() = default;
};
class DescribeDcdnDomainRealTimeDetailDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  DescribeDcdnDomainRealTimeDetailDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeDetailDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeDetailDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeDetailDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainRealTimeDetailDataResponseBody> body{};

  DescribeDcdnDomainRealTimeDetailDataResponse() {}

  explicit DescribeDcdnDomainRealTimeDetailDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeDetailDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeDetailDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeDetailDataResponse() = default;
};
class DescribeDcdnDomainRealTimeHttpCodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainRealTimeHttpCodeDataRequest() {}

  explicit DescribeDcdnDomainRealTimeHttpCodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeHttpCodeDataRequest() = default;
};
class DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> count{};
  shared_ptr<string> proportion{};

  DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData() {}

  explicit DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData() = default;
};
class DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData>> realTimeCodeProportionData{};

  DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue() {}

  explicit DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realTimeCodeProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*realTimeCodeProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealTimeCodeProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealTimeCodeProportionData") != m.end() && !m["RealTimeCodeProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["RealTimeCodeProportionData"].type()) {
        vector<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealTimeCodeProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realTimeCodeProportionData = make_shared<vector<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue() = default;
};
class DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue> value{};

  DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData() {}

  explicit DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData() = default;
};
class DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData>> usageData{};

  DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData() {}

  explicit DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData() = default;
};
class DescribeDcdnDomainRealTimeHttpCodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData> realTimeHttpCodeData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainRealTimeHttpCodeDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeHttpCodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeHttpCodeData) {
      res["RealTimeHttpCodeData"] = realTimeHttpCodeData ? boost::any(realTimeHttpCodeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeHttpCodeData") != m.end() && !m["RealTimeHttpCodeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeHttpCodeData"].type()) {
        DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeHttpCodeData"]));
        realTimeHttpCodeData = make_shared<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeHttpCodeDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeHttpCodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainRealTimeHttpCodeDataResponseBody> body{};

  DescribeDcdnDomainRealTimeHttpCodeDataResponse() {}

  explicit DescribeDcdnDomainRealTimeHttpCodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeHttpCodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeHttpCodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeHttpCodeDataResponse() = default;
};
class DescribeDcdnDomainRealTimeQpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainRealTimeQpsDataRequest() {}

  explicit DescribeDcdnDomainRealTimeQpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeQpsDataRequest() = default;
};
class DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel : public Darabonba::Model {
public:
  shared_ptr<double> qps{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel() {}

  explicit DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<double>(boost::any_cast<double>(m["Qps"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel() = default;
};
class DescribeDcdnDomainRealTimeQpsDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel>> qpsModel{};

  DescribeDcdnDomainRealTimeQpsDataResponseBodyData() {}

  explicit DescribeDcdnDomainRealTimeQpsDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qpsModel) {
      vector<boost::any> temp1;
      for(auto item1:*qpsModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QpsModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QpsModel") != m.end() && !m["QpsModel"].empty()) {
      if (typeid(vector<boost::any>) == m["QpsModel"].type()) {
        vector<DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QpsModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        qpsModel = make_shared<vector<DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeQpsDataResponseBodyData() = default;
};
class DescribeDcdnDomainRealTimeQpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainRealTimeQpsDataResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeDcdnDomainRealTimeQpsDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeQpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeDcdnDomainRealTimeQpsDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeDcdnDomainRealTimeQpsDataResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeQpsDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeQpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainRealTimeQpsDataResponseBody> body{};

  DescribeDcdnDomainRealTimeQpsDataResponse() {}

  explicit DescribeDcdnDomainRealTimeQpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeQpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeQpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeQpsDataResponse() = default;
};
class DescribeDcdnDomainRealTimeReqHitRateDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainRealTimeReqHitRateDataRequest() {}

  explicit DescribeDcdnDomainRealTimeReqHitRateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeReqHitRateDataRequest() = default;
};
class DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel : public Darabonba::Model {
public:
  shared_ptr<double> reqHitRate{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel() {}

  explicit DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reqHitRate) {
      res["ReqHitRate"] = boost::any(*reqHitRate);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReqHitRate") != m.end() && !m["ReqHitRate"].empty()) {
      reqHitRate = make_shared<double>(boost::any_cast<double>(m["ReqHitRate"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel() = default;
};
class DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel>> reqHitRateDataModel{};

  DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData() {}

  explicit DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reqHitRateDataModel) {
      vector<boost::any> temp1;
      for(auto item1:*reqHitRateDataModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReqHitRateDataModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReqHitRateDataModel") != m.end() && !m["ReqHitRateDataModel"].empty()) {
      if (typeid(vector<boost::any>) == m["ReqHitRateDataModel"].type()) {
        vector<DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReqHitRateDataModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reqHitRateDataModel = make_shared<vector<DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData() = default;
};
class DescribeDcdnDomainRealTimeReqHitRateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeDcdnDomainRealTimeReqHitRateDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeReqHitRateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeReqHitRateDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeReqHitRateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainRealTimeReqHitRateDataResponseBody> body{};

  DescribeDcdnDomainRealTimeReqHitRateDataResponse() {}

  explicit DescribeDcdnDomainRealTimeReqHitRateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeReqHitRateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeReqHitRateDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeReqHitRateDataResponse() = default;
};
class DescribeDcdnDomainRealTimeSrcBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainRealTimeSrcBpsDataRequest() {}

  explicit DescribeDcdnDomainRealTimeSrcBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcBpsDataRequest() = default;
};
class DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval() {}

  explicit DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval() = default;
};
class DescribeDcdnDomainRealTimeSrcBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval> realTimeSrcBpsDataPerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainRealTimeSrcBpsDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeSrcBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeSrcBpsDataPerInterval) {
      res["RealTimeSrcBpsDataPerInterval"] = realTimeSrcBpsDataPerInterval ? boost::any(realTimeSrcBpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeSrcBpsDataPerInterval") != m.end() && !m["RealTimeSrcBpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeSrcBpsDataPerInterval"].type()) {
        DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeSrcBpsDataPerInterval"]));
        realTimeSrcBpsDataPerInterval = make_shared<DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcBpsDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeSrcBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainRealTimeSrcBpsDataResponseBody> body{};

  DescribeDcdnDomainRealTimeSrcBpsDataResponse() {}

  explicit DescribeDcdnDomainRealTimeSrcBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeSrcBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeSrcBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcBpsDataResponse() = default;
};
class DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest() {}

  explicit DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest() = default;
};
class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> count{};
  shared_ptr<string> proportion{};

  DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData() {}

  explicit DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData() = default;
};
class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData>> realTimeSrcCodeProportionData{};

  DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue() {}

  explicit DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realTimeSrcCodeProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*realTimeSrcCodeProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealTimeSrcCodeProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealTimeSrcCodeProportionData") != m.end() && !m["RealTimeSrcCodeProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["RealTimeSrcCodeProportionData"].type()) {
        vector<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealTimeSrcCodeProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realTimeSrcCodeProportionData = make_shared<vector<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue() = default;
};
class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue> value{};

  DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData() {}

  explicit DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData() = default;
};
class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData>> usageData{};

  DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData() {}

  explicit DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData() = default;
};
class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData> realTimeSrcHttpCodeData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeSrcHttpCodeData) {
      res["RealTimeSrcHttpCodeData"] = realTimeSrcHttpCodeData ? boost::any(realTimeSrcHttpCodeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeSrcHttpCodeData") != m.end() && !m["RealTimeSrcHttpCodeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeSrcHttpCodeData"].type()) {
        DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeSrcHttpCodeData"]));
        realTimeSrcHttpCodeData = make_shared<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody> body{};

  DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse() {}

  explicit DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse() = default;
};
class DescribeDcdnDomainRealTimeSrcTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainRealTimeSrcTrafficDataRequest() {}

  explicit DescribeDcdnDomainRealTimeSrcTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcTrafficDataRequest() = default;
};
class DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval() {}

  explicit DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval() = default;
};
class DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval> realTimeSrcTrafficDataPerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeSrcTrafficDataPerInterval) {
      res["RealTimeSrcTrafficDataPerInterval"] = realTimeSrcTrafficDataPerInterval ? boost::any(realTimeSrcTrafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeSrcTrafficDataPerInterval") != m.end() && !m["RealTimeSrcTrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeSrcTrafficDataPerInterval"].type()) {
        DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeSrcTrafficDataPerInterval"]));
        realTimeSrcTrafficDataPerInterval = make_shared<DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeSrcTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody> body{};

  DescribeDcdnDomainRealTimeSrcTrafficDataResponse() {}

  explicit DescribeDcdnDomainRealTimeSrcTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcTrafficDataResponse() = default;
};
class DescribeDcdnDomainRealTimeTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainRealTimeTrafficDataRequest() {}

  explicit DescribeDcdnDomainRealTimeTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeTrafficDataRequest() = default;
};
class DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval() {}

  explicit DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval() = default;
};
class DescribeDcdnDomainRealTimeTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval> realTimeTrafficDataPerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainRealTimeTrafficDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (realTimeTrafficDataPerInterval) {
      res["RealTimeTrafficDataPerInterval"] = realTimeTrafficDataPerInterval ? boost::any(realTimeTrafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RealTimeTrafficDataPerInterval") != m.end() && !m["RealTimeTrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeTrafficDataPerInterval"].type()) {
        DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeTrafficDataPerInterval"]));
        realTimeTrafficDataPerInterval = make_shared<DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeTrafficDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainRealTimeTrafficDataResponseBody> body{};

  DescribeDcdnDomainRealTimeTrafficDataResponse() {}

  explicit DescribeDcdnDomainRealTimeTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeTrafficDataResponse() = default;
};
class DescribeDcdnDomainRegionDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainRegionDataRequest() {}

  explicit DescribeDcdnDomainRegionDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRegionDataRequest() = default;
};
class DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData : public Darabonba::Model {
public:
  shared_ptr<string> avgObjectSize{};
  shared_ptr<string> avgResponseRate{};
  shared_ptr<string> avgResponseTime{};
  shared_ptr<string> bps{};
  shared_ptr<string> bytesProportion{};
  shared_ptr<string> proportion{};
  shared_ptr<string> qps{};
  shared_ptr<string> region{};
  shared_ptr<string> regionEname{};
  shared_ptr<string> totalBytes{};
  shared_ptr<string> totalQuery{};

  DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData() {}

  explicit DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgObjectSize) {
      res["AvgObjectSize"] = boost::any(*avgObjectSize);
    }
    if (avgResponseRate) {
      res["AvgResponseRate"] = boost::any(*avgResponseRate);
    }
    if (avgResponseTime) {
      res["AvgResponseTime"] = boost::any(*avgResponseTime);
    }
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (bytesProportion) {
      res["BytesProportion"] = boost::any(*bytesProportion);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionEname) {
      res["RegionEname"] = boost::any(*regionEname);
    }
    if (totalBytes) {
      res["TotalBytes"] = boost::any(*totalBytes);
    }
    if (totalQuery) {
      res["TotalQuery"] = boost::any(*totalQuery);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgObjectSize") != m.end() && !m["AvgObjectSize"].empty()) {
      avgObjectSize = make_shared<string>(boost::any_cast<string>(m["AvgObjectSize"]));
    }
    if (m.find("AvgResponseRate") != m.end() && !m["AvgResponseRate"].empty()) {
      avgResponseRate = make_shared<string>(boost::any_cast<string>(m["AvgResponseRate"]));
    }
    if (m.find("AvgResponseTime") != m.end() && !m["AvgResponseTime"].empty()) {
      avgResponseTime = make_shared<string>(boost::any_cast<string>(m["AvgResponseTime"]));
    }
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<string>(boost::any_cast<string>(m["Bps"]));
    }
    if (m.find("BytesProportion") != m.end() && !m["BytesProportion"].empty()) {
      bytesProportion = make_shared<string>(boost::any_cast<string>(m["BytesProportion"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<string>(boost::any_cast<string>(m["Qps"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionEname") != m.end() && !m["RegionEname"].empty()) {
      regionEname = make_shared<string>(boost::any_cast<string>(m["RegionEname"]));
    }
    if (m.find("TotalBytes") != m.end() && !m["TotalBytes"].empty()) {
      totalBytes = make_shared<string>(boost::any_cast<string>(m["TotalBytes"]));
    }
    if (m.find("TotalQuery") != m.end() && !m["TotalQuery"].empty()) {
      totalQuery = make_shared<string>(boost::any_cast<string>(m["TotalQuery"]));
    }
  }


  virtual ~DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData() = default;
};
class DescribeDcdnDomainRegionDataResponseBodyValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData>> regionProportionData{};

  DescribeDcdnDomainRegionDataResponseBodyValue() {}

  explicit DescribeDcdnDomainRegionDataResponseBodyValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*regionProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegionProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionProportionData") != m.end() && !m["RegionProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["RegionProportionData"].type()) {
        vector<DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegionProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regionProportionData = make_shared<vector<DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRegionDataResponseBodyValue() = default;
};
class DescribeDcdnDomainRegionDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDcdnDomainRegionDataResponseBodyValue> value{};

  DescribeDcdnDomainRegionDataResponseBody() {}

  explicit DescribeDcdnDomainRegionDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeDcdnDomainRegionDataResponseBodyValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeDcdnDomainRegionDataResponseBodyValue>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRegionDataResponseBody() = default;
};
class DescribeDcdnDomainRegionDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainRegionDataResponseBody> body{};

  DescribeDcdnDomainRegionDataResponse() {}

  explicit DescribeDcdnDomainRegionDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRegionDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRegionDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRegionDataResponse() = default;
};
class DescribeDcdnDomainStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functionNames{};

  DescribeDcdnDomainStagingConfigRequest() {}

  explicit DescribeDcdnDomainStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
  }


  virtual ~DescribeDcdnDomainStagingConfigRequest() = default;
};
class DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};

  DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs() {}

  explicit DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
  }


  virtual ~DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs() = default;
};
class DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<vector<DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs>> functionArgs{};
  shared_ptr<string> functionName{};
  shared_ptr<string> status{};

  DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs() {}

  explicit DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionArgs) {
      vector<boost::any> temp1;
      for(auto item1:*functionArgs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FunctionArgs"] = boost::any(temp1);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      if (typeid(vector<boost::any>) == m["FunctionArgs"].type()) {
        vector<DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FunctionArgs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functionArgs = make_shared<vector<DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs>>(expect1);
      }
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs() = default;
};
class DescribeDcdnDomainStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs>> domainConfigs{};
  shared_ptr<string> requestId{};

  DescribeDcdnDomainStagingConfigResponseBody() {}

  explicit DescribeDcdnDomainStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfigs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfigs") != m.end() && !m["DomainConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfigs"].type()) {
        vector<DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfigs = make_shared<vector<DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDomainStagingConfigResponseBody() = default;
};
class DescribeDcdnDomainStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainStagingConfigResponseBody> body{};

  DescribeDcdnDomainStagingConfigResponse() {}

  explicit DescribeDcdnDomainStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainStagingConfigResponse() = default;
};
class DescribeDcdnDomainTopReferVisitRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainTopReferVisitRequest() {}

  explicit DescribeDcdnDomainTopReferVisitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainTopReferVisitRequest() = default;
};
class DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> referDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList() {}

  explicit DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (referDetail) {
      res["ReferDetail"] = boost::any(*referDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("ReferDetail") != m.end() && !m["ReferDetail"].empty()) {
      referDetail = make_shared<string>(boost::any_cast<string>(m["ReferDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList() = default;
};
class DescribeDcdnDomainTopReferVisitResponseBodyTopReferList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList>> referList{};

  DescribeDcdnDomainTopReferVisitResponseBodyTopReferList() {}

  explicit DescribeDcdnDomainTopReferVisitResponseBodyTopReferList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referList) {
      vector<boost::any> temp1;
      for(auto item1:*referList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReferList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferList") != m.end() && !m["ReferList"].empty()) {
      if (typeid(vector<boost::any>) == m["ReferList"].type()) {
        vector<DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReferList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        referList = make_shared<vector<DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopReferVisitResponseBodyTopReferList() = default;
};
class DescribeDcdnDomainTopReferVisitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDcdnDomainTopReferVisitResponseBodyTopReferList> topReferList{};

  DescribeDcdnDomainTopReferVisitResponseBody() {}

  explicit DescribeDcdnDomainTopReferVisitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (topReferList) {
      res["TopReferList"] = topReferList ? boost::any(topReferList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TopReferList") != m.end() && !m["TopReferList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TopReferList"].type()) {
        DescribeDcdnDomainTopReferVisitResponseBodyTopReferList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TopReferList"]));
        topReferList = make_shared<DescribeDcdnDomainTopReferVisitResponseBodyTopReferList>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopReferVisitResponseBody() = default;
};
class DescribeDcdnDomainTopReferVisitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainTopReferVisitResponseBody> body{};

  DescribeDcdnDomainTopReferVisitResponse() {}

  explicit DescribeDcdnDomainTopReferVisitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainTopReferVisitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainTopReferVisitResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopReferVisitResponse() = default;
};
class DescribeDcdnDomainTopUrlVisitRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainTopUrlVisitRequest() {}

  explicit DescribeDcdnDomainTopUrlVisitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitRequest() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> urlDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList>> urlList{};

  DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> urlDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList>> urlList{};

  DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> urlDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList>> urlList{};

  DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> urlDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList>> urlList{};

  DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> urlDetail{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList>> urlList{};

  DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList> allUrlList{};
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List> url200List{};
  shared_ptr<DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List> url300List{};
  shared_ptr<DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List> url400List{};
  shared_ptr<DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List> url500List{};

  DescribeDcdnDomainTopUrlVisitResponseBody() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allUrlList) {
      res["AllUrlList"] = allUrlList ? boost::any(allUrlList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (url200List) {
      res["Url200List"] = url200List ? boost::any(url200List->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url300List) {
      res["Url300List"] = url300List ? boost::any(url300List->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url400List) {
      res["Url400List"] = url400List ? boost::any(url400List->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url500List) {
      res["Url500List"] = url500List ? boost::any(url500List->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllUrlList") != m.end() && !m["AllUrlList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AllUrlList"].type()) {
        DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AllUrlList"]));
        allUrlList = make_shared<DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList>(model1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Url200List") != m.end() && !m["Url200List"].empty()) {
      if (typeid(map<string, boost::any>) == m["Url200List"].type()) {
        DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Url200List"]));
        url200List = make_shared<DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List>(model1);
      }
    }
    if (m.find("Url300List") != m.end() && !m["Url300List"].empty()) {
      if (typeid(map<string, boost::any>) == m["Url300List"].type()) {
        DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Url300List"]));
        url300List = make_shared<DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List>(model1);
      }
    }
    if (m.find("Url400List") != m.end() && !m["Url400List"].empty()) {
      if (typeid(map<string, boost::any>) == m["Url400List"].type()) {
        DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Url400List"]));
        url400List = make_shared<DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List>(model1);
      }
    }
    if (m.find("Url500List") != m.end() && !m["Url500List"].empty()) {
      if (typeid(map<string, boost::any>) == m["Url500List"].type()) {
        DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Url500List"]));
        url500List = make_shared<DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBody() = default;
};
class DescribeDcdnDomainTopUrlVisitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainTopUrlVisitResponseBody> body{};

  DescribeDcdnDomainTopUrlVisitResponse() {}

  explicit DescribeDcdnDomainTopUrlVisitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainTopUrlVisitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainTopUrlVisitResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponse() = default;
};
class DescribeDcdnDomainTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainTrafficDataRequest() {}

  explicit DescribeDcdnDomainTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainTrafficDataRequest() = default;
};
class DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<double> dynamicHttpTraffic{};
  shared_ptr<double> dynamicHttpsTraffic{};
  shared_ptr<double> staticHttpTraffic{};
  shared_ptr<double> staticHttpsTraffic{};
  shared_ptr<string> timeStamp{};
  shared_ptr<double> traffic{};

  DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicHttpTraffic) {
      res["DynamicHttpTraffic"] = boost::any(*dynamicHttpTraffic);
    }
    if (dynamicHttpsTraffic) {
      res["DynamicHttpsTraffic"] = boost::any(*dynamicHttpsTraffic);
    }
    if (staticHttpTraffic) {
      res["StaticHttpTraffic"] = boost::any(*staticHttpTraffic);
    }
    if (staticHttpsTraffic) {
      res["StaticHttpsTraffic"] = boost::any(*staticHttpsTraffic);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (traffic) {
      res["Traffic"] = boost::any(*traffic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicHttpTraffic") != m.end() && !m["DynamicHttpTraffic"].empty()) {
      dynamicHttpTraffic = make_shared<double>(boost::any_cast<double>(m["DynamicHttpTraffic"]));
    }
    if (m.find("DynamicHttpsTraffic") != m.end() && !m["DynamicHttpsTraffic"].empty()) {
      dynamicHttpsTraffic = make_shared<double>(boost::any_cast<double>(m["DynamicHttpsTraffic"]));
    }
    if (m.find("StaticHttpTraffic") != m.end() && !m["StaticHttpTraffic"].empty()) {
      staticHttpTraffic = make_shared<double>(boost::any_cast<double>(m["StaticHttpTraffic"]));
    }
    if (m.find("StaticHttpsTraffic") != m.end() && !m["StaticHttpsTraffic"].empty()) {
      staticHttpsTraffic = make_shared<double>(boost::any_cast<double>(m["StaticHttpsTraffic"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Traffic") != m.end() && !m["Traffic"].empty()) {
      traffic = make_shared<double>(boost::any_cast<double>(m["Traffic"]));
    }
  }


  virtual ~DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval() {}

  explicit DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval() = default;
};
class DescribeDcdnDomainTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval> trafficDataPerInterval{};

  DescribeDcdnDomainTrafficDataResponseBody() {}

  explicit DescribeDcdnDomainTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (trafficDataPerInterval) {
      res["TrafficDataPerInterval"] = trafficDataPerInterval ? boost::any(trafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TrafficDataPerInterval") != m.end() && !m["TrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficDataPerInterval"].type()) {
        DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficDataPerInterval"]));
        trafficDataPerInterval = make_shared<DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTrafficDataResponseBody() = default;
};
class DescribeDcdnDomainTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainTrafficDataResponseBody> body{};

  DescribeDcdnDomainTrafficDataResponse() {}

  explicit DescribeDcdnDomainTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTrafficDataResponse() = default;
};
class DescribeDcdnDomainUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> dataProtocol{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> field{};
  shared_ptr<string> interval{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};

  DescribeDcdnDomainUsageDataRequest() {}

  explicit DescribeDcdnDomainUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (dataProtocol) {
      res["DataProtocol"] = boost::any(*dataProtocol);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("DataProtocol") != m.end() && !m["DataProtocol"].empty()) {
      dataProtocol = make_shared<string>(boost::any_cast<string>(m["DataProtocol"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDcdnDomainUsageDataRequest() = default;
};
class DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> peakTime{};
  shared_ptr<string> specialValue{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (peakTime) {
      res["PeakTime"] = boost::any(*peakTime);
    }
    if (specialValue) {
      res["SpecialValue"] = boost::any(*specialValue);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeakTime") != m.end() && !m["PeakTime"].empty()) {
      peakTime = make_shared<string>(boost::any_cast<string>(m["PeakTime"]));
    }
    if (m.find("SpecialValue") != m.end() && !m["SpecialValue"].empty()) {
      specialValue = make_shared<string>(boost::any_cast<string>(m["SpecialValue"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval() {}

  explicit DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainUsageDataResponseBodyUsageDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval() = default;
};
class DescribeDcdnDomainUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> type{};
  shared_ptr<DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval> usageDataPerInterval{};

  DescribeDcdnDomainUsageDataResponseBody() {}

  explicit DescribeDcdnDomainUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (usageDataPerInterval) {
      res["UsageDataPerInterval"] = usageDataPerInterval ? boost::any(usageDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UsageDataPerInterval") != m.end() && !m["UsageDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["UsageDataPerInterval"].type()) {
        DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UsageDataPerInterval"]));
        usageDataPerInterval = make_shared<DescribeDcdnDomainUsageDataResponseBodyUsageDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainUsageDataResponseBody() = default;
};
class DescribeDcdnDomainUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainUsageDataResponseBody> body{};

  DescribeDcdnDomainUsageDataResponse() {}

  explicit DescribeDcdnDomainUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainUsageDataResponse() = default;
};
class DescribeDcdnDomainUvDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainUvDataRequest() {}

  explicit DescribeDcdnDomainUvDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainUvDataRequest() = default;
};
class DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<string> value{};

  DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData() {}

  explicit DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData() = default;
};
class DescribeDcdnDomainUvDataResponseBodyUvDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData>> usageData{};

  DescribeDcdnDomainUvDataResponseBodyUvDataInterval() {}

  explicit DescribeDcdnDomainUvDataResponseBodyUvDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainUvDataResponseBodyUvDataInterval() = default;
};
class DescribeDcdnDomainUvDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDcdnDomainUvDataResponseBodyUvDataInterval> uvDataInterval{};

  DescribeDcdnDomainUvDataResponseBody() {}

  explicit DescribeDcdnDomainUvDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (uvDataInterval) {
      res["UvDataInterval"] = uvDataInterval ? boost::any(uvDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("UvDataInterval") != m.end() && !m["UvDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["UvDataInterval"].type()) {
        DescribeDcdnDomainUvDataResponseBodyUvDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UvDataInterval"]));
        uvDataInterval = make_shared<DescribeDcdnDomainUvDataResponseBodyUvDataInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainUvDataResponseBody() = default;
};
class DescribeDcdnDomainUvDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainUvDataResponseBody> body{};

  DescribeDcdnDomainUvDataResponse() {}

  explicit DescribeDcdnDomainUvDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainUvDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainUvDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainUvDataResponse() = default;
};
class DescribeDcdnDomainWebsocketBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainWebsocketBpsDataRequest() {}

  explicit DescribeDcdnDomainWebsocketBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainWebsocketBpsDataRequest() = default;
};
class DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<double> websocketBps{};

  DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (websocketBps) {
      res["WebsocketBps"] = boost::any(*websocketBps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("WebsocketBps") != m.end() && !m["WebsocketBps"].empty()) {
      websocketBps = make_shared<double>(boost::any_cast<double>(m["WebsocketBps"]));
    }
  }


  virtual ~DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval() {}

  explicit DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval() = default;
};
class DescribeDcdnDomainWebsocketBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval> bpsDataPerInterval{};
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainWebsocketBpsDataResponseBody() {}

  explicit DescribeDcdnDomainWebsocketBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsDataPerInterval) {
      res["BpsDataPerInterval"] = bpsDataPerInterval ? boost::any(bpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsDataPerInterval") != m.end() && !m["BpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataPerInterval"].type()) {
        DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataPerInterval"]));
        bpsDataPerInterval = make_shared<DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval>(model1);
      }
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainWebsocketBpsDataResponseBody() = default;
};
class DescribeDcdnDomainWebsocketBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainWebsocketBpsDataResponseBody> body{};

  DescribeDcdnDomainWebsocketBpsDataResponse() {}

  explicit DescribeDcdnDomainWebsocketBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainWebsocketBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainWebsocketBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketBpsDataResponse() = default;
};
class DescribeDcdnDomainWebsocketHttpCodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainWebsocketHttpCodeDataRequest() {}

  explicit DescribeDcdnDomainWebsocketHttpCodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainWebsocketHttpCodeDataRequest() = default;
};
class DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<double> count{};
  shared_ptr<double> proportion{};

  DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule() {}

  explicit DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<double>(boost::any_cast<double>(m["Count"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<double>(boost::any_cast<double>(m["Proportion"]));
    }
  }


  virtual ~DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule() = default;
};
class DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule>> httpCodeDataModule{};

  DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode() {}

  explicit DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpCodeDataModule) {
      vector<boost::any> temp1;
      for(auto item1:*httpCodeDataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpCodeDataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpCodeDataModule") != m.end() && !m["HttpCodeDataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpCodeDataModule"].type()) {
        vector<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpCodeDataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpCodeDataModule = make_shared<vector<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCodeHttpCodeDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode() = default;
};
class DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode> websocketHttpCode{};

  DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (websocketHttpCode) {
      res["WebsocketHttpCode"] = websocketHttpCode ? boost::any(websocketHttpCode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("WebsocketHttpCode") != m.end() && !m["WebsocketHttpCode"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebsocketHttpCode"].type()) {
        DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebsocketHttpCode"]));
        websocketHttpCode = make_shared<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModuleWebsocketHttpCode>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval() {}

  explicit DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval() = default;
};
class DescribeDcdnDomainWebsocketHttpCodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval> httpCodeDataPerInterval{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainWebsocketHttpCodeDataResponseBody() {}

  explicit DescribeDcdnDomainWebsocketHttpCodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (httpCodeDataPerInterval) {
      res["HttpCodeDataPerInterval"] = httpCodeDataPerInterval ? boost::any(httpCodeDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("HttpCodeDataPerInterval") != m.end() && !m["HttpCodeDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpCodeDataPerInterval"].type()) {
        DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpCodeDataPerInterval"]));
        httpCodeDataPerInterval = make_shared<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyHttpCodeDataPerInterval>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainWebsocketHttpCodeDataResponseBody() = default;
};
class DescribeDcdnDomainWebsocketHttpCodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainWebsocketHttpCodeDataResponseBody> body{};

  DescribeDcdnDomainWebsocketHttpCodeDataResponse() {}

  explicit DescribeDcdnDomainWebsocketHttpCodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainWebsocketHttpCodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainWebsocketHttpCodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketHttpCodeDataResponse() = default;
};
class DescribeDcdnDomainWebsocketTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};

  DescribeDcdnDomainWebsocketTrafficDataRequest() {}

  explicit DescribeDcdnDomainWebsocketTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnDomainWebsocketTrafficDataRequest() = default;
};
class DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<double> websocketTraffic{};

  DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (websocketTraffic) {
      res["WebsocketTraffic"] = boost::any(*websocketTraffic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("WebsocketTraffic") != m.end() && !m["WebsocketTraffic"].empty()) {
      websocketTraffic = make_shared<double>(boost::any_cast<double>(m["WebsocketTraffic"]));
    }
  }


  virtual ~DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval() {}

  explicit DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval() = default;
};
class DescribeDcdnDomainWebsocketTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dataInterval{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval> trafficDataPerInterval{};

  DescribeDcdnDomainWebsocketTrafficDataResponseBody() {}

  explicit DescribeDcdnDomainWebsocketTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (trafficDataPerInterval) {
      res["TrafficDataPerInterval"] = trafficDataPerInterval ? boost::any(trafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TrafficDataPerInterval") != m.end() && !m["TrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficDataPerInterval"].type()) {
        DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficDataPerInterval"]));
        trafficDataPerInterval = make_shared<DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketTrafficDataResponseBody() = default;
};
class DescribeDcdnDomainWebsocketTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnDomainWebsocketTrafficDataResponseBody> body{};

  DescribeDcdnDomainWebsocketTrafficDataResponse() {}

  explicit DescribeDcdnDomainWebsocketTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainWebsocketTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainWebsocketTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketTrafficDataResponse() = default;
};
class DescribeDcdnErUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> routineID{};
  shared_ptr<string> spec{};
  shared_ptr<string> splitBy{};
  shared_ptr<string> startTime{};

  DescribeDcdnErUsageDataRequest() {}

  explicit DescribeDcdnErUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (routineID) {
      res["RoutineID"] = boost::any(*routineID);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (splitBy) {
      res["SplitBy"] = boost::any(*splitBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RoutineID") != m.end() && !m["RoutineID"].empty()) {
      routineID = make_shared<string>(boost::any_cast<string>(m["RoutineID"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("SplitBy") != m.end() && !m["SplitBy"].empty()) {
      splitBy = make_shared<string>(boost::any_cast<string>(m["SplitBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnErUsageDataRequest() = default;
};
class DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem : public Darabonba::Model {
public:
  shared_ptr<long> erAcc{};
  shared_ptr<string> routine{};
  shared_ptr<string> spec{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem() {}

  explicit DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (erAcc) {
      res["ErAcc"] = boost::any(*erAcc);
    }
    if (routine) {
      res["Routine"] = boost::any(*routine);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErAcc") != m.end() && !m["ErAcc"].empty()) {
      erAcc = make_shared<long>(boost::any_cast<long>(m["ErAcc"]));
    }
    if (m.find("Routine") != m.end() && !m["Routine"].empty()) {
      routine = make_shared<string>(boost::any_cast<string>(m["Routine"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem() = default;
};
class DescribeDcdnErUsageDataResponseBodyErAccData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem>> erAccItem{};

  DescribeDcdnErUsageDataResponseBodyErAccData() {}

  explicit DescribeDcdnErUsageDataResponseBodyErAccData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (erAccItem) {
      vector<boost::any> temp1;
      for(auto item1:*erAccItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErAccItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErAccItem") != m.end() && !m["ErAccItem"].empty()) {
      if (typeid(vector<boost::any>) == m["ErAccItem"].type()) {
        vector<DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErAccItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        erAccItem = make_shared<vector<DescribeDcdnErUsageDataResponseBodyErAccDataErAccItem>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnErUsageDataResponseBodyErAccData() = default;
};
class DescribeDcdnErUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<DescribeDcdnErUsageDataResponseBodyErAccData> erAccData{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};

  DescribeDcdnErUsageDataResponseBody() {}

  explicit DescribeDcdnErUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (erAccData) {
      res["ErAccData"] = erAccData ? boost::any(erAccData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ErAccData") != m.end() && !m["ErAccData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErAccData"].type()) {
        DescribeDcdnErUsageDataResponseBodyErAccData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErAccData"]));
        erAccData = make_shared<DescribeDcdnErUsageDataResponseBodyErAccData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnErUsageDataResponseBody() = default;
};
class DescribeDcdnErUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnErUsageDataResponseBody> body{};

  DescribeDcdnErUsageDataResponse() {}

  explicit DescribeDcdnErUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnErUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnErUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnErUsageDataResponse() = default;
};
class DescribeDcdnFullDomainsBlockIPConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> IPList{};

  DescribeDcdnFullDomainsBlockIPConfigRequest() {}

  explicit DescribeDcdnFullDomainsBlockIPConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPList) {
      res["IPList"] = boost::any(*IPList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPList") != m.end() && !m["IPList"].empty()) {
      IPList = make_shared<string>(boost::any_cast<string>(m["IPList"]));
    }
  }


  virtual ~DescribeDcdnFullDomainsBlockIPConfigRequest() = default;
};
class DescribeDcdnFullDomainsBlockIPConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DescribeDcdnFullDomainsBlockIPConfigResponseBody() {}

  explicit DescribeDcdnFullDomainsBlockIPConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnFullDomainsBlockIPConfigResponseBody() = default;
};
class DescribeDcdnFullDomainsBlockIPConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnFullDomainsBlockIPConfigResponseBody> body{};

  DescribeDcdnFullDomainsBlockIPConfigResponse() {}

  explicit DescribeDcdnFullDomainsBlockIPConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnFullDomainsBlockIPConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnFullDomainsBlockIPConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnFullDomainsBlockIPConfigResponse() = default;
};
class DescribeDcdnFullDomainsBlockIPHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> IPList{};
  shared_ptr<string> startTime{};

  DescribeDcdnFullDomainsBlockIPHistoryRequest() {}

  explicit DescribeDcdnFullDomainsBlockIPHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (IPList) {
      res["IPList"] = boost::any(*IPList);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IPList") != m.end() && !m["IPList"].empty()) {
      IPList = make_shared<string>(boost::any_cast<string>(m["IPList"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnFullDomainsBlockIPHistoryRequest() = default;
};
class DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo : public Darabonba::Model {
public:
  shared_ptr<string> blockIP{};
  shared_ptr<string> deliverTime{};
  shared_ptr<string> status{};

  DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo() {}

  explicit DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockIP) {
      res["BlockIP"] = boost::any(*blockIP);
    }
    if (deliverTime) {
      res["DeliverTime"] = boost::any(*deliverTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockIP") != m.end() && !m["BlockIP"].empty()) {
      blockIP = make_shared<string>(boost::any_cast<string>(m["BlockIP"]));
    }
    if (m.find("DeliverTime") != m.end() && !m["DeliverTime"].empty()) {
      deliverTime = make_shared<string>(boost::any_cast<string>(m["DeliverTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo() = default;
};
class DescribeDcdnFullDomainsBlockIPHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> description{};
  shared_ptr<vector<DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo>> IPBlockInfo{};
  shared_ptr<string> requestId{};

  DescribeDcdnFullDomainsBlockIPHistoryResponseBody() {}

  explicit DescribeDcdnFullDomainsBlockIPHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (IPBlockInfo) {
      vector<boost::any> temp1;
      for(auto item1:*IPBlockInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IPBlockInfo"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IPBlockInfo") != m.end() && !m["IPBlockInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["IPBlockInfo"].type()) {
        vector<DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IPBlockInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        IPBlockInfo = make_shared<vector<DescribeDcdnFullDomainsBlockIPHistoryResponseBodyIPBlockInfo>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnFullDomainsBlockIPHistoryResponseBody() = default;
};
class DescribeDcdnFullDomainsBlockIPHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnFullDomainsBlockIPHistoryResponseBody> body{};

  DescribeDcdnFullDomainsBlockIPHistoryResponse() {}

  explicit DescribeDcdnFullDomainsBlockIPHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnFullDomainsBlockIPHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnFullDomainsBlockIPHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnFullDomainsBlockIPHistoryResponse() = default;
};
class DescribeDcdnHttpsDomainListRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeDcdnHttpsDomainListRequest() {}

  explicit DescribeDcdnHttpsDomainListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeDcdnHttpsDomainListRequest() = default;
};
class DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> certCommonName{};
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certName{};
  shared_ptr<string> certStartTime{};
  shared_ptr<string> certStatus{};
  shared_ptr<string> certType{};
  shared_ptr<string> certUpdateTime{};
  shared_ptr<string> domainName{};

  DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo() {}

  explicit DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certCommonName) {
      res["CertCommonName"] = boost::any(*certCommonName);
    }
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certStartTime) {
      res["CertStartTime"] = boost::any(*certStartTime);
    }
    if (certStatus) {
      res["CertStatus"] = boost::any(*certStatus);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (certUpdateTime) {
      res["CertUpdateTime"] = boost::any(*certUpdateTime);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertCommonName") != m.end() && !m["CertCommonName"].empty()) {
      certCommonName = make_shared<string>(boost::any_cast<string>(m["CertCommonName"]));
    }
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertStartTime") != m.end() && !m["CertStartTime"].empty()) {
      certStartTime = make_shared<string>(boost::any_cast<string>(m["CertStartTime"]));
    }
    if (m.find("CertStatus") != m.end() && !m["CertStatus"].empty()) {
      certStatus = make_shared<string>(boost::any_cast<string>(m["CertStatus"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("CertUpdateTime") != m.end() && !m["CertUpdateTime"].empty()) {
      certUpdateTime = make_shared<string>(boost::any_cast<string>(m["CertUpdateTime"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo() = default;
};
class DescribeDcdnHttpsDomainListResponseBodyCertInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo>> certInfo{};

  DescribeDcdnHttpsDomainListResponseBodyCertInfos() {}

  explicit DescribeDcdnHttpsDomainListResponseBodyCertInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfo) {
      vector<boost::any> temp1;
      for(auto item1:*certInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CertInfo"].type()) {
        vector<DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certInfo = make_shared<vector<DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnHttpsDomainListResponseBodyCertInfos() = default;
};
class DescribeDcdnHttpsDomainListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnHttpsDomainListResponseBodyCertInfos> certInfos{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDcdnHttpsDomainListResponseBody() {}

  explicit DescribeDcdnHttpsDomainListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfos) {
      res["CertInfos"] = certInfos ? boost::any(certInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfos") != m.end() && !m["CertInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertInfos"].type()) {
        DescribeDcdnHttpsDomainListResponseBodyCertInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertInfos"]));
        certInfos = make_shared<DescribeDcdnHttpsDomainListResponseBodyCertInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDcdnHttpsDomainListResponseBody() = default;
};
class DescribeDcdnHttpsDomainListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnHttpsDomainListResponseBody> body{};

  DescribeDcdnHttpsDomainListResponse() {}

  explicit DescribeDcdnHttpsDomainListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnHttpsDomainListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnHttpsDomainListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnHttpsDomainListResponse() = default;
};
class DescribeDcdnIpInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> IP{};

  DescribeDcdnIpInfoRequest() {}

  explicit DescribeDcdnIpInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
  }


  virtual ~DescribeDcdnIpInfoRequest() = default;
};
class DescribeDcdnIpInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dcdnIp{};
  shared_ptr<string> ISP{};
  shared_ptr<string> ispEname{};
  shared_ptr<string> region{};
  shared_ptr<string> regionEname{};
  shared_ptr<string> requestId{};

  DescribeDcdnIpInfoResponseBody() {}

  explicit DescribeDcdnIpInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dcdnIp) {
      res["DcdnIp"] = boost::any(*dcdnIp);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (ispEname) {
      res["IspEname"] = boost::any(*ispEname);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionEname) {
      res["RegionEname"] = boost::any(*regionEname);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DcdnIp") != m.end() && !m["DcdnIp"].empty()) {
      dcdnIp = make_shared<string>(boost::any_cast<string>(m["DcdnIp"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("IspEname") != m.end() && !m["IspEname"].empty()) {
      ispEname = make_shared<string>(boost::any_cast<string>(m["IspEname"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionEname") != m.end() && !m["RegionEname"].empty()) {
      regionEname = make_shared<string>(boost::any_cast<string>(m["RegionEname"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnIpInfoResponseBody() = default;
};
class DescribeDcdnIpInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnIpInfoResponseBody> body{};

  DescribeDcdnIpInfoResponse() {}

  explicit DescribeDcdnIpInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnIpInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnIpInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpInfoResponse() = default;
};
class DescribeDcdnIpaDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functionNames{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnIpaDomainConfigsRequest() {}

  explicit DescribeDcdnIpaDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnIpaDomainConfigsRequest() = default;
};
class DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};

  DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg() {}

  explicit DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
  }


  virtual ~DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg() = default;
};
class DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg>> functionArg{};

  DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs() {}

  explicit DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionArg) {
      vector<boost::any> temp1;
      for(auto item1:*functionArg){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FunctionArg"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionArg") != m.end() && !m["FunctionArg"].empty()) {
      if (typeid(vector<boost::any>) == m["FunctionArg"].type()) {
        vector<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FunctionArg"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functionArg = make_shared<vector<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs() = default;
};
class DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig : public Darabonba::Model {
public:
  shared_ptr<string> configId{};
  shared_ptr<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs> functionArgs{};
  shared_ptr<string> functionName{};
  shared_ptr<string> status{};

  DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig() {}

  explicit DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionArgs) {
      res["FunctionArgs"] = functionArgs ? boost::any(functionArgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionArgs"].type()) {
        DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionArgs"]));
        functionArgs = make_shared<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs>(model1);
      }
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig() = default;
};
class DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig>> domainConfig{};

  DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs() {}

  explicit DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfig) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfig") != m.end() && !m["DomainConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfig"].type()) {
        vector<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfig = make_shared<vector<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs() = default;
};
class DescribeDcdnIpaDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs> domainConfigs{};
  shared_ptr<string> requestId{};

  DescribeDcdnIpaDomainConfigsResponseBody() {}

  explicit DescribeDcdnIpaDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfigs) {
      res["DomainConfigs"] = domainConfigs ? boost::any(domainConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfigs") != m.end() && !m["DomainConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainConfigs"].type()) {
        DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainConfigs"]));
        domainConfigs = make_shared<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnIpaDomainConfigsResponseBody() = default;
};
class DescribeDcdnIpaDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnIpaDomainConfigsResponseBody> body{};

  DescribeDcdnIpaDomainConfigsResponse() {}

  explicit DescribeDcdnIpaDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnIpaDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnIpaDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaDomainConfigsResponse() = default;
};
class DescribeDcdnIpaDomainDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnIpaDomainDetailRequest() {}

  explicit DescribeDcdnIpaDomainDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnIpaDomainDetailRequest() = default;
};
class DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> enabled{};
  shared_ptr<long> port{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};
  shared_ptr<string> weight{};

  DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource() {}

  explicit DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<string>(boost::any_cast<string>(m["Enabled"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
  }


  virtual ~DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource() = default;
};
class DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource>> source{};

  DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources() {}

  explicit DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      vector<boost::any> temp1;
      for(auto item1:*source){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Source"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(vector<boost::any>) == m["Source"].type()) {
        vector<DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Source"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        source = make_shared<vector<DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources() = default;
};
class DescribeDcdnIpaDomainDetailResponseBodyDomainDetail : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> cname{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> scope{};
  shared_ptr<DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources> sources{};

  DescribeDcdnIpaDomainDetailResponseBodyDomainDetail() {}

  explicit DescribeDcdnIpaDomainDetailResponseBodyDomainDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (sources) {
      res["Sources"] = sources ? boost::any(sources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sources"].type()) {
        DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sources"]));
        sources = make_shared<DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaDomainDetailResponseBodyDomainDetail() = default;
};
class DescribeDcdnIpaDomainDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnIpaDomainDetailResponseBodyDomainDetail> domainDetail{};
  shared_ptr<string> requestId{};

  DescribeDcdnIpaDomainDetailResponseBody() {}

  explicit DescribeDcdnIpaDomainDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainDetail) {
      res["DomainDetail"] = domainDetail ? boost::any(domainDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainDetail") != m.end() && !m["DomainDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainDetail"].type()) {
        DescribeDcdnIpaDomainDetailResponseBodyDomainDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainDetail"]));
        domainDetail = make_shared<DescribeDcdnIpaDomainDetailResponseBodyDomainDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnIpaDomainDetailResponseBody() = default;
};
class DescribeDcdnIpaDomainDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnIpaDomainDetailResponseBody> body{};

  DescribeDcdnIpaDomainDetailResponse() {}

  explicit DescribeDcdnIpaDomainDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnIpaDomainDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnIpaDomainDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaDomainDetailResponse() = default;
};
class DescribeDcdnIpaServiceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnIpaServiceRequest() {}

  explicit DescribeDcdnIpaServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnIpaServiceRequest() = default;
};
class DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason : public Darabonba::Model {
public:
  shared_ptr<string> lockReason{};

  DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason() {}

  explicit DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
  }


  virtual ~DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason() = default;
};
class DescribeDcdnIpaServiceResponseBodyOperationLocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason>> lockReason{};

  DescribeDcdnIpaServiceResponseBodyOperationLocks() {}

  explicit DescribeDcdnIpaServiceResponseBodyOperationLocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      vector<boost::any> temp1;
      for(auto item1:*lockReason){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LockReason"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      if (typeid(vector<boost::any>) == m["LockReason"].type()) {
        vector<DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LockReason"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lockReason = make_shared<vector<DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnIpaServiceResponseBodyOperationLocks() = default;
};
class DescribeDcdnIpaServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changingAffectTime{};
  shared_ptr<string> changingChargeType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> openingTime{};
  shared_ptr<DescribeDcdnIpaServiceResponseBodyOperationLocks> operationLocks{};
  shared_ptr<string> requestId{};

  DescribeDcdnIpaServiceResponseBody() {}

  explicit DescribeDcdnIpaServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changingAffectTime) {
      res["ChangingAffectTime"] = boost::any(*changingAffectTime);
    }
    if (changingChargeType) {
      res["ChangingChargeType"] = boost::any(*changingChargeType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (openingTime) {
      res["OpeningTime"] = boost::any(*openingTime);
    }
    if (operationLocks) {
      res["OperationLocks"] = operationLocks ? boost::any(operationLocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangingAffectTime") != m.end() && !m["ChangingAffectTime"].empty()) {
      changingAffectTime = make_shared<string>(boost::any_cast<string>(m["ChangingAffectTime"]));
    }
    if (m.find("ChangingChargeType") != m.end() && !m["ChangingChargeType"].empty()) {
      changingChargeType = make_shared<string>(boost::any_cast<string>(m["ChangingChargeType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("OpeningTime") != m.end() && !m["OpeningTime"].empty()) {
      openingTime = make_shared<string>(boost::any_cast<string>(m["OpeningTime"]));
    }
    if (m.find("OperationLocks") != m.end() && !m["OperationLocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationLocks"].type()) {
        DescribeDcdnIpaServiceResponseBodyOperationLocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationLocks"]));
        operationLocks = make_shared<DescribeDcdnIpaServiceResponseBodyOperationLocks>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnIpaServiceResponseBody() = default;
};
class DescribeDcdnIpaServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnIpaServiceResponseBody> body{};

  DescribeDcdnIpaServiceResponse() {}

  explicit DescribeDcdnIpaServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnIpaServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnIpaServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaServiceResponse() = default;
};
class DescribeDcdnIpaUserDomainsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDcdnIpaUserDomainsRequestTag() {}

  explicit DescribeDcdnIpaUserDomainsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnIpaUserDomainsRequestTag() = default;
};
class DescribeDcdnIpaUserDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> checkDomainShow{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainSearchType{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> funcFilter{};
  shared_ptr<string> funcId{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<DescribeDcdnIpaUserDomainsRequestTag>> tag{};

  DescribeDcdnIpaUserDomainsRequest() {}

  explicit DescribeDcdnIpaUserDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkDomainShow) {
      res["CheckDomainShow"] = boost::any(*checkDomainShow);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainSearchType) {
      res["DomainSearchType"] = boost::any(*domainSearchType);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (funcFilter) {
      res["FuncFilter"] = boost::any(*funcFilter);
    }
    if (funcId) {
      res["FuncId"] = boost::any(*funcId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckDomainShow") != m.end() && !m["CheckDomainShow"].empty()) {
      checkDomainShow = make_shared<bool>(boost::any_cast<bool>(m["CheckDomainShow"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainSearchType") != m.end() && !m["DomainSearchType"].empty()) {
      domainSearchType = make_shared<string>(boost::any_cast<string>(m["DomainSearchType"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("FuncFilter") != m.end() && !m["FuncFilter"].empty()) {
      funcFilter = make_shared<string>(boost::any_cast<string>(m["FuncFilter"]));
    }
    if (m.find("FuncId") != m.end() && !m["FuncId"].empty()) {
      funcId = make_shared<string>(boost::any_cast<string>(m["FuncId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDcdnIpaUserDomainsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnIpaUserDomainsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDcdnIpaUserDomainsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnIpaUserDomainsRequest() = default;
};
class DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> port{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};
  shared_ptr<string> weight{};

  DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource() {}

  explicit DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
  }


  virtual ~DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource() = default;
};
class DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource>> source{};

  DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources() {}

  explicit DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      vector<boost::any> temp1;
      for(auto item1:*source){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Source"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(vector<boost::any>) == m["Source"].type()) {
        vector<DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Source"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        source = make_shared<vector<DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources() = default;
};
class DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> sandbox{};
  shared_ptr<DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources> sources{};

  DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData() {}

  explicit DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (sandbox) {
      res["Sandbox"] = boost::any(*sandbox);
    }
    if (sources) {
      res["Sources"] = sources ? boost::any(sources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("Sandbox") != m.end() && !m["Sandbox"].empty()) {
      sandbox = make_shared<string>(boost::any_cast<string>(m["Sandbox"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sources"].type()) {
        DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sources"]));
        sources = make_shared<DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData() = default;
};
class DescribeDcdnIpaUserDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData>> pageData{};

  DescribeDcdnIpaUserDomainsResponseBodyDomains() {}

  explicit DescribeDcdnIpaUserDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageData) {
      vector<boost::any> temp1;
      for(auto item1:*pageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageData") != m.end() && !m["PageData"].empty()) {
      if (typeid(vector<boost::any>) == m["PageData"].type()) {
        vector<DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pageData = make_shared<vector<DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnIpaUserDomainsResponseBodyDomains() = default;
};
class DescribeDcdnIpaUserDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnIpaUserDomainsResponseBodyDomains> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDcdnIpaUserDomainsResponseBody() {}

  explicit DescribeDcdnIpaUserDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribeDcdnIpaUserDomainsResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribeDcdnIpaUserDomainsResponseBodyDomains>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDcdnIpaUserDomainsResponseBody() = default;
};
class DescribeDcdnIpaUserDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnIpaUserDomainsResponseBody> body{};

  DescribeDcdnIpaUserDomainsResponse() {}

  explicit DescribeDcdnIpaUserDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnIpaUserDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnIpaUserDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaUserDomainsResponse() = default;
};
class DescribeDcdnKvAccountResponseBodyNamespaceList : public Darabonba::Model {
public:
  shared_ptr<string> capacityString{};
  shared_ptr<string> capacityUsedString{};
  shared_ptr<string> description{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> status{};

  DescribeDcdnKvAccountResponseBodyNamespaceList() {}

  explicit DescribeDcdnKvAccountResponseBodyNamespaceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityString) {
      res["CapacityString"] = boost::any(*capacityString);
    }
    if (capacityUsedString) {
      res["CapacityUsedString"] = boost::any(*capacityUsedString);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityString") != m.end() && !m["CapacityString"].empty()) {
      capacityString = make_shared<string>(boost::any_cast<string>(m["CapacityString"]));
    }
    if (m.find("CapacityUsedString") != m.end() && !m["CapacityUsedString"].empty()) {
      capacityUsedString = make_shared<string>(boost::any_cast<string>(m["CapacityUsedString"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDcdnKvAccountResponseBodyNamespaceList() = default;
};
class DescribeDcdnKvAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> capacityString{};
  shared_ptr<string> capacityUsedString{};
  shared_ptr<vector<DescribeDcdnKvAccountResponseBodyNamespaceList>> namespaceList{};
  shared_ptr<long> namespaceQuota{};
  shared_ptr<long> namespaceUsed{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribeDcdnKvAccountResponseBody() {}

  explicit DescribeDcdnKvAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityString) {
      res["CapacityString"] = boost::any(*capacityString);
    }
    if (capacityUsedString) {
      res["CapacityUsedString"] = boost::any(*capacityUsedString);
    }
    if (namespaceList) {
      vector<boost::any> temp1;
      for(auto item1:*namespaceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NamespaceList"] = boost::any(temp1);
    }
    if (namespaceQuota) {
      res["NamespaceQuota"] = boost::any(*namespaceQuota);
    }
    if (namespaceUsed) {
      res["NamespaceUsed"] = boost::any(*namespaceUsed);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityString") != m.end() && !m["CapacityString"].empty()) {
      capacityString = make_shared<string>(boost::any_cast<string>(m["CapacityString"]));
    }
    if (m.find("CapacityUsedString") != m.end() && !m["CapacityUsedString"].empty()) {
      capacityUsedString = make_shared<string>(boost::any_cast<string>(m["CapacityUsedString"]));
    }
    if (m.find("NamespaceList") != m.end() && !m["NamespaceList"].empty()) {
      if (typeid(vector<boost::any>) == m["NamespaceList"].type()) {
        vector<DescribeDcdnKvAccountResponseBodyNamespaceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NamespaceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnKvAccountResponseBodyNamespaceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        namespaceList = make_shared<vector<DescribeDcdnKvAccountResponseBodyNamespaceList>>(expect1);
      }
    }
    if (m.find("NamespaceQuota") != m.end() && !m["NamespaceQuota"].empty()) {
      namespaceQuota = make_shared<long>(boost::any_cast<long>(m["NamespaceQuota"]));
    }
    if (m.find("NamespaceUsed") != m.end() && !m["NamespaceUsed"].empty()) {
      namespaceUsed = make_shared<long>(boost::any_cast<long>(m["NamespaceUsed"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDcdnKvAccountResponseBody() = default;
};
class DescribeDcdnKvAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnKvAccountResponseBody> body{};

  DescribeDcdnKvAccountResponse() {}

  explicit DescribeDcdnKvAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnKvAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnKvAccountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnKvAccountResponse() = default;
};
class DescribeDcdnKvAccountStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribeDcdnKvAccountStatusResponseBody() {}

  explicit DescribeDcdnKvAccountStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDcdnKvAccountStatusResponseBody() = default;
};
class DescribeDcdnKvAccountStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnKvAccountStatusResponseBody> body{};

  DescribeDcdnKvAccountStatusResponse() {}

  explicit DescribeDcdnKvAccountStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnKvAccountStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnKvAccountStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnKvAccountStatusResponse() = default;
};
class DescribeDcdnKvNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};

  DescribeDcdnKvNamespaceRequest() {}

  explicit DescribeDcdnKvNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DescribeDcdnKvNamespaceRequest() = default;
};
class DescribeDcdnKvNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> capacityString{};
  shared_ptr<string> capacityUsedString{};
  shared_ptr<string> description{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribeDcdnKvNamespaceResponseBody() {}

  explicit DescribeDcdnKvNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityString) {
      res["CapacityString"] = boost::any(*capacityString);
    }
    if (capacityUsedString) {
      res["CapacityUsedString"] = boost::any(*capacityUsedString);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityString") != m.end() && !m["CapacityString"].empty()) {
      capacityString = make_shared<string>(boost::any_cast<string>(m["CapacityString"]));
    }
    if (m.find("CapacityUsedString") != m.end() && !m["CapacityUsedString"].empty()) {
      capacityUsedString = make_shared<string>(boost::any_cast<string>(m["CapacityUsedString"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDcdnKvNamespaceResponseBody() = default;
};
class DescribeDcdnKvNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnKvNamespaceResponseBody> body{};

  DescribeDcdnKvNamespaceResponse() {}

  explicit DescribeDcdnKvNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnKvNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnKvNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnKvNamespaceResponse() = default;
};
class DescribeDcdnL2IpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> vips{};

  DescribeDcdnL2IpsResponseBody() {}

  explicit DescribeDcdnL2IpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vips) {
      res["Vips"] = boost::any(*vips);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Vips") != m.end() && !m["Vips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Vips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Vips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vips = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDcdnL2IpsResponseBody() = default;
};
class DescribeDcdnL2IpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnL2IpsResponseBody> body{};

  DescribeDcdnL2IpsResponse() {}

  explicit DescribeDcdnL2IpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnL2IpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnL2IpsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnL2IpsResponse() = default;
};
class DescribeDcdnL2VipsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  DescribeDcdnL2VipsRequest() {}

  explicit DescribeDcdnL2VipsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnL2VipsRequest() = default;
};
class DescribeDcdnL2VipsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> vips{};

  DescribeDcdnL2VipsResponseBody() {}

  explicit DescribeDcdnL2VipsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vips) {
      res["Vips"] = boost::any(*vips);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Vips") != m.end() && !m["Vips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Vips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Vips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vips = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDcdnL2VipsResponseBody() = default;
};
class DescribeDcdnL2VipsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnL2VipsResponseBody> body{};

  DescribeDcdnL2VipsResponse() {}

  explicit DescribeDcdnL2VipsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnL2VipsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnL2VipsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnL2VipsResponse() = default;
};
class DescribeDcdnRealTimeDeliveryFieldRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};

  DescribeDcdnRealTimeDeliveryFieldRequest() {}

  explicit DescribeDcdnRealTimeDeliveryFieldRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
  }


  virtual ~DescribeDcdnRealTimeDeliveryFieldRequest() = default;
};
class DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> fieldName{};

  DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields() {}

  explicit DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
  }


  virtual ~DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields() = default;
};
class DescribeDcdnRealTimeDeliveryFieldResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields>> fields{};

  DescribeDcdnRealTimeDeliveryFieldResponseBodyContent() {}

  explicit DescribeDcdnRealTimeDeliveryFieldResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fields) {
      vector<boost::any> temp1;
      for(auto item1:*fields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Fields"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      if (typeid(vector<boost::any>) == m["Fields"].type()) {
        vector<DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Fields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fields = make_shared<vector<DescribeDcdnRealTimeDeliveryFieldResponseBodyContentFields>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnRealTimeDeliveryFieldResponseBodyContent() = default;
};
class DescribeDcdnRealTimeDeliveryFieldResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnRealTimeDeliveryFieldResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnRealTimeDeliveryFieldResponseBody() {}

  explicit DescribeDcdnRealTimeDeliveryFieldResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        DescribeDcdnRealTimeDeliveryFieldResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<DescribeDcdnRealTimeDeliveryFieldResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnRealTimeDeliveryFieldResponseBody() = default;
};
class DescribeDcdnRealTimeDeliveryFieldResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnRealTimeDeliveryFieldResponseBody> body{};

  DescribeDcdnRealTimeDeliveryFieldResponse() {}

  explicit DescribeDcdnRealTimeDeliveryFieldResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnRealTimeDeliveryFieldResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnRealTimeDeliveryFieldResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnRealTimeDeliveryFieldResponse() = default;
};
class DescribeDcdnRefreshQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnRefreshQuotaRequest() {}

  explicit DescribeDcdnRefreshQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnRefreshQuotaRequest() = default;
};
class DescribeDcdnRefreshQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> blockQuota{};
  shared_ptr<string> blockRemain{};
  shared_ptr<string> dirQuota{};
  shared_ptr<string> dirRemain{};
  shared_ptr<string> ignoreParamsQuota{};
  shared_ptr<string> ignoreParamsRemain{};
  shared_ptr<string> preloadQuota{};
  shared_ptr<string> preloadRemain{};
  shared_ptr<string> regexQuota{};
  shared_ptr<string> regexRemain{};
  shared_ptr<string> requestId{};
  shared_ptr<string> urlQuota{};
  shared_ptr<string> urlRemain{};

  DescribeDcdnRefreshQuotaResponseBody() {}

  explicit DescribeDcdnRefreshQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockQuota) {
      res["BlockQuota"] = boost::any(*blockQuota);
    }
    if (blockRemain) {
      res["BlockRemain"] = boost::any(*blockRemain);
    }
    if (dirQuota) {
      res["DirQuota"] = boost::any(*dirQuota);
    }
    if (dirRemain) {
      res["DirRemain"] = boost::any(*dirRemain);
    }
    if (ignoreParamsQuota) {
      res["IgnoreParamsQuota"] = boost::any(*ignoreParamsQuota);
    }
    if (ignoreParamsRemain) {
      res["IgnoreParamsRemain"] = boost::any(*ignoreParamsRemain);
    }
    if (preloadQuota) {
      res["PreloadQuota"] = boost::any(*preloadQuota);
    }
    if (preloadRemain) {
      res["PreloadRemain"] = boost::any(*preloadRemain);
    }
    if (regexQuota) {
      res["RegexQuota"] = boost::any(*regexQuota);
    }
    if (regexRemain) {
      res["RegexRemain"] = boost::any(*regexRemain);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (urlQuota) {
      res["UrlQuota"] = boost::any(*urlQuota);
    }
    if (urlRemain) {
      res["UrlRemain"] = boost::any(*urlRemain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockQuota") != m.end() && !m["BlockQuota"].empty()) {
      blockQuota = make_shared<string>(boost::any_cast<string>(m["BlockQuota"]));
    }
    if (m.find("BlockRemain") != m.end() && !m["BlockRemain"].empty()) {
      blockRemain = make_shared<string>(boost::any_cast<string>(m["BlockRemain"]));
    }
    if (m.find("DirQuota") != m.end() && !m["DirQuota"].empty()) {
      dirQuota = make_shared<string>(boost::any_cast<string>(m["DirQuota"]));
    }
    if (m.find("DirRemain") != m.end() && !m["DirRemain"].empty()) {
      dirRemain = make_shared<string>(boost::any_cast<string>(m["DirRemain"]));
    }
    if (m.find("IgnoreParamsQuota") != m.end() && !m["IgnoreParamsQuota"].empty()) {
      ignoreParamsQuota = make_shared<string>(boost::any_cast<string>(m["IgnoreParamsQuota"]));
    }
    if (m.find("IgnoreParamsRemain") != m.end() && !m["IgnoreParamsRemain"].empty()) {
      ignoreParamsRemain = make_shared<string>(boost::any_cast<string>(m["IgnoreParamsRemain"]));
    }
    if (m.find("PreloadQuota") != m.end() && !m["PreloadQuota"].empty()) {
      preloadQuota = make_shared<string>(boost::any_cast<string>(m["PreloadQuota"]));
    }
    if (m.find("PreloadRemain") != m.end() && !m["PreloadRemain"].empty()) {
      preloadRemain = make_shared<string>(boost::any_cast<string>(m["PreloadRemain"]));
    }
    if (m.find("RegexQuota") != m.end() && !m["RegexQuota"].empty()) {
      regexQuota = make_shared<string>(boost::any_cast<string>(m["RegexQuota"]));
    }
    if (m.find("RegexRemain") != m.end() && !m["RegexRemain"].empty()) {
      regexRemain = make_shared<string>(boost::any_cast<string>(m["RegexRemain"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UrlQuota") != m.end() && !m["UrlQuota"].empty()) {
      urlQuota = make_shared<string>(boost::any_cast<string>(m["UrlQuota"]));
    }
    if (m.find("UrlRemain") != m.end() && !m["UrlRemain"].empty()) {
      urlRemain = make_shared<string>(boost::any_cast<string>(m["UrlRemain"]));
    }
  }


  virtual ~DescribeDcdnRefreshQuotaResponseBody() = default;
};
class DescribeDcdnRefreshQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnRefreshQuotaResponseBody> body{};

  DescribeDcdnRefreshQuotaResponse() {}

  explicit DescribeDcdnRefreshQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnRefreshQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnRefreshQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnRefreshQuotaResponse() = default;
};
class DescribeDcdnRefreshTaskByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  DescribeDcdnRefreshTaskByIdRequest() {}

  explicit DescribeDcdnRefreshTaskByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeDcdnRefreshTaskByIdRequest() = default;
};
class DescribeDcdnRefreshTaskByIdResponseBodyTasks : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> objectPath{};
  shared_ptr<string> objectType{};
  shared_ptr<string> process{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  DescribeDcdnRefreshTaskByIdResponseBodyTasks() {}

  explicit DescribeDcdnRefreshTaskByIdResponseBodyTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (process) {
      res["Process"] = boost::any(*process);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      process = make_shared<string>(boost::any_cast<string>(m["Process"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeDcdnRefreshTaskByIdResponseBodyTasks() = default;
};
class DescribeDcdnRefreshTaskByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnRefreshTaskByIdResponseBodyTasks>> tasks{};
  shared_ptr<long> totalCount{};

  DescribeDcdnRefreshTaskByIdResponseBody() {}

  explicit DescribeDcdnRefreshTaskByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<DescribeDcdnRefreshTaskByIdResponseBodyTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnRefreshTaskByIdResponseBodyTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<DescribeDcdnRefreshTaskByIdResponseBodyTasks>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDcdnRefreshTaskByIdResponseBody() = default;
};
class DescribeDcdnRefreshTaskByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnRefreshTaskByIdResponseBody> body{};

  DescribeDcdnRefreshTaskByIdResponse() {}

  explicit DescribeDcdnRefreshTaskByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnRefreshTaskByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnRefreshTaskByIdResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnRefreshTaskByIdResponse() = default;
};
class DescribeDcdnRefreshTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> objectPath{};
  shared_ptr<string> objectType{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  DescribeDcdnRefreshTasksRequest() {}

  explicit DescribeDcdnRefreshTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeDcdnRefreshTasksRequest() = default;
};
class DescribeDcdnRefreshTasksResponseBodyTasksTask : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> objectPath{};
  shared_ptr<string> objectType{};
  shared_ptr<string> process{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  DescribeDcdnRefreshTasksResponseBodyTasksTask() {}

  explicit DescribeDcdnRefreshTasksResponseBodyTasksTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (process) {
      res["Process"] = boost::any(*process);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      process = make_shared<string>(boost::any_cast<string>(m["Process"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeDcdnRefreshTasksResponseBodyTasksTask() = default;
};
class DescribeDcdnRefreshTasksResponseBodyTasks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnRefreshTasksResponseBodyTasksTask>> task{};

  DescribeDcdnRefreshTasksResponseBodyTasks() {}

  explicit DescribeDcdnRefreshTasksResponseBodyTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (task) {
      vector<boost::any> temp1;
      for(auto item1:*task){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Task"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(vector<boost::any>) == m["Task"].type()) {
        vector<DescribeDcdnRefreshTasksResponseBodyTasksTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Task"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnRefreshTasksResponseBodyTasksTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        task = make_shared<vector<DescribeDcdnRefreshTasksResponseBodyTasksTask>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnRefreshTasksResponseBodyTasks() = default;
};
class DescribeDcdnRefreshTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnRefreshTasksResponseBodyTasks> tasks{};
  shared_ptr<long> totalCount{};

  DescribeDcdnRefreshTasksResponseBody() {}

  explicit DescribeDcdnRefreshTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tasks) {
      res["Tasks"] = tasks ? boost::any(tasks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tasks"].type()) {
        DescribeDcdnRefreshTasksResponseBodyTasks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tasks"]));
        tasks = make_shared<DescribeDcdnRefreshTasksResponseBodyTasks>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDcdnRefreshTasksResponseBody() = default;
};
class DescribeDcdnRefreshTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnRefreshTasksResponseBody> body{};

  DescribeDcdnRefreshTasksResponse() {}

  explicit DescribeDcdnRefreshTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnRefreshTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnRefreshTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnRefreshTasksResponse() = default;
};
class DescribeDcdnRegionAndIspRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnRegionAndIspRequest() {}

  explicit DescribeDcdnRegionAndIspRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnRegionAndIspRequest() = default;
};
class DescribeDcdnRegionAndIspResponseBodyIspsIsp : public Darabonba::Model {
public:
  shared_ptr<string> nameEn{};
  shared_ptr<string> nameZh{};

  DescribeDcdnRegionAndIspResponseBodyIspsIsp() {}

  explicit DescribeDcdnRegionAndIspResponseBodyIspsIsp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameEn) {
      res["NameEn"] = boost::any(*nameEn);
    }
    if (nameZh) {
      res["NameZh"] = boost::any(*nameZh);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameEn") != m.end() && !m["NameEn"].empty()) {
      nameEn = make_shared<string>(boost::any_cast<string>(m["NameEn"]));
    }
    if (m.find("NameZh") != m.end() && !m["NameZh"].empty()) {
      nameZh = make_shared<string>(boost::any_cast<string>(m["NameZh"]));
    }
  }


  virtual ~DescribeDcdnRegionAndIspResponseBodyIspsIsp() = default;
};
class DescribeDcdnRegionAndIspResponseBodyIsps : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnRegionAndIspResponseBodyIspsIsp>> isp{};

  DescribeDcdnRegionAndIspResponseBodyIsps() {}

  explicit DescribeDcdnRegionAndIspResponseBodyIsps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isp) {
      vector<boost::any> temp1;
      for(auto item1:*isp){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Isp"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      if (typeid(vector<boost::any>) == m["Isp"].type()) {
        vector<DescribeDcdnRegionAndIspResponseBodyIspsIsp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Isp"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnRegionAndIspResponseBodyIspsIsp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        isp = make_shared<vector<DescribeDcdnRegionAndIspResponseBodyIspsIsp>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnRegionAndIspResponseBodyIsps() = default;
};
class DescribeDcdnRegionAndIspResponseBodyRegionsRegion : public Darabonba::Model {
public:
  shared_ptr<string> nameEn{};
  shared_ptr<string> nameZh{};

  DescribeDcdnRegionAndIspResponseBodyRegionsRegion() {}

  explicit DescribeDcdnRegionAndIspResponseBodyRegionsRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameEn) {
      res["NameEn"] = boost::any(*nameEn);
    }
    if (nameZh) {
      res["NameZh"] = boost::any(*nameZh);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameEn") != m.end() && !m["NameEn"].empty()) {
      nameEn = make_shared<string>(boost::any_cast<string>(m["NameEn"]));
    }
    if (m.find("NameZh") != m.end() && !m["NameZh"].empty()) {
      nameZh = make_shared<string>(boost::any_cast<string>(m["NameZh"]));
    }
  }


  virtual ~DescribeDcdnRegionAndIspResponseBodyRegionsRegion() = default;
};
class DescribeDcdnRegionAndIspResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnRegionAndIspResponseBodyRegionsRegion>> region{};

  DescribeDcdnRegionAndIspResponseBodyRegions() {}

  explicit DescribeDcdnRegionAndIspResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      vector<boost::any> temp1;
      for(auto item1:*region){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Region"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      if (typeid(vector<boost::any>) == m["Region"].type()) {
        vector<DescribeDcdnRegionAndIspResponseBodyRegionsRegion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Region"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnRegionAndIspResponseBodyRegionsRegion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        region = make_shared<vector<DescribeDcdnRegionAndIspResponseBodyRegionsRegion>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnRegionAndIspResponseBodyRegions() = default;
};
class DescribeDcdnRegionAndIspResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnRegionAndIspResponseBodyIsps> isps{};
  shared_ptr<DescribeDcdnRegionAndIspResponseBodyRegions> regions{};
  shared_ptr<string> requestId{};

  DescribeDcdnRegionAndIspResponseBody() {}

  explicit DescribeDcdnRegionAndIspResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isps) {
      res["Isps"] = isps ? boost::any(isps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regions) {
      res["Regions"] = regions ? boost::any(regions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Isps") != m.end() && !m["Isps"].empty()) {
      if (typeid(map<string, boost::any>) == m["Isps"].type()) {
        DescribeDcdnRegionAndIspResponseBodyIsps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Isps"]));
        isps = make_shared<DescribeDcdnRegionAndIspResponseBodyIsps>(model1);
      }
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Regions"].type()) {
        DescribeDcdnRegionAndIspResponseBodyRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Regions"]));
        regions = make_shared<DescribeDcdnRegionAndIspResponseBodyRegions>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnRegionAndIspResponseBody() = default;
};
class DescribeDcdnRegionAndIspResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnRegionAndIspResponseBody> body{};

  DescribeDcdnRegionAndIspResponse() {}

  explicit DescribeDcdnRegionAndIspResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnRegionAndIspResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnRegionAndIspResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnRegionAndIspResponse() = default;
};
class DescribeDcdnReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> isOverseas{};
  shared_ptr<long> reportId{};
  shared_ptr<string> startTime{};

  DescribeDcdnReportRequest() {}

  explicit DescribeDcdnReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (isOverseas) {
      res["IsOverseas"] = boost::any(*isOverseas);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("IsOverseas") != m.end() && !m["IsOverseas"].empty()) {
      isOverseas = make_shared<string>(boost::any_cast<string>(m["IsOverseas"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<long>(boost::any_cast<long>(m["ReportId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnReportRequest() = default;
};
class DescribeDcdnReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnReportResponseBody() {}

  explicit DescribeDcdnReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnReportResponseBody() = default;
};
class DescribeDcdnReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnReportResponseBody> body{};

  DescribeDcdnReportResponse() {}

  explicit DescribeDcdnReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnReportResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnReportResponse() = default;
};
class DescribeDcdnReportListRequest : public Darabonba::Model {
public:
  shared_ptr<long> reportId{};

  DescribeDcdnReportListRequest() {}

  explicit DescribeDcdnReportListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<long>(boost::any_cast<long>(m["ReportId"]));
    }
  }


  virtual ~DescribeDcdnReportListRequest() = default;
};
class DescribeDcdnReportListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnReportListResponseBody() {}

  explicit DescribeDcdnReportListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnReportListResponseBody() = default;
};
class DescribeDcdnReportListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnReportListResponseBody> body{};

  DescribeDcdnReportListResponse() {}

  explicit DescribeDcdnReportListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnReportListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnReportListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnReportListResponse() = default;
};
class DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> desc{};

  DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness() {}

  explicit DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
  }


  virtual ~DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness() = default;
};
class DescribeDcdnSLSRealTimeLogTypeResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness>> business{};

  DescribeDcdnSLSRealTimeLogTypeResponseBodyContent() {}

  explicit DescribeDcdnSLSRealTimeLogTypeResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (business) {
      vector<boost::any> temp1;
      for(auto item1:*business){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Business"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Business") != m.end() && !m["Business"].empty()) {
      if (typeid(vector<boost::any>) == m["Business"].type()) {
        vector<DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Business"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        business = make_shared<vector<DescribeDcdnSLSRealTimeLogTypeResponseBodyContentBusiness>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnSLSRealTimeLogTypeResponseBodyContent() = default;
};
class DescribeDcdnSLSRealTimeLogTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnSLSRealTimeLogTypeResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnSLSRealTimeLogTypeResponseBody() {}

  explicit DescribeDcdnSLSRealTimeLogTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        DescribeDcdnSLSRealTimeLogTypeResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<DescribeDcdnSLSRealTimeLogTypeResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnSLSRealTimeLogTypeResponseBody() = default;
};
class DescribeDcdnSLSRealTimeLogTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnSLSRealTimeLogTypeResponseBody> body{};

  DescribeDcdnSLSRealTimeLogTypeResponse() {}

  explicit DescribeDcdnSLSRealTimeLogTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnSLSRealTimeLogTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnSLSRealTimeLogTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnSLSRealTimeLogTypeResponse() = default;
};
class DescribeDcdnSLSRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};

  DescribeDcdnSLSRealtimeLogDeliveryRequest() {}

  explicit DescribeDcdnSLSRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~DescribeDcdnSLSRealtimeLogDeliveryRequest() = default;
};
class DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> domainName{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> SLSLogStore{};
  shared_ptr<string> SLSProject{};
  shared_ptr<string> SLSRegion{};
  shared_ptr<string> samplingRate{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent() {}

  explicit DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (SLSLogStore) {
      res["SLSLogStore"] = boost::any(*SLSLogStore);
    }
    if (SLSProject) {
      res["SLSProject"] = boost::any(*SLSProject);
    }
    if (SLSRegion) {
      res["SLSRegion"] = boost::any(*SLSRegion);
    }
    if (samplingRate) {
      res["SamplingRate"] = boost::any(*samplingRate);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SLSLogStore") != m.end() && !m["SLSLogStore"].empty()) {
      SLSLogStore = make_shared<string>(boost::any_cast<string>(m["SLSLogStore"]));
    }
    if (m.find("SLSProject") != m.end() && !m["SLSProject"].empty()) {
      SLSProject = make_shared<string>(boost::any_cast<string>(m["SLSProject"]));
    }
    if (m.find("SLSRegion") != m.end() && !m["SLSRegion"].empty()) {
      SLSRegion = make_shared<string>(boost::any_cast<string>(m["SLSRegion"]));
    }
    if (m.find("SamplingRate") != m.end() && !m["SamplingRate"].empty()) {
      samplingRate = make_shared<string>(boost::any_cast<string>(m["SamplingRate"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent() = default;
};
class DescribeDcdnSLSRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnSLSRealtimeLogDeliveryResponseBody() {}

  explicit DescribeDcdnSLSRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<DescribeDcdnSLSRealtimeLogDeliveryResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnSLSRealtimeLogDeliveryResponseBody() = default;
};
class DescribeDcdnSLSRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnSLSRealtimeLogDeliveryResponseBody> body{};

  DescribeDcdnSLSRealtimeLogDeliveryResponse() {}

  explicit DescribeDcdnSLSRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnSLSRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnSLSRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnSLSRealtimeLogDeliveryResponse() = default;
};
class DescribeDcdnSMCertificateDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> certIdentifier{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnSMCertificateDetailRequest() {}

  explicit DescribeDcdnSMCertificateDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnSMCertificateDetailRequest() = default;
};
class DescribeDcdnSMCertificateDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certIdentifier{};
  shared_ptr<string> certName{};
  shared_ptr<string> certOrg{};
  shared_ptr<string> commonName{};
  shared_ptr<string> encryptCertificate{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sans{};
  shared_ptr<string> signCertificate{};

  DescribeDcdnSMCertificateDetailResponseBody() {}

  explicit DescribeDcdnSMCertificateDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certOrg) {
      res["CertOrg"] = boost::any(*certOrg);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (encryptCertificate) {
      res["EncryptCertificate"] = boost::any(*encryptCertificate);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sans) {
      res["Sans"] = boost::any(*sans);
    }
    if (signCertificate) {
      res["SignCertificate"] = boost::any(*signCertificate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertOrg") != m.end() && !m["CertOrg"].empty()) {
      certOrg = make_shared<string>(boost::any_cast<string>(m["CertOrg"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("EncryptCertificate") != m.end() && !m["EncryptCertificate"].empty()) {
      encryptCertificate = make_shared<string>(boost::any_cast<string>(m["EncryptCertificate"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Sans") != m.end() && !m["Sans"].empty()) {
      sans = make_shared<string>(boost::any_cast<string>(m["Sans"]));
    }
    if (m.find("SignCertificate") != m.end() && !m["SignCertificate"].empty()) {
      signCertificate = make_shared<string>(boost::any_cast<string>(m["SignCertificate"]));
    }
  }


  virtual ~DescribeDcdnSMCertificateDetailResponseBody() = default;
};
class DescribeDcdnSMCertificateDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnSMCertificateDetailResponseBody> body{};

  DescribeDcdnSMCertificateDetailResponse() {}

  explicit DescribeDcdnSMCertificateDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnSMCertificateDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnSMCertificateDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnSMCertificateDetailResponse() = default;
};
class DescribeDcdnSMCertificateListRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnSMCertificateListRequest() {}

  explicit DescribeDcdnSMCertificateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnSMCertificateListRequest() = default;
};
class DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList : public Darabonba::Model {
public:
  shared_ptr<string> certIdentifier{};
  shared_ptr<string> certName{};
  shared_ptr<string> common{};
  shared_ptr<string> issuer{};

  DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList() {}

  explicit DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (common) {
      res["Common"] = boost::any(*common);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Common") != m.end() && !m["Common"].empty()) {
      common = make_shared<string>(boost::any_cast<string>(m["Common"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
  }


  virtual ~DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList() = default;
};
class DescribeDcdnSMCertificateListResponseBodyCertificateListModel : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList>> certList{};
  shared_ptr<long> count{};

  DescribeDcdnSMCertificateListResponseBodyCertificateListModel() {}

  explicit DescribeDcdnSMCertificateListResponseBodyCertificateListModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certList) {
      vector<boost::any> temp1;
      for(auto item1:*certList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertList"] = boost::any(temp1);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertList") != m.end() && !m["CertList"].empty()) {
      if (typeid(vector<boost::any>) == m["CertList"].type()) {
        vector<DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certList = make_shared<vector<DescribeDcdnSMCertificateListResponseBodyCertificateListModelCertList>>(expect1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeDcdnSMCertificateListResponseBodyCertificateListModel() = default;
};
class DescribeDcdnSMCertificateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnSMCertificateListResponseBodyCertificateListModel> certificateListModel{};
  shared_ptr<string> requestId{};

  DescribeDcdnSMCertificateListResponseBody() {}

  explicit DescribeDcdnSMCertificateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateListModel) {
      res["CertificateListModel"] = certificateListModel ? boost::any(certificateListModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateListModel") != m.end() && !m["CertificateListModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertificateListModel"].type()) {
        DescribeDcdnSMCertificateListResponseBodyCertificateListModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertificateListModel"]));
        certificateListModel = make_shared<DescribeDcdnSMCertificateListResponseBodyCertificateListModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnSMCertificateListResponseBody() = default;
};
class DescribeDcdnSMCertificateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnSMCertificateListResponseBody> body{};

  DescribeDcdnSMCertificateListResponse() {}

  explicit DescribeDcdnSMCertificateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnSMCertificateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnSMCertificateListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnSMCertificateListResponse() = default;
};
class DescribeDcdnSecFuncInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};
  shared_ptr<string> secFuncType{};

  DescribeDcdnSecFuncInfoRequest() {}

  explicit DescribeDcdnSecFuncInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (secFuncType) {
      res["SecFuncType"] = boost::any(*secFuncType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SecFuncType") != m.end() && !m["SecFuncType"].empty()) {
      secFuncType = make_shared<string>(boost::any_cast<string>(m["SecFuncType"]));
    }
  }


  virtual ~DescribeDcdnSecFuncInfoRequest() = default;
};
class DescribeDcdnSecFuncInfoResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> value{};

  DescribeDcdnSecFuncInfoResponseBodyContent() {}

  explicit DescribeDcdnSecFuncInfoResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnSecFuncInfoResponseBodyContent() = default;
};
class DescribeDcdnSecFuncInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnSecFuncInfoResponseBodyContent>> content{};
  shared_ptr<string> description{};
  shared_ptr<string> httpStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<string> retCode{};

  DescribeDcdnSecFuncInfoResponseBody() {}

  explicit DescribeDcdnSecFuncInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (httpStatus) {
      res["HttpStatus"] = boost::any(*httpStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<DescribeDcdnSecFuncInfoResponseBodyContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnSecFuncInfoResponseBodyContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<DescribeDcdnSecFuncInfoResponseBodyContent>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HttpStatus") != m.end() && !m["HttpStatus"].empty()) {
      httpStatus = make_shared<string>(boost::any_cast<string>(m["HttpStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<string>(boost::any_cast<string>(m["RetCode"]));
    }
  }


  virtual ~DescribeDcdnSecFuncInfoResponseBody() = default;
};
class DescribeDcdnSecFuncInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnSecFuncInfoResponseBody> body{};

  DescribeDcdnSecFuncInfoResponse() {}

  explicit DescribeDcdnSecFuncInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnSecFuncInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnSecFuncInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnSecFuncInfoResponse() = default;
};
class DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> expr{};
  shared_ptr<string> value{};

  DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs() {}

  explicit DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (expr) {
      res["Expr"] = boost::any(*expr);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Expr") != m.end() && !m["Expr"].empty()) {
      expr = make_shared<string>(boost::any_cast<string>(m["Expr"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs() = default;
};
class DescribeDcdnSecSpecInfoResponseBodySpecInfos : public Darabonba::Model {
public:
  shared_ptr<string> ruleCode{};
  shared_ptr<vector<DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs>> ruleConfigs{};

  DescribeDcdnSecSpecInfoResponseBodySpecInfos() {}

  explicit DescribeDcdnSecSpecInfoResponseBodySpecInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleCode) {
      res["RuleCode"] = boost::any(*ruleCode);
    }
    if (ruleConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*ruleConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleCode") != m.end() && !m["RuleCode"].empty()) {
      ruleCode = make_shared<string>(boost::any_cast<string>(m["RuleCode"]));
    }
    if (m.find("RuleConfigs") != m.end() && !m["RuleConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleConfigs"].type()) {
        vector<DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleConfigs = make_shared<vector<DescribeDcdnSecSpecInfoResponseBodySpecInfosRuleConfigs>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnSecSpecInfoResponseBodySpecInfos() = default;
};
class DescribeDcdnSecSpecInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnSecSpecInfoResponseBodySpecInfos>> specInfos{};
  shared_ptr<string> version{};

  DescribeDcdnSecSpecInfoResponseBody() {}

  explicit DescribeDcdnSecSpecInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (specInfos) {
      vector<boost::any> temp1;
      for(auto item1:*specInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecInfos"] = boost::any(temp1);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpecInfos") != m.end() && !m["SpecInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecInfos"].type()) {
        vector<DescribeDcdnSecSpecInfoResponseBodySpecInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnSecSpecInfoResponseBodySpecInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specInfos = make_shared<vector<DescribeDcdnSecSpecInfoResponseBodySpecInfos>>(expect1);
      }
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeDcdnSecSpecInfoResponseBody() = default;
};
class DescribeDcdnSecSpecInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnSecSpecInfoResponseBody> body{};

  DescribeDcdnSecSpecInfoResponse() {}

  explicit DescribeDcdnSecSpecInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnSecSpecInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnSecSpecInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnSecSpecInfoResponse() = default;
};
class DescribeDcdnServiceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnServiceRequest() {}

  explicit DescribeDcdnServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnServiceRequest() = default;
};
class DescribeDcdnServiceResponseBodyOperationLocksLockReason : public Darabonba::Model {
public:
  shared_ptr<string> lockReason{};

  DescribeDcdnServiceResponseBodyOperationLocksLockReason() {}

  explicit DescribeDcdnServiceResponseBodyOperationLocksLockReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
  }


  virtual ~DescribeDcdnServiceResponseBodyOperationLocksLockReason() = default;
};
class DescribeDcdnServiceResponseBodyOperationLocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnServiceResponseBodyOperationLocksLockReason>> lockReason{};

  DescribeDcdnServiceResponseBodyOperationLocks() {}

  explicit DescribeDcdnServiceResponseBodyOperationLocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      vector<boost::any> temp1;
      for(auto item1:*lockReason){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LockReason"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      if (typeid(vector<boost::any>) == m["LockReason"].type()) {
        vector<DescribeDcdnServiceResponseBodyOperationLocksLockReason> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LockReason"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnServiceResponseBodyOperationLocksLockReason model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lockReason = make_shared<vector<DescribeDcdnServiceResponseBodyOperationLocksLockReason>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnServiceResponseBodyOperationLocks() = default;
};
class DescribeDcdnServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changingAffectTime{};
  shared_ptr<string> changingChargeType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> openingTime{};
  shared_ptr<DescribeDcdnServiceResponseBodyOperationLocks> operationLocks{};
  shared_ptr<string> requestId{};
  shared_ptr<string> websocketChangingTime{};
  shared_ptr<string> websocketChangingType{};
  shared_ptr<string> websocketType{};

  DescribeDcdnServiceResponseBody() {}

  explicit DescribeDcdnServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changingAffectTime) {
      res["ChangingAffectTime"] = boost::any(*changingAffectTime);
    }
    if (changingChargeType) {
      res["ChangingChargeType"] = boost::any(*changingChargeType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (openingTime) {
      res["OpeningTime"] = boost::any(*openingTime);
    }
    if (operationLocks) {
      res["OperationLocks"] = operationLocks ? boost::any(operationLocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (websocketChangingTime) {
      res["WebsocketChangingTime"] = boost::any(*websocketChangingTime);
    }
    if (websocketChangingType) {
      res["WebsocketChangingType"] = boost::any(*websocketChangingType);
    }
    if (websocketType) {
      res["WebsocketType"] = boost::any(*websocketType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangingAffectTime") != m.end() && !m["ChangingAffectTime"].empty()) {
      changingAffectTime = make_shared<string>(boost::any_cast<string>(m["ChangingAffectTime"]));
    }
    if (m.find("ChangingChargeType") != m.end() && !m["ChangingChargeType"].empty()) {
      changingChargeType = make_shared<string>(boost::any_cast<string>(m["ChangingChargeType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("OpeningTime") != m.end() && !m["OpeningTime"].empty()) {
      openingTime = make_shared<string>(boost::any_cast<string>(m["OpeningTime"]));
    }
    if (m.find("OperationLocks") != m.end() && !m["OperationLocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationLocks"].type()) {
        DescribeDcdnServiceResponseBodyOperationLocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationLocks"]));
        operationLocks = make_shared<DescribeDcdnServiceResponseBodyOperationLocks>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WebsocketChangingTime") != m.end() && !m["WebsocketChangingTime"].empty()) {
      websocketChangingTime = make_shared<string>(boost::any_cast<string>(m["WebsocketChangingTime"]));
    }
    if (m.find("WebsocketChangingType") != m.end() && !m["WebsocketChangingType"].empty()) {
      websocketChangingType = make_shared<string>(boost::any_cast<string>(m["WebsocketChangingType"]));
    }
    if (m.find("WebsocketType") != m.end() && !m["WebsocketType"].empty()) {
      websocketType = make_shared<string>(boost::any_cast<string>(m["WebsocketType"]));
    }
  }


  virtual ~DescribeDcdnServiceResponseBody() = default;
};
class DescribeDcdnServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnServiceResponseBody> body{};

  DescribeDcdnServiceResponse() {}

  explicit DescribeDcdnServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnServiceResponse() = default;
};
class DescribeDcdnStagingIpResponseBodyIPV4s : public Darabonba::Model {
public:
  shared_ptr<vector<string>> IPV4{};

  DescribeDcdnStagingIpResponseBodyIPV4s() {}

  explicit DescribeDcdnStagingIpResponseBodyIPV4s(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPV4) {
      res["IPV4"] = boost::any(*IPV4);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPV4") != m.end() && !m["IPV4"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPV4"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPV4"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPV4 = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDcdnStagingIpResponseBodyIPV4s() = default;
};
class DescribeDcdnStagingIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnStagingIpResponseBodyIPV4s> IPV4s{};
  shared_ptr<string> requestId{};

  DescribeDcdnStagingIpResponseBody() {}

  explicit DescribeDcdnStagingIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPV4s) {
      res["IPV4s"] = IPV4s ? boost::any(IPV4s->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPV4s") != m.end() && !m["IPV4s"].empty()) {
      if (typeid(map<string, boost::any>) == m["IPV4s"].type()) {
        DescribeDcdnStagingIpResponseBodyIPV4s model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IPV4s"]));
        IPV4s = make_shared<DescribeDcdnStagingIpResponseBodyIPV4s>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnStagingIpResponseBody() = default;
};
class DescribeDcdnStagingIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnStagingIpResponseBody> body{};

  DescribeDcdnStagingIpResponse() {}

  explicit DescribeDcdnStagingIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnStagingIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnStagingIpResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnStagingIpResponse() = default;
};
class DescribeDcdnSubListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnSubListResponseBody() {}

  explicit DescribeDcdnSubListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnSubListResponseBody() = default;
};
class DescribeDcdnSubListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnSubListResponseBody> body{};

  DescribeDcdnSubListResponse() {}

  explicit DescribeDcdnSubListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnSubListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnSubListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnSubListResponse() = default;
};
class DescribeDcdnTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDcdnTagResourcesRequestTag() {}

  explicit DescribeDcdnTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnTagResourcesRequestTag() = default;
};
class DescribeDcdnTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<DescribeDcdnTagResourcesRequestTag>> tag{};

  DescribeDcdnTagResourcesRequest() {}

  explicit DescribeDcdnTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDcdnTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDcdnTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnTagResourcesRequest() = default;
};
class DescribeDcdnTagResourcesResponseBodyTagResourcesTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDcdnTagResourcesResponseBodyTagResourcesTag() {}

  explicit DescribeDcdnTagResourcesResponseBodyTagResourcesTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnTagResourcesResponseBodyTagResourcesTag() = default;
};
class DescribeDcdnTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<vector<DescribeDcdnTagResourcesResponseBodyTagResourcesTag>> tag{};

  DescribeDcdnTagResourcesResponseBodyTagResources() {}

  explicit DescribeDcdnTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDcdnTagResourcesResponseBodyTagResourcesTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnTagResourcesResponseBodyTagResourcesTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDcdnTagResourcesResponseBodyTagResourcesTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnTagResourcesResponseBodyTagResources() = default;
};
class DescribeDcdnTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnTagResourcesResponseBodyTagResources>> tagResources{};

  DescribeDcdnTagResourcesResponseBody() {}

  explicit DescribeDcdnTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<DescribeDcdnTagResourcesResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnTagResourcesResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<DescribeDcdnTagResourcesResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnTagResourcesResponseBody() = default;
};
class DescribeDcdnTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnTagResourcesResponseBody> body{};

  DescribeDcdnTagResourcesResponse() {}

  explicit DescribeDcdnTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnTagResourcesResponse() = default;
};
class DescribeDcdnTopDomainsByFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> limit{};
  shared_ptr<string> startTime{};

  DescribeDcdnTopDomainsByFlowRequest() {}

  explicit DescribeDcdnTopDomainsByFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnTopDomainsByFlowRequest() = default;
};
class DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> maxBps{};
  shared_ptr<string> maxBpsTime{};
  shared_ptr<long> rank{};
  shared_ptr<long> totalAccess{};
  shared_ptr<string> totalTraffic{};
  shared_ptr<string> trafficPercent{};

  DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain() {}

  explicit DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (maxBps) {
      res["MaxBps"] = boost::any(*maxBps);
    }
    if (maxBpsTime) {
      res["MaxBpsTime"] = boost::any(*maxBpsTime);
    }
    if (rank) {
      res["Rank"] = boost::any(*rank);
    }
    if (totalAccess) {
      res["TotalAccess"] = boost::any(*totalAccess);
    }
    if (totalTraffic) {
      res["TotalTraffic"] = boost::any(*totalTraffic);
    }
    if (trafficPercent) {
      res["TrafficPercent"] = boost::any(*trafficPercent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("MaxBps") != m.end() && !m["MaxBps"].empty()) {
      maxBps = make_shared<long>(boost::any_cast<long>(m["MaxBps"]));
    }
    if (m.find("MaxBpsTime") != m.end() && !m["MaxBpsTime"].empty()) {
      maxBpsTime = make_shared<string>(boost::any_cast<string>(m["MaxBpsTime"]));
    }
    if (m.find("Rank") != m.end() && !m["Rank"].empty()) {
      rank = make_shared<long>(boost::any_cast<long>(m["Rank"]));
    }
    if (m.find("TotalAccess") != m.end() && !m["TotalAccess"].empty()) {
      totalAccess = make_shared<long>(boost::any_cast<long>(m["TotalAccess"]));
    }
    if (m.find("TotalTraffic") != m.end() && !m["TotalTraffic"].empty()) {
      totalTraffic = make_shared<string>(boost::any_cast<string>(m["TotalTraffic"]));
    }
    if (m.find("TrafficPercent") != m.end() && !m["TrafficPercent"].empty()) {
      trafficPercent = make_shared<string>(boost::any_cast<string>(m["TrafficPercent"]));
    }
  }


  virtual ~DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain() = default;
};
class DescribeDcdnTopDomainsByFlowResponseBodyTopDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain>> topDomain{};

  DescribeDcdnTopDomainsByFlowResponseBodyTopDomains() {}

  explicit DescribeDcdnTopDomainsByFlowResponseBodyTopDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topDomain) {
      vector<boost::any> temp1;
      for(auto item1:*topDomain){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopDomain"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopDomain") != m.end() && !m["TopDomain"].empty()) {
      if (typeid(vector<boost::any>) == m["TopDomain"].type()) {
        vector<DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopDomain"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topDomain = make_shared<vector<DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnTopDomainsByFlowResponseBodyTopDomains() = default;
};
class DescribeDcdnTopDomainsByFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> domainCount{};
  shared_ptr<long> domainOnlineCount{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDcdnTopDomainsByFlowResponseBodyTopDomains> topDomains{};

  DescribeDcdnTopDomainsByFlowResponseBody() {}

  explicit DescribeDcdnTopDomainsByFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainCount) {
      res["DomainCount"] = boost::any(*domainCount);
    }
    if (domainOnlineCount) {
      res["DomainOnlineCount"] = boost::any(*domainOnlineCount);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (topDomains) {
      res["TopDomains"] = topDomains ? boost::any(topDomains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainCount") != m.end() && !m["DomainCount"].empty()) {
      domainCount = make_shared<long>(boost::any_cast<long>(m["DomainCount"]));
    }
    if (m.find("DomainOnlineCount") != m.end() && !m["DomainOnlineCount"].empty()) {
      domainOnlineCount = make_shared<long>(boost::any_cast<long>(m["DomainOnlineCount"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TopDomains") != m.end() && !m["TopDomains"].empty()) {
      if (typeid(map<string, boost::any>) == m["TopDomains"].type()) {
        DescribeDcdnTopDomainsByFlowResponseBodyTopDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TopDomains"]));
        topDomains = make_shared<DescribeDcdnTopDomainsByFlowResponseBodyTopDomains>(model1);
      }
    }
  }


  virtual ~DescribeDcdnTopDomainsByFlowResponseBody() = default;
};
class DescribeDcdnTopDomainsByFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnTopDomainsByFlowResponseBody> body{};

  DescribeDcdnTopDomainsByFlowResponse() {}

  explicit DescribeDcdnTopDomainsByFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnTopDomainsByFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnTopDomainsByFlowResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnTopDomainsByFlowResponse() = default;
};
class DescribeDcdnUserBillHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDcdnUserBillHistoryRequest() {}

  explicit DescribeDcdnUserBillHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnUserBillHistoryRequest() = default;
};
class DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem : public Darabonba::Model {
public:
  shared_ptr<double> bandwidth{};
  shared_ptr<string> cdnRegion{};
  shared_ptr<string> chargeType{};
  shared_ptr<double> count{};
  shared_ptr<double> flow{};

  DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem() {}

  explicit DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (cdnRegion) {
      res["CdnRegion"] = boost::any(*cdnRegion);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<double>(boost::any_cast<double>(m["Bandwidth"]));
    }
    if (m.find("CdnRegion") != m.end() && !m["CdnRegion"].empty()) {
      cdnRegion = make_shared<string>(boost::any_cast<string>(m["CdnRegion"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<double>(boost::any_cast<double>(m["Count"]));
    }
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<double>(boost::any_cast<double>(m["Flow"]));
    }
  }


  virtual ~DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem() = default;
};
class DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem>> billingDataItem{};

  DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData() {}

  explicit DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billingDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*billingDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BillingDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillingDataItem") != m.end() && !m["BillingDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["BillingDataItem"].type()) {
        vector<DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BillingDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        billingDataItem = make_shared<vector<DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData() = default;
};
class DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem : public Darabonba::Model {
public:
  shared_ptr<string> billTime{};
  shared_ptr<string> billType{};
  shared_ptr<DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData> billingData{};
  shared_ptr<string> dimension{};

  DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem() {}

  explicit DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billTime) {
      res["BillTime"] = boost::any(*billTime);
    }
    if (billType) {
      res["BillType"] = boost::any(*billType);
    }
    if (billingData) {
      res["BillingData"] = billingData ? boost::any(billingData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillTime") != m.end() && !m["BillTime"].empty()) {
      billTime = make_shared<string>(boost::any_cast<string>(m["BillTime"]));
    }
    if (m.find("BillType") != m.end() && !m["BillType"].empty()) {
      billType = make_shared<string>(boost::any_cast<string>(m["BillType"]));
    }
    if (m.find("BillingData") != m.end() && !m["BillingData"].empty()) {
      if (typeid(map<string, boost::any>) == m["BillingData"].type()) {
        DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BillingData"]));
        billingData = make_shared<DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData>(model1);
      }
    }
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
  }


  virtual ~DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem() = default;
};
class DescribeDcdnUserBillHistoryResponseBodyBillHistoryData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem>> billHistoryDataItem{};

  DescribeDcdnUserBillHistoryResponseBodyBillHistoryData() {}

  explicit DescribeDcdnUserBillHistoryResponseBodyBillHistoryData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billHistoryDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*billHistoryDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BillHistoryDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillHistoryDataItem") != m.end() && !m["BillHistoryDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["BillHistoryDataItem"].type()) {
        vector<DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BillHistoryDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        billHistoryDataItem = make_shared<vector<DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserBillHistoryResponseBodyBillHistoryData() = default;
};
class DescribeDcdnUserBillHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnUserBillHistoryResponseBodyBillHistoryData> billHistoryData{};
  shared_ptr<string> requestId{};

  DescribeDcdnUserBillHistoryResponseBody() {}

  explicit DescribeDcdnUserBillHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billHistoryData) {
      res["BillHistoryData"] = billHistoryData ? boost::any(billHistoryData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillHistoryData") != m.end() && !m["BillHistoryData"].empty()) {
      if (typeid(map<string, boost::any>) == m["BillHistoryData"].type()) {
        DescribeDcdnUserBillHistoryResponseBodyBillHistoryData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BillHistoryData"]));
        billHistoryData = make_shared<DescribeDcdnUserBillHistoryResponseBodyBillHistoryData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnUserBillHistoryResponseBody() = default;
};
class DescribeDcdnUserBillHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnUserBillHistoryResponseBody> body{};

  DescribeDcdnUserBillHistoryResponse() {}

  explicit DescribeDcdnUserBillHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserBillHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserBillHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserBillHistoryResponse() = default;
};
class DescribeDcdnUserBillTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  DescribeDcdnUserBillTypeRequest() {}

  explicit DescribeDcdnUserBillTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnUserBillTypeRequest() = default;
};
class DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem : public Darabonba::Model {
public:
  shared_ptr<string> billType{};
  shared_ptr<string> billingCycle{};
  shared_ptr<string> dimension{};
  shared_ptr<string> endTime{};
  shared_ptr<string> product{};
  shared_ptr<string> startTime{};

  DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem() {}

  explicit DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billType) {
      res["BillType"] = boost::any(*billType);
    }
    if (billingCycle) {
      res["BillingCycle"] = boost::any(*billingCycle);
    }
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillType") != m.end() && !m["BillType"].empty()) {
      billType = make_shared<string>(boost::any_cast<string>(m["BillType"]));
    }
    if (m.find("BillingCycle") != m.end() && !m["BillingCycle"].empty()) {
      billingCycle = make_shared<string>(boost::any_cast<string>(m["BillingCycle"]));
    }
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem() = default;
};
class DescribeDcdnUserBillTypeResponseBodyBillTypeData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem>> billTypeDataItem{};

  DescribeDcdnUserBillTypeResponseBodyBillTypeData() {}

  explicit DescribeDcdnUserBillTypeResponseBodyBillTypeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billTypeDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*billTypeDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BillTypeDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillTypeDataItem") != m.end() && !m["BillTypeDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["BillTypeDataItem"].type()) {
        vector<DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BillTypeDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        billTypeDataItem = make_shared<vector<DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserBillTypeResponseBodyBillTypeData() = default;
};
class DescribeDcdnUserBillTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnUserBillTypeResponseBodyBillTypeData> billTypeData{};
  shared_ptr<string> requestId{};

  DescribeDcdnUserBillTypeResponseBody() {}

  explicit DescribeDcdnUserBillTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billTypeData) {
      res["BillTypeData"] = billTypeData ? boost::any(billTypeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillTypeData") != m.end() && !m["BillTypeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["BillTypeData"].type()) {
        DescribeDcdnUserBillTypeResponseBodyBillTypeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BillTypeData"]));
        billTypeData = make_shared<DescribeDcdnUserBillTypeResponseBodyBillTypeData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnUserBillTypeResponseBody() = default;
};
class DescribeDcdnUserBillTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnUserBillTypeResponseBody> body{};

  DescribeDcdnUserBillTypeResponse() {}

  explicit DescribeDcdnUserBillTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserBillTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserBillTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserBillTypeResponse() = default;
};
class DescribeDcdnUserCertificateExpireCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> expireWithin30DaysCount{};
  shared_ptr<long> expiredCount{};
  shared_ptr<string> requestId{};

  DescribeDcdnUserCertificateExpireCountResponseBody() {}

  explicit DescribeDcdnUserCertificateExpireCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expireWithin30DaysCount) {
      res["ExpireWithin30DaysCount"] = boost::any(*expireWithin30DaysCount);
    }
    if (expiredCount) {
      res["ExpiredCount"] = boost::any(*expiredCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpireWithin30DaysCount") != m.end() && !m["ExpireWithin30DaysCount"].empty()) {
      expireWithin30DaysCount = make_shared<long>(boost::any_cast<long>(m["ExpireWithin30DaysCount"]));
    }
    if (m.find("ExpiredCount") != m.end() && !m["ExpiredCount"].empty()) {
      expiredCount = make_shared<long>(boost::any_cast<long>(m["ExpiredCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnUserCertificateExpireCountResponseBody() = default;
};
class DescribeDcdnUserCertificateExpireCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnUserCertificateExpireCountResponseBody> body{};

  DescribeDcdnUserCertificateExpireCountResponse() {}

  explicit DescribeDcdnUserCertificateExpireCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserCertificateExpireCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserCertificateExpireCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserCertificateExpireCountResponse() = default;
};
class DescribeDcdnUserConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionName{};

  DescribeDcdnUserConfigsRequest() {}

  explicit DescribeDcdnUserConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
  }


  virtual ~DescribeDcdnUserConfigsRequest() = default;
};
class DescribeDcdnUserConfigsResponseBodyConfigs : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};
  shared_ptr<string> functionName{};

  DescribeDcdnUserConfigsResponseBodyConfigs() {}

  explicit DescribeDcdnUserConfigsResponseBodyConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
  }


  virtual ~DescribeDcdnUserConfigsResponseBodyConfigs() = default;
};
class DescribeDcdnUserConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserConfigsResponseBodyConfigs>> configs{};
  shared_ptr<string> requestId{};

  DescribeDcdnUserConfigsResponseBody() {}

  explicit DescribeDcdnUserConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<DescribeDcdnUserConfigsResponseBodyConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserConfigsResponseBodyConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<DescribeDcdnUserConfigsResponseBodyConfigs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnUserConfigsResponseBody() = default;
};
class DescribeDcdnUserConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnUserConfigsResponseBody> body{};

  DescribeDcdnUserConfigsResponse() {}

  explicit DescribeDcdnUserConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserConfigsResponse() = default;
};
class DescribeDcdnUserDomainsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDcdnUserDomainsRequestTag() {}

  explicit DescribeDcdnUserDomainsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnUserDomainsRequestTag() = default;
};
class DescribeDcdnUserDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> changeEndTime{};
  shared_ptr<string> changeStartTime{};
  shared_ptr<bool> checkDomainShow{};
  shared_ptr<string> coverage{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainSearchType{};
  shared_ptr<string> domainStatus{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DescribeDcdnUserDomainsRequestTag>> tag{};

  DescribeDcdnUserDomainsRequest() {}

  explicit DescribeDcdnUserDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeEndTime) {
      res["ChangeEndTime"] = boost::any(*changeEndTime);
    }
    if (changeStartTime) {
      res["ChangeStartTime"] = boost::any(*changeStartTime);
    }
    if (checkDomainShow) {
      res["CheckDomainShow"] = boost::any(*checkDomainShow);
    }
    if (coverage) {
      res["Coverage"] = boost::any(*coverage);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainSearchType) {
      res["DomainSearchType"] = boost::any(*domainSearchType);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeEndTime") != m.end() && !m["ChangeEndTime"].empty()) {
      changeEndTime = make_shared<string>(boost::any_cast<string>(m["ChangeEndTime"]));
    }
    if (m.find("ChangeStartTime") != m.end() && !m["ChangeStartTime"].empty()) {
      changeStartTime = make_shared<string>(boost::any_cast<string>(m["ChangeStartTime"]));
    }
    if (m.find("CheckDomainShow") != m.end() && !m["CheckDomainShow"].empty()) {
      checkDomainShow = make_shared<bool>(boost::any_cast<bool>(m["CheckDomainShow"]));
    }
    if (m.find("Coverage") != m.end() && !m["Coverage"].empty()) {
      coverage = make_shared<string>(boost::any_cast<string>(m["Coverage"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainSearchType") != m.end() && !m["DomainSearchType"].empty()) {
      domainSearchType = make_shared<string>(boost::any_cast<string>(m["DomainSearchType"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDcdnUserDomainsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserDomainsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDcdnUserDomainsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsRequest() = default;
};
class DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> port{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};
  shared_ptr<string> weight{};

  DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource() {}

  explicit DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
  }


  virtual ~DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource() = default;
};
class DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource>> source{};

  DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources() {}

  explicit DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      vector<boost::any> temp1;
      for(auto item1:*source){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Source"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(vector<boost::any>) == m["Source"].type()) {
        vector<DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Source"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        source = make_shared<vector<DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources() = default;
};
class DescribeDcdnUserDomainsResponseBodyDomainsPageData : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> description{};
  shared_ptr<long> domainId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> sandbox{};
  shared_ptr<string> scene{};
  shared_ptr<DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources> sources{};

  DescribeDcdnUserDomainsResponseBodyDomainsPageData() {}

  explicit DescribeDcdnUserDomainsResponseBodyDomainsPageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (sandbox) {
      res["Sandbox"] = boost::any(*sandbox);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (sources) {
      res["Sources"] = sources ? boost::any(sources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<long>(boost::any_cast<long>(m["DomainId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("Sandbox") != m.end() && !m["Sandbox"].empty()) {
      sandbox = make_shared<string>(boost::any_cast<string>(m["Sandbox"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sources"].type()) {
        DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sources"]));
        sources = make_shared<DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsResponseBodyDomainsPageData() = default;
};
class DescribeDcdnUserDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserDomainsResponseBodyDomainsPageData>> pageData{};

  DescribeDcdnUserDomainsResponseBodyDomains() {}

  explicit DescribeDcdnUserDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageData) {
      vector<boost::any> temp1;
      for(auto item1:*pageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageData") != m.end() && !m["PageData"].empty()) {
      if (typeid(vector<boost::any>) == m["PageData"].type()) {
        vector<DescribeDcdnUserDomainsResponseBodyDomainsPageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserDomainsResponseBodyDomainsPageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pageData = make_shared<vector<DescribeDcdnUserDomainsResponseBodyDomainsPageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsResponseBodyDomains() = default;
};
class DescribeDcdnUserDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnUserDomainsResponseBodyDomains> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDcdnUserDomainsResponseBody() {}

  explicit DescribeDcdnUserDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribeDcdnUserDomainsResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribeDcdnUserDomainsResponseBodyDomains>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDcdnUserDomainsResponseBody() = default;
};
class DescribeDcdnUserDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnUserDomainsResponseBody> body{};

  DescribeDcdnUserDomainsResponse() {}

  explicit DescribeDcdnUserDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsResponse() = default;
};
class DescribeDcdnUserDomainsByFuncRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> funcFilter{};
  shared_ptr<long> funcId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};

  DescribeDcdnUserDomainsByFuncRequest() {}

  explicit DescribeDcdnUserDomainsByFuncRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (funcFilter) {
      res["FuncFilter"] = boost::any(*funcFilter);
    }
    if (funcId) {
      res["FuncId"] = boost::any(*funcId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FuncFilter") != m.end() && !m["FuncFilter"].empty()) {
      funcFilter = make_shared<string>(boost::any_cast<string>(m["FuncFilter"]));
    }
    if (m.find("FuncId") != m.end() && !m["FuncId"].empty()) {
      funcId = make_shared<long>(boost::any_cast<long>(m["FuncId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeDcdnUserDomainsByFuncRequest() = default;
};
class DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> port{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};
  shared_ptr<string> weight{};

  DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource() {}

  explicit DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
  }


  virtual ~DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource() = default;
};
class DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource>> source{};

  DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources() {}

  explicit DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      vector<boost::any> temp1;
      for(auto item1:*source){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Source"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(vector<boost::any>) == m["Source"].type()) {
        vector<DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Source"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        source = make_shared<vector<DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources() = default;
};
class DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sandbox{};
  shared_ptr<DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources> sources{};
  shared_ptr<string> sslProtocol{};

  DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData() {}

  explicit DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sandbox) {
      res["Sandbox"] = boost::any(*sandbox);
    }
    if (sources) {
      res["Sources"] = sources ? boost::any(sources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sslProtocol) {
      res["SslProtocol"] = boost::any(*sslProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Sandbox") != m.end() && !m["Sandbox"].empty()) {
      sandbox = make_shared<string>(boost::any_cast<string>(m["Sandbox"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sources"].type()) {
        DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sources"]));
        sources = make_shared<DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources>(model1);
      }
    }
    if (m.find("SslProtocol") != m.end() && !m["SslProtocol"].empty()) {
      sslProtocol = make_shared<string>(boost::any_cast<string>(m["SslProtocol"]));
    }
  }


  virtual ~DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData() = default;
};
class DescribeDcdnUserDomainsByFuncResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData>> pageData{};

  DescribeDcdnUserDomainsByFuncResponseBodyDomains() {}

  explicit DescribeDcdnUserDomainsByFuncResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageData) {
      vector<boost::any> temp1;
      for(auto item1:*pageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageData") != m.end() && !m["PageData"].empty()) {
      if (typeid(vector<boost::any>) == m["PageData"].type()) {
        vector<DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pageData = make_shared<vector<DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsByFuncResponseBodyDomains() = default;
};
class DescribeDcdnUserDomainsByFuncResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnUserDomainsByFuncResponseBodyDomains> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDcdnUserDomainsByFuncResponseBody() {}

  explicit DescribeDcdnUserDomainsByFuncResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribeDcdnUserDomainsByFuncResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribeDcdnUserDomainsByFuncResponseBodyDomains>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDcdnUserDomainsByFuncResponseBody() = default;
};
class DescribeDcdnUserDomainsByFuncResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnUserDomainsByFuncResponseBody> body{};

  DescribeDcdnUserDomainsByFuncResponse() {}

  explicit DescribeDcdnUserDomainsByFuncResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserDomainsByFuncResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserDomainsByFuncResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsByFuncResponse() = default;
};
class DescribeDcdnUserQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnUserQuotaRequest() {}

  explicit DescribeDcdnUserQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnUserQuotaRequest() = default;
};
class DescribeDcdnUserQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> blockQuota{};
  shared_ptr<long> blockRemain{};
  shared_ptr<long> domainQuota{};
  shared_ptr<long> ignoreParamsQuota{};
  shared_ptr<long> ignoreParamsRemain{};
  shared_ptr<long> preloadQuota{};
  shared_ptr<long> preloadRemain{};
  shared_ptr<long> refreshDirQuota{};
  shared_ptr<long> refreshDirRemain{};
  shared_ptr<long> refreshUrlQuota{};
  shared_ptr<long> refreshUrlRemain{};
  shared_ptr<string> requestId{};

  DescribeDcdnUserQuotaResponseBody() {}

  explicit DescribeDcdnUserQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockQuota) {
      res["BlockQuota"] = boost::any(*blockQuota);
    }
    if (blockRemain) {
      res["BlockRemain"] = boost::any(*blockRemain);
    }
    if (domainQuota) {
      res["DomainQuota"] = boost::any(*domainQuota);
    }
    if (ignoreParamsQuota) {
      res["IgnoreParamsQuota"] = boost::any(*ignoreParamsQuota);
    }
    if (ignoreParamsRemain) {
      res["IgnoreParamsRemain"] = boost::any(*ignoreParamsRemain);
    }
    if (preloadQuota) {
      res["PreloadQuota"] = boost::any(*preloadQuota);
    }
    if (preloadRemain) {
      res["PreloadRemain"] = boost::any(*preloadRemain);
    }
    if (refreshDirQuota) {
      res["RefreshDirQuota"] = boost::any(*refreshDirQuota);
    }
    if (refreshDirRemain) {
      res["RefreshDirRemain"] = boost::any(*refreshDirRemain);
    }
    if (refreshUrlQuota) {
      res["RefreshUrlQuota"] = boost::any(*refreshUrlQuota);
    }
    if (refreshUrlRemain) {
      res["RefreshUrlRemain"] = boost::any(*refreshUrlRemain);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockQuota") != m.end() && !m["BlockQuota"].empty()) {
      blockQuota = make_shared<long>(boost::any_cast<long>(m["BlockQuota"]));
    }
    if (m.find("BlockRemain") != m.end() && !m["BlockRemain"].empty()) {
      blockRemain = make_shared<long>(boost::any_cast<long>(m["BlockRemain"]));
    }
    if (m.find("DomainQuota") != m.end() && !m["DomainQuota"].empty()) {
      domainQuota = make_shared<long>(boost::any_cast<long>(m["DomainQuota"]));
    }
    if (m.find("IgnoreParamsQuota") != m.end() && !m["IgnoreParamsQuota"].empty()) {
      ignoreParamsQuota = make_shared<long>(boost::any_cast<long>(m["IgnoreParamsQuota"]));
    }
    if (m.find("IgnoreParamsRemain") != m.end() && !m["IgnoreParamsRemain"].empty()) {
      ignoreParamsRemain = make_shared<long>(boost::any_cast<long>(m["IgnoreParamsRemain"]));
    }
    if (m.find("PreloadQuota") != m.end() && !m["PreloadQuota"].empty()) {
      preloadQuota = make_shared<long>(boost::any_cast<long>(m["PreloadQuota"]));
    }
    if (m.find("PreloadRemain") != m.end() && !m["PreloadRemain"].empty()) {
      preloadRemain = make_shared<long>(boost::any_cast<long>(m["PreloadRemain"]));
    }
    if (m.find("RefreshDirQuota") != m.end() && !m["RefreshDirQuota"].empty()) {
      refreshDirQuota = make_shared<long>(boost::any_cast<long>(m["RefreshDirQuota"]));
    }
    if (m.find("RefreshDirRemain") != m.end() && !m["RefreshDirRemain"].empty()) {
      refreshDirRemain = make_shared<long>(boost::any_cast<long>(m["RefreshDirRemain"]));
    }
    if (m.find("RefreshUrlQuota") != m.end() && !m["RefreshUrlQuota"].empty()) {
      refreshUrlQuota = make_shared<long>(boost::any_cast<long>(m["RefreshUrlQuota"]));
    }
    if (m.find("RefreshUrlRemain") != m.end() && !m["RefreshUrlRemain"].empty()) {
      refreshUrlRemain = make_shared<long>(boost::any_cast<long>(m["RefreshUrlRemain"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnUserQuotaResponseBody() = default;
};
class DescribeDcdnUserQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnUserQuotaResponseBody> body{};

  DescribeDcdnUserQuotaResponse() {}

  explicit DescribeDcdnUserQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserQuotaResponse() = default;
};
class DescribeDcdnUserRealTimeDeliveryFieldRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};

  DescribeDcdnUserRealTimeDeliveryFieldRequest() {}

  explicit DescribeDcdnUserRealTimeDeliveryFieldRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
  }


  virtual ~DescribeDcdnUserRealTimeDeliveryFieldRequest() = default;
};
class DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> fieldName{};
  shared_ptr<bool> selected{};

  DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields() {}

  explicit DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (selected) {
      res["Selected"] = boost::any(*selected);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("Selected") != m.end() && !m["Selected"].empty()) {
      selected = make_shared<bool>(boost::any_cast<bool>(m["Selected"]));
    }
  }


  virtual ~DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields() = default;
};
class DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields>> fields{};

  DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent() {}

  explicit DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fields) {
      vector<boost::any> temp1;
      for(auto item1:*fields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Fields"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      if (typeid(vector<boost::any>) == m["Fields"].type()) {
        vector<DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Fields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fields = make_shared<vector<DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContentFields>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent() = default;
};
class DescribeDcdnUserRealTimeDeliveryFieldResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnUserRealTimeDeliveryFieldResponseBody() {}

  explicit DescribeDcdnUserRealTimeDeliveryFieldResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<DescribeDcdnUserRealTimeDeliveryFieldResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnUserRealTimeDeliveryFieldResponseBody() = default;
};
class DescribeDcdnUserRealTimeDeliveryFieldResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnUserRealTimeDeliveryFieldResponseBody> body{};

  DescribeDcdnUserRealTimeDeliveryFieldResponse() {}

  explicit DescribeDcdnUserRealTimeDeliveryFieldResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserRealTimeDeliveryFieldResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserRealTimeDeliveryFieldResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserRealTimeDeliveryFieldResponse() = default;
};
class DescribeDcdnUserResourcePackageRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> status{};

  DescribeDcdnUserResourcePackageRequest() {}

  explicit DescribeDcdnUserResourcePackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDcdnUserResourcePackageRequest() = default;
};
class DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> currCapacity{};
  shared_ptr<string> displayName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> initCapacity{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> templateName{};

  DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo() {}

  explicit DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (currCapacity) {
      res["CurrCapacity"] = boost::any(*currCapacity);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (initCapacity) {
      res["InitCapacity"] = boost::any(*initCapacity);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CurrCapacity") != m.end() && !m["CurrCapacity"].empty()) {
      currCapacity = make_shared<string>(boost::any_cast<string>(m["CurrCapacity"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InitCapacity") != m.end() && !m["InitCapacity"].empty()) {
      initCapacity = make_shared<string>(boost::any_cast<string>(m["InitCapacity"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo() = default;
};
class DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo>> resourcePackageInfo{};

  DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos() {}

  explicit DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourcePackageInfo) {
      vector<boost::any> temp1;
      for(auto item1:*resourcePackageInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourcePackageInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourcePackageInfo") != m.end() && !m["ResourcePackageInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourcePackageInfo"].type()) {
        vector<DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourcePackageInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourcePackageInfo = make_shared<vector<DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos() = default;
};
class DescribeDcdnUserResourcePackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos> resourcePackageInfos{};

  DescribeDcdnUserResourcePackageResponseBody() {}

  explicit DescribeDcdnUserResourcePackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourcePackageInfos) {
      res["ResourcePackageInfos"] = resourcePackageInfos ? boost::any(resourcePackageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourcePackageInfos") != m.end() && !m["ResourcePackageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourcePackageInfos"].type()) {
        DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourcePackageInfos"]));
        resourcePackageInfos = make_shared<DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserResourcePackageResponseBody() = default;
};
class DescribeDcdnUserResourcePackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnUserResourcePackageResponseBody> body{};

  DescribeDcdnUserResourcePackageResponse() {}

  explicit DescribeDcdnUserResourcePackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserResourcePackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserResourcePackageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserResourcePackageResponse() = default;
};
class DescribeDcdnUserSecDropRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> metric{};
  shared_ptr<string> secFunc{};

  DescribeDcdnUserSecDropRequest() {}

  explicit DescribeDcdnUserSecDropRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (secFunc) {
      res["SecFunc"] = boost::any(*secFunc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("SecFunc") != m.end() && !m["SecFunc"].empty()) {
      secFunc = make_shared<string>(boost::any_cast<string>(m["SecFunc"]));
    }
  }


  virtual ~DescribeDcdnUserSecDropRequest() = default;
};
class DescribeDcdnUserSecDropResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> drops{};
  shared_ptr<string> msg{};
  shared_ptr<string> requestId{};
  shared_ptr<string> uuidStr{};

  DescribeDcdnUserSecDropResponseBody() {}

  explicit DescribeDcdnUserSecDropResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (drops) {
      res["Drops"] = boost::any(*drops);
    }
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uuidStr) {
      res["UuidStr"] = boost::any(*uuidStr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Drops") != m.end() && !m["Drops"].empty()) {
      drops = make_shared<long>(boost::any_cast<long>(m["Drops"]));
    }
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UuidStr") != m.end() && !m["UuidStr"].empty()) {
      uuidStr = make_shared<string>(boost::any_cast<string>(m["UuidStr"]));
    }
  }


  virtual ~DescribeDcdnUserSecDropResponseBody() = default;
};
class DescribeDcdnUserSecDropResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnUserSecDropResponseBody> body{};

  DescribeDcdnUserSecDropResponse() {}

  explicit DescribeDcdnUserSecDropResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserSecDropResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserSecDropResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserSecDropResponse() = default;
};
class DescribeDcdnUserSecDropByMinuteRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> lang{};
  shared_ptr<string> object{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> secFunc{};
  shared_ptr<string> startTime{};

  DescribeDcdnUserSecDropByMinuteRequest() {}

  explicit DescribeDcdnUserSecDropByMinuteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (secFunc) {
      res["SecFunc"] = boost::any(*secFunc);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SecFunc") != m.end() && !m["SecFunc"].empty()) {
      secFunc = make_shared<string>(boost::any_cast<string>(m["SecFunc"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnUserSecDropByMinuteRequest() = default;
};
class DescribeDcdnUserSecDropByMinuteResponseBodyRows : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<long> drops{};
  shared_ptr<string> object{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> secFunc{};
  shared_ptr<string> tmStr{};

  DescribeDcdnUserSecDropByMinuteResponseBodyRows() {}

  explicit DescribeDcdnUserSecDropByMinuteResponseBodyRows(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (drops) {
      res["Drops"] = boost::any(*drops);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (secFunc) {
      res["SecFunc"] = boost::any(*secFunc);
    }
    if (tmStr) {
      res["TmStr"] = boost::any(*tmStr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Drops") != m.end() && !m["Drops"].empty()) {
      drops = make_shared<long>(boost::any_cast<long>(m["Drops"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("SecFunc") != m.end() && !m["SecFunc"].empty()) {
      secFunc = make_shared<string>(boost::any_cast<string>(m["SecFunc"]));
    }
    if (m.find("TmStr") != m.end() && !m["TmStr"].empty()) {
      tmStr = make_shared<string>(boost::any_cast<string>(m["TmStr"]));
    }
  }


  virtual ~DescribeDcdnUserSecDropByMinuteResponseBodyRows() = default;
};
class DescribeDcdnUserSecDropByMinuteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> len{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnUserSecDropByMinuteResponseBodyRows>> rows{};
  shared_ptr<long> totalCount{};

  DescribeDcdnUserSecDropByMinuteResponseBody() {}

  explicit DescribeDcdnUserSecDropByMinuteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (len) {
      res["Len"] = boost::any(*len);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rows) {
      vector<boost::any> temp1;
      for(auto item1:*rows){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rows"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Len") != m.end() && !m["Len"].empty()) {
      len = make_shared<long>(boost::any_cast<long>(m["Len"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rows") != m.end() && !m["Rows"].empty()) {
      if (typeid(vector<boost::any>) == m["Rows"].type()) {
        vector<DescribeDcdnUserSecDropByMinuteResponseBodyRows> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rows"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserSecDropByMinuteResponseBodyRows model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rows = make_shared<vector<DescribeDcdnUserSecDropByMinuteResponseBodyRows>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDcdnUserSecDropByMinuteResponseBody() = default;
};
class DescribeDcdnUserSecDropByMinuteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnUserSecDropByMinuteResponseBody> body{};

  DescribeDcdnUserSecDropByMinuteResponse() {}

  explicit DescribeDcdnUserSecDropByMinuteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserSecDropByMinuteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserSecDropByMinuteResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserSecDropByMinuteResponse() = default;
};
class DescribeDcdnUserTagsResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeDcdnUserTagsResponseBodyTags() {}

  explicit DescribeDcdnUserTagsResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDcdnUserTagsResponseBodyTags() = default;
};
class DescribeDcdnUserTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnUserTagsResponseBodyTags>> tags{};

  DescribeDcdnUserTagsResponseBody() {}

  explicit DescribeDcdnUserTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeDcdnUserTagsResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserTagsResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeDcdnUserTagsResponseBodyTags>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserTagsResponseBody() = default;
};
class DescribeDcdnUserTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnUserTagsResponseBody> body{};

  DescribeDcdnUserTagsResponse() {}

  explicit DescribeDcdnUserTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserTagsResponse() = default;
};
class DescribeDcdnVerifyContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  DescribeDcdnVerifyContentRequest() {}

  explicit DescribeDcdnVerifyContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnVerifyContentRequest() = default;
};
class DescribeDcdnVerifyContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnVerifyContentResponseBody() {}

  explicit DescribeDcdnVerifyContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnVerifyContentResponseBody() = default;
};
class DescribeDcdnVerifyContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnVerifyContentResponseBody> body{};

  DescribeDcdnVerifyContentResponse() {}

  explicit DescribeDcdnVerifyContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnVerifyContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnVerifyContentResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnVerifyContentResponse() = default;
};
class DescribeDcdnWafBotAppKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> requestId{};

  DescribeDcdnWafBotAppKeyResponseBody() {}

  explicit DescribeDcdnWafBotAppKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnWafBotAppKeyResponseBody() = default;
};
class DescribeDcdnWafBotAppKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafBotAppKeyResponseBody> body{};

  DescribeDcdnWafBotAppKeyResponse() {}

  explicit DescribeDcdnWafBotAppKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafBotAppKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafBotAppKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafBotAppKeyResponse() = default;
};
class DescribeDcdnWafDefaultRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> queryArgs{};

  DescribeDcdnWafDefaultRulesRequest() {}

  explicit DescribeDcdnWafDefaultRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (queryArgs) {
      res["QueryArgs"] = boost::any(*queryArgs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QueryArgs") != m.end() && !m["QueryArgs"].empty()) {
      queryArgs = make_shared<string>(boost::any_cast<string>(m["QueryArgs"]));
    }
  }


  virtual ~DescribeDcdnWafDefaultRulesRequest() = default;
};
class DescribeDcdnWafDefaultRulesResponseBodyContentRules : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> config{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeDcdnWafDefaultRulesResponseBodyContentRules() {}

  explicit DescribeDcdnWafDefaultRulesResponseBodyContentRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDcdnWafDefaultRulesResponseBodyContentRules() = default;
};
class DescribeDcdnWafDefaultRulesResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<vector<DescribeDcdnWafDefaultRulesResponseBodyContentRules>> rules{};

  DescribeDcdnWafDefaultRulesResponseBodyContent() {}

  explicit DescribeDcdnWafDefaultRulesResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeDcdnWafDefaultRulesResponseBodyContentRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafDefaultRulesResponseBodyContentRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeDcdnWafDefaultRulesResponseBodyContentRules>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnWafDefaultRulesResponseBodyContent() = default;
};
class DescribeDcdnWafDefaultRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnWafDefaultRulesResponseBodyContent>> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnWafDefaultRulesResponseBody() {}

  explicit DescribeDcdnWafDefaultRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<DescribeDcdnWafDefaultRulesResponseBodyContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafDefaultRulesResponseBodyContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<DescribeDcdnWafDefaultRulesResponseBodyContent>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnWafDefaultRulesResponseBody() = default;
};
class DescribeDcdnWafDefaultRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafDefaultRulesResponseBody> body{};

  DescribeDcdnWafDefaultRulesResponse() {}

  explicit DescribeDcdnWafDefaultRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafDefaultRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafDefaultRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafDefaultRulesResponse() = default;
};
class DescribeDcdnWafDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};

  DescribeDcdnWafDomainRequest() {}

  explicit DescribeDcdnWafDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeDcdnWafDomainRequest() = default;
};
class DescribeDcdnWafDomainResponseBodyOutPutDomains : public Darabonba::Model {
public:
  shared_ptr<long> aclStatus{};
  shared_ptr<long> ccStatus{};
  shared_ptr<string> domain{};
  shared_ptr<long> status{};
  shared_ptr<long> wafStatus{};

  DescribeDcdnWafDomainResponseBodyOutPutDomains() {}

  explicit DescribeDcdnWafDomainResponseBodyOutPutDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclStatus) {
      res["AclStatus"] = boost::any(*aclStatus);
    }
    if (ccStatus) {
      res["CcStatus"] = boost::any(*ccStatus);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (wafStatus) {
      res["WafStatus"] = boost::any(*wafStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclStatus") != m.end() && !m["AclStatus"].empty()) {
      aclStatus = make_shared<long>(boost::any_cast<long>(m["AclStatus"]));
    }
    if (m.find("CcStatus") != m.end() && !m["CcStatus"].empty()) {
      ccStatus = make_shared<long>(boost::any_cast<long>(m["CcStatus"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("WafStatus") != m.end() && !m["WafStatus"].empty()) {
      wafStatus = make_shared<long>(boost::any_cast<long>(m["WafStatus"]));
    }
  }


  virtual ~DescribeDcdnWafDomainResponseBodyOutPutDomains() = default;
};
class DescribeDcdnWafDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnWafDomainResponseBodyOutPutDomains>> outPutDomains{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDcdnWafDomainResponseBody() {}

  explicit DescribeDcdnWafDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outPutDomains) {
      vector<boost::any> temp1;
      for(auto item1:*outPutDomains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutPutDomains"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutPutDomains") != m.end() && !m["OutPutDomains"].empty()) {
      if (typeid(vector<boost::any>) == m["OutPutDomains"].type()) {
        vector<DescribeDcdnWafDomainResponseBodyOutPutDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutPutDomains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafDomainResponseBodyOutPutDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outPutDomains = make_shared<vector<DescribeDcdnWafDomainResponseBodyOutPutDomains>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDcdnWafDomainResponseBody() = default;
};
class DescribeDcdnWafDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafDomainResponseBody> body{};

  DescribeDcdnWafDomainResponse() {}

  explicit DescribeDcdnWafDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafDomainResponse() = default;
};
class DescribeDcdnWafDomainDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  DescribeDcdnWafDomainDetailRequest() {}

  explicit DescribeDcdnWafDomainDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnWafDomainDetailRequest() = default;
};
class DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<long> policyId{};
  shared_ptr<string> policyIds{};

  DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes() {}

  explicit DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyIds) {
      res["PolicyIds"] = boost::any(*policyIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("PolicyIds") != m.end() && !m["PolicyIds"].empty()) {
      policyIds = make_shared<string>(boost::any_cast<string>(m["PolicyIds"]));
    }
  }


  virtual ~DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes() = default;
};
class DescribeDcdnWafDomainDetailResponseBodyDomain : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes>> defenseScenes{};
  shared_ptr<string> domainName{};

  DescribeDcdnWafDomainDetailResponseBodyDomain() {}

  explicit DescribeDcdnWafDomainDetailResponseBodyDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScenes) {
      vector<boost::any> temp1;
      for(auto item1:*defenseScenes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DefenseScenes"] = boost::any(temp1);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScenes") != m.end() && !m["DefenseScenes"].empty()) {
      if (typeid(vector<boost::any>) == m["DefenseScenes"].type()) {
        vector<DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DefenseScenes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        defenseScenes = make_shared<vector<DescribeDcdnWafDomainDetailResponseBodyDomainDefenseScenes>>(expect1);
      }
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnWafDomainDetailResponseBodyDomain() = default;
};
class DescribeDcdnWafDomainDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnWafDomainDetailResponseBodyDomain> domain{};
  shared_ptr<string> requestId{};

  DescribeDcdnWafDomainDetailResponseBody() {}

  explicit DescribeDcdnWafDomainDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = domain ? boost::any(domain->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domain"].type()) {
        DescribeDcdnWafDomainDetailResponseBodyDomain model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domain"]));
        domain = make_shared<DescribeDcdnWafDomainDetailResponseBodyDomain>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnWafDomainDetailResponseBody() = default;
};
class DescribeDcdnWafDomainDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafDomainDetailResponseBody> body{};

  DescribeDcdnWafDomainDetailResponse() {}

  explicit DescribeDcdnWafDomainDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafDomainDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafDomainDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafDomainDetailResponse() = default;
};
class DescribeDcdnWafDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryArgs{};

  DescribeDcdnWafDomainsRequest() {}

  explicit DescribeDcdnWafDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryArgs) {
      res["QueryArgs"] = boost::any(*queryArgs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryArgs") != m.end() && !m["QueryArgs"].empty()) {
      queryArgs = make_shared<string>(boost::any_cast<string>(m["QueryArgs"]));
    }
  }


  virtual ~DescribeDcdnWafDomainsRequest() = default;
};
class DescribeDcdnWafDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<string> clientIpTag{};
  shared_ptr<string> domainName{};
  shared_ptr<long> policyCount{};

  DescribeDcdnWafDomainsResponseBodyDomains() {}

  explicit DescribeDcdnWafDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIpTag) {
      res["ClientIpTag"] = boost::any(*clientIpTag);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (policyCount) {
      res["PolicyCount"] = boost::any(*policyCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientIpTag") != m.end() && !m["ClientIpTag"].empty()) {
      clientIpTag = make_shared<string>(boost::any_cast<string>(m["ClientIpTag"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("PolicyCount") != m.end() && !m["PolicyCount"].empty()) {
      policyCount = make_shared<long>(boost::any_cast<long>(m["PolicyCount"]));
    }
  }


  virtual ~DescribeDcdnWafDomainsResponseBodyDomains() = default;
};
class DescribeDcdnWafDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnWafDomainsResponseBodyDomains>> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDcdnWafDomainsResponseBody() {}

  explicit DescribeDcdnWafDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      vector<boost::any> temp1;
      for(auto item1:*domains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Domains"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<DescribeDcdnWafDomainsResponseBodyDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Domains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafDomainsResponseBodyDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domains = make_shared<vector<DescribeDcdnWafDomainsResponseBodyDomains>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDcdnWafDomainsResponseBody() = default;
};
class DescribeDcdnWafDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafDomainsResponseBody> body{};

  DescribeDcdnWafDomainsResponse() {}

  explicit DescribeDcdnWafDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafDomainsResponse() = default;
};
class DescribeDcdnWafFilterInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> defenseScenes{};
  shared_ptr<string> language{};

  DescribeDcdnWafFilterInfoRequest() {}

  explicit DescribeDcdnWafFilterInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScenes) {
      res["DefenseScenes"] = boost::any(*defenseScenes);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScenes") != m.end() && !m["DefenseScenes"].empty()) {
      defenseScenes = make_shared<string>(boost::any_cast<string>(m["DefenseScenes"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
  }


  virtual ~DescribeDcdnWafFilterInfoRequest() = default;
};
class DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp : public Darabonba::Model {
public:
  shared_ptr<string> errMsg{};
  shared_ptr<string> pattern{};

  DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp() {}

  explicit DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
  }


  virtual ~DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp() = default;
};
class DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> maxLength{};
  shared_ptr<DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp> regexp{};
  shared_ptr<string> symbol{};
  shared_ptr<string> tip{};
  shared_ptr<string> type{};

  DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol() {}

  explicit DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (regexp) {
      res["Regexp"] = regexp ? boost::any(regexp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (symbol) {
      res["Symbol"] = boost::any(*symbol);
    }
    if (tip) {
      res["Tip"] = boost::any(*tip);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("Regexp") != m.end() && !m["Regexp"].empty()) {
      if (typeid(map<string, boost::any>) == m["Regexp"].type()) {
        DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Regexp"]));
        regexp = make_shared<DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbolRegexp>(model1);
      }
    }
    if (m.find("Symbol") != m.end() && !m["Symbol"].empty()) {
      symbol = make_shared<string>(boost::any_cast<string>(m["Symbol"]));
    }
    if (m.find("Tip") != m.end() && !m["Tip"].empty()) {
      tip = make_shared<string>(boost::any_cast<string>(m["Tip"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol() = default;
};
class DescribeDcdnWafFilterInfoResponseBodyContentFields : public Darabonba::Model {
public:
  shared_ptr<string> extendField{};
  shared_ptr<vector<DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol>> logicalSymbol{};
  shared_ptr<string> matchField{};

  DescribeDcdnWafFilterInfoResponseBodyContentFields() {}

  explicit DescribeDcdnWafFilterInfoResponseBodyContentFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extendField) {
      res["ExtendField"] = boost::any(*extendField);
    }
    if (logicalSymbol) {
      vector<boost::any> temp1;
      for(auto item1:*logicalSymbol){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogicalSymbol"] = boost::any(temp1);
    }
    if (matchField) {
      res["MatchField"] = boost::any(*matchField);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtendField") != m.end() && !m["ExtendField"].empty()) {
      extendField = make_shared<string>(boost::any_cast<string>(m["ExtendField"]));
    }
    if (m.find("LogicalSymbol") != m.end() && !m["LogicalSymbol"].empty()) {
      if (typeid(vector<boost::any>) == m["LogicalSymbol"].type()) {
        vector<DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogicalSymbol"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logicalSymbol = make_shared<vector<DescribeDcdnWafFilterInfoResponseBodyContentFieldsLogicalSymbol>>(expect1);
      }
    }
    if (m.find("MatchField") != m.end() && !m["MatchField"].empty()) {
      matchField = make_shared<string>(boost::any_cast<string>(m["MatchField"]));
    }
  }


  virtual ~DescribeDcdnWafFilterInfoResponseBodyContentFields() = default;
};
class DescribeDcdnWafFilterInfoResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<vector<DescribeDcdnWafFilterInfoResponseBodyContentFields>> fields{};

  DescribeDcdnWafFilterInfoResponseBodyContent() {}

  explicit DescribeDcdnWafFilterInfoResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (fields) {
      vector<boost::any> temp1;
      for(auto item1:*fields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Fields"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      if (typeid(vector<boost::any>) == m["Fields"].type()) {
        vector<DescribeDcdnWafFilterInfoResponseBodyContentFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Fields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafFilterInfoResponseBodyContentFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fields = make_shared<vector<DescribeDcdnWafFilterInfoResponseBodyContentFields>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnWafFilterInfoResponseBodyContent() = default;
};
class DescribeDcdnWafFilterInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnWafFilterInfoResponseBodyContent>> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnWafFilterInfoResponseBody() {}

  explicit DescribeDcdnWafFilterInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<DescribeDcdnWafFilterInfoResponseBodyContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafFilterInfoResponseBodyContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<DescribeDcdnWafFilterInfoResponseBodyContent>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnWafFilterInfoResponseBody() = default;
};
class DescribeDcdnWafFilterInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafFilterInfoResponseBody> body{};

  DescribeDcdnWafFilterInfoResponse() {}

  explicit DescribeDcdnWafFilterInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafFilterInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafFilterInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafFilterInfoResponse() = default;
};
class DescribeDcdnWafGeoInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> language{};

  DescribeDcdnWafGeoInfoRequest() {}

  explicit DescribeDcdnWafGeoInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["Language"] = boost::any(*language);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
  }


  virtual ~DescribeDcdnWafGeoInfoRequest() = default;
};
class DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions() {}

  explicit DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions() = default;
};
class DescribeDcdnWafGeoInfoResponseBodyContentContinents : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions>> regions{};

  DescribeDcdnWafGeoInfoResponseBodyContentContinents() {}

  explicit DescribeDcdnWafGeoInfoResponseBodyContentContinents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<DescribeDcdnWafGeoInfoResponseBodyContentContinentsRegions>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnWafGeoInfoResponseBodyContentContinents() = default;
};
class DescribeDcdnWafGeoInfoResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnWafGeoInfoResponseBodyContentContinents>> continents{};
  shared_ptr<string> type{};

  DescribeDcdnWafGeoInfoResponseBodyContent() {}

  explicit DescribeDcdnWafGeoInfoResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (continents) {
      vector<boost::any> temp1;
      for(auto item1:*continents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Continents"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Continents") != m.end() && !m["Continents"].empty()) {
      if (typeid(vector<boost::any>) == m["Continents"].type()) {
        vector<DescribeDcdnWafGeoInfoResponseBodyContentContinents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Continents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafGeoInfoResponseBodyContentContinents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        continents = make_shared<vector<DescribeDcdnWafGeoInfoResponseBodyContentContinents>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDcdnWafGeoInfoResponseBodyContent() = default;
};
class DescribeDcdnWafGeoInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnWafGeoInfoResponseBodyContent>> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnWafGeoInfoResponseBody() {}

  explicit DescribeDcdnWafGeoInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<DescribeDcdnWafGeoInfoResponseBodyContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafGeoInfoResponseBodyContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<DescribeDcdnWafGeoInfoResponseBodyContent>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnWafGeoInfoResponseBody() = default;
};
class DescribeDcdnWafGeoInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafGeoInfoResponseBody> body{};

  DescribeDcdnWafGeoInfoResponse() {}

  explicit DescribeDcdnWafGeoInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafGeoInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafGeoInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafGeoInfoResponse() = default;
};
class DescribeDcdnWafGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> language{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryArgs{};
  shared_ptr<string> scope{};

  DescribeDcdnWafGroupRequest() {}

  explicit DescribeDcdnWafGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryArgs) {
      res["QueryArgs"] = boost::any(*queryArgs);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryArgs") != m.end() && !m["QueryArgs"].empty()) {
      queryArgs = make_shared<string>(boost::any_cast<string>(m["QueryArgs"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
  }


  virtual ~DescribeDcdnWafGroupRequest() = default;
};
class DescribeDcdnWafGroupResponseBodyRules : public Darabonba::Model {
public:
  shared_ptr<long> applicationType{};
  shared_ptr<string> cveId{};
  shared_ptr<string> cveUrl{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> protectionType{};
  shared_ptr<long> riskLevel{};

  DescribeDcdnWafGroupResponseBodyRules() {}

  explicit DescribeDcdnWafGroupResponseBodyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationType) {
      res["ApplicationType"] = boost::any(*applicationType);
    }
    if (cveId) {
      res["CveId"] = boost::any(*cveId);
    }
    if (cveUrl) {
      res["CveUrl"] = boost::any(*cveUrl);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (protectionType) {
      res["ProtectionType"] = boost::any(*protectionType);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationType") != m.end() && !m["ApplicationType"].empty()) {
      applicationType = make_shared<long>(boost::any_cast<long>(m["ApplicationType"]));
    }
    if (m.find("CveId") != m.end() && !m["CveId"].empty()) {
      cveId = make_shared<string>(boost::any_cast<string>(m["CveId"]));
    }
    if (m.find("CveUrl") != m.end() && !m["CveUrl"].empty()) {
      cveUrl = make_shared<string>(boost::any_cast<string>(m["CveUrl"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProtectionType") != m.end() && !m["ProtectionType"].empty()) {
      protectionType = make_shared<long>(boost::any_cast<long>(m["ProtectionType"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<long>(boost::any_cast<long>(m["RiskLevel"]));
    }
  }


  virtual ~DescribeDcdnWafGroupResponseBodyRules() = default;
};
class DescribeDcdnWafGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnWafGroupResponseBodyRules>> rules{};
  shared_ptr<string> subscribe{};
  shared_ptr<long> templateId{};
  shared_ptr<long> totalCount{};

  DescribeDcdnWafGroupResponseBody() {}

  explicit DescribeDcdnWafGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (subscribe) {
      res["Subscribe"] = boost::any(*subscribe);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeDcdnWafGroupResponseBodyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafGroupResponseBodyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeDcdnWafGroupResponseBodyRules>>(expect1);
      }
    }
    if (m.find("Subscribe") != m.end() && !m["Subscribe"].empty()) {
      subscribe = make_shared<string>(boost::any_cast<string>(m["Subscribe"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDcdnWafGroupResponseBody() = default;
};
class DescribeDcdnWafGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafGroupResponseBody> body{};

  DescribeDcdnWafGroupResponse() {}

  explicit DescribeDcdnWafGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafGroupResponse() = default;
};
class DescribeDcdnWafGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> language{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryArgs{};

  DescribeDcdnWafGroupsRequest() {}

  explicit DescribeDcdnWafGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryArgs) {
      res["QueryArgs"] = boost::any(*queryArgs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryArgs") != m.end() && !m["QueryArgs"].empty()) {
      queryArgs = make_shared<string>(boost::any_cast<string>(m["QueryArgs"]));
    }
  }


  virtual ~DescribeDcdnWafGroupsRequest() = default;
};
class DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies() {}

  explicit DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies() = default;
};
class DescribeDcdnWafGroupsResponseBodyWafGroups : public Darabonba::Model {
public:
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies>> policies{};
  shared_ptr<long> ruleCount{};
  shared_ptr<string> subscribe{};
  shared_ptr<long> templateId{};

  DescribeDcdnWafGroupsResponseBodyWafGroups() {}

  explicit DescribeDcdnWafGroupsResponseBodyWafGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (policies) {
      vector<boost::any> temp1;
      for(auto item1:*policies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Policies"] = boost::any(temp1);
    }
    if (ruleCount) {
      res["RuleCount"] = boost::any(*ruleCount);
    }
    if (subscribe) {
      res["Subscribe"] = boost::any(*subscribe);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(vector<boost::any>) == m["Policies"].type()) {
        vector<DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Policies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policies = make_shared<vector<DescribeDcdnWafGroupsResponseBodyWafGroupsPolicies>>(expect1);
      }
    }
    if (m.find("RuleCount") != m.end() && !m["RuleCount"].empty()) {
      ruleCount = make_shared<long>(boost::any_cast<long>(m["RuleCount"]));
    }
    if (m.find("Subscribe") != m.end() && !m["Subscribe"].empty()) {
      subscribe = make_shared<string>(boost::any_cast<string>(m["Subscribe"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~DescribeDcdnWafGroupsResponseBodyWafGroups() = default;
};
class DescribeDcdnWafGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeDcdnWafGroupsResponseBodyWafGroups>> wafGroups{};

  DescribeDcdnWafGroupsResponseBody() {}

  explicit DescribeDcdnWafGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (wafGroups) {
      vector<boost::any> temp1;
      for(auto item1:*wafGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WafGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("WafGroups") != m.end() && !m["WafGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["WafGroups"].type()) {
        vector<DescribeDcdnWafGroupsResponseBodyWafGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WafGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafGroupsResponseBodyWafGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wafGroups = make_shared<vector<DescribeDcdnWafGroupsResponseBodyWafGroups>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnWafGroupsResponseBody() = default;
};
class DescribeDcdnWafGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafGroupsResponseBody> body{};

  DescribeDcdnWafGroupsResponse() {}

  explicit DescribeDcdnWafGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafGroupsResponse() = default;
};
class DescribeDcdnWafLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};

  DescribeDcdnWafLogsRequest() {}

  explicit DescribeDcdnWafLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnWafLogsRequest() = default;
};
class DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> logName{};
  shared_ptr<string> logPath{};
  shared_ptr<long> logSize{};
  shared_ptr<string> startTime{};

  DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos() {}

  explicit DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (logName) {
      res["LogName"] = boost::any(*logName);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    if (logSize) {
      res["LogSize"] = boost::any(*logSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("LogName") != m.end() && !m["LogName"].empty()) {
      logName = make_shared<string>(boost::any_cast<string>(m["LogName"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
    if (m.find("LogSize") != m.end() && !m["LogSize"].empty()) {
      logSize = make_shared<long>(boost::any_cast<long>(m["LogSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos() = default;
};
class DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos() {}

  explicit DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos() = default;
};
class DescribeDcdnWafLogsResponseBodyDomainLogDetails : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> logCount{};
  shared_ptr<vector<DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos>> logInfos{};
  shared_ptr<DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos> pageInfos{};

  DescribeDcdnWafLogsResponseBodyDomainLogDetails() {}

  explicit DescribeDcdnWafLogsResponseBodyDomainLogDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (logCount) {
      res["LogCount"] = boost::any(*logCount);
    }
    if (logInfos) {
      vector<boost::any> temp1;
      for(auto item1:*logInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfos"] = boost::any(temp1);
    }
    if (pageInfos) {
      res["PageInfos"] = pageInfos ? boost::any(pageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LogCount") != m.end() && !m["LogCount"].empty()) {
      logCount = make_shared<long>(boost::any_cast<long>(m["LogCount"]));
    }
    if (m.find("LogInfos") != m.end() && !m["LogInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfos"].type()) {
        vector<DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfos = make_shared<vector<DescribeDcdnWafLogsResponseBodyDomainLogDetailsLogInfos>>(expect1);
      }
    }
    if (m.find("PageInfos") != m.end() && !m["PageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfos"].type()) {
        DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfos"]));
        pageInfos = make_shared<DescribeDcdnWafLogsResponseBodyDomainLogDetailsPageInfos>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafLogsResponseBodyDomainLogDetails() = default;
};
class DescribeDcdnWafLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnWafLogsResponseBodyDomainLogDetails>> domainLogDetails{};
  shared_ptr<string> requestId{};

  DescribeDcdnWafLogsResponseBody() {}

  explicit DescribeDcdnWafLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetails) {
      vector<boost::any> temp1;
      for(auto item1:*domainLogDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainLogDetails"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetails") != m.end() && !m["DomainLogDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainLogDetails"].type()) {
        vector<DescribeDcdnWafLogsResponseBodyDomainLogDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainLogDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafLogsResponseBodyDomainLogDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainLogDetails = make_shared<vector<DescribeDcdnWafLogsResponseBodyDomainLogDetails>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnWafLogsResponseBody() = default;
};
class DescribeDcdnWafLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafLogsResponseBody> body{};

  DescribeDcdnWafLogsResponse() {}

  explicit DescribeDcdnWafLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafLogsResponse() = default;
};
class DescribeDcdnWafPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryArgs{};

  DescribeDcdnWafPoliciesRequest() {}

  explicit DescribeDcdnWafPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryArgs) {
      res["QueryArgs"] = boost::any(*queryArgs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryArgs") != m.end() && !m["QueryArgs"].empty()) {
      queryArgs = make_shared<string>(boost::any_cast<string>(m["QueryArgs"]));
    }
  }


  virtual ~DescribeDcdnWafPoliciesRequest() = default;
};
class DescribeDcdnWafPoliciesResponseBodyPolicies : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<long> domainCount{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> policyId{};
  shared_ptr<string> policyName{};
  shared_ptr<string> policyStatus{};
  shared_ptr<string> policyType{};
  shared_ptr<long> ruleCount{};

  DescribeDcdnWafPoliciesResponseBodyPolicies() {}

  explicit DescribeDcdnWafPoliciesResponseBodyPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (domainCount) {
      res["DomainCount"] = boost::any(*domainCount);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (policyStatus) {
      res["PolicyStatus"] = boost::any(*policyStatus);
    }
    if (policyType) {
      res["PolicyType"] = boost::any(*policyType);
    }
    if (ruleCount) {
      res["RuleCount"] = boost::any(*ruleCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("DomainCount") != m.end() && !m["DomainCount"].empty()) {
      domainCount = make_shared<long>(boost::any_cast<long>(m["DomainCount"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("PolicyStatus") != m.end() && !m["PolicyStatus"].empty()) {
      policyStatus = make_shared<string>(boost::any_cast<string>(m["PolicyStatus"]));
    }
    if (m.find("PolicyType") != m.end() && !m["PolicyType"].empty()) {
      policyType = make_shared<string>(boost::any_cast<string>(m["PolicyType"]));
    }
    if (m.find("RuleCount") != m.end() && !m["RuleCount"].empty()) {
      ruleCount = make_shared<long>(boost::any_cast<long>(m["RuleCount"]));
    }
  }


  virtual ~DescribeDcdnWafPoliciesResponseBodyPolicies() = default;
};
class DescribeDcdnWafPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeDcdnWafPoliciesResponseBodyPolicies>> policies{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDcdnWafPoliciesResponseBody() {}

  explicit DescribeDcdnWafPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (policies) {
      vector<boost::any> temp1;
      for(auto item1:*policies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Policies"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(vector<boost::any>) == m["Policies"].type()) {
        vector<DescribeDcdnWafPoliciesResponseBodyPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Policies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafPoliciesResponseBodyPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policies = make_shared<vector<DescribeDcdnWafPoliciesResponseBodyPolicies>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDcdnWafPoliciesResponseBody() = default;
};
class DescribeDcdnWafPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafPoliciesResponseBody> body{};

  DescribeDcdnWafPoliciesResponse() {}

  explicit DescribeDcdnWafPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafPoliciesResponse() = default;
};
class DescribeDcdnWafPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};

  DescribeDcdnWafPolicyRequest() {}

  explicit DescribeDcdnWafPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
  }


  virtual ~DescribeDcdnWafPolicyRequest() = default;
};
class DescribeDcdnWafPolicyResponseBodyPolicy : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<long> domainCount{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> policyId{};
  shared_ptr<string> policyName{};
  shared_ptr<string> policyStatus{};
  shared_ptr<string> policyType{};
  shared_ptr<string> ruleConfigs{};
  shared_ptr<long> ruleCount{};

  DescribeDcdnWafPolicyResponseBodyPolicy() {}

  explicit DescribeDcdnWafPolicyResponseBodyPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (domainCount) {
      res["DomainCount"] = boost::any(*domainCount);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (policyStatus) {
      res["PolicyStatus"] = boost::any(*policyStatus);
    }
    if (policyType) {
      res["PolicyType"] = boost::any(*policyType);
    }
    if (ruleConfigs) {
      res["RuleConfigs"] = boost::any(*ruleConfigs);
    }
    if (ruleCount) {
      res["RuleCount"] = boost::any(*ruleCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("DomainCount") != m.end() && !m["DomainCount"].empty()) {
      domainCount = make_shared<long>(boost::any_cast<long>(m["DomainCount"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("PolicyStatus") != m.end() && !m["PolicyStatus"].empty()) {
      policyStatus = make_shared<string>(boost::any_cast<string>(m["PolicyStatus"]));
    }
    if (m.find("PolicyType") != m.end() && !m["PolicyType"].empty()) {
      policyType = make_shared<string>(boost::any_cast<string>(m["PolicyType"]));
    }
    if (m.find("RuleConfigs") != m.end() && !m["RuleConfigs"].empty()) {
      ruleConfigs = make_shared<string>(boost::any_cast<string>(m["RuleConfigs"]));
    }
    if (m.find("RuleCount") != m.end() && !m["RuleCount"].empty()) {
      ruleCount = make_shared<long>(boost::any_cast<long>(m["RuleCount"]));
    }
  }


  virtual ~DescribeDcdnWafPolicyResponseBodyPolicy() = default;
};
class DescribeDcdnWafPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDcdnWafPolicyResponseBodyPolicy> policy{};
  shared_ptr<string> requestId{};

  DescribeDcdnWafPolicyResponseBody() {}

  explicit DescribeDcdnWafPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policy) {
      res["Policy"] = policy ? boost::any(policy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Policy"].type()) {
        DescribeDcdnWafPolicyResponseBodyPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Policy"]));
        policy = make_shared<DescribeDcdnWafPolicyResponseBodyPolicy>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnWafPolicyResponseBody() = default;
};
class DescribeDcdnWafPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafPolicyResponseBody> body{};

  DescribeDcdnWafPolicyResponse() {}

  explicit DescribeDcdnWafPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafPolicyResponse() = default;
};
class DescribeDcdnWafPolicyDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> policyId{};

  DescribeDcdnWafPolicyDomainsRequest() {}

  explicit DescribeDcdnWafPolicyDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
  }


  virtual ~DescribeDcdnWafPolicyDomainsRequest() = default;
};
class DescribeDcdnWafPolicyDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  DescribeDcdnWafPolicyDomainsResponseBodyDomains() {}

  explicit DescribeDcdnWafPolicyDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnWafPolicyDomainsResponseBodyDomains() = default;
};
class DescribeDcdnWafPolicyDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnWafPolicyDomainsResponseBodyDomains>> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDcdnWafPolicyDomainsResponseBody() {}

  explicit DescribeDcdnWafPolicyDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      vector<boost::any> temp1;
      for(auto item1:*domains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Domains"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<DescribeDcdnWafPolicyDomainsResponseBodyDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Domains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafPolicyDomainsResponseBodyDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domains = make_shared<vector<DescribeDcdnWafPolicyDomainsResponseBodyDomains>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDcdnWafPolicyDomainsResponseBody() = default;
};
class DescribeDcdnWafPolicyDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafPolicyDomainsResponseBody> body{};

  DescribeDcdnWafPolicyDomainsResponse() {}

  explicit DescribeDcdnWafPolicyDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafPolicyDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafPolicyDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafPolicyDomainsResponse() = default;
};
class DescribeDcdnWafPolicyValidDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<string> domainNameLike{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeDcdnWafPolicyValidDomainsRequest() {}

  explicit DescribeDcdnWafPolicyValidDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (domainNameLike) {
      res["DomainNameLike"] = boost::any(*domainNameLike);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("DomainNameLike") != m.end() && !m["DomainNameLike"].empty()) {
      domainNameLike = make_shared<string>(boost::any_cast<string>(m["DomainNameLike"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeDcdnWafPolicyValidDomainsRequest() = default;
};
class DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies() {}

  explicit DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies() = default;
};
class DescribeDcdnWafPolicyValidDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<vector<DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies>> policies{};
  shared_ptr<long> policyId{};
  shared_ptr<string> policyName{};
  shared_ptr<string> policyType{};

  DescribeDcdnWafPolicyValidDomainsResponseBodyDomains() {}

  explicit DescribeDcdnWafPolicyValidDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (policies) {
      vector<boost::any> temp1;
      for(auto item1:*policies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Policies"] = boost::any(temp1);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (policyType) {
      res["PolicyType"] = boost::any(*policyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(vector<boost::any>) == m["Policies"].type()) {
        vector<DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Policies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policies = make_shared<vector<DescribeDcdnWafPolicyValidDomainsResponseBodyDomainsPolicies>>(expect1);
      }
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("PolicyType") != m.end() && !m["PolicyType"].empty()) {
      policyType = make_shared<string>(boost::any_cast<string>(m["PolicyType"]));
    }
  }


  virtual ~DescribeDcdnWafPolicyValidDomainsResponseBodyDomains() = default;
};
class DescribeDcdnWafPolicyValidDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnWafPolicyValidDomainsResponseBodyDomains>> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDcdnWafPolicyValidDomainsResponseBody() {}

  explicit DescribeDcdnWafPolicyValidDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      vector<boost::any> temp1;
      for(auto item1:*domains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Domains"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<DescribeDcdnWafPolicyValidDomainsResponseBodyDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Domains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafPolicyValidDomainsResponseBodyDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domains = make_shared<vector<DescribeDcdnWafPolicyValidDomainsResponseBodyDomains>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDcdnWafPolicyValidDomainsResponseBody() = default;
};
class DescribeDcdnWafPolicyValidDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafPolicyValidDomainsResponseBody> body{};

  DescribeDcdnWafPolicyValidDomainsResponse() {}

  explicit DescribeDcdnWafPolicyValidDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafPolicyValidDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafPolicyValidDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafPolicyValidDomainsResponse() = default;
};
class DescribeDcdnWafRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> ruleId{};

  DescribeDcdnWafRuleRequest() {}

  explicit DescribeDcdnWafRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DescribeDcdnWafRuleRequest() = default;
};
class DescribeDcdnWafRuleResponseBodyRule : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> policyId{};
  shared_ptr<string> ruleConfig{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleStatus{};

  DescribeDcdnWafRuleResponseBodyRule() {}

  explicit DescribeDcdnWafRuleResponseBodyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (ruleConfig) {
      res["RuleConfig"] = boost::any(*ruleConfig);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["RuleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("RuleConfig") != m.end() && !m["RuleConfig"].empty()) {
      ruleConfig = make_shared<string>(boost::any_cast<string>(m["RuleConfig"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleStatus") != m.end() && !m["RuleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["RuleStatus"]));
    }
  }


  virtual ~DescribeDcdnWafRuleResponseBodyRule() = default;
};
class DescribeDcdnWafRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnWafRuleResponseBodyRule> rule{};

  DescribeDcdnWafRuleResponseBody() {}

  explicit DescribeDcdnWafRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rule) {
      res["Rule"] = rule ? boost::any(rule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rule"].type()) {
        DescribeDcdnWafRuleResponseBodyRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rule"]));
        rule = make_shared<DescribeDcdnWafRuleResponseBodyRule>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafRuleResponseBody() = default;
};
class DescribeDcdnWafRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafRuleResponseBody> body{};

  DescribeDcdnWafRuleResponse() {}

  explicit DescribeDcdnWafRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafRuleResponse() = default;
};
class DescribeDcdnWafRulesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryArgs{};

  DescribeDcdnWafRulesRequest() {}

  explicit DescribeDcdnWafRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryArgs) {
      res["QueryArgs"] = boost::any(*queryArgs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryArgs") != m.end() && !m["QueryArgs"].empty()) {
      queryArgs = make_shared<string>(boost::any_cast<string>(m["QueryArgs"]));
    }
  }


  virtual ~DescribeDcdnWafRulesRequest() = default;
};
class DescribeDcdnWafRulesResponseBodyRules : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> policyId{};
  shared_ptr<string> ruleConfig{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleStatus{};

  DescribeDcdnWafRulesResponseBodyRules() {}

  explicit DescribeDcdnWafRulesResponseBodyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (ruleConfig) {
      res["RuleConfig"] = boost::any(*ruleConfig);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["RuleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("RuleConfig") != m.end() && !m["RuleConfig"].empty()) {
      ruleConfig = make_shared<string>(boost::any_cast<string>(m["RuleConfig"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleStatus") != m.end() && !m["RuleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["RuleStatus"]));
    }
  }


  virtual ~DescribeDcdnWafRulesResponseBodyRules() = default;
};
class DescribeDcdnWafRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnWafRulesResponseBodyRules>> rules{};
  shared_ptr<long> totalCount{};

  DescribeDcdnWafRulesResponseBody() {}

  explicit DescribeDcdnWafRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeDcdnWafRulesResponseBodyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafRulesResponseBodyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeDcdnWafRulesResponseBodyRules>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDcdnWafRulesResponseBody() = default;
};
class DescribeDcdnWafRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafRulesResponseBody> body{};

  DescribeDcdnWafRulesResponse() {}

  explicit DescribeDcdnWafRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafRulesResponse() = default;
};
class DescribeDcdnWafScenesRequest : public Darabonba::Model {
public:
  shared_ptr<string> defenseScenes{};

  DescribeDcdnWafScenesRequest() {}

  explicit DescribeDcdnWafScenesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScenes) {
      res["DefenseScenes"] = boost::any(*defenseScenes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScenes") != m.end() && !m["DefenseScenes"].empty()) {
      defenseScenes = make_shared<string>(boost::any_cast<string>(m["DefenseScenes"]));
    }
  }


  virtual ~DescribeDcdnWafScenesRequest() = default;
};
class DescribeDcdnWafScenesResponseBodyDefenseScenes : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<long> policyCount{};
  shared_ptr<long> ruleCount{};

  DescribeDcdnWafScenesResponseBodyDefenseScenes() {}

  explicit DescribeDcdnWafScenesResponseBodyDefenseScenes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (policyCount) {
      res["PolicyCount"] = boost::any(*policyCount);
    }
    if (ruleCount) {
      res["RuleCount"] = boost::any(*ruleCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("PolicyCount") != m.end() && !m["PolicyCount"].empty()) {
      policyCount = make_shared<long>(boost::any_cast<long>(m["PolicyCount"]));
    }
    if (m.find("RuleCount") != m.end() && !m["RuleCount"].empty()) {
      ruleCount = make_shared<long>(boost::any_cast<long>(m["RuleCount"]));
    }
  }


  virtual ~DescribeDcdnWafScenesResponseBodyDefenseScenes() = default;
};
class DescribeDcdnWafScenesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnWafScenesResponseBodyDefenseScenes>> defenseScenes{};
  shared_ptr<string> requestId{};

  DescribeDcdnWafScenesResponseBody() {}

  explicit DescribeDcdnWafScenesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScenes) {
      vector<boost::any> temp1;
      for(auto item1:*defenseScenes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DefenseScenes"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScenes") != m.end() && !m["DefenseScenes"].empty()) {
      if (typeid(vector<boost::any>) == m["DefenseScenes"].type()) {
        vector<DescribeDcdnWafScenesResponseBodyDefenseScenes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DefenseScenes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafScenesResponseBodyDefenseScenes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        defenseScenes = make_shared<vector<DescribeDcdnWafScenesResponseBodyDefenseScenes>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnWafScenesResponseBody() = default;
};
class DescribeDcdnWafScenesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafScenesResponseBody> body{};

  DescribeDcdnWafScenesResponse() {}

  explicit DescribeDcdnWafScenesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafScenesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafScenesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafScenesResponse() = default;
};
class DescribeDcdnWafServiceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnWafServiceRequest() {}

  explicit DescribeDcdnWafServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnWafServiceRequest() = default;
};
class DescribeDcdnWafServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> edition{};
  shared_ptr<string> enabled{};
  shared_ptr<string> openingTime{};
  shared_ptr<string> requestBillingType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> ruleBillingType{};
  shared_ptr<string> status{};

  DescribeDcdnWafServiceResponseBody() {}

  explicit DescribeDcdnWafServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edition) {
      res["Edition"] = boost::any(*edition);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (openingTime) {
      res["OpeningTime"] = boost::any(*openingTime);
    }
    if (requestBillingType) {
      res["RequestBillingType"] = boost::any(*requestBillingType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleBillingType) {
      res["RuleBillingType"] = boost::any(*ruleBillingType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Edition") != m.end() && !m["Edition"].empty()) {
      edition = make_shared<string>(boost::any_cast<string>(m["Edition"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<string>(boost::any_cast<string>(m["Enabled"]));
    }
    if (m.find("OpeningTime") != m.end() && !m["OpeningTime"].empty()) {
      openingTime = make_shared<string>(boost::any_cast<string>(m["OpeningTime"]));
    }
    if (m.find("RequestBillingType") != m.end() && !m["RequestBillingType"].empty()) {
      requestBillingType = make_shared<string>(boost::any_cast<string>(m["RequestBillingType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleBillingType") != m.end() && !m["RuleBillingType"].empty()) {
      ruleBillingType = make_shared<string>(boost::any_cast<string>(m["RuleBillingType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDcdnWafServiceResponseBody() = default;
};
class DescribeDcdnWafServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafServiceResponseBody> body{};

  DescribeDcdnWafServiceResponse() {}

  explicit DescribeDcdnWafServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafServiceResponse() = default;
};
class DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> expr{};
  shared_ptr<string> value{};

  DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs() {}

  explicit DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (expr) {
      res["Expr"] = boost::any(*expr);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("Expr") != m.end() && !m["Expr"].empty()) {
      expr = make_shared<string>(boost::any_cast<string>(m["Expr"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs() = default;
};
class DescribeDcdnWafSpecInfoResponseBodySpecInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs>> configs{};
  shared_ptr<string> defenseScene{};

  DescribeDcdnWafSpecInfoResponseBodySpecInfos() {}

  explicit DescribeDcdnWafSpecInfoResponseBodySpecInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<DescribeDcdnWafSpecInfoResponseBodySpecInfosConfigs>>(expect1);
      }
    }
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
  }


  virtual ~DescribeDcdnWafSpecInfoResponseBodySpecInfos() = default;
};
class DescribeDcdnWafSpecInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> edition{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnWafSpecInfoResponseBodySpecInfos>> specInfos{};

  DescribeDcdnWafSpecInfoResponseBody() {}

  explicit DescribeDcdnWafSpecInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edition) {
      res["Edition"] = boost::any(*edition);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (specInfos) {
      vector<boost::any> temp1;
      for(auto item1:*specInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Edition") != m.end() && !m["Edition"].empty()) {
      edition = make_shared<string>(boost::any_cast<string>(m["Edition"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpecInfos") != m.end() && !m["SpecInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecInfos"].type()) {
        vector<DescribeDcdnWafSpecInfoResponseBodySpecInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafSpecInfoResponseBodySpecInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specInfos = make_shared<vector<DescribeDcdnWafSpecInfoResponseBodySpecInfos>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnWafSpecInfoResponseBody() = default;
};
class DescribeDcdnWafSpecInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafSpecInfoResponseBody> body{};

  DescribeDcdnWafSpecInfoResponse() {}

  explicit DescribeDcdnWafSpecInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafSpecInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafSpecInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafSpecInfoResponse() = default;
};
class DescribeDcdnWafUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> splitBy{};
  shared_ptr<string> startTime{};

  DescribeDcdnWafUsageDataRequest() {}

  explicit DescribeDcdnWafUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (splitBy) {
      res["SplitBy"] = boost::any(*splitBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("SplitBy") != m.end() && !m["SplitBy"].empty()) {
      splitBy = make_shared<string>(boost::any_cast<string>(m["SplitBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDcdnWafUsageDataRequest() = default;
};
class DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem : public Darabonba::Model {
public:
  shared_ptr<long> accessCnt{};
  shared_ptr<long> blockCnt{};
  shared_ptr<string> domain{};
  shared_ptr<long> observeCnt{};
  shared_ptr<long> secCu{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem() {}

  explicit DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessCnt) {
      res["AccessCnt"] = boost::any(*accessCnt);
    }
    if (blockCnt) {
      res["BlockCnt"] = boost::any(*blockCnt);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (observeCnt) {
      res["ObserveCnt"] = boost::any(*observeCnt);
    }
    if (secCu) {
      res["SecCu"] = boost::any(*secCu);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessCnt") != m.end() && !m["AccessCnt"].empty()) {
      accessCnt = make_shared<long>(boost::any_cast<long>(m["AccessCnt"]));
    }
    if (m.find("BlockCnt") != m.end() && !m["BlockCnt"].empty()) {
      blockCnt = make_shared<long>(boost::any_cast<long>(m["BlockCnt"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ObserveCnt") != m.end() && !m["ObserveCnt"].empty()) {
      observeCnt = make_shared<long>(boost::any_cast<long>(m["ObserveCnt"]));
    }
    if (m.find("SecCu") != m.end() && !m["SecCu"].empty()) {
      secCu = make_shared<long>(boost::any_cast<long>(m["SecCu"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem() = default;
};
class DescribeDcdnWafUsageDataResponseBodyWafUsageData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem>> wafUsageDataItem{};

  DescribeDcdnWafUsageDataResponseBodyWafUsageData() {}

  explicit DescribeDcdnWafUsageDataResponseBodyWafUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (wafUsageDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*wafUsageDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WafUsageDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WafUsageDataItem") != m.end() && !m["WafUsageDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["WafUsageDataItem"].type()) {
        vector<DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WafUsageDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wafUsageDataItem = make_shared<vector<DescribeDcdnWafUsageDataResponseBodyWafUsageDataWafUsageDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnWafUsageDataResponseBodyWafUsageData() = default;
};
class DescribeDcdnWafUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<DescribeDcdnWafUsageDataResponseBodyWafUsageData> wafUsageData{};

  DescribeDcdnWafUsageDataResponseBody() {}

  explicit DescribeDcdnWafUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (wafUsageData) {
      res["WafUsageData"] = wafUsageData ? boost::any(wafUsageData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("WafUsageData") != m.end() && !m["WafUsageData"].empty()) {
      if (typeid(map<string, boost::any>) == m["WafUsageData"].type()) {
        DescribeDcdnWafUsageDataResponseBodyWafUsageData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WafUsageData"]));
        wafUsageData = make_shared<DescribeDcdnWafUsageDataResponseBodyWafUsageData>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafUsageDataResponseBody() = default;
};
class DescribeDcdnWafUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnWafUsageDataResponseBody> body{};

  DescribeDcdnWafUsageDataResponse() {}

  explicit DescribeDcdnWafUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafUsageDataResponse() = default;
};
class DescribeDcdnsecServiceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnsecServiceRequest() {}

  explicit DescribeDcdnsecServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnsecServiceRequest() = default;
};
class DescribeDcdnsecServiceResponseBodyOperationLocksLockReason : public Darabonba::Model {
public:
  shared_ptr<string> lockReason{};

  DescribeDcdnsecServiceResponseBodyOperationLocksLockReason() {}

  explicit DescribeDcdnsecServiceResponseBodyOperationLocksLockReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
  }


  virtual ~DescribeDcdnsecServiceResponseBodyOperationLocksLockReason() = default;
};
class DescribeDcdnsecServiceResponseBodyOperationLocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnsecServiceResponseBodyOperationLocksLockReason>> lockReason{};

  DescribeDcdnsecServiceResponseBodyOperationLocks() {}

  explicit DescribeDcdnsecServiceResponseBodyOperationLocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      vector<boost::any> temp1;
      for(auto item1:*lockReason){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LockReason"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      if (typeid(vector<boost::any>) == m["LockReason"].type()) {
        vector<DescribeDcdnsecServiceResponseBodyOperationLocksLockReason> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LockReason"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnsecServiceResponseBodyOperationLocksLockReason model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lockReason = make_shared<vector<DescribeDcdnsecServiceResponseBodyOperationLocksLockReason>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnsecServiceResponseBodyOperationLocks() = default;
};
class DescribeDcdnsecServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changingAffectTime{};
  shared_ptr<string> changingChargeType{};
  shared_ptr<string> domainNum{};
  shared_ptr<string> endTime{};
  shared_ptr<string> flowType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<DescribeDcdnsecServiceResponseBodyOperationLocks> operationLocks{};
  shared_ptr<string> requestId{};
  shared_ptr<string> requestType{};
  shared_ptr<string> startTime{};
  shared_ptr<string> version{};

  DescribeDcdnsecServiceResponseBody() {}

  explicit DescribeDcdnsecServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changingAffectTime) {
      res["ChangingAffectTime"] = boost::any(*changingAffectTime);
    }
    if (changingChargeType) {
      res["ChangingChargeType"] = boost::any(*changingChargeType);
    }
    if (domainNum) {
      res["DomainNum"] = boost::any(*domainNum);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (flowType) {
      res["FlowType"] = boost::any(*flowType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (operationLocks) {
      res["OperationLocks"] = operationLocks ? boost::any(operationLocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestType) {
      res["RequestType"] = boost::any(*requestType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangingAffectTime") != m.end() && !m["ChangingAffectTime"].empty()) {
      changingAffectTime = make_shared<string>(boost::any_cast<string>(m["ChangingAffectTime"]));
    }
    if (m.find("ChangingChargeType") != m.end() && !m["ChangingChargeType"].empty()) {
      changingChargeType = make_shared<string>(boost::any_cast<string>(m["ChangingChargeType"]));
    }
    if (m.find("DomainNum") != m.end() && !m["DomainNum"].empty()) {
      domainNum = make_shared<string>(boost::any_cast<string>(m["DomainNum"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FlowType") != m.end() && !m["FlowType"].empty()) {
      flowType = make_shared<string>(boost::any_cast<string>(m["FlowType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("OperationLocks") != m.end() && !m["OperationLocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationLocks"].type()) {
        DescribeDcdnsecServiceResponseBodyOperationLocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationLocks"]));
        operationLocks = make_shared<DescribeDcdnsecServiceResponseBodyOperationLocks>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestType") != m.end() && !m["RequestType"].empty()) {
      requestType = make_shared<string>(boost::any_cast<string>(m["RequestType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeDcdnsecServiceResponseBody() = default;
};
class DescribeDcdnsecServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDcdnsecServiceResponseBody> body{};

  DescribeDcdnsecServiceResponse() {}

  explicit DescribeDcdnsecServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnsecServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnsecServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnsecServiceResponse() = default;
};
class DescribeDdosAllEventListRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> eventType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};

  DescribeDdosAllEventListRequest() {}

  explicit DescribeDdosAllEventListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeDdosAllEventListRequest() = default;
};
class DescribeDdosAllEventListResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> bps{};
  shared_ptr<long> cps{};
  shared_ptr<string> endTime{};
  shared_ptr<string> eventId{};
  shared_ptr<string> eventType{};
  shared_ptr<long> pps{};
  shared_ptr<long> qps{};
  shared_ptr<string> startTime{};
  shared_ptr<string> target{};

  DescribeDdosAllEventListResponseBodyDataList() {}

  explicit DescribeDdosAllEventListResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (cps) {
      res["Cps"] = boost::any(*cps);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (pps) {
      res["Pps"] = boost::any(*pps);
    }
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<long>(boost::any_cast<long>(m["Bps"]));
    }
    if (m.find("Cps") != m.end() && !m["Cps"].empty()) {
      cps = make_shared<long>(boost::any_cast<long>(m["Cps"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Pps") != m.end() && !m["Pps"].empty()) {
      pps = make_shared<long>(boost::any_cast<long>(m["Pps"]));
    }
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<long>(boost::any_cast<long>(m["Qps"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~DescribeDdosAllEventListResponseBodyDataList() = default;
};
class DescribeDdosAllEventListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDdosAllEventListResponseBodyDataList>> dataList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeDdosAllEventListResponseBody() {}

  explicit DescribeDdosAllEventListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataList) {
      vector<boost::any> temp1;
      for(auto item1:*dataList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataList") != m.end() && !m["DataList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataList"].type()) {
        vector<DescribeDdosAllEventListResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDdosAllEventListResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataList = make_shared<vector<DescribeDdosAllEventListResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeDdosAllEventListResponseBody() = default;
};
class DescribeDdosAllEventListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDdosAllEventListResponseBody> body{};

  DescribeDdosAllEventListResponse() {}

  explicit DescribeDdosAllEventListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDdosAllEventListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDdosAllEventListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDdosAllEventListResponse() = default;
};
class DescribeEncryptRoutineUidResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeEncryptRoutineUidResponseBody() {}

  explicit DescribeEncryptRoutineUidResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeEncryptRoutineUidResponseBody() = default;
};
class DescribeEncryptRoutineUidResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEncryptRoutineUidResponseBody> body{};

  DescribeEncryptRoutineUidResponse() {}

  explicit DescribeEncryptRoutineUidResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEncryptRoutineUidResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEncryptRoutineUidResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEncryptRoutineUidResponse() = default;
};
class DescribeHighlightInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> lang{};
  shared_ptr<string> startTime{};
  shared_ptr<string> traceId{};

  DescribeHighlightInfoRequest() {}

  explicit DescribeHighlightInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeHighlightInfoRequest() = default;
};
class DescribeHighlightInfoResponseBodyDataModule : public Darabonba::Model {
public:
  shared_ptr<string> hit{};
  shared_ptr<string> key{};
  shared_ptr<string> raw{};

  DescribeHighlightInfoResponseBodyDataModule() {}

  explicit DescribeHighlightInfoResponseBodyDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hit) {
      res["Hit"] = boost::any(*hit);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (raw) {
      res["Raw"] = boost::any(*raw);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hit") != m.end() && !m["Hit"].empty()) {
      hit = make_shared<string>(boost::any_cast<string>(m["Hit"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Raw") != m.end() && !m["Raw"].empty()) {
      raw = make_shared<string>(boost::any_cast<string>(m["Raw"]));
    }
  }


  virtual ~DescribeHighlightInfoResponseBodyDataModule() = default;
};
class DescribeHighlightInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHighlightInfoResponseBodyDataModule>> dataModule{};
  shared_ptr<string> requestId{};

  DescribeHighlightInfoResponseBody() {}

  explicit DescribeHighlightInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeHighlightInfoResponseBodyDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHighlightInfoResponseBodyDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeHighlightInfoResponseBodyDataModule>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeHighlightInfoResponseBody() = default;
};
class DescribeHighlightInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHighlightInfoResponseBody> body{};

  DescribeHighlightInfoResponse() {}

  explicit DescribeHighlightInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHighlightInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHighlightInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHighlightInfoResponse() = default;
};
class DescribeRDDomainConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functionName{};

  DescribeRDDomainConfigRequest() {}

  explicit DescribeRDDomainConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
  }


  virtual ~DescribeRDDomainConfigRequest() = default;
};
class DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};

  DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs() {}

  explicit DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
  }


  virtual ~DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs() = default;
};
class DescribeRDDomainConfigResponseBodyDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<long> configId{};
  shared_ptr<vector<DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs>> functionArgs{};
  shared_ptr<string> functionName{};
  shared_ptr<string> parentId{};
  shared_ptr<string> status{};

  DescribeRDDomainConfigResponseBodyDomainConfigs() {}

  explicit DescribeRDDomainConfigResponseBodyDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionArgs) {
      vector<boost::any> temp1;
      for(auto item1:*functionArgs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FunctionArgs"] = boost::any(temp1);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      if (typeid(vector<boost::any>) == m["FunctionArgs"].type()) {
        vector<DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FunctionArgs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functionArgs = make_shared<vector<DescribeRDDomainConfigResponseBodyDomainConfigsFunctionArgs>>(expect1);
      }
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeRDDomainConfigResponseBodyDomainConfigs() = default;
};
class DescribeRDDomainConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRDDomainConfigResponseBodyDomainConfigs>> domainConfigs{};
  shared_ptr<string> requestId{};

  DescribeRDDomainConfigResponseBody() {}

  explicit DescribeRDDomainConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfigs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfigs") != m.end() && !m["DomainConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfigs"].type()) {
        vector<DescribeRDDomainConfigResponseBodyDomainConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRDDomainConfigResponseBodyDomainConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfigs = make_shared<vector<DescribeRDDomainConfigResponseBodyDomainConfigs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRDDomainConfigResponseBody() = default;
};
class DescribeRDDomainConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRDDomainConfigResponseBody> body{};

  DescribeRDDomainConfigResponse() {}

  explicit DescribeRDDomainConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRDDomainConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRDDomainConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRDDomainConfigResponse() = default;
};
class DescribeRDDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeRDDomainsRequest() {}

  explicit DescribeRDDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeRDDomainsRequest() = default;
};
class DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> port{};
  shared_ptr<string> priority{};
  shared_ptr<string> type{};
  shared_ptr<string> weight{};

  DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource() {}

  explicit DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
  }


  virtual ~DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource() = default;
};
class DescribeRDDomainsResponseBodyDomainsPageDataSources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource>> source{};

  DescribeRDDomainsResponseBodyDomainsPageDataSources() {}

  explicit DescribeRDDomainsResponseBodyDomainsPageDataSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      vector<boost::any> temp1;
      for(auto item1:*source){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Source"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(vector<boost::any>) == m["Source"].type()) {
        vector<DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Source"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        source = make_shared<vector<DescribeRDDomainsResponseBodyDomainsPageDataSourcesSource>>(expect1);
      }
    }
  }


  virtual ~DescribeRDDomainsResponseBodyDomainsPageDataSources() = default;
};
class DescribeRDDomainsResponseBodyDomainsPageData : public Darabonba::Model {
public:
  shared_ptr<string> bizName{};
  shared_ptr<string> cname{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sandbox{};
  shared_ptr<string> serviceCode{};
  shared_ptr<DescribeRDDomainsResponseBodyDomainsPageDataSources> sources{};
  shared_ptr<string> sslProtocol{};

  DescribeRDDomainsResponseBodyDomainsPageData() {}

  explicit DescribeRDDomainsResponseBodyDomainsPageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sandbox) {
      res["Sandbox"] = boost::any(*sandbox);
    }
    if (serviceCode) {
      res["ServiceCode"] = boost::any(*serviceCode);
    }
    if (sources) {
      res["Sources"] = sources ? boost::any(sources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sslProtocol) {
      res["SslProtocol"] = boost::any(*sslProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Sandbox") != m.end() && !m["Sandbox"].empty()) {
      sandbox = make_shared<string>(boost::any_cast<string>(m["Sandbox"]));
    }
    if (m.find("ServiceCode") != m.end() && !m["ServiceCode"].empty()) {
      serviceCode = make_shared<string>(boost::any_cast<string>(m["ServiceCode"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sources"].type()) {
        DescribeRDDomainsResponseBodyDomainsPageDataSources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sources"]));
        sources = make_shared<DescribeRDDomainsResponseBodyDomainsPageDataSources>(model1);
      }
    }
    if (m.find("SslProtocol") != m.end() && !m["SslProtocol"].empty()) {
      sslProtocol = make_shared<string>(boost::any_cast<string>(m["SslProtocol"]));
    }
  }


  virtual ~DescribeRDDomainsResponseBodyDomainsPageData() = default;
};
class DescribeRDDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRDDomainsResponseBodyDomainsPageData>> pageData{};

  DescribeRDDomainsResponseBodyDomains() {}

  explicit DescribeRDDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageData) {
      vector<boost::any> temp1;
      for(auto item1:*pageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageData") != m.end() && !m["PageData"].empty()) {
      if (typeid(vector<boost::any>) == m["PageData"].type()) {
        vector<DescribeRDDomainsResponseBodyDomainsPageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRDDomainsResponseBodyDomainsPageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pageData = make_shared<vector<DescribeRDDomainsResponseBodyDomainsPageData>>(expect1);
      }
    }
  }


  virtual ~DescribeRDDomainsResponseBodyDomains() = default;
};
class DescribeRDDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeRDDomainsResponseBodyDomains> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeRDDomainsResponseBody() {}

  explicit DescribeRDDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribeRDDomainsResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribeRDDomainsResponseBodyDomains>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeRDDomainsResponseBody() = default;
};
class DescribeRDDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRDDomainsResponseBody> body{};

  DescribeRDDomainsResponse() {}

  explicit DescribeRDDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRDDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRDDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRDDomainsResponse() = default;
};
class DescribeRoutineRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  DescribeRoutineRequest() {}

  explicit DescribeRoutineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeRoutineRequest() = default;
};
class DescribeRoutineResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DescribeRoutineResponseBody() {}

  explicit DescribeRoutineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRoutineResponseBody() = default;
};
class DescribeRoutineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRoutineResponseBody> body{};

  DescribeRoutineResponse() {}

  explicit DescribeRoutineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRoutineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRoutineResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRoutineResponse() = default;
};
class DescribeRoutineCanaryEnvsResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DescribeRoutineCanaryEnvsResponseBody() {}

  explicit DescribeRoutineCanaryEnvsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRoutineCanaryEnvsResponseBody() = default;
};
class DescribeRoutineCanaryEnvsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRoutineCanaryEnvsResponseBody> body{};

  DescribeRoutineCanaryEnvsResponse() {}

  explicit DescribeRoutineCanaryEnvsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRoutineCanaryEnvsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRoutineCanaryEnvsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRoutineCanaryEnvsResponse() = default;
};
class DescribeRoutineCodeRevisionRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> selectCodeRevision{};

  DescribeRoutineCodeRevisionRequest() {}

  explicit DescribeRoutineCodeRevisionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (selectCodeRevision) {
      res["SelectCodeRevision"] = boost::any(*selectCodeRevision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SelectCodeRevision") != m.end() && !m["SelectCodeRevision"].empty()) {
      selectCodeRevision = make_shared<string>(boost::any_cast<string>(m["SelectCodeRevision"]));
    }
  }


  virtual ~DescribeRoutineCodeRevisionRequest() = default;
};
class DescribeRoutineCodeRevisionResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DescribeRoutineCodeRevisionResponseBody() {}

  explicit DescribeRoutineCodeRevisionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRoutineCodeRevisionResponseBody() = default;
};
class DescribeRoutineCodeRevisionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRoutineCodeRevisionResponseBody> body{};

  DescribeRoutineCodeRevisionResponse() {}

  explicit DescribeRoutineCodeRevisionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRoutineCodeRevisionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRoutineCodeRevisionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRoutineCodeRevisionResponse() = default;
};
class DescribeRoutineSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DescribeRoutineSpecResponseBody() {}

  explicit DescribeRoutineSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRoutineSpecResponseBody() = default;
};
class DescribeRoutineSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRoutineSpecResponseBody> body{};

  DescribeRoutineSpecResponse() {}

  explicit DescribeRoutineSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRoutineSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRoutineSpecResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRoutineSpecResponse() = default;
};
class DescribeRoutineUserInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DescribeRoutineUserInfoResponseBody() {}

  explicit DescribeRoutineUserInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRoutineUserInfoResponseBody() = default;
};
class DescribeRoutineUserInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRoutineUserInfoResponseBody> body{};

  DescribeRoutineUserInfoResponse() {}

  explicit DescribeRoutineUserInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRoutineUserInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRoutineUserInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRoutineUserInfoResponse() = default;
};
class DescribeUserDcdnIpaStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeUserDcdnIpaStatusRequest() {}

  explicit DescribeUserDcdnIpaStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeUserDcdnIpaStatusRequest() = default;
};
class DescribeUserDcdnIpaStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<bool> inDebt{};
  shared_ptr<bool> inDebtOverdue{};
  shared_ptr<bool> onService{};
  shared_ptr<string> requestId{};

  DescribeUserDcdnIpaStatusResponseBody() {}

  explicit DescribeUserDcdnIpaStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (inDebt) {
      res["InDebt"] = boost::any(*inDebt);
    }
    if (inDebtOverdue) {
      res["InDebtOverdue"] = boost::any(*inDebtOverdue);
    }
    if (onService) {
      res["OnService"] = boost::any(*onService);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("InDebt") != m.end() && !m["InDebt"].empty()) {
      inDebt = make_shared<bool>(boost::any_cast<bool>(m["InDebt"]));
    }
    if (m.find("InDebtOverdue") != m.end() && !m["InDebtOverdue"].empty()) {
      inDebtOverdue = make_shared<bool>(boost::any_cast<bool>(m["InDebtOverdue"]));
    }
    if (m.find("OnService") != m.end() && !m["OnService"].empty()) {
      onService = make_shared<bool>(boost::any_cast<bool>(m["OnService"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserDcdnIpaStatusResponseBody() = default;
};
class DescribeUserDcdnIpaStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserDcdnIpaStatusResponseBody> body{};

  DescribeUserDcdnIpaStatusResponse() {}

  explicit DescribeUserDcdnIpaStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserDcdnIpaStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserDcdnIpaStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserDcdnIpaStatusResponse() = default;
};
class DescribeUserDcdnStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  DescribeUserDcdnStatusRequest() {}

  explicit DescribeUserDcdnStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeUserDcdnStatusRequest() = default;
};
class DescribeUserDcdnStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<bool> inDebt{};
  shared_ptr<bool> inDebtOverdue{};
  shared_ptr<bool> onService{};
  shared_ptr<string> requestId{};

  DescribeUserDcdnStatusResponseBody() {}

  explicit DescribeUserDcdnStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (inDebt) {
      res["InDebt"] = boost::any(*inDebt);
    }
    if (inDebtOverdue) {
      res["InDebtOverdue"] = boost::any(*inDebtOverdue);
    }
    if (onService) {
      res["OnService"] = boost::any(*onService);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("InDebt") != m.end() && !m["InDebt"].empty()) {
      inDebt = make_shared<bool>(boost::any_cast<bool>(m["InDebt"]));
    }
    if (m.find("InDebtOverdue") != m.end() && !m["InDebtOverdue"].empty()) {
      inDebtOverdue = make_shared<bool>(boost::any_cast<bool>(m["InDebtOverdue"]));
    }
    if (m.find("OnService") != m.end() && !m["OnService"].empty()) {
      onService = make_shared<bool>(boost::any_cast<bool>(m["OnService"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserDcdnStatusResponseBody() = default;
};
class DescribeUserDcdnStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserDcdnStatusResponseBody> body{};

  DescribeUserDcdnStatusResponse() {}

  explicit DescribeUserDcdnStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserDcdnStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserDcdnStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserDcdnStatusResponse() = default;
};
class DescribeUserErStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  DescribeUserErStatusRequest() {}

  explicit DescribeUserErStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeUserErStatusRequest() = default;
};
class DescribeUserErStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<bool> inDebt{};
  shared_ptr<bool> inDebtOverdue{};
  shared_ptr<bool> onService{};
  shared_ptr<string> requestId{};

  DescribeUserErStatusResponseBody() {}

  explicit DescribeUserErStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (inDebt) {
      res["InDebt"] = boost::any(*inDebt);
    }
    if (inDebtOverdue) {
      res["InDebtOverdue"] = boost::any(*inDebtOverdue);
    }
    if (onService) {
      res["OnService"] = boost::any(*onService);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("InDebt") != m.end() && !m["InDebt"].empty()) {
      inDebt = make_shared<bool>(boost::any_cast<bool>(m["InDebt"]));
    }
    if (m.find("InDebtOverdue") != m.end() && !m["InDebtOverdue"].empty()) {
      inDebtOverdue = make_shared<bool>(boost::any_cast<bool>(m["InDebtOverdue"]));
    }
    if (m.find("OnService") != m.end() && !m["OnService"].empty()) {
      onService = make_shared<bool>(boost::any_cast<bool>(m["OnService"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserErStatusResponseBody() = default;
};
class DescribeUserErStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserErStatusResponseBody> body{};

  DescribeUserErStatusResponse() {}

  explicit DescribeUserErStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserErStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserErStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserErStatusResponse() = default;
};
class DescribeUserLogserviceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeUserLogserviceStatusRequest() {}

  explicit DescribeUserLogserviceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeUserLogserviceStatusRequest() = default;
};
class DescribeUserLogserviceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};
  shared_ptr<bool> inDebt{};
  shared_ptr<bool> inDebtOverdue{};
  shared_ptr<bool> onService{};
  shared_ptr<string> requestId{};

  DescribeUserLogserviceStatusResponseBody() {}

  explicit DescribeUserLogserviceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (inDebt) {
      res["InDebt"] = boost::any(*inDebt);
    }
    if (inDebtOverdue) {
      res["InDebtOverdue"] = boost::any(*inDebtOverdue);
    }
    if (onService) {
      res["OnService"] = boost::any(*onService);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
    if (m.find("InDebt") != m.end() && !m["InDebt"].empty()) {
      inDebt = make_shared<bool>(boost::any_cast<bool>(m["InDebt"]));
    }
    if (m.find("InDebtOverdue") != m.end() && !m["InDebtOverdue"].empty()) {
      inDebtOverdue = make_shared<bool>(boost::any_cast<bool>(m["InDebtOverdue"]));
    }
    if (m.find("OnService") != m.end() && !m["OnService"].empty()) {
      onService = make_shared<bool>(boost::any_cast<bool>(m["OnService"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserLogserviceStatusResponseBody() = default;
};
class DescribeUserLogserviceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserLogserviceStatusResponseBody> body{};

  DescribeUserLogserviceStatusResponse() {}

  explicit DescribeUserLogserviceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserLogserviceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserLogserviceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserLogserviceStatusResponse() = default;
};
class EditRoutineConfRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> envConf{};
  shared_ptr<string> name{};

  EditRoutineConfRequest() {}

  explicit EditRoutineConfRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envConf) {
      res["EnvConf"] = boost::any(*envConf);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["EnvConf"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      envConf = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~EditRoutineConfRequest() = default;
};
class EditRoutineConfShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> envConfShrink{};
  shared_ptr<string> name{};

  EditRoutineConfShrinkRequest() {}

  explicit EditRoutineConfShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envConfShrink) {
      res["EnvConf"] = boost::any(*envConfShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      envConfShrink = make_shared<string>(boost::any_cast<string>(m["EnvConf"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~EditRoutineConfShrinkRequest() = default;
};
class EditRoutineConfResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  EditRoutineConfResponseBody() {}

  explicit EditRoutineConfResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EditRoutineConfResponseBody() = default;
};
class EditRoutineConfResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EditRoutineConfResponseBody> body{};

  EditRoutineConfResponse() {}

  explicit EditRoutineConfResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EditRoutineConfResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EditRoutineConfResponseBody>(model1);
      }
    }
  }


  virtual ~EditRoutineConfResponse() = default;
};
class GetDcdnKvRequest : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> namespace_{};

  GetDcdnKvRequest() {}

  explicit GetDcdnKvRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~GetDcdnKvRequest() = default;
};
class GetDcdnKvResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> value{};

  GetDcdnKvResponseBody() {}

  explicit GetDcdnKvResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetDcdnKvResponseBody() = default;
};
class GetDcdnKvResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDcdnKvResponseBody> body{};

  GetDcdnKvResponse() {}

  explicit GetDcdnKvResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDcdnKvResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDcdnKvResponseBody>(model1);
      }
    }
  }


  virtual ~GetDcdnKvResponse() = default;
};
class ListDcdnKvRequest : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> prefix{};

  ListDcdnKvRequest() {}

  explicit ListDcdnKvRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (prefix) {
      res["Prefix"] = boost::any(*prefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      prefix = make_shared<string>(boost::any_cast<string>(m["Prefix"]));
    }
  }


  virtual ~ListDcdnKvRequest() = default;
};
class ListDcdnKvResponseBodyKeys : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> updateTime{};

  ListDcdnKvResponseBodyKeys() {}

  explicit ListDcdnKvResponseBodyKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListDcdnKvResponseBodyKeys() = default;
};
class ListDcdnKvResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDcdnKvResponseBodyKeys>> keys{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDcdnKvResponseBody() {}

  explicit ListDcdnKvResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keys) {
      vector<boost::any> temp1;
      for(auto item1:*keys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Keys"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keys") != m.end() && !m["Keys"].empty()) {
      if (typeid(vector<boost::any>) == m["Keys"].type()) {
        vector<ListDcdnKvResponseBodyKeys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Keys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDcdnKvResponseBodyKeys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keys = make_shared<vector<ListDcdnKvResponseBodyKeys>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDcdnKvResponseBody() = default;
};
class ListDcdnKvResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDcdnKvResponseBody> body{};

  ListDcdnKvResponse() {}

  explicit ListDcdnKvResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDcdnKvResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDcdnKvResponseBody>(model1);
      }
    }
  }


  virtual ~ListDcdnKvResponse() = default;
};
class ListDcdnRealTimeDeliveryProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> domainName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListDcdnRealTimeDeliveryProjectRequest() {}

  explicit ListDcdnRealTimeDeliveryProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListDcdnRealTimeDeliveryProjectRequest() = default;
};
class ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> dataCenter{};
  shared_ptr<string> domainName{};
  shared_ptr<string> fieldName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> SLSLogStore{};
  shared_ptr<string> SLSProject{};
  shared_ptr<string> SLSRegion{};
  shared_ptr<double> samplingRate{};
  shared_ptr<string> type{};

  ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects() {}

  explicit ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (SLSLogStore) {
      res["SLSLogStore"] = boost::any(*SLSLogStore);
    }
    if (SLSProject) {
      res["SLSProject"] = boost::any(*SLSProject);
    }
    if (SLSRegion) {
      res["SLSRegion"] = boost::any(*SLSRegion);
    }
    if (samplingRate) {
      res["SamplingRate"] = boost::any(*samplingRate);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SLSLogStore") != m.end() && !m["SLSLogStore"].empty()) {
      SLSLogStore = make_shared<string>(boost::any_cast<string>(m["SLSLogStore"]));
    }
    if (m.find("SLSProject") != m.end() && !m["SLSProject"].empty()) {
      SLSProject = make_shared<string>(boost::any_cast<string>(m["SLSProject"]));
    }
    if (m.find("SLSRegion") != m.end() && !m["SLSRegion"].empty()) {
      SLSRegion = make_shared<string>(boost::any_cast<string>(m["SLSRegion"]));
    }
    if (m.find("SamplingRate") != m.end() && !m["SamplingRate"].empty()) {
      samplingRate = make_shared<double>(boost::any_cast<double>(m["SamplingRate"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects() = default;
};
class ListDcdnRealTimeDeliveryProjectResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects>> projects{};

  ListDcdnRealTimeDeliveryProjectResponseBodyContent() {}

  explicit ListDcdnRealTimeDeliveryProjectResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projects) {
      vector<boost::any> temp1;
      for(auto item1:*projects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Projects"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Projects") != m.end() && !m["Projects"].empty()) {
      if (typeid(vector<boost::any>) == m["Projects"].type()) {
        vector<ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Projects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projects = make_shared<vector<ListDcdnRealTimeDeliveryProjectResponseBodyContentProjects>>(expect1);
      }
    }
  }


  virtual ~ListDcdnRealTimeDeliveryProjectResponseBodyContent() = default;
};
class ListDcdnRealTimeDeliveryProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDcdnRealTimeDeliveryProjectResponseBodyContent> content{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDcdnRealTimeDeliveryProjectResponseBody() {}

  explicit ListDcdnRealTimeDeliveryProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        ListDcdnRealTimeDeliveryProjectResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<ListDcdnRealTimeDeliveryProjectResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDcdnRealTimeDeliveryProjectResponseBody() = default;
};
class ListDcdnRealTimeDeliveryProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDcdnRealTimeDeliveryProjectResponseBody> body{};

  ListDcdnRealTimeDeliveryProjectResponse() {}

  explicit ListDcdnRealTimeDeliveryProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDcdnRealTimeDeliveryProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDcdnRealTimeDeliveryProjectResponseBody>(model1);
      }
    }
  }


  virtual ~ListDcdnRealTimeDeliveryProjectResponse() = default;
};
class ModifyDCdnDomainSchdmByPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> property{};

  ModifyDCdnDomainSchdmByPropertyRequest() {}

  explicit ModifyDCdnDomainSchdmByPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
  }


  virtual ~ModifyDCdnDomainSchdmByPropertyRequest() = default;
};
class ModifyDCdnDomainSchdmByPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDCdnDomainSchdmByPropertyResponseBody() {}

  explicit ModifyDCdnDomainSchdmByPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDCdnDomainSchdmByPropertyResponseBody() = default;
};
class ModifyDCdnDomainSchdmByPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDCdnDomainSchdmByPropertyResponseBody> body{};

  ModifyDCdnDomainSchdmByPropertyResponse() {}

  explicit ModifyDCdnDomainSchdmByPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDCdnDomainSchdmByPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDCdnDomainSchdmByPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDCdnDomainSchdmByPropertyResponse() = default;
};
class ModifyDcdnWafGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> rules{};

  ModifyDcdnWafGroupRequest() {}

  explicit ModifyDcdnWafGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
  }


  virtual ~ModifyDcdnWafGroupRequest() = default;
};
class ModifyDcdnWafGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDcdnWafGroupResponseBody() {}

  explicit ModifyDcdnWafGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDcdnWafGroupResponseBody() = default;
};
class ModifyDcdnWafGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDcdnWafGroupResponseBody> body{};

  ModifyDcdnWafGroupResponse() {}

  explicit ModifyDcdnWafGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDcdnWafGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDcdnWafGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDcdnWafGroupResponse() = default;
};
class ModifyDcdnWafPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<long> policyId{};
  shared_ptr<string> policyName{};
  shared_ptr<string> policyStatus{};

  ModifyDcdnWafPolicyRequest() {}

  explicit ModifyDcdnWafPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (policyName) {
      res["PolicyName"] = boost::any(*policyName);
    }
    if (policyStatus) {
      res["PolicyStatus"] = boost::any(*policyStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("PolicyName") != m.end() && !m["PolicyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["PolicyName"]));
    }
    if (m.find("PolicyStatus") != m.end() && !m["PolicyStatus"].empty()) {
      policyStatus = make_shared<string>(boost::any_cast<string>(m["PolicyStatus"]));
    }
  }


  virtual ~ModifyDcdnWafPolicyRequest() = default;
};
class ModifyDcdnWafPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDcdnWafPolicyResponseBody() {}

  explicit ModifyDcdnWafPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDcdnWafPolicyResponseBody() = default;
};
class ModifyDcdnWafPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDcdnWafPolicyResponseBody> body{};

  ModifyDcdnWafPolicyResponse() {}

  explicit ModifyDcdnWafPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDcdnWafPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDcdnWafPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDcdnWafPolicyResponse() = default;
};
class ModifyDcdnWafPolicyDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bindDomains{};
  shared_ptr<long> method{};
  shared_ptr<long> policyId{};
  shared_ptr<string> unbindDomains{};

  ModifyDcdnWafPolicyDomainsRequest() {}

  explicit ModifyDcdnWafPolicyDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindDomains) {
      res["BindDomains"] = boost::any(*bindDomains);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (unbindDomains) {
      res["UnbindDomains"] = boost::any(*unbindDomains);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindDomains") != m.end() && !m["BindDomains"].empty()) {
      bindDomains = make_shared<string>(boost::any_cast<string>(m["BindDomains"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<long>(boost::any_cast<long>(m["Method"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<long>(boost::any_cast<long>(m["PolicyId"]));
    }
    if (m.find("UnbindDomains") != m.end() && !m["UnbindDomains"].empty()) {
      unbindDomains = make_shared<string>(boost::any_cast<string>(m["UnbindDomains"]));
    }
  }


  virtual ~ModifyDcdnWafPolicyDomainsRequest() = default;
};
class ModifyDcdnWafPolicyDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDcdnWafPolicyDomainsResponseBody() {}

  explicit ModifyDcdnWafPolicyDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDcdnWafPolicyDomainsResponseBody() = default;
};
class ModifyDcdnWafPolicyDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDcdnWafPolicyDomainsResponseBody> body{};

  ModifyDcdnWafPolicyDomainsResponse() {}

  explicit ModifyDcdnWafPolicyDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDcdnWafPolicyDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDcdnWafPolicyDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDcdnWafPolicyDomainsResponse() = default;
};
class ModifyDcdnWafRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> ruleConfig{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleStatus{};

  ModifyDcdnWafRuleRequest() {}

  explicit ModifyDcdnWafRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleConfig) {
      res["RuleConfig"] = boost::any(*ruleConfig);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleStatus) {
      res["RuleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleConfig") != m.end() && !m["RuleConfig"].empty()) {
      ruleConfig = make_shared<string>(boost::any_cast<string>(m["RuleConfig"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleStatus") != m.end() && !m["RuleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["RuleStatus"]));
    }
  }


  virtual ~ModifyDcdnWafRuleRequest() = default;
};
class ModifyDcdnWafRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDcdnWafRuleResponseBody() {}

  explicit ModifyDcdnWafRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDcdnWafRuleResponseBody() = default;
};
class ModifyDcdnWafRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDcdnWafRuleResponseBody> body{};

  ModifyDcdnWafRuleResponse() {}

  explicit ModifyDcdnWafRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDcdnWafRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDcdnWafRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDcdnWafRuleResponse() = default;
};
class OpenDcdnServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> billType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> websocketBillType{};

  OpenDcdnServiceRequest() {}

  explicit OpenDcdnServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billType) {
      res["BillType"] = boost::any(*billType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (websocketBillType) {
      res["WebsocketBillType"] = boost::any(*websocketBillType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillType") != m.end() && !m["BillType"].empty()) {
      billType = make_shared<string>(boost::any_cast<string>(m["BillType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("WebsocketBillType") != m.end() && !m["WebsocketBillType"].empty()) {
      websocketBillType = make_shared<string>(boost::any_cast<string>(m["WebsocketBillType"]));
    }
  }


  virtual ~OpenDcdnServiceRequest() = default;
};
class OpenDcdnServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OpenDcdnServiceResponseBody() {}

  explicit OpenDcdnServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenDcdnServiceResponseBody() = default;
};
class OpenDcdnServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenDcdnServiceResponseBody> body{};

  OpenDcdnServiceResponse() {}

  explicit OpenDcdnServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenDcdnServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenDcdnServiceResponseBody>(model1);
      }
    }
  }


  virtual ~OpenDcdnServiceResponse() = default;
};
class PreloadDcdnObjectCachesRequest : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<bool> l2Preload{};
  shared_ptr<string> objectPath{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> withHeader{};

  PreloadDcdnObjectCachesRequest() {}

  explicit PreloadDcdnObjectCachesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (l2Preload) {
      res["L2Preload"] = boost::any(*l2Preload);
    }
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (withHeader) {
      res["WithHeader"] = boost::any(*withHeader);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("L2Preload") != m.end() && !m["L2Preload"].empty()) {
      l2Preload = make_shared<bool>(boost::any_cast<bool>(m["L2Preload"]));
    }
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("WithHeader") != m.end() && !m["WithHeader"].empty()) {
      withHeader = make_shared<string>(boost::any_cast<string>(m["WithHeader"]));
    }
  }


  virtual ~PreloadDcdnObjectCachesRequest() = default;
};
class PreloadDcdnObjectCachesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> preloadTaskId{};
  shared_ptr<string> requestId{};

  PreloadDcdnObjectCachesResponseBody() {}

  explicit PreloadDcdnObjectCachesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTaskId) {
      res["PreloadTaskId"] = boost::any(*preloadTaskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTaskId") != m.end() && !m["PreloadTaskId"].empty()) {
      preloadTaskId = make_shared<string>(boost::any_cast<string>(m["PreloadTaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PreloadDcdnObjectCachesResponseBody() = default;
};
class PreloadDcdnObjectCachesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PreloadDcdnObjectCachesResponseBody> body{};

  PreloadDcdnObjectCachesResponse() {}

  explicit PreloadDcdnObjectCachesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PreloadDcdnObjectCachesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PreloadDcdnObjectCachesResponseBody>(model1);
      }
    }
  }


  virtual ~PreloadDcdnObjectCachesResponse() = default;
};
class PublishDcdnStagingConfigToProductionRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functionName{};

  PublishDcdnStagingConfigToProductionRequest() {}

  explicit PublishDcdnStagingConfigToProductionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
  }


  virtual ~PublishDcdnStagingConfigToProductionRequest() = default;
};
class PublishDcdnStagingConfigToProductionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PublishDcdnStagingConfigToProductionResponseBody() {}

  explicit PublishDcdnStagingConfigToProductionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PublishDcdnStagingConfigToProductionResponseBody() = default;
};
class PublishDcdnStagingConfigToProductionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublishDcdnStagingConfigToProductionResponseBody> body{};

  PublishDcdnStagingConfigToProductionResponse() {}

  explicit PublishDcdnStagingConfigToProductionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishDcdnStagingConfigToProductionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishDcdnStagingConfigToProductionResponseBody>(model1);
      }
    }
  }


  virtual ~PublishDcdnStagingConfigToProductionResponse() = default;
};
class PublishRoutineCodeRevisionRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> envs{};
  shared_ptr<string> name{};
  shared_ptr<string> selectCodeRevision{};

  PublishRoutineCodeRevisionRequest() {}

  explicit PublishRoutineCodeRevisionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (selectCodeRevision) {
      res["SelectCodeRevision"] = boost::any(*selectCodeRevision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Envs"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      envs = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SelectCodeRevision") != m.end() && !m["SelectCodeRevision"].empty()) {
      selectCodeRevision = make_shared<string>(boost::any_cast<string>(m["SelectCodeRevision"]));
    }
  }


  virtual ~PublishRoutineCodeRevisionRequest() = default;
};
class PublishRoutineCodeRevisionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> envsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> selectCodeRevision{};

  PublishRoutineCodeRevisionShrinkRequest() {}

  explicit PublishRoutineCodeRevisionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envsShrink) {
      res["Envs"] = boost::any(*envsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (selectCodeRevision) {
      res["SelectCodeRevision"] = boost::any(*selectCodeRevision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envsShrink = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SelectCodeRevision") != m.end() && !m["SelectCodeRevision"].empty()) {
      selectCodeRevision = make_shared<string>(boost::any_cast<string>(m["SelectCodeRevision"]));
    }
  }


  virtual ~PublishRoutineCodeRevisionShrinkRequest() = default;
};
class PublishRoutineCodeRevisionResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  PublishRoutineCodeRevisionResponseBody() {}

  explicit PublishRoutineCodeRevisionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PublishRoutineCodeRevisionResponseBody() = default;
};
class PublishRoutineCodeRevisionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublishRoutineCodeRevisionResponseBody> body{};

  PublishRoutineCodeRevisionResponse() {}

  explicit PublishRoutineCodeRevisionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishRoutineCodeRevisionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishRoutineCodeRevisionResponseBody>(model1);
      }
    }
  }


  virtual ~PublishRoutineCodeRevisionResponse() = default;
};
class PutDcdnKvRequest : public Darabonba::Model {
public:
  shared_ptr<long> expiration{};
  shared_ptr<long> expirationTtl{};
  shared_ptr<string> key{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> value{};

  PutDcdnKvRequest() {}

  explicit PutDcdnKvRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expiration) {
      res["Expiration"] = boost::any(*expiration);
    }
    if (expirationTtl) {
      res["ExpirationTtl"] = boost::any(*expirationTtl);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expiration") != m.end() && !m["Expiration"].empty()) {
      expiration = make_shared<long>(boost::any_cast<long>(m["Expiration"]));
    }
    if (m.find("ExpirationTtl") != m.end() && !m["ExpirationTtl"].empty()) {
      expirationTtl = make_shared<long>(boost::any_cast<long>(m["ExpirationTtl"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PutDcdnKvRequest() = default;
};
class PutDcdnKvResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> length{};
  shared_ptr<string> requestId{};
  shared_ptr<string> value{};

  PutDcdnKvResponseBody() {}

  explicit PutDcdnKvResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~PutDcdnKvResponseBody() = default;
};
class PutDcdnKvResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutDcdnKvResponseBody> body{};

  PutDcdnKvResponse() {}

  explicit PutDcdnKvResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutDcdnKvResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutDcdnKvResponseBody>(model1);
      }
    }
  }


  virtual ~PutDcdnKvResponse() = default;
};
class PutDcdnKvNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> namespace_{};

  PutDcdnKvNamespaceRequest() {}

  explicit PutDcdnKvNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~PutDcdnKvNamespaceRequest() = default;
};
class PutDcdnKvNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> namespaceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  PutDcdnKvNamespaceResponseBody() {}

  explicit PutDcdnKvNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (namespaceId) {
      res["NamespaceId"] = boost::any(*namespaceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("NamespaceId") != m.end() && !m["NamespaceId"].empty()) {
      namespaceId = make_shared<string>(boost::any_cast<string>(m["NamespaceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~PutDcdnKvNamespaceResponseBody() = default;
};
class PutDcdnKvNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PutDcdnKvNamespaceResponseBody> body{};

  PutDcdnKvNamespaceResponse() {}

  explicit PutDcdnKvNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PutDcdnKvNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PutDcdnKvNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~PutDcdnKvNamespaceResponse() = default;
};
class RefreshDcdnObjectCachesRequest : public Darabonba::Model {
public:
  shared_ptr<string> objectPath{};
  shared_ptr<string> objectType{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  RefreshDcdnObjectCachesRequest() {}

  explicit RefreshDcdnObjectCachesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~RefreshDcdnObjectCachesRequest() = default;
};
class RefreshDcdnObjectCachesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> refreshTaskId{};
  shared_ptr<string> requestId{};

  RefreshDcdnObjectCachesResponseBody() {}

  explicit RefreshDcdnObjectCachesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (refreshTaskId) {
      res["RefreshTaskId"] = boost::any(*refreshTaskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RefreshTaskId") != m.end() && !m["RefreshTaskId"].empty()) {
      refreshTaskId = make_shared<string>(boost::any_cast<string>(m["RefreshTaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RefreshDcdnObjectCachesResponseBody() = default;
};
class RefreshDcdnObjectCachesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshDcdnObjectCachesResponseBody> body{};

  RefreshDcdnObjectCachesResponse() {}

  explicit RefreshDcdnObjectCachesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshDcdnObjectCachesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshDcdnObjectCachesResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshDcdnObjectCachesResponse() = default;
};
class RollbackDcdnStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  RollbackDcdnStagingConfigRequest() {}

  explicit RollbackDcdnStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~RollbackDcdnStagingConfigRequest() = default;
};
class RollbackDcdnStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RollbackDcdnStagingConfigResponseBody() {}

  explicit RollbackDcdnStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RollbackDcdnStagingConfigResponseBody() = default;
};
class RollbackDcdnStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RollbackDcdnStagingConfigResponseBody> body{};

  RollbackDcdnStagingConfigResponse() {}

  explicit RollbackDcdnStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackDcdnStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackDcdnStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackDcdnStagingConfigResponse() = default;
};
class SetDcdnDomainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> forceSet{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> region{};
  shared_ptr<string> SSLPri{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> securityToken{};

  SetDcdnDomainCertificateRequest() {}

  explicit SetDcdnDomainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (forceSet) {
      res["ForceSet"] = boost::any(*forceSet);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (SSLPri) {
      res["SSLPri"] = boost::any(*SSLPri);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ForceSet") != m.end() && !m["ForceSet"].empty()) {
      forceSet = make_shared<string>(boost::any_cast<string>(m["ForceSet"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SSLPri") != m.end() && !m["SSLPri"].empty()) {
      SSLPri = make_shared<string>(boost::any_cast<string>(m["SSLPri"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetDcdnDomainCertificateRequest() = default;
};
class SetDcdnDomainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDcdnDomainCertificateResponseBody() {}

  explicit SetDcdnDomainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDcdnDomainCertificateResponseBody() = default;
};
class SetDcdnDomainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDcdnDomainCertificateResponseBody> body{};

  SetDcdnDomainCertificateResponse() {}

  explicit SetDcdnDomainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDcdnDomainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDcdnDomainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetDcdnDomainCertificateResponse() = default;
};
class SetDcdnDomainSMCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certIdentifier{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> securityToken{};

  SetDcdnDomainSMCertificateRequest() {}

  explicit SetDcdnDomainSMCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetDcdnDomainSMCertificateRequest() = default;
};
class SetDcdnDomainSMCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDcdnDomainSMCertificateResponseBody() {}

  explicit SetDcdnDomainSMCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDcdnDomainSMCertificateResponseBody() = default;
};
class SetDcdnDomainSMCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDcdnDomainSMCertificateResponseBody> body{};

  SetDcdnDomainSMCertificateResponse() {}

  explicit SetDcdnDomainSMCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDcdnDomainSMCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDcdnDomainSMCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetDcdnDomainSMCertificateResponse() = default;
};
class SetDcdnDomainSSLCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<long> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> certRegion{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> SSLPri{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> securityToken{};

  SetDcdnDomainSSLCertificateRequest() {}

  explicit SetDcdnDomainSSLCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certRegion) {
      res["CertRegion"] = boost::any(*certRegion);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (SSLPri) {
      res["SSLPri"] = boost::any(*SSLPri);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertRegion") != m.end() && !m["CertRegion"].empty()) {
      certRegion = make_shared<string>(boost::any_cast<string>(m["CertRegion"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SSLPri") != m.end() && !m["SSLPri"].empty()) {
      SSLPri = make_shared<string>(boost::any_cast<string>(m["SSLPri"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetDcdnDomainSSLCertificateRequest() = default;
};
class SetDcdnDomainSSLCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDcdnDomainSSLCertificateResponseBody() {}

  explicit SetDcdnDomainSSLCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDcdnDomainSSLCertificateResponseBody() = default;
};
class SetDcdnDomainSSLCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDcdnDomainSSLCertificateResponseBody> body{};

  SetDcdnDomainSSLCertificateResponse() {}

  explicit SetDcdnDomainSSLCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDcdnDomainSSLCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDcdnDomainSSLCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetDcdnDomainSSLCertificateResponse() = default;
};
class SetDcdnDomainStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> functions{};

  SetDcdnDomainStagingConfigRequest() {}

  explicit SetDcdnDomainStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functions) {
      res["Functions"] = boost::any(*functions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      functions = make_shared<string>(boost::any_cast<string>(m["Functions"]));
    }
  }


  virtual ~SetDcdnDomainStagingConfigRequest() = default;
};
class SetDcdnDomainStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDcdnDomainStagingConfigResponseBody() {}

  explicit SetDcdnDomainStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDcdnDomainStagingConfigResponseBody() = default;
};
class SetDcdnDomainStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDcdnDomainStagingConfigResponseBody> body{};

  SetDcdnDomainStagingConfigResponse() {}

  explicit SetDcdnDomainStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDcdnDomainStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDcdnDomainStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetDcdnDomainStagingConfigResponse() = default;
};
class SetDcdnFullDomainsBlockIPRequest : public Darabonba::Model {
public:
  shared_ptr<long> blockInterval{};
  shared_ptr<string> IPList{};
  shared_ptr<string> operationType{};
  shared_ptr<string> updateType{};

  SetDcdnFullDomainsBlockIPRequest() {}

  explicit SetDcdnFullDomainsBlockIPRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockInterval) {
      res["BlockInterval"] = boost::any(*blockInterval);
    }
    if (IPList) {
      res["IPList"] = boost::any(*IPList);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (updateType) {
      res["UpdateType"] = boost::any(*updateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockInterval") != m.end() && !m["BlockInterval"].empty()) {
      blockInterval = make_shared<long>(boost::any_cast<long>(m["BlockInterval"]));
    }
    if (m.find("IPList") != m.end() && !m["IPList"].empty()) {
      IPList = make_shared<string>(boost::any_cast<string>(m["IPList"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("UpdateType") != m.end() && !m["UpdateType"].empty()) {
      updateType = make_shared<string>(boost::any_cast<string>(m["UpdateType"]));
    }
  }


  virtual ~SetDcdnFullDomainsBlockIPRequest() = default;
};
class SetDcdnFullDomainsBlockIPResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  SetDcdnFullDomainsBlockIPResponseBody() {}

  explicit SetDcdnFullDomainsBlockIPResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDcdnFullDomainsBlockIPResponseBody() = default;
};
class SetDcdnFullDomainsBlockIPResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDcdnFullDomainsBlockIPResponseBody> body{};

  SetDcdnFullDomainsBlockIPResponse() {}

  explicit SetDcdnFullDomainsBlockIPResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDcdnFullDomainsBlockIPResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDcdnFullDomainsBlockIPResponseBody>(model1);
      }
    }
  }


  virtual ~SetDcdnFullDomainsBlockIPResponse() = default;
};
class SetDcdnUserConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> configs{};
  shared_ptr<long> functionId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  SetDcdnUserConfigRequest() {}

  explicit SetDcdnUserConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configs) {
      res["Configs"] = boost::any(*configs);
    }
    if (functionId) {
      res["FunctionId"] = boost::any(*functionId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      configs = make_shared<string>(boost::any_cast<string>(m["Configs"]));
    }
    if (m.find("FunctionId") != m.end() && !m["FunctionId"].empty()) {
      functionId = make_shared<long>(boost::any_cast<long>(m["FunctionId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetDcdnUserConfigRequest() = default;
};
class SetDcdnUserConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDcdnUserConfigResponseBody() {}

  explicit SetDcdnUserConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDcdnUserConfigResponseBody() = default;
};
class SetDcdnUserConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDcdnUserConfigResponseBody> body{};

  SetDcdnUserConfigResponse() {}

  explicit SetDcdnUserConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDcdnUserConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDcdnUserConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetDcdnUserConfigResponse() = default;
};
class SetRoutineSubdomainRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> subdomains{};

  SetRoutineSubdomainRequest() {}

  explicit SetRoutineSubdomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subdomains) {
      res["Subdomains"] = boost::any(*subdomains);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subdomains") != m.end() && !m["Subdomains"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Subdomains"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      subdomains = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~SetRoutineSubdomainRequest() = default;
};
class SetRoutineSubdomainShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> subdomainsShrink{};

  SetRoutineSubdomainShrinkRequest() {}

  explicit SetRoutineSubdomainShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subdomainsShrink) {
      res["Subdomains"] = boost::any(*subdomainsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subdomains") != m.end() && !m["Subdomains"].empty()) {
      subdomainsShrink = make_shared<string>(boost::any_cast<string>(m["Subdomains"]));
    }
  }


  virtual ~SetRoutineSubdomainShrinkRequest() = default;
};
class SetRoutineSubdomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  SetRoutineSubdomainResponseBody() {}

  explicit SetRoutineSubdomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetRoutineSubdomainResponseBody() = default;
};
class SetRoutineSubdomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetRoutineSubdomainResponseBody> body{};

  SetRoutineSubdomainResponse() {}

  explicit SetRoutineSubdomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetRoutineSubdomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetRoutineSubdomainResponseBody>(model1);
      }
    }
  }


  virtual ~SetRoutineSubdomainResponse() = default;
};
class StartDcdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  StartDcdnDomainRequest() {}

  explicit StartDcdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~StartDcdnDomainRequest() = default;
};
class StartDcdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartDcdnDomainResponseBody() {}

  explicit StartDcdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartDcdnDomainResponseBody() = default;
};
class StartDcdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartDcdnDomainResponseBody> body{};

  StartDcdnDomainResponse() {}

  explicit StartDcdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartDcdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartDcdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~StartDcdnDomainResponse() = default;
};
class StartDcdnIpaDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  StartDcdnIpaDomainRequest() {}

  explicit StartDcdnIpaDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~StartDcdnIpaDomainRequest() = default;
};
class StartDcdnIpaDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartDcdnIpaDomainResponseBody() {}

  explicit StartDcdnIpaDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartDcdnIpaDomainResponseBody() = default;
};
class StartDcdnIpaDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartDcdnIpaDomainResponseBody> body{};

  StartDcdnIpaDomainResponse() {}

  explicit StartDcdnIpaDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartDcdnIpaDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartDcdnIpaDomainResponseBody>(model1);
      }
    }
  }


  virtual ~StartDcdnIpaDomainResponse() = default;
};
class StopDcdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  StopDcdnDomainRequest() {}

  explicit StopDcdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~StopDcdnDomainRequest() = default;
};
class StopDcdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopDcdnDomainResponseBody() {}

  explicit StopDcdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopDcdnDomainResponseBody() = default;
};
class StopDcdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopDcdnDomainResponseBody> body{};

  StopDcdnDomainResponse() {}

  explicit StopDcdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopDcdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopDcdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~StopDcdnDomainResponse() = default;
};
class StopDcdnIpaDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  StopDcdnIpaDomainRequest() {}

  explicit StopDcdnIpaDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~StopDcdnIpaDomainRequest() = default;
};
class StopDcdnIpaDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopDcdnIpaDomainResponseBody() {}

  explicit StopDcdnIpaDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopDcdnIpaDomainResponseBody() = default;
};
class StopDcdnIpaDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopDcdnIpaDomainResponseBody> body{};

  StopDcdnIpaDomainResponse() {}

  explicit StopDcdnIpaDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopDcdnIpaDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopDcdnIpaDomainResponseBody>(model1);
      }
    }
  }


  virtual ~StopDcdnIpaDomainResponse() = default;
};
class TagDcdnResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagDcdnResourcesRequestTag() {}

  explicit TagDcdnResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagDcdnResourcesRequestTag() = default;
};
class TagDcdnResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagDcdnResourcesRequestTag>> tag{};

  TagDcdnResourcesRequest() {}

  explicit TagDcdnResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagDcdnResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagDcdnResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagDcdnResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagDcdnResourcesRequest() = default;
};
class TagDcdnResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagDcdnResourcesResponseBody() {}

  explicit TagDcdnResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagDcdnResourcesResponseBody() = default;
};
class TagDcdnResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagDcdnResourcesResponseBody> body{};

  TagDcdnResourcesResponse() {}

  explicit TagDcdnResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagDcdnResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagDcdnResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagDcdnResourcesResponse() = default;
};
class UntagDcdnResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UntagDcdnResourcesRequest() {}

  explicit UntagDcdnResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagDcdnResourcesRequest() = default;
};
class UntagDcdnResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagDcdnResourcesResponseBody() {}

  explicit UntagDcdnResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagDcdnResourcesResponseBody() = default;
};
class UntagDcdnResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagDcdnResourcesResponseBody> body{};

  UntagDcdnResourcesResponse() {}

  explicit UntagDcdnResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagDcdnResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagDcdnResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagDcdnResourcesResponse() = default;
};
class UpdateDcdnDeliverTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> deliver{};
  shared_ptr<long> deliverId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> name{};
  shared_ptr<string> reports{};
  shared_ptr<string> schedule{};

  UpdateDcdnDeliverTaskRequest() {}

  explicit UpdateDcdnDeliverTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliver) {
      res["Deliver"] = boost::any(*deliver);
    }
    if (deliverId) {
      res["DeliverId"] = boost::any(*deliverId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (reports) {
      res["Reports"] = boost::any(*reports);
    }
    if (schedule) {
      res["Schedule"] = boost::any(*schedule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Deliver") != m.end() && !m["Deliver"].empty()) {
      deliver = make_shared<string>(boost::any_cast<string>(m["Deliver"]));
    }
    if (m.find("DeliverId") != m.end() && !m["DeliverId"].empty()) {
      deliverId = make_shared<long>(boost::any_cast<long>(m["DeliverId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Reports") != m.end() && !m["Reports"].empty()) {
      reports = make_shared<string>(boost::any_cast<string>(m["Reports"]));
    }
    if (m.find("Schedule") != m.end() && !m["Schedule"].empty()) {
      schedule = make_shared<string>(boost::any_cast<string>(m["Schedule"]));
    }
  }


  virtual ~UpdateDcdnDeliverTaskRequest() = default;
};
class UpdateDcdnDeliverTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDcdnDeliverTaskResponseBody() {}

  explicit UpdateDcdnDeliverTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDcdnDeliverTaskResponseBody() = default;
};
class UpdateDcdnDeliverTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDcdnDeliverTaskResponseBody> body{};

  UpdateDcdnDeliverTaskResponse() {}

  explicit UpdateDcdnDeliverTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDcdnDeliverTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDcdnDeliverTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDcdnDeliverTaskResponse() = default;
};
class UpdateDcdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sources{};
  shared_ptr<string> topLevelDomain{};

  UpdateDcdnDomainRequest() {}

  explicit UpdateDcdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~UpdateDcdnDomainRequest() = default;
};
class UpdateDcdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDcdnDomainResponseBody() {}

  explicit UpdateDcdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDcdnDomainResponseBody() = default;
};
class UpdateDcdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDcdnDomainResponseBody> body{};

  UpdateDcdnDomainResponse() {}

  explicit UpdateDcdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDcdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDcdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDcdnDomainResponse() = default;
};
class UpdateDcdnIpaDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sources{};
  shared_ptr<string> topLevelDomain{};

  UpdateDcdnIpaDomainRequest() {}

  explicit UpdateDcdnIpaDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~UpdateDcdnIpaDomainRequest() = default;
};
class UpdateDcdnIpaDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDcdnIpaDomainResponseBody() {}

  explicit UpdateDcdnIpaDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDcdnIpaDomainResponseBody() = default;
};
class UpdateDcdnIpaDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDcdnIpaDomainResponseBody> body{};

  UpdateDcdnIpaDomainResponse() {}

  explicit UpdateDcdnIpaDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDcdnIpaDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDcdnIpaDomainResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDcdnIpaDomainResponse() = default;
};
class UpdateDcdnSLSRealtimeLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> dataCenter{};
  shared_ptr<string> domainName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> SLSLogStore{};
  shared_ptr<string> SLSProject{};
  shared_ptr<string> SLSRegion{};
  shared_ptr<string> samplingRate{};

  UpdateDcdnSLSRealtimeLogDeliveryRequest() {}

  explicit UpdateDcdnSLSRealtimeLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataCenter) {
      res["DataCenter"] = boost::any(*dataCenter);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (SLSLogStore) {
      res["SLSLogStore"] = boost::any(*SLSLogStore);
    }
    if (SLSProject) {
      res["SLSProject"] = boost::any(*SLSProject);
    }
    if (SLSRegion) {
      res["SLSRegion"] = boost::any(*SLSRegion);
    }
    if (samplingRate) {
      res["SamplingRate"] = boost::any(*samplingRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataCenter") != m.end() && !m["DataCenter"].empty()) {
      dataCenter = make_shared<string>(boost::any_cast<string>(m["DataCenter"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SLSLogStore") != m.end() && !m["SLSLogStore"].empty()) {
      SLSLogStore = make_shared<string>(boost::any_cast<string>(m["SLSLogStore"]));
    }
    if (m.find("SLSProject") != m.end() && !m["SLSProject"].empty()) {
      SLSProject = make_shared<string>(boost::any_cast<string>(m["SLSProject"]));
    }
    if (m.find("SLSRegion") != m.end() && !m["SLSRegion"].empty()) {
      SLSRegion = make_shared<string>(boost::any_cast<string>(m["SLSRegion"]));
    }
    if (m.find("SamplingRate") != m.end() && !m["SamplingRate"].empty()) {
      samplingRate = make_shared<string>(boost::any_cast<string>(m["SamplingRate"]));
    }
  }


  virtual ~UpdateDcdnSLSRealtimeLogDeliveryRequest() = default;
};
class UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> domainName{};
  shared_ptr<string> region{};
  shared_ptr<string> status{};

  UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains() {}

  explicit UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains() = default;
};
class UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains>> domains{};

  UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent() {}

  explicit UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      vector<boost::any> temp1;
      for(auto item1:*domains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Domains"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Domains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domains = make_shared<vector<UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContentDomains>>(expect1);
      }
    }
  }


  virtual ~UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent() = default;
};
class UpdateDcdnSLSRealtimeLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent> content{};
  shared_ptr<string> requestId{};

  UpdateDcdnSLSRealtimeLogDeliveryResponseBody() {}

  explicit UpdateDcdnSLSRealtimeLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<UpdateDcdnSLSRealtimeLogDeliveryResponseBodyContent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDcdnSLSRealtimeLogDeliveryResponseBody() = default;
};
class UpdateDcdnSLSRealtimeLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDcdnSLSRealtimeLogDeliveryResponseBody> body{};

  UpdateDcdnSLSRealtimeLogDeliveryResponse() {}

  explicit UpdateDcdnSLSRealtimeLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDcdnSLSRealtimeLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDcdnSLSRealtimeLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDcdnSLSRealtimeLogDeliveryResponse() = default;
};
class UpdateDcdnSubTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> reportIds{};
  shared_ptr<string> startTime{};

  UpdateDcdnSubTaskRequest() {}

  explicit UpdateDcdnSubTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (reportIds) {
      res["ReportIds"] = boost::any(*reportIds);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("ReportIds") != m.end() && !m["ReportIds"].empty()) {
      reportIds = make_shared<string>(boost::any_cast<string>(m["ReportIds"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~UpdateDcdnSubTaskRequest() = default;
};
class UpdateDcdnSubTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDcdnSubTaskResponseBody() {}

  explicit UpdateDcdnSubTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDcdnSubTaskResponseBody() = default;
};
class UpdateDcdnSubTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDcdnSubTaskResponseBody> body{};

  UpdateDcdnSubTaskResponse() {}

  explicit UpdateDcdnSubTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDcdnSubTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDcdnSubTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDcdnSubTaskResponse() = default;
};
class UpdateDcdnUserRealTimeDeliveryFieldRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> fields{};

  UpdateDcdnUserRealTimeDeliveryFieldRequest() {}

  explicit UpdateDcdnUserRealTimeDeliveryFieldRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (fields) {
      res["Fields"] = boost::any(*fields);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      fields = make_shared<string>(boost::any_cast<string>(m["Fields"]));
    }
  }


  virtual ~UpdateDcdnUserRealTimeDeliveryFieldRequest() = default;
};
class UpdateDcdnUserRealTimeDeliveryFieldResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDcdnUserRealTimeDeliveryFieldResponseBody() {}

  explicit UpdateDcdnUserRealTimeDeliveryFieldResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDcdnUserRealTimeDeliveryFieldResponseBody() = default;
};
class UpdateDcdnUserRealTimeDeliveryFieldResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDcdnUserRealTimeDeliveryFieldResponseBody> body{};

  UpdateDcdnUserRealTimeDeliveryFieldResponse() {}

  explicit UpdateDcdnUserRealTimeDeliveryFieldResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDcdnUserRealTimeDeliveryFieldResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDcdnUserRealTimeDeliveryFieldResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDcdnUserRealTimeDeliveryFieldResponse() = default;
};
class UploadRoutineCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> codeDescription{};
  shared_ptr<string> name{};

  UploadRoutineCodeRequest() {}

  explicit UploadRoutineCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeDescription) {
      res["CodeDescription"] = boost::any(*codeDescription);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeDescription") != m.end() && !m["CodeDescription"].empty()) {
      codeDescription = make_shared<string>(boost::any_cast<string>(m["CodeDescription"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UploadRoutineCodeRequest() = default;
};
class UploadRoutineCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  UploadRoutineCodeResponseBody() {}

  explicit UploadRoutineCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UploadRoutineCodeResponseBody() = default;
};
class UploadRoutineCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadRoutineCodeResponseBody> body{};

  UploadRoutineCodeResponse() {}

  explicit UploadRoutineCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadRoutineCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadRoutineCodeResponseBody>(model1);
      }
    }
  }


  virtual ~UploadRoutineCodeResponse() = default;
};
class UploadStagingRoutineCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> codeDescription{};
  shared_ptr<string> name{};

  UploadStagingRoutineCodeRequest() {}

  explicit UploadStagingRoutineCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeDescription) {
      res["CodeDescription"] = boost::any(*codeDescription);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeDescription") != m.end() && !m["CodeDescription"].empty()) {
      codeDescription = make_shared<string>(boost::any_cast<string>(m["CodeDescription"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UploadStagingRoutineCodeRequest() = default;
};
class UploadStagingRoutineCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  UploadStagingRoutineCodeResponseBody() {}

  explicit UploadStagingRoutineCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UploadStagingRoutineCodeResponseBody() = default;
};
class UploadStagingRoutineCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadStagingRoutineCodeResponseBody> body{};

  UploadStagingRoutineCodeResponse() {}

  explicit UploadStagingRoutineCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadStagingRoutineCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadStagingRoutineCodeResponseBody>(model1);
      }
    }
  }


  virtual ~UploadStagingRoutineCodeResponse() = default;
};
class VerifyDcdnDomainOwnerRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> verifyType{};

  VerifyDcdnDomainOwnerRequest() {}

  explicit VerifyDcdnDomainOwnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (verifyType) {
      res["VerifyType"] = boost::any(*verifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("VerifyType") != m.end() && !m["VerifyType"].empty()) {
      verifyType = make_shared<string>(boost::any_cast<string>(m["VerifyType"]));
    }
  }


  virtual ~VerifyDcdnDomainOwnerRequest() = default;
};
class VerifyDcdnDomainOwnerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  VerifyDcdnDomainOwnerResponseBody() {}

  explicit VerifyDcdnDomainOwnerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VerifyDcdnDomainOwnerResponseBody() = default;
};
class VerifyDcdnDomainOwnerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VerifyDcdnDomainOwnerResponseBody> body{};

  VerifyDcdnDomainOwnerResponse() {}

  explicit VerifyDcdnDomainOwnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VerifyDcdnDomainOwnerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VerifyDcdnDomainOwnerResponseBody>(model1);
      }
    }
  }


  virtual ~VerifyDcdnDomainOwnerResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddDcdnDomainResponse addDcdnDomainWithOptions(shared_ptr<AddDcdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDcdnDomainResponse addDcdnDomain(shared_ptr<AddDcdnDomainRequest> request);
  AddDcdnIpaDomainResponse addDcdnIpaDomainWithOptions(shared_ptr<AddDcdnIpaDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDcdnIpaDomainResponse addDcdnIpaDomain(shared_ptr<AddDcdnIpaDomainRequest> request);
  BatchAddDcdnDomainResponse batchAddDcdnDomainWithOptions(shared_ptr<BatchAddDcdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchAddDcdnDomainResponse batchAddDcdnDomain(shared_ptr<BatchAddDcdnDomainRequest> request);
  BatchCreateDcdnWafRulesResponse batchCreateDcdnWafRulesWithOptions(shared_ptr<BatchCreateDcdnWafRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchCreateDcdnWafRulesResponse batchCreateDcdnWafRules(shared_ptr<BatchCreateDcdnWafRulesRequest> request);
  BatchDeleteDcdnDomainConfigsResponse batchDeleteDcdnDomainConfigsWithOptions(shared_ptr<BatchDeleteDcdnDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteDcdnDomainConfigsResponse batchDeleteDcdnDomainConfigs(shared_ptr<BatchDeleteDcdnDomainConfigsRequest> request);
  BatchDeleteDcdnWafRulesResponse batchDeleteDcdnWafRulesWithOptions(shared_ptr<BatchDeleteDcdnWafRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteDcdnWafRulesResponse batchDeleteDcdnWafRules(shared_ptr<BatchDeleteDcdnWafRulesRequest> request);
  BatchModifyDcdnWafRulesResponse batchModifyDcdnWafRulesWithOptions(shared_ptr<BatchModifyDcdnWafRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchModifyDcdnWafRulesResponse batchModifyDcdnWafRules(shared_ptr<BatchModifyDcdnWafRulesRequest> request);
  BatchSetDcdnDomainCertificateResponse batchSetDcdnDomainCertificateWithOptions(shared_ptr<BatchSetDcdnDomainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetDcdnDomainCertificateResponse batchSetDcdnDomainCertificate(shared_ptr<BatchSetDcdnDomainCertificateRequest> request);
  BatchSetDcdnDomainConfigsResponse batchSetDcdnDomainConfigsWithOptions(shared_ptr<BatchSetDcdnDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetDcdnDomainConfigsResponse batchSetDcdnDomainConfigs(shared_ptr<BatchSetDcdnDomainConfigsRequest> request);
  BatchSetDcdnIpaDomainConfigsResponse batchSetDcdnIpaDomainConfigsWithOptions(shared_ptr<BatchSetDcdnIpaDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetDcdnIpaDomainConfigsResponse batchSetDcdnIpaDomainConfigs(shared_ptr<BatchSetDcdnIpaDomainConfigsRequest> request);
  BatchSetDcdnWafDomainConfigsResponse batchSetDcdnWafDomainConfigsWithOptions(shared_ptr<BatchSetDcdnWafDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetDcdnWafDomainConfigsResponse batchSetDcdnWafDomainConfigs(shared_ptr<BatchSetDcdnWafDomainConfigsRequest> request);
  BatchStartDcdnDomainResponse batchStartDcdnDomainWithOptions(shared_ptr<BatchStartDcdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchStartDcdnDomainResponse batchStartDcdnDomain(shared_ptr<BatchStartDcdnDomainRequest> request);
  BatchStopDcdnDomainResponse batchStopDcdnDomainWithOptions(shared_ptr<BatchStopDcdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchStopDcdnDomainResponse batchStopDcdnDomain(shared_ptr<BatchStopDcdnDomainRequest> request);
  CheckDcdnProjectExistResponse checkDcdnProjectExistWithOptions(shared_ptr<CheckDcdnProjectExistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckDcdnProjectExistResponse checkDcdnProjectExist(shared_ptr<CheckDcdnProjectExistRequest> request);
  CommitStagingRoutineCodeResponse commitStagingRoutineCodeWithOptions(shared_ptr<CommitStagingRoutineCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CommitStagingRoutineCodeResponse commitStagingRoutineCode(shared_ptr<CommitStagingRoutineCodeRequest> request);
  CreateDcdnDeliverTaskResponse createDcdnDeliverTaskWithOptions(shared_ptr<CreateDcdnDeliverTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDcdnDeliverTaskResponse createDcdnDeliverTask(shared_ptr<CreateDcdnDeliverTaskRequest> request);
  CreateDcdnSLSRealTimeLogDeliveryResponse createDcdnSLSRealTimeLogDeliveryWithOptions(shared_ptr<CreateDcdnSLSRealTimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDcdnSLSRealTimeLogDeliveryResponse createDcdnSLSRealTimeLogDelivery(shared_ptr<CreateDcdnSLSRealTimeLogDeliveryRequest> request);
  CreateDcdnSubTaskResponse createDcdnSubTaskWithOptions(shared_ptr<CreateDcdnSubTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDcdnSubTaskResponse createDcdnSubTask(shared_ptr<CreateDcdnSubTaskRequest> request);
  CreateDcdnWafGroupResponse createDcdnWafGroupWithOptions(shared_ptr<CreateDcdnWafGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDcdnWafGroupResponse createDcdnWafGroup(shared_ptr<CreateDcdnWafGroupRequest> request);
  CreateDcdnWafPolicyResponse createDcdnWafPolicyWithOptions(shared_ptr<CreateDcdnWafPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDcdnWafPolicyResponse createDcdnWafPolicy(shared_ptr<CreateDcdnWafPolicyRequest> request);
  CreateRoutineResponse createRoutineWithOptions(shared_ptr<CreateRoutineRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRoutineResponse createRoutine(shared_ptr<CreateRoutineRequest> request);
  CreateSlrAndSlsProjectResponse createSlrAndSlsProjectWithOptions(shared_ptr<CreateSlrAndSlsProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSlrAndSlsProjectResponse createSlrAndSlsProject(shared_ptr<CreateSlrAndSlsProjectRequest> request);
  DeleteDcdnDeliverTaskResponse deleteDcdnDeliverTaskWithOptions(shared_ptr<DeleteDcdnDeliverTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnDeliverTaskResponse deleteDcdnDeliverTask(shared_ptr<DeleteDcdnDeliverTaskRequest> request);
  DeleteDcdnDomainResponse deleteDcdnDomainWithOptions(shared_ptr<DeleteDcdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnDomainResponse deleteDcdnDomain(shared_ptr<DeleteDcdnDomainRequest> request);
  DeleteDcdnIpaDomainResponse deleteDcdnIpaDomainWithOptions(shared_ptr<DeleteDcdnIpaDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnIpaDomainResponse deleteDcdnIpaDomain(shared_ptr<DeleteDcdnIpaDomainRequest> request);
  DeleteDcdnIpaSpecificConfigResponse deleteDcdnIpaSpecificConfigWithOptions(shared_ptr<DeleteDcdnIpaSpecificConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnIpaSpecificConfigResponse deleteDcdnIpaSpecificConfig(shared_ptr<DeleteDcdnIpaSpecificConfigRequest> request);
  DeleteDcdnKvResponse deleteDcdnKvWithOptions(shared_ptr<DeleteDcdnKvRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnKvResponse deleteDcdnKv(shared_ptr<DeleteDcdnKvRequest> request);
  DeleteDcdnKvNamespaceResponse deleteDcdnKvNamespaceWithOptions(shared_ptr<DeleteDcdnKvNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnKvNamespaceResponse deleteDcdnKvNamespace(shared_ptr<DeleteDcdnKvNamespaceRequest> request);
  DeleteDcdnRealTimeLogProjectResponse deleteDcdnRealTimeLogProjectWithOptions(shared_ptr<DeleteDcdnRealTimeLogProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnRealTimeLogProjectResponse deleteDcdnRealTimeLogProject(shared_ptr<DeleteDcdnRealTimeLogProjectRequest> request);
  DeleteDcdnSpecificConfigResponse deleteDcdnSpecificConfigWithOptions(shared_ptr<DeleteDcdnSpecificConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnSpecificConfigResponse deleteDcdnSpecificConfig(shared_ptr<DeleteDcdnSpecificConfigRequest> request);
  DeleteDcdnSpecificStagingConfigResponse deleteDcdnSpecificStagingConfigWithOptions(shared_ptr<DeleteDcdnSpecificStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnSpecificStagingConfigResponse deleteDcdnSpecificStagingConfig(shared_ptr<DeleteDcdnSpecificStagingConfigRequest> request);
  DeleteDcdnSubTaskResponse deleteDcdnSubTaskWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnSubTaskResponse deleteDcdnSubTask();
  DeleteDcdnWafGroupResponse deleteDcdnWafGroupWithOptions(shared_ptr<DeleteDcdnWafGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnWafGroupResponse deleteDcdnWafGroup(shared_ptr<DeleteDcdnWafGroupRequest> request);
  DeleteDcdnWafPolicyResponse deleteDcdnWafPolicyWithOptions(shared_ptr<DeleteDcdnWafPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnWafPolicyResponse deleteDcdnWafPolicy(shared_ptr<DeleteDcdnWafPolicyRequest> request);
  DeleteRoutineResponse deleteRoutineWithOptions(shared_ptr<DeleteRoutineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRoutineResponse deleteRoutine(shared_ptr<DeleteRoutineRequest> request);
  DeleteRoutineCodeRevisionResponse deleteRoutineCodeRevisionWithOptions(shared_ptr<DeleteRoutineCodeRevisionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRoutineCodeRevisionResponse deleteRoutineCodeRevision(shared_ptr<DeleteRoutineCodeRevisionRequest> request);
  DeleteRoutineConfEnvsResponse deleteRoutineConfEnvsWithOptions(shared_ptr<DeleteRoutineConfEnvsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRoutineConfEnvsResponse deleteRoutineConfEnvs(shared_ptr<DeleteRoutineConfEnvsRequest> request);
  DescribeDcdnAclFieldsResponse describeDcdnAclFieldsWithOptions(shared_ptr<DescribeDcdnAclFieldsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnAclFieldsResponse describeDcdnAclFields(shared_ptr<DescribeDcdnAclFieldsRequest> request);
  DescribeDcdnBgpBpsDataResponse describeDcdnBgpBpsDataWithOptions(shared_ptr<DescribeDcdnBgpBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnBgpBpsDataResponse describeDcdnBgpBpsData(shared_ptr<DescribeDcdnBgpBpsDataRequest> request);
  DescribeDcdnBgpTrafficDataResponse describeDcdnBgpTrafficDataWithOptions(shared_ptr<DescribeDcdnBgpTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnBgpTrafficDataResponse describeDcdnBgpTrafficData(shared_ptr<DescribeDcdnBgpTrafficDataRequest> request);
  DescribeDcdnBlockedRegionsResponse describeDcdnBlockedRegionsWithOptions(shared_ptr<DescribeDcdnBlockedRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnBlockedRegionsResponse describeDcdnBlockedRegions(shared_ptr<DescribeDcdnBlockedRegionsRequest> request);
  DescribeDcdnCertificateDetailResponse describeDcdnCertificateDetailWithOptions(shared_ptr<DescribeDcdnCertificateDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnCertificateDetailResponse describeDcdnCertificateDetail(shared_ptr<DescribeDcdnCertificateDetailRequest> request);
  DescribeDcdnCertificateListResponse describeDcdnCertificateListWithOptions(shared_ptr<DescribeDcdnCertificateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnCertificateListResponse describeDcdnCertificateList(shared_ptr<DescribeDcdnCertificateListRequest> request);
  DescribeDcdnDdosServiceResponse describeDcdnDdosServiceWithOptions(shared_ptr<DescribeDcdnDdosServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDdosServiceResponse describeDcdnDdosService(shared_ptr<DescribeDcdnDdosServiceRequest> request);
  DescribeDcdnDdosSpecInfoResponse describeDcdnDdosSpecInfoWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDdosSpecInfoResponse describeDcdnDdosSpecInfo();
  DescribeDcdnDeletedDomainsResponse describeDcdnDeletedDomainsWithOptions(shared_ptr<DescribeDcdnDeletedDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDeletedDomainsResponse describeDcdnDeletedDomains(shared_ptr<DescribeDcdnDeletedDomainsRequest> request);
  DescribeDcdnDeliverListResponse describeDcdnDeliverListWithOptions(shared_ptr<DescribeDcdnDeliverListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDeliverListResponse describeDcdnDeliverList(shared_ptr<DescribeDcdnDeliverListRequest> request);
  DescribeDcdnDomainBpsDataResponse describeDcdnDomainBpsDataWithOptions(shared_ptr<DescribeDcdnDomainBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainBpsDataResponse describeDcdnDomainBpsData(shared_ptr<DescribeDcdnDomainBpsDataRequest> request);
  DescribeDcdnDomainBpsDataByLayerResponse describeDcdnDomainBpsDataByLayerWithOptions(shared_ptr<DescribeDcdnDomainBpsDataByLayerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainBpsDataByLayerResponse describeDcdnDomainBpsDataByLayer(shared_ptr<DescribeDcdnDomainBpsDataByLayerRequest> request);
  DescribeDcdnDomainByCertificateResponse describeDcdnDomainByCertificateWithOptions(shared_ptr<DescribeDcdnDomainByCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainByCertificateResponse describeDcdnDomainByCertificate(shared_ptr<DescribeDcdnDomainByCertificateRequest> request);
  DescribeDcdnDomainCcActivityLogResponse describeDcdnDomainCcActivityLogWithOptions(shared_ptr<DescribeDcdnDomainCcActivityLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainCcActivityLogResponse describeDcdnDomainCcActivityLog(shared_ptr<DescribeDcdnDomainCcActivityLogRequest> request);
  DescribeDcdnDomainCertificateInfoResponse describeDcdnDomainCertificateInfoWithOptions(shared_ptr<DescribeDcdnDomainCertificateInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainCertificateInfoResponse describeDcdnDomainCertificateInfo(shared_ptr<DescribeDcdnDomainCertificateInfoRequest> request);
  DescribeDcdnDomainCnameResponse describeDcdnDomainCnameWithOptions(shared_ptr<DescribeDcdnDomainCnameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainCnameResponse describeDcdnDomainCname(shared_ptr<DescribeDcdnDomainCnameRequest> request);
  DescribeDcdnDomainConfigsResponse describeDcdnDomainConfigsWithOptions(shared_ptr<DescribeDcdnDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainConfigsResponse describeDcdnDomainConfigs(shared_ptr<DescribeDcdnDomainConfigsRequest> request);
  DescribeDcdnDomainDetailResponse describeDcdnDomainDetailWithOptions(shared_ptr<DescribeDcdnDomainDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainDetailResponse describeDcdnDomainDetail(shared_ptr<DescribeDcdnDomainDetailRequest> request);
  DescribeDcdnDomainHitRateDataResponse describeDcdnDomainHitRateDataWithOptions(shared_ptr<DescribeDcdnDomainHitRateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainHitRateDataResponse describeDcdnDomainHitRateData(shared_ptr<DescribeDcdnDomainHitRateDataRequest> request);
  DescribeDcdnDomainHttpCodeDataResponse describeDcdnDomainHttpCodeDataWithOptions(shared_ptr<DescribeDcdnDomainHttpCodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainHttpCodeDataResponse describeDcdnDomainHttpCodeData(shared_ptr<DescribeDcdnDomainHttpCodeDataRequest> request);
  DescribeDcdnDomainHttpCodeDataByLayerResponse describeDcdnDomainHttpCodeDataByLayerWithOptions(shared_ptr<DescribeDcdnDomainHttpCodeDataByLayerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainHttpCodeDataByLayerResponse describeDcdnDomainHttpCodeDataByLayer(shared_ptr<DescribeDcdnDomainHttpCodeDataByLayerRequest> request);
  DescribeDcdnDomainIpaBpsDataResponse describeDcdnDomainIpaBpsDataWithOptions(shared_ptr<DescribeDcdnDomainIpaBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainIpaBpsDataResponse describeDcdnDomainIpaBpsData(shared_ptr<DescribeDcdnDomainIpaBpsDataRequest> request);
  DescribeDcdnDomainIpaConnDataResponse describeDcdnDomainIpaConnDataWithOptions(shared_ptr<DescribeDcdnDomainIpaConnDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainIpaConnDataResponse describeDcdnDomainIpaConnData(shared_ptr<DescribeDcdnDomainIpaConnDataRequest> request);
  DescribeDcdnDomainIpaTrafficDataResponse describeDcdnDomainIpaTrafficDataWithOptions(shared_ptr<DescribeDcdnDomainIpaTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainIpaTrafficDataResponse describeDcdnDomainIpaTrafficData(shared_ptr<DescribeDcdnDomainIpaTrafficDataRequest> request);
  DescribeDcdnDomainIspDataResponse describeDcdnDomainIspDataWithOptions(shared_ptr<DescribeDcdnDomainIspDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainIspDataResponse describeDcdnDomainIspData(shared_ptr<DescribeDcdnDomainIspDataRequest> request);
  DescribeDcdnDomainLogResponse describeDcdnDomainLogWithOptions(shared_ptr<DescribeDcdnDomainLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainLogResponse describeDcdnDomainLog(shared_ptr<DescribeDcdnDomainLogRequest> request);
  DescribeDcdnDomainMultiUsageDataResponse describeDcdnDomainMultiUsageDataWithOptions(shared_ptr<DescribeDcdnDomainMultiUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainMultiUsageDataResponse describeDcdnDomainMultiUsageData(shared_ptr<DescribeDcdnDomainMultiUsageDataRequest> request);
  DescribeDcdnDomainOriginBpsDataResponse describeDcdnDomainOriginBpsDataWithOptions(shared_ptr<DescribeDcdnDomainOriginBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainOriginBpsDataResponse describeDcdnDomainOriginBpsData(shared_ptr<DescribeDcdnDomainOriginBpsDataRequest> request);
  DescribeDcdnDomainOriginTrafficDataResponse describeDcdnDomainOriginTrafficDataWithOptions(shared_ptr<DescribeDcdnDomainOriginTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainOriginTrafficDataResponse describeDcdnDomainOriginTrafficData(shared_ptr<DescribeDcdnDomainOriginTrafficDataRequest> request);
  DescribeDcdnDomainPropertyResponse describeDcdnDomainPropertyWithOptions(shared_ptr<DescribeDcdnDomainPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainPropertyResponse describeDcdnDomainProperty(shared_ptr<DescribeDcdnDomainPropertyRequest> request);
  DescribeDcdnDomainPvDataResponse describeDcdnDomainPvDataWithOptions(shared_ptr<DescribeDcdnDomainPvDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainPvDataResponse describeDcdnDomainPvData(shared_ptr<DescribeDcdnDomainPvDataRequest> request);
  DescribeDcdnDomainQpsDataResponse describeDcdnDomainQpsDataWithOptions(shared_ptr<DescribeDcdnDomainQpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainQpsDataResponse describeDcdnDomainQpsData(shared_ptr<DescribeDcdnDomainQpsDataRequest> request);
  DescribeDcdnDomainQpsDataByLayerResponse describeDcdnDomainQpsDataByLayerWithOptions(shared_ptr<DescribeDcdnDomainQpsDataByLayerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainQpsDataByLayerResponse describeDcdnDomainQpsDataByLayer(shared_ptr<DescribeDcdnDomainQpsDataByLayerRequest> request);
  DescribeDcdnDomainRealTimeBpsDataResponse describeDcdnDomainRealTimeBpsDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeBpsDataResponse describeDcdnDomainRealTimeBpsData(shared_ptr<DescribeDcdnDomainRealTimeBpsDataRequest> request);
  DescribeDcdnDomainRealTimeByteHitRateDataResponse describeDcdnDomainRealTimeByteHitRateDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeByteHitRateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeByteHitRateDataResponse describeDcdnDomainRealTimeByteHitRateData(shared_ptr<DescribeDcdnDomainRealTimeByteHitRateDataRequest> request);
  DescribeDcdnDomainRealTimeDetailDataResponse describeDcdnDomainRealTimeDetailDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeDetailDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeDetailDataResponse describeDcdnDomainRealTimeDetailData(shared_ptr<DescribeDcdnDomainRealTimeDetailDataRequest> request);
  DescribeDcdnDomainRealTimeHttpCodeDataResponse describeDcdnDomainRealTimeHttpCodeDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeHttpCodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeHttpCodeDataResponse describeDcdnDomainRealTimeHttpCodeData(shared_ptr<DescribeDcdnDomainRealTimeHttpCodeDataRequest> request);
  DescribeDcdnDomainRealTimeQpsDataResponse describeDcdnDomainRealTimeQpsDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeQpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeQpsDataResponse describeDcdnDomainRealTimeQpsData(shared_ptr<DescribeDcdnDomainRealTimeQpsDataRequest> request);
  DescribeDcdnDomainRealTimeReqHitRateDataResponse describeDcdnDomainRealTimeReqHitRateDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeReqHitRateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeReqHitRateDataResponse describeDcdnDomainRealTimeReqHitRateData(shared_ptr<DescribeDcdnDomainRealTimeReqHitRateDataRequest> request);
  DescribeDcdnDomainRealTimeSrcBpsDataResponse describeDcdnDomainRealTimeSrcBpsDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeSrcBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeSrcBpsDataResponse describeDcdnDomainRealTimeSrcBpsData(shared_ptr<DescribeDcdnDomainRealTimeSrcBpsDataRequest> request);
  DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse describeDcdnDomainRealTimeSrcHttpCodeDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse describeDcdnDomainRealTimeSrcHttpCodeData(shared_ptr<DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest> request);
  DescribeDcdnDomainRealTimeSrcTrafficDataResponse describeDcdnDomainRealTimeSrcTrafficDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeSrcTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeSrcTrafficDataResponse describeDcdnDomainRealTimeSrcTrafficData(shared_ptr<DescribeDcdnDomainRealTimeSrcTrafficDataRequest> request);
  DescribeDcdnDomainRealTimeTrafficDataResponse describeDcdnDomainRealTimeTrafficDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeTrafficDataResponse describeDcdnDomainRealTimeTrafficData(shared_ptr<DescribeDcdnDomainRealTimeTrafficDataRequest> request);
  DescribeDcdnDomainRegionDataResponse describeDcdnDomainRegionDataWithOptions(shared_ptr<DescribeDcdnDomainRegionDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRegionDataResponse describeDcdnDomainRegionData(shared_ptr<DescribeDcdnDomainRegionDataRequest> request);
  DescribeDcdnDomainStagingConfigResponse describeDcdnDomainStagingConfigWithOptions(shared_ptr<DescribeDcdnDomainStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainStagingConfigResponse describeDcdnDomainStagingConfig(shared_ptr<DescribeDcdnDomainStagingConfigRequest> request);
  DescribeDcdnDomainTopReferVisitResponse describeDcdnDomainTopReferVisitWithOptions(shared_ptr<DescribeDcdnDomainTopReferVisitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainTopReferVisitResponse describeDcdnDomainTopReferVisit(shared_ptr<DescribeDcdnDomainTopReferVisitRequest> request);
  DescribeDcdnDomainTopUrlVisitResponse describeDcdnDomainTopUrlVisitWithOptions(shared_ptr<DescribeDcdnDomainTopUrlVisitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainTopUrlVisitResponse describeDcdnDomainTopUrlVisit(shared_ptr<DescribeDcdnDomainTopUrlVisitRequest> request);
  DescribeDcdnDomainTrafficDataResponse describeDcdnDomainTrafficDataWithOptions(shared_ptr<DescribeDcdnDomainTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainTrafficDataResponse describeDcdnDomainTrafficData(shared_ptr<DescribeDcdnDomainTrafficDataRequest> request);
  DescribeDcdnDomainUsageDataResponse describeDcdnDomainUsageDataWithOptions(shared_ptr<DescribeDcdnDomainUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainUsageDataResponse describeDcdnDomainUsageData(shared_ptr<DescribeDcdnDomainUsageDataRequest> request);
  DescribeDcdnDomainUvDataResponse describeDcdnDomainUvDataWithOptions(shared_ptr<DescribeDcdnDomainUvDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainUvDataResponse describeDcdnDomainUvData(shared_ptr<DescribeDcdnDomainUvDataRequest> request);
  DescribeDcdnDomainWebsocketBpsDataResponse describeDcdnDomainWebsocketBpsDataWithOptions(shared_ptr<DescribeDcdnDomainWebsocketBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainWebsocketBpsDataResponse describeDcdnDomainWebsocketBpsData(shared_ptr<DescribeDcdnDomainWebsocketBpsDataRequest> request);
  DescribeDcdnDomainWebsocketHttpCodeDataResponse describeDcdnDomainWebsocketHttpCodeDataWithOptions(shared_ptr<DescribeDcdnDomainWebsocketHttpCodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainWebsocketHttpCodeDataResponse describeDcdnDomainWebsocketHttpCodeData(shared_ptr<DescribeDcdnDomainWebsocketHttpCodeDataRequest> request);
  DescribeDcdnDomainWebsocketTrafficDataResponse describeDcdnDomainWebsocketTrafficDataWithOptions(shared_ptr<DescribeDcdnDomainWebsocketTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainWebsocketTrafficDataResponse describeDcdnDomainWebsocketTrafficData(shared_ptr<DescribeDcdnDomainWebsocketTrafficDataRequest> request);
  DescribeDcdnErUsageDataResponse describeDcdnErUsageDataWithOptions(shared_ptr<DescribeDcdnErUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnErUsageDataResponse describeDcdnErUsageData(shared_ptr<DescribeDcdnErUsageDataRequest> request);
  DescribeDcdnFullDomainsBlockIPConfigResponse describeDcdnFullDomainsBlockIPConfigWithOptions(shared_ptr<DescribeDcdnFullDomainsBlockIPConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnFullDomainsBlockIPConfigResponse describeDcdnFullDomainsBlockIPConfig(shared_ptr<DescribeDcdnFullDomainsBlockIPConfigRequest> request);
  DescribeDcdnFullDomainsBlockIPHistoryResponse describeDcdnFullDomainsBlockIPHistoryWithOptions(shared_ptr<DescribeDcdnFullDomainsBlockIPHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnFullDomainsBlockIPHistoryResponse describeDcdnFullDomainsBlockIPHistory(shared_ptr<DescribeDcdnFullDomainsBlockIPHistoryRequest> request);
  DescribeDcdnHttpsDomainListResponse describeDcdnHttpsDomainListWithOptions(shared_ptr<DescribeDcdnHttpsDomainListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnHttpsDomainListResponse describeDcdnHttpsDomainList(shared_ptr<DescribeDcdnHttpsDomainListRequest> request);
  DescribeDcdnIpInfoResponse describeDcdnIpInfoWithOptions(shared_ptr<DescribeDcdnIpInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnIpInfoResponse describeDcdnIpInfo(shared_ptr<DescribeDcdnIpInfoRequest> request);
  DescribeDcdnIpaDomainConfigsResponse describeDcdnIpaDomainConfigsWithOptions(shared_ptr<DescribeDcdnIpaDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnIpaDomainConfigsResponse describeDcdnIpaDomainConfigs(shared_ptr<DescribeDcdnIpaDomainConfigsRequest> request);
  DescribeDcdnIpaDomainDetailResponse describeDcdnIpaDomainDetailWithOptions(shared_ptr<DescribeDcdnIpaDomainDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnIpaDomainDetailResponse describeDcdnIpaDomainDetail(shared_ptr<DescribeDcdnIpaDomainDetailRequest> request);
  DescribeDcdnIpaServiceResponse describeDcdnIpaServiceWithOptions(shared_ptr<DescribeDcdnIpaServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnIpaServiceResponse describeDcdnIpaService(shared_ptr<DescribeDcdnIpaServiceRequest> request);
  DescribeDcdnIpaUserDomainsResponse describeDcdnIpaUserDomainsWithOptions(shared_ptr<DescribeDcdnIpaUserDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnIpaUserDomainsResponse describeDcdnIpaUserDomains(shared_ptr<DescribeDcdnIpaUserDomainsRequest> request);
  DescribeDcdnKvAccountResponse describeDcdnKvAccountWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnKvAccountResponse describeDcdnKvAccount();
  DescribeDcdnKvAccountStatusResponse describeDcdnKvAccountStatusWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnKvAccountStatusResponse describeDcdnKvAccountStatus();
  DescribeDcdnKvNamespaceResponse describeDcdnKvNamespaceWithOptions(shared_ptr<DescribeDcdnKvNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnKvNamespaceResponse describeDcdnKvNamespace(shared_ptr<DescribeDcdnKvNamespaceRequest> request);
  DescribeDcdnL2IpsResponse describeDcdnL2IpsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnL2IpsResponse describeDcdnL2Ips();
  DescribeDcdnL2VipsResponse describeDcdnL2VipsWithOptions(shared_ptr<DescribeDcdnL2VipsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnL2VipsResponse describeDcdnL2Vips(shared_ptr<DescribeDcdnL2VipsRequest> request);
  DescribeDcdnRealTimeDeliveryFieldResponse describeDcdnRealTimeDeliveryFieldWithOptions(shared_ptr<DescribeDcdnRealTimeDeliveryFieldRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnRealTimeDeliveryFieldResponse describeDcdnRealTimeDeliveryField(shared_ptr<DescribeDcdnRealTimeDeliveryFieldRequest> request);
  DescribeDcdnRefreshQuotaResponse describeDcdnRefreshQuotaWithOptions(shared_ptr<DescribeDcdnRefreshQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnRefreshQuotaResponse describeDcdnRefreshQuota(shared_ptr<DescribeDcdnRefreshQuotaRequest> request);
  DescribeDcdnRefreshTaskByIdResponse describeDcdnRefreshTaskByIdWithOptions(shared_ptr<DescribeDcdnRefreshTaskByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnRefreshTaskByIdResponse describeDcdnRefreshTaskById(shared_ptr<DescribeDcdnRefreshTaskByIdRequest> request);
  DescribeDcdnRefreshTasksResponse describeDcdnRefreshTasksWithOptions(shared_ptr<DescribeDcdnRefreshTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnRefreshTasksResponse describeDcdnRefreshTasks(shared_ptr<DescribeDcdnRefreshTasksRequest> request);
  DescribeDcdnRegionAndIspResponse describeDcdnRegionAndIspWithOptions(shared_ptr<DescribeDcdnRegionAndIspRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnRegionAndIspResponse describeDcdnRegionAndIsp(shared_ptr<DescribeDcdnRegionAndIspRequest> request);
  DescribeDcdnReportResponse describeDcdnReportWithOptions(shared_ptr<DescribeDcdnReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnReportResponse describeDcdnReport(shared_ptr<DescribeDcdnReportRequest> request);
  DescribeDcdnReportListResponse describeDcdnReportListWithOptions(shared_ptr<DescribeDcdnReportListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnReportListResponse describeDcdnReportList(shared_ptr<DescribeDcdnReportListRequest> request);
  DescribeDcdnSLSRealTimeLogTypeResponse describeDcdnSLSRealTimeLogTypeWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnSLSRealTimeLogTypeResponse describeDcdnSLSRealTimeLogType();
  DescribeDcdnSLSRealtimeLogDeliveryResponse describeDcdnSLSRealtimeLogDeliveryWithOptions(shared_ptr<DescribeDcdnSLSRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnSLSRealtimeLogDeliveryResponse describeDcdnSLSRealtimeLogDelivery(shared_ptr<DescribeDcdnSLSRealtimeLogDeliveryRequest> request);
  DescribeDcdnSMCertificateDetailResponse describeDcdnSMCertificateDetailWithOptions(shared_ptr<DescribeDcdnSMCertificateDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnSMCertificateDetailResponse describeDcdnSMCertificateDetail(shared_ptr<DescribeDcdnSMCertificateDetailRequest> request);
  DescribeDcdnSMCertificateListResponse describeDcdnSMCertificateListWithOptions(shared_ptr<DescribeDcdnSMCertificateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnSMCertificateListResponse describeDcdnSMCertificateList(shared_ptr<DescribeDcdnSMCertificateListRequest> request);
  DescribeDcdnSecFuncInfoResponse describeDcdnSecFuncInfoWithOptions(shared_ptr<DescribeDcdnSecFuncInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnSecFuncInfoResponse describeDcdnSecFuncInfo(shared_ptr<DescribeDcdnSecFuncInfoRequest> request);
  DescribeDcdnSecSpecInfoResponse describeDcdnSecSpecInfoWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnSecSpecInfoResponse describeDcdnSecSpecInfo();
  DescribeDcdnServiceResponse describeDcdnServiceWithOptions(shared_ptr<DescribeDcdnServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnServiceResponse describeDcdnService(shared_ptr<DescribeDcdnServiceRequest> request);
  DescribeDcdnStagingIpResponse describeDcdnStagingIpWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnStagingIpResponse describeDcdnStagingIp();
  DescribeDcdnSubListResponse describeDcdnSubListWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnSubListResponse describeDcdnSubList();
  DescribeDcdnTagResourcesResponse describeDcdnTagResourcesWithOptions(shared_ptr<DescribeDcdnTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnTagResourcesResponse describeDcdnTagResources(shared_ptr<DescribeDcdnTagResourcesRequest> request);
  DescribeDcdnTopDomainsByFlowResponse describeDcdnTopDomainsByFlowWithOptions(shared_ptr<DescribeDcdnTopDomainsByFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnTopDomainsByFlowResponse describeDcdnTopDomainsByFlow(shared_ptr<DescribeDcdnTopDomainsByFlowRequest> request);
  DescribeDcdnUserBillHistoryResponse describeDcdnUserBillHistoryWithOptions(shared_ptr<DescribeDcdnUserBillHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserBillHistoryResponse describeDcdnUserBillHistory(shared_ptr<DescribeDcdnUserBillHistoryRequest> request);
  DescribeDcdnUserBillTypeResponse describeDcdnUserBillTypeWithOptions(shared_ptr<DescribeDcdnUserBillTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserBillTypeResponse describeDcdnUserBillType(shared_ptr<DescribeDcdnUserBillTypeRequest> request);
  DescribeDcdnUserCertificateExpireCountResponse describeDcdnUserCertificateExpireCountWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserCertificateExpireCountResponse describeDcdnUserCertificateExpireCount();
  DescribeDcdnUserConfigsResponse describeDcdnUserConfigsWithOptions(shared_ptr<DescribeDcdnUserConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserConfigsResponse describeDcdnUserConfigs(shared_ptr<DescribeDcdnUserConfigsRequest> request);
  DescribeDcdnUserDomainsResponse describeDcdnUserDomainsWithOptions(shared_ptr<DescribeDcdnUserDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserDomainsResponse describeDcdnUserDomains(shared_ptr<DescribeDcdnUserDomainsRequest> request);
  DescribeDcdnUserDomainsByFuncResponse describeDcdnUserDomainsByFuncWithOptions(shared_ptr<DescribeDcdnUserDomainsByFuncRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserDomainsByFuncResponse describeDcdnUserDomainsByFunc(shared_ptr<DescribeDcdnUserDomainsByFuncRequest> request);
  DescribeDcdnUserQuotaResponse describeDcdnUserQuotaWithOptions(shared_ptr<DescribeDcdnUserQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserQuotaResponse describeDcdnUserQuota(shared_ptr<DescribeDcdnUserQuotaRequest> request);
  DescribeDcdnUserRealTimeDeliveryFieldResponse describeDcdnUserRealTimeDeliveryFieldWithOptions(shared_ptr<DescribeDcdnUserRealTimeDeliveryFieldRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserRealTimeDeliveryFieldResponse describeDcdnUserRealTimeDeliveryField(shared_ptr<DescribeDcdnUserRealTimeDeliveryFieldRequest> request);
  DescribeDcdnUserResourcePackageResponse describeDcdnUserResourcePackageWithOptions(shared_ptr<DescribeDcdnUserResourcePackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserResourcePackageResponse describeDcdnUserResourcePackage(shared_ptr<DescribeDcdnUserResourcePackageRequest> request);
  DescribeDcdnUserSecDropResponse describeDcdnUserSecDropWithOptions(shared_ptr<DescribeDcdnUserSecDropRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserSecDropResponse describeDcdnUserSecDrop(shared_ptr<DescribeDcdnUserSecDropRequest> request);
  DescribeDcdnUserSecDropByMinuteResponse describeDcdnUserSecDropByMinuteWithOptions(shared_ptr<DescribeDcdnUserSecDropByMinuteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserSecDropByMinuteResponse describeDcdnUserSecDropByMinute(shared_ptr<DescribeDcdnUserSecDropByMinuteRequest> request);
  DescribeDcdnUserTagsResponse describeDcdnUserTagsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserTagsResponse describeDcdnUserTags();
  DescribeDcdnVerifyContentResponse describeDcdnVerifyContentWithOptions(shared_ptr<DescribeDcdnVerifyContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnVerifyContentResponse describeDcdnVerifyContent(shared_ptr<DescribeDcdnVerifyContentRequest> request);
  DescribeDcdnWafBotAppKeyResponse describeDcdnWafBotAppKeyWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafBotAppKeyResponse describeDcdnWafBotAppKey();
  DescribeDcdnWafDefaultRulesResponse describeDcdnWafDefaultRulesWithOptions(shared_ptr<DescribeDcdnWafDefaultRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafDefaultRulesResponse describeDcdnWafDefaultRules(shared_ptr<DescribeDcdnWafDefaultRulesRequest> request);
  DescribeDcdnWafDomainResponse describeDcdnWafDomainWithOptions(shared_ptr<DescribeDcdnWafDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafDomainResponse describeDcdnWafDomain(shared_ptr<DescribeDcdnWafDomainRequest> request);
  DescribeDcdnWafDomainDetailResponse describeDcdnWafDomainDetailWithOptions(shared_ptr<DescribeDcdnWafDomainDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafDomainDetailResponse describeDcdnWafDomainDetail(shared_ptr<DescribeDcdnWafDomainDetailRequest> request);
  DescribeDcdnWafDomainsResponse describeDcdnWafDomainsWithOptions(shared_ptr<DescribeDcdnWafDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafDomainsResponse describeDcdnWafDomains(shared_ptr<DescribeDcdnWafDomainsRequest> request);
  DescribeDcdnWafFilterInfoResponse describeDcdnWafFilterInfoWithOptions(shared_ptr<DescribeDcdnWafFilterInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafFilterInfoResponse describeDcdnWafFilterInfo(shared_ptr<DescribeDcdnWafFilterInfoRequest> request);
  DescribeDcdnWafGeoInfoResponse describeDcdnWafGeoInfoWithOptions(shared_ptr<DescribeDcdnWafGeoInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafGeoInfoResponse describeDcdnWafGeoInfo(shared_ptr<DescribeDcdnWafGeoInfoRequest> request);
  DescribeDcdnWafGroupResponse describeDcdnWafGroupWithOptions(shared_ptr<DescribeDcdnWafGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafGroupResponse describeDcdnWafGroup(shared_ptr<DescribeDcdnWafGroupRequest> request);
  DescribeDcdnWafGroupsResponse describeDcdnWafGroupsWithOptions(shared_ptr<DescribeDcdnWafGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafGroupsResponse describeDcdnWafGroups(shared_ptr<DescribeDcdnWafGroupsRequest> request);
  DescribeDcdnWafLogsResponse describeDcdnWafLogsWithOptions(shared_ptr<DescribeDcdnWafLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafLogsResponse describeDcdnWafLogs(shared_ptr<DescribeDcdnWafLogsRequest> request);
  DescribeDcdnWafPoliciesResponse describeDcdnWafPoliciesWithOptions(shared_ptr<DescribeDcdnWafPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafPoliciesResponse describeDcdnWafPolicies(shared_ptr<DescribeDcdnWafPoliciesRequest> request);
  DescribeDcdnWafPolicyResponse describeDcdnWafPolicyWithOptions(shared_ptr<DescribeDcdnWafPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafPolicyResponse describeDcdnWafPolicy(shared_ptr<DescribeDcdnWafPolicyRequest> request);
  DescribeDcdnWafPolicyDomainsResponse describeDcdnWafPolicyDomainsWithOptions(shared_ptr<DescribeDcdnWafPolicyDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafPolicyDomainsResponse describeDcdnWafPolicyDomains(shared_ptr<DescribeDcdnWafPolicyDomainsRequest> request);
  DescribeDcdnWafPolicyValidDomainsResponse describeDcdnWafPolicyValidDomainsWithOptions(shared_ptr<DescribeDcdnWafPolicyValidDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafPolicyValidDomainsResponse describeDcdnWafPolicyValidDomains(shared_ptr<DescribeDcdnWafPolicyValidDomainsRequest> request);
  DescribeDcdnWafRuleResponse describeDcdnWafRuleWithOptions(shared_ptr<DescribeDcdnWafRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafRuleResponse describeDcdnWafRule(shared_ptr<DescribeDcdnWafRuleRequest> request);
  DescribeDcdnWafRulesResponse describeDcdnWafRulesWithOptions(shared_ptr<DescribeDcdnWafRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafRulesResponse describeDcdnWafRules(shared_ptr<DescribeDcdnWafRulesRequest> request);
  DescribeDcdnWafScenesResponse describeDcdnWafScenesWithOptions(shared_ptr<DescribeDcdnWafScenesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafScenesResponse describeDcdnWafScenes(shared_ptr<DescribeDcdnWafScenesRequest> request);
  DescribeDcdnWafServiceResponse describeDcdnWafServiceWithOptions(shared_ptr<DescribeDcdnWafServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafServiceResponse describeDcdnWafService(shared_ptr<DescribeDcdnWafServiceRequest> request);
  DescribeDcdnWafSpecInfoResponse describeDcdnWafSpecInfoWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafSpecInfoResponse describeDcdnWafSpecInfo();
  DescribeDcdnWafUsageDataResponse describeDcdnWafUsageDataWithOptions(shared_ptr<DescribeDcdnWafUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafUsageDataResponse describeDcdnWafUsageData(shared_ptr<DescribeDcdnWafUsageDataRequest> request);
  DescribeDcdnsecServiceResponse describeDcdnsecServiceWithOptions(shared_ptr<DescribeDcdnsecServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnsecServiceResponse describeDcdnsecService(shared_ptr<DescribeDcdnsecServiceRequest> request);
  DescribeDdosAllEventListResponse describeDdosAllEventListWithOptions(shared_ptr<DescribeDdosAllEventListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDdosAllEventListResponse describeDdosAllEventList(shared_ptr<DescribeDdosAllEventListRequest> request);
  DescribeEncryptRoutineUidResponse describeEncryptRoutineUidWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEncryptRoutineUidResponse describeEncryptRoutineUid();
  DescribeHighlightInfoResponse describeHighlightInfoWithOptions(shared_ptr<DescribeHighlightInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHighlightInfoResponse describeHighlightInfo(shared_ptr<DescribeHighlightInfoRequest> request);
  DescribeRDDomainConfigResponse describeRDDomainConfigWithOptions(shared_ptr<DescribeRDDomainConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRDDomainConfigResponse describeRDDomainConfig(shared_ptr<DescribeRDDomainConfigRequest> request);
  DescribeRDDomainsResponse describeRDDomainsWithOptions(shared_ptr<DescribeRDDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRDDomainsResponse describeRDDomains(shared_ptr<DescribeRDDomainsRequest> request);
  DescribeRoutineResponse describeRoutineWithOptions(shared_ptr<DescribeRoutineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRoutineResponse describeRoutine(shared_ptr<DescribeRoutineRequest> request);
  DescribeRoutineCanaryEnvsResponse describeRoutineCanaryEnvsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRoutineCanaryEnvsResponse describeRoutineCanaryEnvs();
  DescribeRoutineCodeRevisionResponse describeRoutineCodeRevisionWithOptions(shared_ptr<DescribeRoutineCodeRevisionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRoutineCodeRevisionResponse describeRoutineCodeRevision(shared_ptr<DescribeRoutineCodeRevisionRequest> request);
  DescribeRoutineSpecResponse describeRoutineSpecWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRoutineSpecResponse describeRoutineSpec();
  DescribeRoutineUserInfoResponse describeRoutineUserInfoWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRoutineUserInfoResponse describeRoutineUserInfo();
  DescribeUserDcdnIpaStatusResponse describeUserDcdnIpaStatusWithOptions(shared_ptr<DescribeUserDcdnIpaStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserDcdnIpaStatusResponse describeUserDcdnIpaStatus(shared_ptr<DescribeUserDcdnIpaStatusRequest> request);
  DescribeUserDcdnStatusResponse describeUserDcdnStatusWithOptions(shared_ptr<DescribeUserDcdnStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserDcdnStatusResponse describeUserDcdnStatus(shared_ptr<DescribeUserDcdnStatusRequest> request);
  DescribeUserErStatusResponse describeUserErStatusWithOptions(shared_ptr<DescribeUserErStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserErStatusResponse describeUserErStatus(shared_ptr<DescribeUserErStatusRequest> request);
  DescribeUserLogserviceStatusResponse describeUserLogserviceStatusWithOptions(shared_ptr<DescribeUserLogserviceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserLogserviceStatusResponse describeUserLogserviceStatus(shared_ptr<DescribeUserLogserviceStatusRequest> request);
  EditRoutineConfResponse editRoutineConfWithOptions(shared_ptr<EditRoutineConfRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EditRoutineConfResponse editRoutineConf(shared_ptr<EditRoutineConfRequest> request);
  GetDcdnKvResponse getDcdnKvWithOptions(shared_ptr<GetDcdnKvRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDcdnKvResponse getDcdnKv(shared_ptr<GetDcdnKvRequest> request);
  ListDcdnKvResponse listDcdnKvWithOptions(shared_ptr<ListDcdnKvRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDcdnKvResponse listDcdnKv(shared_ptr<ListDcdnKvRequest> request);
  ListDcdnRealTimeDeliveryProjectResponse listDcdnRealTimeDeliveryProjectWithOptions(shared_ptr<ListDcdnRealTimeDeliveryProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDcdnRealTimeDeliveryProjectResponse listDcdnRealTimeDeliveryProject(shared_ptr<ListDcdnRealTimeDeliveryProjectRequest> request);
  ModifyDCdnDomainSchdmByPropertyResponse modifyDCdnDomainSchdmByPropertyWithOptions(shared_ptr<ModifyDCdnDomainSchdmByPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDCdnDomainSchdmByPropertyResponse modifyDCdnDomainSchdmByProperty(shared_ptr<ModifyDCdnDomainSchdmByPropertyRequest> request);
  ModifyDcdnWafGroupResponse modifyDcdnWafGroupWithOptions(shared_ptr<ModifyDcdnWafGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDcdnWafGroupResponse modifyDcdnWafGroup(shared_ptr<ModifyDcdnWafGroupRequest> request);
  ModifyDcdnWafPolicyResponse modifyDcdnWafPolicyWithOptions(shared_ptr<ModifyDcdnWafPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDcdnWafPolicyResponse modifyDcdnWafPolicy(shared_ptr<ModifyDcdnWafPolicyRequest> request);
  ModifyDcdnWafPolicyDomainsResponse modifyDcdnWafPolicyDomainsWithOptions(shared_ptr<ModifyDcdnWafPolicyDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDcdnWafPolicyDomainsResponse modifyDcdnWafPolicyDomains(shared_ptr<ModifyDcdnWafPolicyDomainsRequest> request);
  ModifyDcdnWafRuleResponse modifyDcdnWafRuleWithOptions(shared_ptr<ModifyDcdnWafRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDcdnWafRuleResponse modifyDcdnWafRule(shared_ptr<ModifyDcdnWafRuleRequest> request);
  OpenDcdnServiceResponse openDcdnServiceWithOptions(shared_ptr<OpenDcdnServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenDcdnServiceResponse openDcdnService(shared_ptr<OpenDcdnServiceRequest> request);
  PreloadDcdnObjectCachesResponse preloadDcdnObjectCachesWithOptions(shared_ptr<PreloadDcdnObjectCachesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PreloadDcdnObjectCachesResponse preloadDcdnObjectCaches(shared_ptr<PreloadDcdnObjectCachesRequest> request);
  PublishDcdnStagingConfigToProductionResponse publishDcdnStagingConfigToProductionWithOptions(shared_ptr<PublishDcdnStagingConfigToProductionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishDcdnStagingConfigToProductionResponse publishDcdnStagingConfigToProduction(shared_ptr<PublishDcdnStagingConfigToProductionRequest> request);
  PublishRoutineCodeRevisionResponse publishRoutineCodeRevisionWithOptions(shared_ptr<PublishRoutineCodeRevisionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishRoutineCodeRevisionResponse publishRoutineCodeRevision(shared_ptr<PublishRoutineCodeRevisionRequest> request);
  PutDcdnKvResponse putDcdnKvWithOptions(shared_ptr<PutDcdnKvRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutDcdnKvResponse putDcdnKv(shared_ptr<PutDcdnKvRequest> request);
  PutDcdnKvNamespaceResponse putDcdnKvNamespaceWithOptions(shared_ptr<PutDcdnKvNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PutDcdnKvNamespaceResponse putDcdnKvNamespace(shared_ptr<PutDcdnKvNamespaceRequest> request);
  RefreshDcdnObjectCachesResponse refreshDcdnObjectCachesWithOptions(shared_ptr<RefreshDcdnObjectCachesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshDcdnObjectCachesResponse refreshDcdnObjectCaches(shared_ptr<RefreshDcdnObjectCachesRequest> request);
  RollbackDcdnStagingConfigResponse rollbackDcdnStagingConfigWithOptions(shared_ptr<RollbackDcdnStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackDcdnStagingConfigResponse rollbackDcdnStagingConfig(shared_ptr<RollbackDcdnStagingConfigRequest> request);
  SetDcdnDomainCertificateResponse setDcdnDomainCertificateWithOptions(shared_ptr<SetDcdnDomainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDcdnDomainCertificateResponse setDcdnDomainCertificate(shared_ptr<SetDcdnDomainCertificateRequest> request);
  SetDcdnDomainSMCertificateResponse setDcdnDomainSMCertificateWithOptions(shared_ptr<SetDcdnDomainSMCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDcdnDomainSMCertificateResponse setDcdnDomainSMCertificate(shared_ptr<SetDcdnDomainSMCertificateRequest> request);
  SetDcdnDomainSSLCertificateResponse setDcdnDomainSSLCertificateWithOptions(shared_ptr<SetDcdnDomainSSLCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDcdnDomainSSLCertificateResponse setDcdnDomainSSLCertificate(shared_ptr<SetDcdnDomainSSLCertificateRequest> request);
  SetDcdnDomainStagingConfigResponse setDcdnDomainStagingConfigWithOptions(shared_ptr<SetDcdnDomainStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDcdnDomainStagingConfigResponse setDcdnDomainStagingConfig(shared_ptr<SetDcdnDomainStagingConfigRequest> request);
  SetDcdnFullDomainsBlockIPResponse setDcdnFullDomainsBlockIPWithOptions(shared_ptr<SetDcdnFullDomainsBlockIPRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDcdnFullDomainsBlockIPResponse setDcdnFullDomainsBlockIP(shared_ptr<SetDcdnFullDomainsBlockIPRequest> request);
  SetDcdnUserConfigResponse setDcdnUserConfigWithOptions(shared_ptr<SetDcdnUserConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDcdnUserConfigResponse setDcdnUserConfig(shared_ptr<SetDcdnUserConfigRequest> request);
  SetRoutineSubdomainResponse setRoutineSubdomainWithOptions(shared_ptr<SetRoutineSubdomainRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetRoutineSubdomainResponse setRoutineSubdomain(shared_ptr<SetRoutineSubdomainRequest> request);
  StartDcdnDomainResponse startDcdnDomainWithOptions(shared_ptr<StartDcdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartDcdnDomainResponse startDcdnDomain(shared_ptr<StartDcdnDomainRequest> request);
  StartDcdnIpaDomainResponse startDcdnIpaDomainWithOptions(shared_ptr<StartDcdnIpaDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartDcdnIpaDomainResponse startDcdnIpaDomain(shared_ptr<StartDcdnIpaDomainRequest> request);
  StopDcdnDomainResponse stopDcdnDomainWithOptions(shared_ptr<StopDcdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopDcdnDomainResponse stopDcdnDomain(shared_ptr<StopDcdnDomainRequest> request);
  StopDcdnIpaDomainResponse stopDcdnIpaDomainWithOptions(shared_ptr<StopDcdnIpaDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopDcdnIpaDomainResponse stopDcdnIpaDomain(shared_ptr<StopDcdnIpaDomainRequest> request);
  TagDcdnResourcesResponse tagDcdnResourcesWithOptions(shared_ptr<TagDcdnResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagDcdnResourcesResponse tagDcdnResources(shared_ptr<TagDcdnResourcesRequest> request);
  UntagDcdnResourcesResponse untagDcdnResourcesWithOptions(shared_ptr<UntagDcdnResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagDcdnResourcesResponse untagDcdnResources(shared_ptr<UntagDcdnResourcesRequest> request);
  UpdateDcdnDeliverTaskResponse updateDcdnDeliverTaskWithOptions(shared_ptr<UpdateDcdnDeliverTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDcdnDeliverTaskResponse updateDcdnDeliverTask(shared_ptr<UpdateDcdnDeliverTaskRequest> request);
  UpdateDcdnDomainResponse updateDcdnDomainWithOptions(shared_ptr<UpdateDcdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDcdnDomainResponse updateDcdnDomain(shared_ptr<UpdateDcdnDomainRequest> request);
  UpdateDcdnIpaDomainResponse updateDcdnIpaDomainWithOptions(shared_ptr<UpdateDcdnIpaDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDcdnIpaDomainResponse updateDcdnIpaDomain(shared_ptr<UpdateDcdnIpaDomainRequest> request);
  UpdateDcdnSLSRealtimeLogDeliveryResponse updateDcdnSLSRealtimeLogDeliveryWithOptions(shared_ptr<UpdateDcdnSLSRealtimeLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDcdnSLSRealtimeLogDeliveryResponse updateDcdnSLSRealtimeLogDelivery(shared_ptr<UpdateDcdnSLSRealtimeLogDeliveryRequest> request);
  UpdateDcdnSubTaskResponse updateDcdnSubTaskWithOptions(shared_ptr<UpdateDcdnSubTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDcdnSubTaskResponse updateDcdnSubTask(shared_ptr<UpdateDcdnSubTaskRequest> request);
  UpdateDcdnUserRealTimeDeliveryFieldResponse updateDcdnUserRealTimeDeliveryFieldWithOptions(shared_ptr<UpdateDcdnUserRealTimeDeliveryFieldRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDcdnUserRealTimeDeliveryFieldResponse updateDcdnUserRealTimeDeliveryField(shared_ptr<UpdateDcdnUserRealTimeDeliveryFieldRequest> request);
  UploadRoutineCodeResponse uploadRoutineCodeWithOptions(shared_ptr<UploadRoutineCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadRoutineCodeResponse uploadRoutineCode(shared_ptr<UploadRoutineCodeRequest> request);
  UploadStagingRoutineCodeResponse uploadStagingRoutineCodeWithOptions(shared_ptr<UploadStagingRoutineCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadStagingRoutineCodeResponse uploadStagingRoutineCode(shared_ptr<UploadStagingRoutineCodeRequest> request);
  VerifyDcdnDomainOwnerResponse verifyDcdnDomainOwnerWithOptions(shared_ptr<VerifyDcdnDomainOwnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifyDcdnDomainOwnerResponse verifyDcdnDomainOwner(shared_ptr<VerifyDcdnDomainOwnerRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Dcdn20180115

#endif
