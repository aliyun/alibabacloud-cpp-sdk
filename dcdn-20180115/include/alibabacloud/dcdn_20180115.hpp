// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_DCDN20180115_H_
#define ALIBABACLOUD_DCDN20180115_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Dcdn20180115 {
class AddDcdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sources{};
  shared_ptr<string> checkUrl{};
  shared_ptr<string> scope{};
  shared_ptr<string> topLevelDomain{};

  AddDcdnDomainRequest() {}

  explicit AddDcdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    if (checkUrl) {
      res["CheckUrl"] = boost::any(*checkUrl);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("CheckUrl") != m.end() && !m["CheckUrl"].empty()) {
      checkUrl = make_shared<string>(boost::any_cast<string>(m["CheckUrl"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~AddDcdnDomainRequest() = default;
};
class AddDcdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddDcdnDomainResponseBody() {}

  explicit AddDcdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddDcdnDomainResponseBody() = default;
};
class AddDcdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddDcdnDomainResponseBody> body{};

  AddDcdnDomainResponse() {}

  explicit AddDcdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDcdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDcdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~AddDcdnDomainResponse() = default;
};
class AddDcdnIpaDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sources{};
  shared_ptr<string> checkUrl{};
  shared_ptr<string> scope{};
  shared_ptr<string> topLevelDomain{};
  shared_ptr<string> protocol{};

  AddDcdnIpaDomainRequest() {}

  explicit AddDcdnIpaDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    if (checkUrl) {
      res["CheckUrl"] = boost::any(*checkUrl);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("CheckUrl") != m.end() && !m["CheckUrl"].empty()) {
      checkUrl = make_shared<string>(boost::any_cast<string>(m["CheckUrl"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~AddDcdnIpaDomainRequest() = default;
};
class AddDcdnIpaDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddDcdnIpaDomainResponseBody() {}

  explicit AddDcdnIpaDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddDcdnIpaDomainResponseBody() = default;
};
class AddDcdnIpaDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddDcdnIpaDomainResponseBody> body{};

  AddDcdnIpaDomainResponse() {}

  explicit AddDcdnIpaDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDcdnIpaDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDcdnIpaDomainResponseBody>(model1);
      }
    }
  }


  virtual ~AddDcdnIpaDomainResponse() = default;
};
class BatchAddDcdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sources{};
  shared_ptr<string> checkUrl{};
  shared_ptr<string> scope{};
  shared_ptr<string> topLevelDomain{};

  BatchAddDcdnDomainRequest() {}

  explicit BatchAddDcdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    if (checkUrl) {
      res["CheckUrl"] = boost::any(*checkUrl);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("CheckUrl") != m.end() && !m["CheckUrl"].empty()) {
      checkUrl = make_shared<string>(boost::any_cast<string>(m["CheckUrl"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~BatchAddDcdnDomainRequest() = default;
};
class BatchAddDcdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchAddDcdnDomainResponseBody() {}

  explicit BatchAddDcdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchAddDcdnDomainResponseBody() = default;
};
class BatchAddDcdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchAddDcdnDomainResponseBody> body{};

  BatchAddDcdnDomainResponse() {}

  explicit BatchAddDcdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchAddDcdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchAddDcdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~BatchAddDcdnDomainResponse() = default;
};
class BatchDeleteDcdnDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainNames{};
  shared_ptr<string> functionNames{};

  BatchDeleteDcdnDomainConfigsRequest() {}

  explicit BatchDeleteDcdnDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
  }


  virtual ~BatchDeleteDcdnDomainConfigsRequest() = default;
};
class BatchDeleteDcdnDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchDeleteDcdnDomainConfigsResponseBody() {}

  explicit BatchDeleteDcdnDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchDeleteDcdnDomainConfigsResponseBody() = default;
};
class BatchDeleteDcdnDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchDeleteDcdnDomainConfigsResponseBody> body{};

  BatchDeleteDcdnDomainConfigsResponse() {}

  explicit BatchDeleteDcdnDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteDcdnDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteDcdnDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteDcdnDomainConfigsResponse() = default;
};
class BatchSetDcdnDomainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};
  shared_ptr<string> certName{};
  shared_ptr<string> certType{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> SSLPri{};
  shared_ptr<string> region{};

  BatchSetDcdnDomainCertificateRequest() {}

  explicit BatchSetDcdnDomainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (SSLPri) {
      res["SSLPri"] = boost::any(*SSLPri);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("SSLPri") != m.end() && !m["SSLPri"].empty()) {
      SSLPri = make_shared<string>(boost::any_cast<string>(m["SSLPri"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~BatchSetDcdnDomainCertificateRequest() = default;
};
class BatchSetDcdnDomainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchSetDcdnDomainCertificateResponseBody() {}

  explicit BatchSetDcdnDomainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchSetDcdnDomainCertificateResponseBody() = default;
};
class BatchSetDcdnDomainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchSetDcdnDomainCertificateResponseBody> body{};

  BatchSetDcdnDomainCertificateResponse() {}

  explicit BatchSetDcdnDomainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetDcdnDomainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetDcdnDomainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetDcdnDomainCertificateResponse() = default;
};
class BatchSetDcdnDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainNames{};
  shared_ptr<string> functions{};

  BatchSetDcdnDomainConfigsRequest() {}

  explicit BatchSetDcdnDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (functions) {
      res["Functions"] = boost::any(*functions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      functions = make_shared<string>(boost::any_cast<string>(m["Functions"]));
    }
  }


  virtual ~BatchSetDcdnDomainConfigsRequest() = default;
};
class BatchSetDcdnDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchSetDcdnDomainConfigsResponseBody() {}

  explicit BatchSetDcdnDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchSetDcdnDomainConfigsResponseBody() = default;
};
class BatchSetDcdnDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchSetDcdnDomainConfigsResponseBody> body{};

  BatchSetDcdnDomainConfigsResponse() {}

  explicit BatchSetDcdnDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetDcdnDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetDcdnDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetDcdnDomainConfigsResponse() = default;
};
class BatchSetDcdnIpaDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainNames{};
  shared_ptr<string> functions{};

  BatchSetDcdnIpaDomainConfigsRequest() {}

  explicit BatchSetDcdnIpaDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (functions) {
      res["Functions"] = boost::any(*functions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      functions = make_shared<string>(boost::any_cast<string>(m["Functions"]));
    }
  }


  virtual ~BatchSetDcdnIpaDomainConfigsRequest() = default;
};
class BatchSetDcdnIpaDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchSetDcdnIpaDomainConfigsResponseBody() {}

  explicit BatchSetDcdnIpaDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchSetDcdnIpaDomainConfigsResponseBody() = default;
};
class BatchSetDcdnIpaDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchSetDcdnIpaDomainConfigsResponseBody> body{};

  BatchSetDcdnIpaDomainConfigsResponse() {}

  explicit BatchSetDcdnIpaDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchSetDcdnIpaDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchSetDcdnIpaDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~BatchSetDcdnIpaDomainConfigsResponse() = default;
};
class BatchStartDcdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainNames{};

  BatchStartDcdnDomainRequest() {}

  explicit BatchStartDcdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
  }


  virtual ~BatchStartDcdnDomainRequest() = default;
};
class BatchStartDcdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchStartDcdnDomainResponseBody() {}

  explicit BatchStartDcdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchStartDcdnDomainResponseBody() = default;
};
class BatchStartDcdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchStartDcdnDomainResponseBody> body{};

  BatchStartDcdnDomainResponse() {}

  explicit BatchStartDcdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchStartDcdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchStartDcdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~BatchStartDcdnDomainResponse() = default;
};
class BatchStopDcdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainNames{};

  BatchStopDcdnDomainRequest() {}

  explicit BatchStopDcdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
  }


  virtual ~BatchStopDcdnDomainRequest() = default;
};
class BatchStopDcdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchStopDcdnDomainResponseBody() {}

  explicit BatchStopDcdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchStopDcdnDomainResponseBody() = default;
};
class BatchStopDcdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchStopDcdnDomainResponseBody> body{};

  BatchStopDcdnDomainResponse() {}

  explicit BatchStopDcdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchStopDcdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchStopDcdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~BatchStopDcdnDomainResponse() = default;
};
class CommitStagingRoutineCodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};
  shared_ptr<string> codeDescription{};

  CommitStagingRoutineCodeRequest() {}

  explicit CommitStagingRoutineCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (codeDescription) {
      res["CodeDescription"] = boost::any(*codeDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("CodeDescription") != m.end() && !m["CodeDescription"].empty()) {
      codeDescription = make_shared<string>(boost::any_cast<string>(m["CodeDescription"]));
    }
  }


  virtual ~CommitStagingRoutineCodeRequest() = default;
};
class CommitStagingRoutineCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  CommitStagingRoutineCodeResponseBody() {}

  explicit CommitStagingRoutineCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CommitStagingRoutineCodeResponseBody() = default;
};
class CommitStagingRoutineCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CommitStagingRoutineCodeResponseBody> body{};

  CommitStagingRoutineCodeResponse() {}

  explicit CommitStagingRoutineCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CommitStagingRoutineCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CommitStagingRoutineCodeResponseBody>(model1);
      }
    }
  }


  virtual ~CommitStagingRoutineCodeResponse() = default;
};
class CreateDcdnCertificateSigningRequestRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> commonName{};
  shared_ptr<string> SANs{};
  shared_ptr<string> organization{};
  shared_ptr<string> organizationUnit{};
  shared_ptr<string> country{};
  shared_ptr<string> state{};
  shared_ptr<string> city{};
  shared_ptr<string> email{};

  CreateDcdnCertificateSigningRequestRequest() {}

  explicit CreateDcdnCertificateSigningRequestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (SANs) {
      res["SANs"] = boost::any(*SANs);
    }
    if (organization) {
      res["Organization"] = boost::any(*organization);
    }
    if (organizationUnit) {
      res["OrganizationUnit"] = boost::any(*organizationUnit);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("SANs") != m.end() && !m["SANs"].empty()) {
      SANs = make_shared<string>(boost::any_cast<string>(m["SANs"]));
    }
    if (m.find("Organization") != m.end() && !m["Organization"].empty()) {
      organization = make_shared<string>(boost::any_cast<string>(m["Organization"]));
    }
    if (m.find("OrganizationUnit") != m.end() && !m["OrganizationUnit"].empty()) {
      organizationUnit = make_shared<string>(boost::any_cast<string>(m["OrganizationUnit"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
  }


  virtual ~CreateDcdnCertificateSigningRequestRequest() = default;
};
class CreateDcdnCertificateSigningRequestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> pubMd5{};
  shared_ptr<string> csr{};
  shared_ptr<string> commonName{};

  CreateDcdnCertificateSigningRequestResponseBody() {}

  explicit CreateDcdnCertificateSigningRequestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pubMd5) {
      res["PubMd5"] = boost::any(*pubMd5);
    }
    if (csr) {
      res["Csr"] = boost::any(*csr);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PubMd5") != m.end() && !m["PubMd5"].empty()) {
      pubMd5 = make_shared<string>(boost::any_cast<string>(m["PubMd5"]));
    }
    if (m.find("Csr") != m.end() && !m["Csr"].empty()) {
      csr = make_shared<string>(boost::any_cast<string>(m["Csr"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
  }


  virtual ~CreateDcdnCertificateSigningRequestResponseBody() = default;
};
class CreateDcdnCertificateSigningRequestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDcdnCertificateSigningRequestResponseBody> body{};

  CreateDcdnCertificateSigningRequestResponse() {}

  explicit CreateDcdnCertificateSigningRequestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDcdnCertificateSigningRequestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDcdnCertificateSigningRequestResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDcdnCertificateSigningRequestResponse() = default;
};
class CreateDcdnDeliverTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> reports{};
  shared_ptr<string> domainName{};
  shared_ptr<map<string, boost::any>> deliver{};
  shared_ptr<map<string, boost::any>> schedule{};

  CreateDcdnDeliverTaskRequest() {}

  explicit CreateDcdnDeliverTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (reports) {
      res["Reports"] = boost::any(*reports);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (deliver) {
      res["Deliver"] = boost::any(*deliver);
    }
    if (schedule) {
      res["Schedule"] = boost::any(*schedule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Reports") != m.end() && !m["Reports"].empty()) {
      reports = make_shared<string>(boost::any_cast<string>(m["Reports"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Deliver") != m.end() && !m["Deliver"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Deliver"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      deliver = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Schedule") != m.end() && !m["Schedule"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Schedule"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      schedule = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~CreateDcdnDeliverTaskRequest() = default;
};
class CreateDcdnDeliverTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> reports{};
  shared_ptr<string> domainName{};
  shared_ptr<string> deliverShrink{};
  shared_ptr<string> scheduleShrink{};

  CreateDcdnDeliverTaskShrinkRequest() {}

  explicit CreateDcdnDeliverTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (reports) {
      res["Reports"] = boost::any(*reports);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (deliverShrink) {
      res["Deliver"] = boost::any(*deliverShrink);
    }
    if (scheduleShrink) {
      res["Schedule"] = boost::any(*scheduleShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Reports") != m.end() && !m["Reports"].empty()) {
      reports = make_shared<string>(boost::any_cast<string>(m["Reports"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Deliver") != m.end() && !m["Deliver"].empty()) {
      deliverShrink = make_shared<string>(boost::any_cast<string>(m["Deliver"]));
    }
    if (m.find("Schedule") != m.end() && !m["Schedule"].empty()) {
      scheduleShrink = make_shared<string>(boost::any_cast<string>(m["Schedule"]));
    }
  }


  virtual ~CreateDcdnDeliverTaskShrinkRequest() = default;
};
class CreateDcdnDeliverTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateDcdnDeliverTaskResponseBody() {}

  explicit CreateDcdnDeliverTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDcdnDeliverTaskResponseBody() = default;
};
class CreateDcdnDeliverTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDcdnDeliverTaskResponseBody> body{};

  CreateDcdnDeliverTaskResponse() {}

  explicit CreateDcdnDeliverTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDcdnDeliverTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDcdnDeliverTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDcdnDeliverTaskResponse() = default;
};
class CreateDcdnDomainOfflineLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> fieldId{};

  CreateDcdnDomainOfflineLogDeliveryRequest() {}

  explicit CreateDcdnDomainOfflineLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (fieldId) {
      res["FieldId"] = boost::any(*fieldId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("FieldId") != m.end() && !m["FieldId"].empty()) {
      fieldId = make_shared<string>(boost::any_cast<string>(m["FieldId"]));
    }
  }


  virtual ~CreateDcdnDomainOfflineLogDeliveryRequest() = default;
};
class CreateDcdnDomainOfflineLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateDcdnDomainOfflineLogDeliveryResponseBody() {}

  explicit CreateDcdnDomainOfflineLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDcdnDomainOfflineLogDeliveryResponseBody() = default;
};
class CreateDcdnDomainOfflineLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDcdnDomainOfflineLogDeliveryResponseBody> body{};

  CreateDcdnDomainOfflineLogDeliveryResponse() {}

  explicit CreateDcdnDomainOfflineLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDcdnDomainOfflineLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDcdnDomainOfflineLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDcdnDomainOfflineLogDeliveryResponse() = default;
};
class CreateDcdnSubTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> status{};
  shared_ptr<string> reportIds{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  CreateDcdnSubTaskRequest() {}

  explicit CreateDcdnSubTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (reportIds) {
      res["ReportIds"] = boost::any(*reportIds);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ReportIds") != m.end() && !m["ReportIds"].empty()) {
      reportIds = make_shared<string>(boost::any_cast<string>(m["ReportIds"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~CreateDcdnSubTaskRequest() = default;
};
class CreateDcdnSubTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateDcdnSubTaskResponseBody() {}

  explicit CreateDcdnSubTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDcdnSubTaskResponseBody() = default;
};
class CreateDcdnSubTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDcdnSubTaskResponseBody> body{};

  CreateDcdnSubTaskResponse() {}

  explicit CreateDcdnSubTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDcdnSubTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDcdnSubTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDcdnSubTaskResponse() = default;
};
class CreateRoutineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> envConf{};

  CreateRoutineRequest() {}

  explicit CreateRoutineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envConf) {
      res["EnvConf"] = boost::any(*envConf);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["EnvConf"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      envConf = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~CreateRoutineRequest() = default;
};
class CreateRoutineShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> envConfShrink{};

  CreateRoutineShrinkRequest() {}

  explicit CreateRoutineShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envConfShrink) {
      res["EnvConf"] = boost::any(*envConfShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      envConfShrink = make_shared<string>(boost::any_cast<string>(m["EnvConf"]));
    }
  }


  virtual ~CreateRoutineShrinkRequest() = default;
};
class CreateRoutineResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  CreateRoutineResponseBody() {}

  explicit CreateRoutineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateRoutineResponseBody() = default;
};
class CreateRoutineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateRoutineResponseBody> body{};

  CreateRoutineResponse() {}

  explicit CreateRoutineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRoutineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRoutineResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRoutineResponse() = default;
};
class DeleteDcdnDeliverTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> deliverId{};

  DeleteDcdnDeliverTaskRequest() {}

  explicit DeleteDcdnDeliverTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (deliverId) {
      res["DeliverId"] = boost::any(*deliverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DeliverId") != m.end() && !m["DeliverId"].empty()) {
      deliverId = make_shared<long>(boost::any_cast<long>(m["DeliverId"]));
    }
  }


  virtual ~DeleteDcdnDeliverTaskRequest() = default;
};
class DeleteDcdnDeliverTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnDeliverTaskResponseBody() {}

  explicit DeleteDcdnDeliverTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnDeliverTaskResponseBody() = default;
};
class DeleteDcdnDeliverTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDcdnDeliverTaskResponseBody> body{};

  DeleteDcdnDeliverTaskResponse() {}

  explicit DeleteDcdnDeliverTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnDeliverTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnDeliverTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnDeliverTaskResponse() = default;
};
class DeleteDcdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};

  DeleteDcdnDomainRequest() {}

  explicit DeleteDcdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DeleteDcdnDomainRequest() = default;
};
class DeleteDcdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnDomainResponseBody() {}

  explicit DeleteDcdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnDomainResponseBody() = default;
};
class DeleteDcdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDcdnDomainResponseBody> body{};

  DeleteDcdnDomainResponse() {}

  explicit DeleteDcdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnDomainResponse() = default;
};
class DeleteDcdnIpaDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};

  DeleteDcdnIpaDomainRequest() {}

  explicit DeleteDcdnIpaDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DeleteDcdnIpaDomainRequest() = default;
};
class DeleteDcdnIpaDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnIpaDomainResponseBody() {}

  explicit DeleteDcdnIpaDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnIpaDomainResponseBody() = default;
};
class DeleteDcdnIpaDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDcdnIpaDomainResponseBody> body{};

  DeleteDcdnIpaDomainResponse() {}

  explicit DeleteDcdnIpaDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnIpaDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnIpaDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnIpaDomainResponse() = default;
};
class DeleteDcdnIpaSpecificConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};
  shared_ptr<string> configId{};

  DeleteDcdnIpaSpecificConfigRequest() {}

  explicit DeleteDcdnIpaSpecificConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
  }


  virtual ~DeleteDcdnIpaSpecificConfigRequest() = default;
};
class DeleteDcdnIpaSpecificConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnIpaSpecificConfigResponseBody() {}

  explicit DeleteDcdnIpaSpecificConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnIpaSpecificConfigResponseBody() = default;
};
class DeleteDcdnIpaSpecificConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDcdnIpaSpecificConfigResponseBody> body{};

  DeleteDcdnIpaSpecificConfigResponse() {}

  explicit DeleteDcdnIpaSpecificConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnIpaSpecificConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnIpaSpecificConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnIpaSpecificConfigResponse() = default;
};
class DeleteDcdnSpecificConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};
  shared_ptr<string> configId{};

  DeleteDcdnSpecificConfigRequest() {}

  explicit DeleteDcdnSpecificConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
  }


  virtual ~DeleteDcdnSpecificConfigRequest() = default;
};
class DeleteDcdnSpecificConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnSpecificConfigResponseBody() {}

  explicit DeleteDcdnSpecificConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnSpecificConfigResponseBody() = default;
};
class DeleteDcdnSpecificConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDcdnSpecificConfigResponseBody> body{};

  DeleteDcdnSpecificConfigResponse() {}

  explicit DeleteDcdnSpecificConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnSpecificConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnSpecificConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnSpecificConfigResponse() = default;
};
class DeleteDcdnSpecificStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};
  shared_ptr<string> configId{};

  DeleteDcdnSpecificStagingConfigRequest() {}

  explicit DeleteDcdnSpecificStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
  }


  virtual ~DeleteDcdnSpecificStagingConfigRequest() = default;
};
class DeleteDcdnSpecificStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnSpecificStagingConfigResponseBody() {}

  explicit DeleteDcdnSpecificStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnSpecificStagingConfigResponseBody() = default;
};
class DeleteDcdnSpecificStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDcdnSpecificStagingConfigResponseBody> body{};

  DeleteDcdnSpecificStagingConfigResponse() {}

  explicit DeleteDcdnSpecificStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnSpecificStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnSpecificStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnSpecificStagingConfigResponse() = default;
};
class DeleteDcdnSubTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  DeleteDcdnSubTaskRequest() {}

  explicit DeleteDcdnSubTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DeleteDcdnSubTaskRequest() = default;
};
class DeleteDcdnSubTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDcdnSubTaskResponseBody() {}

  explicit DeleteDcdnSubTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDcdnSubTaskResponseBody() = default;
};
class DeleteDcdnSubTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDcdnSubTaskResponseBody> body{};

  DeleteDcdnSubTaskResponse() {}

  explicit DeleteDcdnSubTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDcdnSubTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDcdnSubTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDcdnSubTaskResponse() = default;
};
class DeleteRoutineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};

  DeleteRoutineRequest() {}

  explicit DeleteRoutineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DeleteRoutineRequest() = default;
};
class DeleteRoutineResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DeleteRoutineResponseBody() {}

  explicit DeleteRoutineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRoutineResponseBody() = default;
};
class DeleteRoutineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteRoutineResponseBody> body{};

  DeleteRoutineResponse() {}

  explicit DeleteRoutineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRoutineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRoutineResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRoutineResponse() = default;
};
class DeleteRoutineCodeRevisionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};
  shared_ptr<string> selectCodeRevision{};

  DeleteRoutineCodeRevisionRequest() {}

  explicit DeleteRoutineCodeRevisionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (selectCodeRevision) {
      res["SelectCodeRevision"] = boost::any(*selectCodeRevision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SelectCodeRevision") != m.end() && !m["SelectCodeRevision"].empty()) {
      selectCodeRevision = make_shared<string>(boost::any_cast<string>(m["SelectCodeRevision"]));
    }
  }


  virtual ~DeleteRoutineCodeRevisionRequest() = default;
};
class DeleteRoutineCodeRevisionResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DeleteRoutineCodeRevisionResponseBody() {}

  explicit DeleteRoutineCodeRevisionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRoutineCodeRevisionResponseBody() = default;
};
class DeleteRoutineCodeRevisionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteRoutineCodeRevisionResponseBody> body{};

  DeleteRoutineCodeRevisionResponse() {}

  explicit DeleteRoutineCodeRevisionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRoutineCodeRevisionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRoutineCodeRevisionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRoutineCodeRevisionResponse() = default;
};
class DeleteRoutineConfEnvsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};
  shared_ptr<map<string, boost::any>> envs{};

  DeleteRoutineConfEnvsRequest() {}

  explicit DeleteRoutineConfEnvsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Envs"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      envs = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DeleteRoutineConfEnvsRequest() = default;
};
class DeleteRoutineConfEnvsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};
  shared_ptr<string> envsShrink{};

  DeleteRoutineConfEnvsShrinkRequest() {}

  explicit DeleteRoutineConfEnvsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (envsShrink) {
      res["Envs"] = boost::any(*envsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envsShrink = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
  }


  virtual ~DeleteRoutineConfEnvsShrinkRequest() = default;
};
class DeleteRoutineConfEnvsResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DeleteRoutineConfEnvsResponseBody() {}

  explicit DeleteRoutineConfEnvsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRoutineConfEnvsResponseBody() = default;
};
class DeleteRoutineConfEnvsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteRoutineConfEnvsResponseBody> body{};

  DeleteRoutineConfEnvsResponse() {}

  explicit DeleteRoutineConfEnvsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRoutineConfEnvsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRoutineConfEnvsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRoutineConfEnvsResponse() = default;
};
class DescribeDcdnBgpBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> isp{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};

  DescribeDcdnBgpBpsDataRequest() {}

  explicit DescribeDcdnBgpBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
  }


  virtual ~DescribeDcdnBgpBpsDataRequest() = default;
};
class DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval : public Darabonba::Model {
public:
  shared_ptr<double> out{};
  shared_ptr<double> in{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval() {}

  explicit DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (out) {
      res["Out"] = boost::any(*out);
    }
    if (in) {
      res["In"] = boost::any(*in);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Out") != m.end() && !m["Out"].empty()) {
      out = make_shared<double>(boost::any_cast<double>(m["Out"]));
    }
    if (m.find("In") != m.end() && !m["In"].empty()) {
      in = make_shared<double>(boost::any_cast<double>(m["In"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval() = default;
};
class DescribeDcdnBgpBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval>> bgpDataInterval{};

  DescribeDcdnBgpBpsDataResponseBody() {}

  explicit DescribeDcdnBgpBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (bgpDataInterval) {
      vector<boost::any> temp1;
      for(auto item1:*bgpDataInterval){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BgpDataInterval"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("BgpDataInterval") != m.end() && !m["BgpDataInterval"].empty()) {
      if (typeid(vector<boost::any>) == m["BgpDataInterval"].type()) {
        vector<DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BgpDataInterval"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bgpDataInterval = make_shared<vector<DescribeDcdnBgpBpsDataResponseBodyBgpDataInterval>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnBgpBpsDataResponseBody() = default;
};
class DescribeDcdnBgpBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnBgpBpsDataResponseBody> body{};

  DescribeDcdnBgpBpsDataResponse() {}

  explicit DescribeDcdnBgpBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnBgpBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnBgpBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnBgpBpsDataResponse() = default;
};
class DescribeDcdnBgpTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> isp{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};

  DescribeDcdnBgpTrafficDataRequest() {}

  explicit DescribeDcdnBgpTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
  }


  virtual ~DescribeDcdnBgpTrafficDataRequest() = default;
};
class DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval : public Darabonba::Model {
public:
  shared_ptr<long> out{};
  shared_ptr<long> in{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval() {}

  explicit DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (out) {
      res["Out"] = boost::any(*out);
    }
    if (in) {
      res["In"] = boost::any(*in);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Out") != m.end() && !m["Out"].empty()) {
      out = make_shared<long>(boost::any_cast<long>(m["Out"]));
    }
    if (m.find("In") != m.end() && !m["In"].empty()) {
      in = make_shared<long>(boost::any_cast<long>(m["In"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval() = default;
};
class DescribeDcdnBgpTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval>> bgpDataInterval{};

  DescribeDcdnBgpTrafficDataResponseBody() {}

  explicit DescribeDcdnBgpTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (bgpDataInterval) {
      vector<boost::any> temp1;
      for(auto item1:*bgpDataInterval){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BgpDataInterval"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("BgpDataInterval") != m.end() && !m["BgpDataInterval"].empty()) {
      if (typeid(vector<boost::any>) == m["BgpDataInterval"].type()) {
        vector<DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BgpDataInterval"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bgpDataInterval = make_shared<vector<DescribeDcdnBgpTrafficDataResponseBodyBgpDataInterval>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnBgpTrafficDataResponseBody() = default;
};
class DescribeDcdnBgpTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnBgpTrafficDataResponseBody> body{};

  DescribeDcdnBgpTrafficDataResponse() {}

  explicit DescribeDcdnBgpTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnBgpTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnBgpTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnBgpTrafficDataResponse() = default;
};
class DescribeDcdnBlockedRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> language{};

  DescribeDcdnBlockedRegionsRequest() {}

  explicit DescribeDcdnBlockedRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
  }


  virtual ~DescribeDcdnBlockedRegionsRequest() = default;
};
class DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem : public Darabonba::Model {
public:
  shared_ptr<string> countriesAndRegions{};
  shared_ptr<string> continent{};
  shared_ptr<string> countriesAndRegionsName{};

  DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem() {}

  explicit DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (countriesAndRegions) {
      res["CountriesAndRegions"] = boost::any(*countriesAndRegions);
    }
    if (continent) {
      res["Continent"] = boost::any(*continent);
    }
    if (countriesAndRegionsName) {
      res["CountriesAndRegionsName"] = boost::any(*countriesAndRegionsName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CountriesAndRegions") != m.end() && !m["CountriesAndRegions"].empty()) {
      countriesAndRegions = make_shared<string>(boost::any_cast<string>(m["CountriesAndRegions"]));
    }
    if (m.find("Continent") != m.end() && !m["Continent"].empty()) {
      continent = make_shared<string>(boost::any_cast<string>(m["Continent"]));
    }
    if (m.find("CountriesAndRegionsName") != m.end() && !m["CountriesAndRegionsName"].empty()) {
      countriesAndRegionsName = make_shared<string>(boost::any_cast<string>(m["CountriesAndRegionsName"]));
    }
  }


  virtual ~DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem() = default;
};
class DescribeDcdnBlockedRegionsResponseBodyInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem>> infoItem{};

  DescribeDcdnBlockedRegionsResponseBodyInfoList() {}

  explicit DescribeDcdnBlockedRegionsResponseBodyInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (infoItem) {
      vector<boost::any> temp1;
      for(auto item1:*infoItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InfoItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InfoItem") != m.end() && !m["InfoItem"].empty()) {
      if (typeid(vector<boost::any>) == m["InfoItem"].type()) {
        vector<DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InfoItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        infoItem = make_shared<vector<DescribeDcdnBlockedRegionsResponseBodyInfoListInfoItem>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnBlockedRegionsResponseBodyInfoList() = default;
};
class DescribeDcdnBlockedRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnBlockedRegionsResponseBodyInfoList> infoList{};

  DescribeDcdnBlockedRegionsResponseBody() {}

  explicit DescribeDcdnBlockedRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (infoList) {
      res["InfoList"] = infoList ? boost::any(infoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InfoList") != m.end() && !m["InfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["InfoList"].type()) {
        DescribeDcdnBlockedRegionsResponseBodyInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InfoList"]));
        infoList = make_shared<DescribeDcdnBlockedRegionsResponseBodyInfoList>(model1);
      }
    }
  }


  virtual ~DescribeDcdnBlockedRegionsResponseBody() = default;
};
class DescribeDcdnBlockedRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnBlockedRegionsResponseBody> body{};

  DescribeDcdnBlockedRegionsResponse() {}

  explicit DescribeDcdnBlockedRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnBlockedRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnBlockedRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnBlockedRegionsResponse() = default;
};
class DescribeDcdnCertificateDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> certName{};

  DescribeDcdnCertificateDetailRequest() {}

  explicit DescribeDcdnCertificateDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
  }


  virtual ~DescribeDcdnCertificateDetailRequest() = default;
};
class DescribeDcdnCertificateDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> key{};
  shared_ptr<string> cert{};
  shared_ptr<long> certId{};
  shared_ptr<string> requestId{};

  DescribeDcdnCertificateDetailResponseBody() {}

  explicit DescribeDcdnCertificateDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (cert) {
      res["Cert"] = boost::any(*cert);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Cert") != m.end() && !m["Cert"].empty()) {
      cert = make_shared<string>(boost::any_cast<string>(m["Cert"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnCertificateDetailResponseBody() = default;
};
class DescribeDcdnCertificateDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnCertificateDetailResponseBody> body{};

  DescribeDcdnCertificateDetailResponse() {}

  explicit DescribeDcdnCertificateDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnCertificateDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnCertificateDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnCertificateDetailResponse() = default;
};
class DescribeDcdnCertificateListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};

  DescribeDcdnCertificateListRequest() {}

  explicit DescribeDcdnCertificateListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnCertificateListRequest() = default;
};
class DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert : public Darabonba::Model {
public:
  shared_ptr<long> lastTime{};
  shared_ptr<string> fingerprint{};
  shared_ptr<string> certName{};
  shared_ptr<string> issuer{};
  shared_ptr<long> certId{};
  shared_ptr<string> common{};

  DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert() {}

  explicit DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lastTime) {
      res["LastTime"] = boost::any(*lastTime);
    }
    if (fingerprint) {
      res["Fingerprint"] = boost::any(*fingerprint);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (common) {
      res["Common"] = boost::any(*common);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LastTime") != m.end() && !m["LastTime"].empty()) {
      lastTime = make_shared<long>(boost::any_cast<long>(m["LastTime"]));
    }
    if (m.find("Fingerprint") != m.end() && !m["Fingerprint"].empty()) {
      fingerprint = make_shared<string>(boost::any_cast<string>(m["Fingerprint"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("Common") != m.end() && !m["Common"].empty()) {
      common = make_shared<string>(boost::any_cast<string>(m["Common"]));
    }
  }


  virtual ~DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert() = default;
};
class DescribeDcdnCertificateListResponseBodyCertificateListModelCertList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert>> cert{};

  DescribeDcdnCertificateListResponseBodyCertificateListModelCertList() {}

  explicit DescribeDcdnCertificateListResponseBodyCertificateListModelCertList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cert) {
      vector<boost::any> temp1;
      for(auto item1:*cert){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cert"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cert") != m.end() && !m["Cert"].empty()) {
      if (typeid(vector<boost::any>) == m["Cert"].type()) {
        vector<DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cert"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cert = make_shared<vector<DescribeDcdnCertificateListResponseBodyCertificateListModelCertListCert>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnCertificateListResponseBodyCertificateListModelCertList() = default;
};
class DescribeDcdnCertificateListResponseBodyCertificateListModel : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<DescribeDcdnCertificateListResponseBodyCertificateListModelCertList> certList{};

  DescribeDcdnCertificateListResponseBodyCertificateListModel() {}

  explicit DescribeDcdnCertificateListResponseBodyCertificateListModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (certList) {
      res["CertList"] = certList ? boost::any(certList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CertList") != m.end() && !m["CertList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertList"].type()) {
        DescribeDcdnCertificateListResponseBodyCertificateListModelCertList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertList"]));
        certList = make_shared<DescribeDcdnCertificateListResponseBodyCertificateListModelCertList>(model1);
      }
    }
  }


  virtual ~DescribeDcdnCertificateListResponseBodyCertificateListModel() = default;
};
class DescribeDcdnCertificateListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnCertificateListResponseBodyCertificateListModel> certificateListModel{};

  DescribeDcdnCertificateListResponseBody() {}

  explicit DescribeDcdnCertificateListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (certificateListModel) {
      res["CertificateListModel"] = certificateListModel ? boost::any(certificateListModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CertificateListModel") != m.end() && !m["CertificateListModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertificateListModel"].type()) {
        DescribeDcdnCertificateListResponseBodyCertificateListModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertificateListModel"]));
        certificateListModel = make_shared<DescribeDcdnCertificateListResponseBodyCertificateListModel>(model1);
      }
    }
  }


  virtual ~DescribeDcdnCertificateListResponseBody() = default;
};
class DescribeDcdnCertificateListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnCertificateListResponseBody> body{};

  DescribeDcdnCertificateListResponse() {}

  explicit DescribeDcdnCertificateListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnCertificateListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnCertificateListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnCertificateListResponse() = default;
};
class DescribeDcdnConfigOfVersionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> versionId{};
  shared_ptr<long> functionId{};
  shared_ptr<string> functionName{};
  shared_ptr<long> groupId{};

  DescribeDcdnConfigOfVersionRequest() {}

  explicit DescribeDcdnConfigOfVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (functionId) {
      res["FunctionId"] = boost::any(*functionId);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("FunctionId") != m.end() && !m["FunctionId"].empty()) {
      functionId = make_shared<long>(boost::any_cast<long>(m["FunctionId"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
  }


  virtual ~DescribeDcdnConfigOfVersionRequest() = default;
};
class DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgsFunctionArg : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};

  DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgsFunctionArg() {}

  explicit DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgsFunctionArg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
  }


  virtual ~DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgsFunctionArg() = default;
};
class DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgsFunctionArg>> functionArg{};

  DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgs() {}

  explicit DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionArg) {
      vector<boost::any> temp1;
      for(auto item1:*functionArg){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FunctionArg"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionArg") != m.end() && !m["FunctionArg"].empty()) {
      if (typeid(vector<boost::any>) == m["FunctionArg"].type()) {
        vector<DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgsFunctionArg> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FunctionArg"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgsFunctionArg model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functionArg = make_shared<vector<DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgsFunctionArg>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgs() = default;
};
class DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfig : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> configId{};
  shared_ptr<string> functionName{};
  shared_ptr<DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgs> functionArgs{};

  DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfig() {}

  explicit DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (functionArgs) {
      res["FunctionArgs"] = functionArgs ? boost::any(functionArgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionArgs"].type()) {
        DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionArgs"]));
        functionArgs = make_shared<DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfigFunctionArgs>(model1);
      }
    }
  }


  virtual ~DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfig() = default;
};
class DescribeDcdnConfigOfVersionResponseBodyVersionConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfig>> versionConfig{};

  DescribeDcdnConfigOfVersionResponseBodyVersionConfigs() {}

  explicit DescribeDcdnConfigOfVersionResponseBodyVersionConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (versionConfig) {
      vector<boost::any> temp1;
      for(auto item1:*versionConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VersionConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VersionConfig") != m.end() && !m["VersionConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["VersionConfig"].type()) {
        vector<DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VersionConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        versionConfig = make_shared<vector<DescribeDcdnConfigOfVersionResponseBodyVersionConfigsVersionConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnConfigOfVersionResponseBodyVersionConfigs() = default;
};
class DescribeDcdnConfigOfVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnConfigOfVersionResponseBodyVersionConfigs> versionConfigs{};

  DescribeDcdnConfigOfVersionResponseBody() {}

  explicit DescribeDcdnConfigOfVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (versionConfigs) {
      res["VersionConfigs"] = versionConfigs ? boost::any(versionConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VersionConfigs") != m.end() && !m["VersionConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["VersionConfigs"].type()) {
        DescribeDcdnConfigOfVersionResponseBodyVersionConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VersionConfigs"]));
        versionConfigs = make_shared<DescribeDcdnConfigOfVersionResponseBodyVersionConfigs>(model1);
      }
    }
  }


  virtual ~DescribeDcdnConfigOfVersionResponseBody() = default;
};
class DescribeDcdnConfigOfVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnConfigOfVersionResponseBody> body{};

  DescribeDcdnConfigOfVersionResponse() {}

  explicit DescribeDcdnConfigOfVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnConfigOfVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnConfigOfVersionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnConfigOfVersionResponse() = default;
};
class DescribeDcdnDeliverListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> deliverId{};
  shared_ptr<string> status{};

  DescribeDcdnDeliverListRequest() {}

  explicit DescribeDcdnDeliverListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (deliverId) {
      res["DeliverId"] = boost::any(*deliverId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DeliverId") != m.end() && !m["DeliverId"].empty()) {
      deliverId = make_shared<long>(boost::any_cast<long>(m["DeliverId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDcdnDeliverListRequest() = default;
};
class DescribeDcdnDeliverListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnDeliverListResponseBody() {}

  explicit DescribeDcdnDeliverListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDeliverListResponseBody() = default;
};
class DescribeDcdnDeliverListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDeliverListResponseBody> body{};

  DescribeDcdnDeliverListResponse() {}

  explicit DescribeDcdnDeliverListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDeliverListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDeliverListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDeliverListResponse() = default;
};
class DescribeDcdnDomainBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};

  DescribeDcdnDomainBpsDataRequest() {}

  explicit DescribeDcdnDomainBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
  }


  virtual ~DescribeDcdnDomainBpsDataRequest() = default;
};
class DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<double> staticHttpsBps{};
  shared_ptr<double> bps{};
  shared_ptr<double> dynamicHttpsBps{};
  shared_ptr<double> dynamicHttpBps{};
  shared_ptr<double> staticHttpBps{};

  DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (staticHttpsBps) {
      res["StaticHttpsBps"] = boost::any(*staticHttpsBps);
    }
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (dynamicHttpsBps) {
      res["DynamicHttpsBps"] = boost::any(*dynamicHttpsBps);
    }
    if (dynamicHttpBps) {
      res["DynamicHttpBps"] = boost::any(*dynamicHttpBps);
    }
    if (staticHttpBps) {
      res["StaticHttpBps"] = boost::any(*staticHttpBps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("StaticHttpsBps") != m.end() && !m["StaticHttpsBps"].empty()) {
      staticHttpsBps = make_shared<double>(boost::any_cast<double>(m["StaticHttpsBps"]));
    }
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<double>(boost::any_cast<double>(m["Bps"]));
    }
    if (m.find("DynamicHttpsBps") != m.end() && !m["DynamicHttpsBps"].empty()) {
      dynamicHttpsBps = make_shared<double>(boost::any_cast<double>(m["DynamicHttpsBps"]));
    }
    if (m.find("DynamicHttpBps") != m.end() && !m["DynamicHttpBps"].empty()) {
      dynamicHttpBps = make_shared<double>(boost::any_cast<double>(m["DynamicHttpBps"]));
    }
    if (m.find("StaticHttpBps") != m.end() && !m["StaticHttpBps"].empty()) {
      staticHttpBps = make_shared<double>(boost::any_cast<double>(m["StaticHttpBps"]));
    }
  }


  virtual ~DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval() {}

  explicit DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainBpsDataResponseBodyBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval() = default;
};
class DescribeDcdnDomainBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval> bpsDataPerInterval{};

  DescribeDcdnDomainBpsDataResponseBody() {}

  explicit DescribeDcdnDomainBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (bpsDataPerInterval) {
      res["BpsDataPerInterval"] = bpsDataPerInterval ? boost::any(bpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("BpsDataPerInterval") != m.end() && !m["BpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataPerInterval"].type()) {
        DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataPerInterval"]));
        bpsDataPerInterval = make_shared<DescribeDcdnDomainBpsDataResponseBodyBpsDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainBpsDataResponseBody() = default;
};
class DescribeDcdnDomainBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainBpsDataResponseBody> body{};

  DescribeDcdnDomainBpsDataResponse() {}

  explicit DescribeDcdnDomainBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainBpsDataResponse() = default;
};
class DescribeDcdnDomainByCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> SSLPub{};

  DescribeDcdnDomainByCertificateRequest() {}

  explicit DescribeDcdnDomainByCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
  }


  virtual ~DescribeDcdnDomainByCertificateRequest() = default;
};
class DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> certStartTime{};
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certCaIsLegacy{};
  shared_ptr<string> certSubjectCommonName{};
  shared_ptr<string> certType{};
  shared_ptr<string> domainNames{};
  shared_ptr<string> certExpired{};
  shared_ptr<string> issuer{};
  shared_ptr<string> domainList{};

  DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo() {}

  explicit DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certStartTime) {
      res["CertStartTime"] = boost::any(*certStartTime);
    }
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certCaIsLegacy) {
      res["CertCaIsLegacy"] = boost::any(*certCaIsLegacy);
    }
    if (certSubjectCommonName) {
      res["CertSubjectCommonName"] = boost::any(*certSubjectCommonName);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (certExpired) {
      res["CertExpired"] = boost::any(*certExpired);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (domainList) {
      res["DomainList"] = boost::any(*domainList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertStartTime") != m.end() && !m["CertStartTime"].empty()) {
      certStartTime = make_shared<string>(boost::any_cast<string>(m["CertStartTime"]));
    }
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertCaIsLegacy") != m.end() && !m["CertCaIsLegacy"].empty()) {
      certCaIsLegacy = make_shared<string>(boost::any_cast<string>(m["CertCaIsLegacy"]));
    }
    if (m.find("CertSubjectCommonName") != m.end() && !m["CertSubjectCommonName"].empty()) {
      certSubjectCommonName = make_shared<string>(boost::any_cast<string>(m["CertSubjectCommonName"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("CertExpired") != m.end() && !m["CertExpired"].empty()) {
      certExpired = make_shared<string>(boost::any_cast<string>(m["CertExpired"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("DomainList") != m.end() && !m["DomainList"].empty()) {
      domainList = make_shared<string>(boost::any_cast<string>(m["DomainList"]));
    }
  }


  virtual ~DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo() = default;
};
class DescribeDcdnDomainByCertificateResponseBodyCertInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo>> certInfo{};

  DescribeDcdnDomainByCertificateResponseBodyCertInfos() {}

  explicit DescribeDcdnDomainByCertificateResponseBodyCertInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfo) {
      vector<boost::any> temp1;
      for(auto item1:*certInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CertInfo"].type()) {
        vector<DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certInfo = make_shared<vector<DescribeDcdnDomainByCertificateResponseBodyCertInfosCertInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainByCertificateResponseBodyCertInfos() = default;
};
class DescribeDcdnDomainByCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnDomainByCertificateResponseBodyCertInfos> certInfos{};

  DescribeDcdnDomainByCertificateResponseBody() {}

  explicit DescribeDcdnDomainByCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (certInfos) {
      res["CertInfos"] = certInfos ? boost::any(certInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CertInfos") != m.end() && !m["CertInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertInfos"].type()) {
        DescribeDcdnDomainByCertificateResponseBodyCertInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertInfos"]));
        certInfos = make_shared<DescribeDcdnDomainByCertificateResponseBodyCertInfos>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainByCertificateResponseBody() = default;
};
class DescribeDcdnDomainByCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainByCertificateResponseBody> body{};

  DescribeDcdnDomainByCertificateResponse() {}

  explicit DescribeDcdnDomainByCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainByCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainByCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainByCertificateResponse() = default;
};
class DescribeDcdnDomainCertificateInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};

  DescribeDcdnDomainCertificateInfoRequest() {}

  explicit DescribeDcdnDomainCertificateInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnDomainCertificateInfoRequest() = default;
};
class DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> certLife{};
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> certType{};
  shared_ptr<string> certDomainName{};
  shared_ptr<string> certName{};
  shared_ptr<string> certOrg{};
  shared_ptr<string> domainName{};

  DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo() {}

  explicit DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (certLife) {
      res["CertLife"] = boost::any(*certLife);
    }
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (certDomainName) {
      res["CertDomainName"] = boost::any(*certDomainName);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certOrg) {
      res["CertOrg"] = boost::any(*certOrg);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CertLife") != m.end() && !m["CertLife"].empty()) {
      certLife = make_shared<string>(boost::any_cast<string>(m["CertLife"]));
    }
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("CertDomainName") != m.end() && !m["CertDomainName"].empty()) {
      certDomainName = make_shared<string>(boost::any_cast<string>(m["CertDomainName"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertOrg") != m.end() && !m["CertOrg"].empty()) {
      certOrg = make_shared<string>(boost::any_cast<string>(m["CertOrg"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo() = default;
};
class DescribeDcdnDomainCertificateInfoResponseBodyCertInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo>> certInfo{};

  DescribeDcdnDomainCertificateInfoResponseBodyCertInfos() {}

  explicit DescribeDcdnDomainCertificateInfoResponseBodyCertInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfo) {
      vector<boost::any> temp1;
      for(auto item1:*certInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CertInfo"].type()) {
        vector<DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certInfo = make_shared<vector<DescribeDcdnDomainCertificateInfoResponseBodyCertInfosCertInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainCertificateInfoResponseBodyCertInfos() = default;
};
class DescribeDcdnDomainCertificateInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnDomainCertificateInfoResponseBodyCertInfos> certInfos{};

  DescribeDcdnDomainCertificateInfoResponseBody() {}

  explicit DescribeDcdnDomainCertificateInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (certInfos) {
      res["CertInfos"] = certInfos ? boost::any(certInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CertInfos") != m.end() && !m["CertInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertInfos"].type()) {
        DescribeDcdnDomainCertificateInfoResponseBodyCertInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertInfos"]));
        certInfos = make_shared<DescribeDcdnDomainCertificateInfoResponseBodyCertInfos>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainCertificateInfoResponseBody() = default;
};
class DescribeDcdnDomainCertificateInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainCertificateInfoResponseBody> body{};

  DescribeDcdnDomainCertificateInfoResponse() {}

  explicit DescribeDcdnDomainCertificateInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainCertificateInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainCertificateInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainCertificateInfoResponse() = default;
};
class DescribeDcdnDomainCnameRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};

  DescribeDcdnDomainCnameRequest() {}

  explicit DescribeDcdnDomainCnameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnDomainCnameRequest() = default;
};
class DescribeDcdnDomainCnameResponseBodyCnameDatasData : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> domain{};
  shared_ptr<string> cname{};

  DescribeDcdnDomainCnameResponseBodyCnameDatasData() {}

  explicit DescribeDcdnDomainCnameResponseBodyCnameDatasData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
  }


  virtual ~DescribeDcdnDomainCnameResponseBodyCnameDatasData() = default;
};
class DescribeDcdnDomainCnameResponseBodyCnameDatas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainCnameResponseBodyCnameDatasData>> data{};

  DescribeDcdnDomainCnameResponseBodyCnameDatas() {}

  explicit DescribeDcdnDomainCnameResponseBodyCnameDatas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeDcdnDomainCnameResponseBodyCnameDatasData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainCnameResponseBodyCnameDatasData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeDcdnDomainCnameResponseBodyCnameDatasData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainCnameResponseBodyCnameDatas() = default;
};
class DescribeDcdnDomainCnameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnDomainCnameResponseBodyCnameDatas> cnameDatas{};

  DescribeDcdnDomainCnameResponseBody() {}

  explicit DescribeDcdnDomainCnameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (cnameDatas) {
      res["CnameDatas"] = cnameDatas ? boost::any(cnameDatas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CnameDatas") != m.end() && !m["CnameDatas"].empty()) {
      if (typeid(map<string, boost::any>) == m["CnameDatas"].type()) {
        DescribeDcdnDomainCnameResponseBodyCnameDatas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CnameDatas"]));
        cnameDatas = make_shared<DescribeDcdnDomainCnameResponseBodyCnameDatas>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainCnameResponseBody() = default;
};
class DescribeDcdnDomainCnameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainCnameResponseBody> body{};

  DescribeDcdnDomainCnameResponse() {}

  explicit DescribeDcdnDomainCnameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainCnameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainCnameResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainCnameResponse() = default;
};
class DescribeDcdnDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};
  shared_ptr<string> functionNames{};

  DescribeDcdnDomainConfigsRequest() {}

  explicit DescribeDcdnDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
  }


  virtual ~DescribeDcdnDomainConfigsRequest() = default;
};
class DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};

  DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg() {}

  explicit DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
  }


  virtual ~DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg() = default;
};
class DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg>> functionArg{};

  DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs() {}

  explicit DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionArg) {
      vector<boost::any> temp1;
      for(auto item1:*functionArg){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FunctionArg"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionArg") != m.end() && !m["FunctionArg"].empty()) {
      if (typeid(vector<boost::any>) == m["FunctionArg"].type()) {
        vector<DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FunctionArg"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functionArg = make_shared<vector<DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs() = default;
};
class DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> configId{};
  shared_ptr<string> functionName{};
  shared_ptr<DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs> functionArgs{};

  DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig() {}

  explicit DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (functionArgs) {
      res["FunctionArgs"] = functionArgs ? boost::any(functionArgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionArgs"].type()) {
        DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionArgs"]));
        functionArgs = make_shared<DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig() = default;
};
class DescribeDcdnDomainConfigsResponseBodyDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig>> domainConfig{};

  DescribeDcdnDomainConfigsResponseBodyDomainConfigs() {}

  explicit DescribeDcdnDomainConfigsResponseBodyDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfig) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfig") != m.end() && !m["DomainConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfig"].type()) {
        vector<DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfig = make_shared<vector<DescribeDcdnDomainConfigsResponseBodyDomainConfigsDomainConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainConfigsResponseBodyDomainConfigs() = default;
};
class DescribeDcdnDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnDomainConfigsResponseBodyDomainConfigs> domainConfigs{};

  DescribeDcdnDomainConfigsResponseBody() {}

  explicit DescribeDcdnDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainConfigs) {
      res["DomainConfigs"] = domainConfigs ? boost::any(domainConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainConfigs") != m.end() && !m["DomainConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainConfigs"].type()) {
        DescribeDcdnDomainConfigsResponseBodyDomainConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainConfigs"]));
        domainConfigs = make_shared<DescribeDcdnDomainConfigsResponseBodyDomainConfigs>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainConfigsResponseBody() = default;
};
class DescribeDcdnDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainConfigsResponseBody> body{};

  DescribeDcdnDomainConfigsResponse() {}

  explicit DescribeDcdnDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainConfigsResponse() = default;
};
class DescribeDcdnDomainDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};

  DescribeDcdnDomainDetailRequest() {}

  explicit DescribeDcdnDomainDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnDomainDetailRequest() = default;
};
class DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> weight{};
  shared_ptr<string> enabled{};
  shared_ptr<string> priority{};
  shared_ptr<long> port{};
  shared_ptr<string> content{};

  DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource() {}

  explicit DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<string>(boost::any_cast<string>(m["Enabled"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource() = default;
};
class DescribeDcdnDomainDetailResponseBodyDomainDetailSources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource>> source{};

  DescribeDcdnDomainDetailResponseBodyDomainDetailSources() {}

  explicit DescribeDcdnDomainDetailResponseBodyDomainDetailSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      vector<boost::any> temp1;
      for(auto item1:*source){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Source"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(vector<boost::any>) == m["Source"].type()) {
        vector<DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Source"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        source = make_shared<vector<DescribeDcdnDomainDetailResponseBodyDomainDetailSourcesSource>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainDetailResponseBodyDomainDetailSources() = default;
};
class DescribeDcdnDomainDetailResponseBodyDomainDetail : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> description{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> certName{};
  shared_ptr<string> scope{};
  shared_ptr<string> cname{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> domainName{};
  shared_ptr<DescribeDcdnDomainDetailResponseBodyDomainDetailSources> sources{};

  DescribeDcdnDomainDetailResponseBodyDomainDetail() {}

  explicit DescribeDcdnDomainDetailResponseBodyDomainDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (sources) {
      res["Sources"] = sources ? boost::any(sources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sources"].type()) {
        DescribeDcdnDomainDetailResponseBodyDomainDetailSources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sources"]));
        sources = make_shared<DescribeDcdnDomainDetailResponseBodyDomainDetailSources>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainDetailResponseBodyDomainDetail() = default;
};
class DescribeDcdnDomainDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnDomainDetailResponseBodyDomainDetail> domainDetail{};

  DescribeDcdnDomainDetailResponseBody() {}

  explicit DescribeDcdnDomainDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainDetail) {
      res["DomainDetail"] = domainDetail ? boost::any(domainDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainDetail") != m.end() && !m["DomainDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainDetail"].type()) {
        DescribeDcdnDomainDetailResponseBodyDomainDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainDetail"]));
        domainDetail = make_shared<DescribeDcdnDomainDetailResponseBodyDomainDetail>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainDetailResponseBody() = default;
};
class DescribeDcdnDomainDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainDetailResponseBody> body{};

  DescribeDcdnDomainDetailResponse() {}

  explicit DescribeDcdnDomainDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainDetailResponse() = default;
};
class DescribeDcdnDomainHitRateDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};

  DescribeDcdnDomainHitRateDataRequest() {}

  explicit DescribeDcdnDomainHitRateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
  }


  virtual ~DescribeDcdnDomainHitRateDataRequest() = default;
};
class DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<double> byteHitRate{};
  shared_ptr<double> reqHitRate{};

  DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule() {}

  explicit DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (byteHitRate) {
      res["ByteHitRate"] = boost::any(*byteHitRate);
    }
    if (reqHitRate) {
      res["ReqHitRate"] = boost::any(*reqHitRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("ByteHitRate") != m.end() && !m["ByteHitRate"].empty()) {
      byteHitRate = make_shared<double>(boost::any_cast<double>(m["ByteHitRate"]));
    }
    if (m.find("ReqHitRate") != m.end() && !m["ReqHitRate"].empty()) {
      reqHitRate = make_shared<double>(boost::any_cast<double>(m["ReqHitRate"]));
    }
  }


  virtual ~DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule() = default;
};
class DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval() {}

  explicit DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainHitRateDataResponseBodyHitRatePerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval() = default;
};
class DescribeDcdnDomainHitRateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval> hitRatePerInterval{};

  DescribeDcdnDomainHitRateDataResponseBody() {}

  explicit DescribeDcdnDomainHitRateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (hitRatePerInterval) {
      res["HitRatePerInterval"] = hitRatePerInterval ? boost::any(hitRatePerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("HitRatePerInterval") != m.end() && !m["HitRatePerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["HitRatePerInterval"].type()) {
        DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HitRatePerInterval"]));
        hitRatePerInterval = make_shared<DescribeDcdnDomainHitRateDataResponseBodyHitRatePerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainHitRateDataResponseBody() = default;
};
class DescribeDcdnDomainHitRateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainHitRateDataResponseBody> body{};

  DescribeDcdnDomainHitRateDataResponse() {}

  explicit DescribeDcdnDomainHitRateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainHitRateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainHitRateDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainHitRateDataResponse() = default;
};
class DescribeDcdnDomainHttpCodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};

  DescribeDcdnDomainHttpCodeDataRequest() {}

  explicit DescribeDcdnDomainHttpCodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataRequest() = default;
};
class DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<double> proportion{};
  shared_ptr<double> count{};

  DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule() {}

  explicit DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<double>(boost::any_cast<double>(m["Proportion"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<double>(boost::any_cast<double>(m["Count"]));
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule() = default;
};
class DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule>> httpCodeDataModule{};

  DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval() {}

  explicit DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpCodeDataModule) {
      vector<boost::any> temp1;
      for(auto item1:*httpCodeDataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpCodeDataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpCodeDataModule") != m.end() && !m["HttpCodeDataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpCodeDataModule"].type()) {
        vector<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpCodeDataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpCodeDataModule = make_shared<vector<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerIntervalHttpCodeDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval() = default;
};
class DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval> httpCodeDataPerInterval{};

  DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (httpCodeDataPerInterval) {
      res["HttpCodeDataPerInterval"] = httpCodeDataPerInterval ? boost::any(httpCodeDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("HttpCodeDataPerInterval") != m.end() && !m["HttpCodeDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["HttpCodeDataPerInterval"].type()) {
        DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HttpCodeDataPerInterval"]));
        httpCodeDataPerInterval = make_shared<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModuleHttpCodeDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval() {}

  explicit DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval() = default;
};
class DescribeDcdnDomainHttpCodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval> dataPerInterval{};

  DescribeDcdnDomainHttpCodeDataResponseBody() {}

  explicit DescribeDcdnDomainHttpCodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (dataPerInterval) {
      res["DataPerInterval"] = dataPerInterval ? boost::any(dataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DataPerInterval") != m.end() && !m["DataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataPerInterval"].type()) {
        DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataPerInterval"]));
        dataPerInterval = make_shared<DescribeDcdnDomainHttpCodeDataResponseBodyDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataResponseBody() = default;
};
class DescribeDcdnDomainHttpCodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainHttpCodeDataResponseBody> body{};

  DescribeDcdnDomainHttpCodeDataResponse() {}

  explicit DescribeDcdnDomainHttpCodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainHttpCodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainHttpCodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainHttpCodeDataResponse() = default;
};
class DescribeDcdnDomainIpaBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> timeMerge{};
  shared_ptr<string> interval{};
  shared_ptr<string> fixTimeGap{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};

  DescribeDcdnDomainIpaBpsDataRequest() {}

  explicit DescribeDcdnDomainIpaBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (timeMerge) {
      res["TimeMerge"] = boost::any(*timeMerge);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (fixTimeGap) {
      res["FixTimeGap"] = boost::any(*fixTimeGap);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("TimeMerge") != m.end() && !m["TimeMerge"].empty()) {
      timeMerge = make_shared<string>(boost::any_cast<string>(m["TimeMerge"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("FixTimeGap") != m.end() && !m["FixTimeGap"].empty()) {
      fixTimeGap = make_shared<string>(boost::any_cast<string>(m["FixTimeGap"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
  }


  virtual ~DescribeDcdnDomainIpaBpsDataRequest() = default;
};
class DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<double> ipaBps{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipaBps) {
      res["IpaBps"] = boost::any(*ipaBps);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpaBps") != m.end() && !m["IpaBps"].empty()) {
      ipaBps = make_shared<double>(boost::any_cast<double>(m["IpaBps"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval() {}

  explicit DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval() = default;
};
class DescribeDcdnDomainIpaBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval> bpsDataPerInterval{};

  DescribeDcdnDomainIpaBpsDataResponseBody() {}

  explicit DescribeDcdnDomainIpaBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (bpsDataPerInterval) {
      res["BpsDataPerInterval"] = bpsDataPerInterval ? boost::any(bpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("BpsDataPerInterval") != m.end() && !m["BpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataPerInterval"].type()) {
        DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataPerInterval"]));
        bpsDataPerInterval = make_shared<DescribeDcdnDomainIpaBpsDataResponseBodyBpsDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIpaBpsDataResponseBody() = default;
};
class DescribeDcdnDomainIpaBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainIpaBpsDataResponseBody> body{};

  DescribeDcdnDomainIpaBpsDataResponse() {}

  explicit DescribeDcdnDomainIpaBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainIpaBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainIpaBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIpaBpsDataResponse() = default;
};
class DescribeDcdnDomainIpaTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> timeMerge{};
  shared_ptr<string> interval{};
  shared_ptr<string> fixTimeGap{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};

  DescribeDcdnDomainIpaTrafficDataRequest() {}

  explicit DescribeDcdnDomainIpaTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (timeMerge) {
      res["TimeMerge"] = boost::any(*timeMerge);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (fixTimeGap) {
      res["FixTimeGap"] = boost::any(*fixTimeGap);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("TimeMerge") != m.end() && !m["TimeMerge"].empty()) {
      timeMerge = make_shared<string>(boost::any_cast<string>(m["TimeMerge"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("FixTimeGap") != m.end() && !m["FixTimeGap"].empty()) {
      fixTimeGap = make_shared<string>(boost::any_cast<string>(m["FixTimeGap"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
  }


  virtual ~DescribeDcdnDomainIpaTrafficDataRequest() = default;
};
class DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<double> ipaTraffic{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipaTraffic) {
      res["IpaTraffic"] = boost::any(*ipaTraffic);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpaTraffic") != m.end() && !m["IpaTraffic"].empty()) {
      ipaTraffic = make_shared<double>(boost::any_cast<double>(m["IpaTraffic"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval() {}

  explicit DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval() = default;
};
class DescribeDcdnDomainIpaTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval> trafficDataPerInterval{};

  DescribeDcdnDomainIpaTrafficDataResponseBody() {}

  explicit DescribeDcdnDomainIpaTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (trafficDataPerInterval) {
      res["TrafficDataPerInterval"] = trafficDataPerInterval ? boost::any(trafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("TrafficDataPerInterval") != m.end() && !m["TrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficDataPerInterval"].type()) {
        DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficDataPerInterval"]));
        trafficDataPerInterval = make_shared<DescribeDcdnDomainIpaTrafficDataResponseBodyTrafficDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIpaTrafficDataResponseBody() = default;
};
class DescribeDcdnDomainIpaTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainIpaTrafficDataResponseBody> body{};

  DescribeDcdnDomainIpaTrafficDataResponse() {}

  explicit DescribeDcdnDomainIpaTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainIpaTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainIpaTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIpaTrafficDataResponse() = default;
};
class DescribeDcdnDomainIspDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnDomainIspDataRequest() {}

  explicit DescribeDcdnDomainIspDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnDomainIspDataRequest() = default;
};
class DescribeDcdnDomainIspDataResponseBodyValueIspProportionData : public Darabonba::Model {
public:
  shared_ptr<string> qps{};
  shared_ptr<string> totalQuery{};
  shared_ptr<string> totalBytes{};
  shared_ptr<string> avgResponseRate{};
  shared_ptr<string> avgResponseTime{};
  shared_ptr<string> proportion{};
  shared_ptr<string> avgObjectSize{};
  shared_ptr<string> ispEname{};
  shared_ptr<string> bps{};
  shared_ptr<string> isp{};
  shared_ptr<string> bytesProportion{};

  DescribeDcdnDomainIspDataResponseBodyValueIspProportionData() {}

  explicit DescribeDcdnDomainIspDataResponseBodyValueIspProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (totalQuery) {
      res["TotalQuery"] = boost::any(*totalQuery);
    }
    if (totalBytes) {
      res["TotalBytes"] = boost::any(*totalBytes);
    }
    if (avgResponseRate) {
      res["AvgResponseRate"] = boost::any(*avgResponseRate);
    }
    if (avgResponseTime) {
      res["AvgResponseTime"] = boost::any(*avgResponseTime);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    if (avgObjectSize) {
      res["AvgObjectSize"] = boost::any(*avgObjectSize);
    }
    if (ispEname) {
      res["IspEname"] = boost::any(*ispEname);
    }
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (bytesProportion) {
      res["BytesProportion"] = boost::any(*bytesProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<string>(boost::any_cast<string>(m["Qps"]));
    }
    if (m.find("TotalQuery") != m.end() && !m["TotalQuery"].empty()) {
      totalQuery = make_shared<string>(boost::any_cast<string>(m["TotalQuery"]));
    }
    if (m.find("TotalBytes") != m.end() && !m["TotalBytes"].empty()) {
      totalBytes = make_shared<string>(boost::any_cast<string>(m["TotalBytes"]));
    }
    if (m.find("AvgResponseRate") != m.end() && !m["AvgResponseRate"].empty()) {
      avgResponseRate = make_shared<string>(boost::any_cast<string>(m["AvgResponseRate"]));
    }
    if (m.find("AvgResponseTime") != m.end() && !m["AvgResponseTime"].empty()) {
      avgResponseTime = make_shared<string>(boost::any_cast<string>(m["AvgResponseTime"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
    if (m.find("AvgObjectSize") != m.end() && !m["AvgObjectSize"].empty()) {
      avgObjectSize = make_shared<string>(boost::any_cast<string>(m["AvgObjectSize"]));
    }
    if (m.find("IspEname") != m.end() && !m["IspEname"].empty()) {
      ispEname = make_shared<string>(boost::any_cast<string>(m["IspEname"]));
    }
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<string>(boost::any_cast<string>(m["Bps"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("BytesProportion") != m.end() && !m["BytesProportion"].empty()) {
      bytesProportion = make_shared<string>(boost::any_cast<string>(m["BytesProportion"]));
    }
  }


  virtual ~DescribeDcdnDomainIspDataResponseBodyValueIspProportionData() = default;
};
class DescribeDcdnDomainIspDataResponseBodyValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainIspDataResponseBodyValueIspProportionData>> ispProportionData{};

  DescribeDcdnDomainIspDataResponseBodyValue() {}

  explicit DescribeDcdnDomainIspDataResponseBodyValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ispProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*ispProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IspProportionData") != m.end() && !m["IspProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["IspProportionData"].type()) {
        vector<DescribeDcdnDomainIspDataResponseBodyValueIspProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainIspDataResponseBodyValueIspProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispProportionData = make_shared<vector<DescribeDcdnDomainIspDataResponseBodyValueIspProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIspDataResponseBodyValue() = default;
};
class DescribeDcdnDomainIspDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainIspDataResponseBodyValue> value{};

  DescribeDcdnDomainIspDataResponseBody() {}

  explicit DescribeDcdnDomainIspDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeDcdnDomainIspDataResponseBodyValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeDcdnDomainIspDataResponseBodyValue>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIspDataResponseBody() = default;
};
class DescribeDcdnDomainIspDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainIspDataResponseBody> body{};

  DescribeDcdnDomainIspDataResponse() {}

  explicit DescribeDcdnDomainIspDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainIspDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainIspDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainIspDataResponse() = default;
};
class DescribeDcdnDomainLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnDomainLogRequest() {}

  explicit DescribeDcdnDomainLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnDomainLogRequest() = default;
};
class DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> logSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> logName{};
  shared_ptr<string> logPath{};

  DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() {}

  explicit DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (logSize) {
      res["LogSize"] = boost::any(*logSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (logName) {
      res["LogName"] = boost::any(*logName);
    }
    if (logPath) {
      res["LogPath"] = boost::any(*logPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("LogSize") != m.end() && !m["LogSize"].empty()) {
      logSize = make_shared<long>(boost::any_cast<long>(m["LogSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("LogName") != m.end() && !m["LogName"].empty()) {
      logName = make_shared<string>(boost::any_cast<string>(m["LogName"]));
    }
    if (m.find("LogPath") != m.end() && !m["LogPath"].empty()) {
      logPath = make_shared<string>(boost::any_cast<string>(m["LogPath"]));
    }
  }


  virtual ~DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail() = default;
};
class DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>> logInfoDetail{};

  DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() {}

  explicit DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfoDetail) {
      vector<boost::any> temp1;
      for(auto item1:*logInfoDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfoDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfoDetail") != m.end() && !m["LogInfoDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfoDetail"].type()) {
        vector<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfoDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfoDetail = make_shared<vector<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos() = default;
};
class DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() {}

  explicit DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos() = default;
};
class DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail : public Darabonba::Model {
public:
  shared_ptr<long> logCount{};
  shared_ptr<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos> logInfos{};
  shared_ptr<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos> pageInfos{};

  DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail() {}

  explicit DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logCount) {
      res["LogCount"] = boost::any(*logCount);
    }
    if (logInfos) {
      res["LogInfos"] = logInfos ? boost::any(logInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageInfos) {
      res["PageInfos"] = pageInfos ? boost::any(pageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogCount") != m.end() && !m["LogCount"].empty()) {
      logCount = make_shared<long>(boost::any_cast<long>(m["LogCount"]));
    }
    if (m.find("LogInfos") != m.end() && !m["LogInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogInfos"].type()) {
        DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogInfos"]));
        logInfos = make_shared<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos>(model1);
      }
    }
    if (m.find("PageInfos") != m.end() && !m["PageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageInfos"].type()) {
        DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageInfos"]));
        pageInfos = make_shared<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail() = default;
};
class DescribeDcdnDomainLogResponseBodyDomainLogDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail>> domainLogDetail{};

  DescribeDcdnDomainLogResponseBodyDomainLogDetails() {}

  explicit DescribeDcdnDomainLogResponseBodyDomainLogDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainLogDetail) {
      vector<boost::any> temp1;
      for(auto item1:*domainLogDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainLogDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainLogDetail") != m.end() && !m["DomainLogDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainLogDetail"].type()) {
        vector<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainLogDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainLogDetail = make_shared<vector<DescribeDcdnDomainLogResponseBodyDomainLogDetailsDomainLogDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainLogResponseBodyDomainLogDetails() = default;
};
class DescribeDcdnDomainLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnDomainLogResponseBodyDomainLogDetails> domainLogDetails{};

  DescribeDcdnDomainLogResponseBody() {}

  explicit DescribeDcdnDomainLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainLogDetails) {
      res["DomainLogDetails"] = domainLogDetails ? boost::any(domainLogDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainLogDetails") != m.end() && !m["DomainLogDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainLogDetails"].type()) {
        DescribeDcdnDomainLogResponseBodyDomainLogDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainLogDetails"]));
        domainLogDetails = make_shared<DescribeDcdnDomainLogResponseBodyDomainLogDetails>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainLogResponseBody() = default;
};
class DescribeDcdnDomainLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainLogResponseBody> body{};

  DescribeDcdnDomainLogResponse() {}

  explicit DescribeDcdnDomainLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainLogResponse() = default;
};
class DescribeDcdnDomainMultiUsageDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnDomainMultiUsageDataRequest() {}

  explicit DescribeDcdnDomainMultiUsageDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnDomainMultiUsageDataRequest() = default;
};
class DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> domain{};
  shared_ptr<long> request{};

  DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule() {}

  explicit DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (request) {
      res["Request"] = boost::any(*request);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Request") != m.end() && !m["Request"].empty()) {
      request = make_shared<long>(boost::any_cast<long>(m["Request"]));
    }
  }


  virtual ~DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule() = default;
};
class DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule>> requestDataModule{};

  DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval() {}

  explicit DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestDataModule) {
      vector<boost::any> temp1;
      for(auto item1:*requestDataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestDataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestDataModule") != m.end() && !m["RequestDataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestDataModule"].type()) {
        vector<DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestDataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestDataModule = make_shared<vector<DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerIntervalRequestDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval() = default;
};
class DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> domain{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> area{};
  shared_ptr<double> bps{};

  DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule() {}

  explicit DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<double>(boost::any_cast<double>(m["Bps"]));
    }
  }


  virtual ~DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule() = default;
};
class DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule>> trafficDataModule{};

  DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval() {}

  explicit DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trafficDataModule) {
      vector<boost::any> temp1;
      for(auto item1:*trafficDataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TrafficDataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrafficDataModule") != m.end() && !m["TrafficDataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["TrafficDataModule"].type()) {
        vector<DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TrafficDataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trafficDataModule = make_shared<vector<DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerIntervalTrafficDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval() = default;
};
class DescribeDcdnDomainMultiUsageDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval> requestPerInterval{};
  shared_ptr<DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval> trafficPerInterval{};

  DescribeDcdnDomainMultiUsageDataResponseBody() {}

  explicit DescribeDcdnDomainMultiUsageDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestPerInterval) {
      res["RequestPerInterval"] = requestPerInterval ? boost::any(requestPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trafficPerInterval) {
      res["TrafficPerInterval"] = trafficPerInterval ? boost::any(trafficPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestPerInterval") != m.end() && !m["RequestPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestPerInterval"].type()) {
        DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestPerInterval"]));
        requestPerInterval = make_shared<DescribeDcdnDomainMultiUsageDataResponseBodyRequestPerInterval>(model1);
      }
    }
    if (m.find("TrafficPerInterval") != m.end() && !m["TrafficPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficPerInterval"].type()) {
        DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficPerInterval"]));
        trafficPerInterval = make_shared<DescribeDcdnDomainMultiUsageDataResponseBodyTrafficPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainMultiUsageDataResponseBody() = default;
};
class DescribeDcdnDomainMultiUsageDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainMultiUsageDataResponseBody> body{};

  DescribeDcdnDomainMultiUsageDataResponse() {}

  explicit DescribeDcdnDomainMultiUsageDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainMultiUsageDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainMultiUsageDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainMultiUsageDataResponse() = default;
};
class DescribeDcdnDomainOriginBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};

  DescribeDcdnDomainOriginBpsDataRequest() {}

  explicit DescribeDcdnDomainOriginBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
  }


  virtual ~DescribeDcdnDomainOriginBpsDataRequest() = default;
};
class DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<double> dynamicHttpOriginBps{};
  shared_ptr<double> staticHttpOriginBps{};
  shared_ptr<string> timeStamp{};
  shared_ptr<double> staticHttpsOriginBps{};
  shared_ptr<double> originBps{};
  shared_ptr<double> dynamicHttpsOriginBps{};

  DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicHttpOriginBps) {
      res["DynamicHttpOriginBps"] = boost::any(*dynamicHttpOriginBps);
    }
    if (staticHttpOriginBps) {
      res["StaticHttpOriginBps"] = boost::any(*staticHttpOriginBps);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (staticHttpsOriginBps) {
      res["StaticHttpsOriginBps"] = boost::any(*staticHttpsOriginBps);
    }
    if (originBps) {
      res["OriginBps"] = boost::any(*originBps);
    }
    if (dynamicHttpsOriginBps) {
      res["DynamicHttpsOriginBps"] = boost::any(*dynamicHttpsOriginBps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicHttpOriginBps") != m.end() && !m["DynamicHttpOriginBps"].empty()) {
      dynamicHttpOriginBps = make_shared<double>(boost::any_cast<double>(m["DynamicHttpOriginBps"]));
    }
    if (m.find("StaticHttpOriginBps") != m.end() && !m["StaticHttpOriginBps"].empty()) {
      staticHttpOriginBps = make_shared<double>(boost::any_cast<double>(m["StaticHttpOriginBps"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("StaticHttpsOriginBps") != m.end() && !m["StaticHttpsOriginBps"].empty()) {
      staticHttpsOriginBps = make_shared<double>(boost::any_cast<double>(m["StaticHttpsOriginBps"]));
    }
    if (m.find("OriginBps") != m.end() && !m["OriginBps"].empty()) {
      originBps = make_shared<double>(boost::any_cast<double>(m["OriginBps"]));
    }
    if (m.find("DynamicHttpsOriginBps") != m.end() && !m["DynamicHttpsOriginBps"].empty()) {
      dynamicHttpsOriginBps = make_shared<double>(boost::any_cast<double>(m["DynamicHttpsOriginBps"]));
    }
  }


  virtual ~DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval() {}

  explicit DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval() = default;
};
class DescribeDcdnDomainOriginBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval> originBpsDataPerInterval{};

  DescribeDcdnDomainOriginBpsDataResponseBody() {}

  explicit DescribeDcdnDomainOriginBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (originBpsDataPerInterval) {
      res["OriginBpsDataPerInterval"] = originBpsDataPerInterval ? boost::any(originBpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("OriginBpsDataPerInterval") != m.end() && !m["OriginBpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["OriginBpsDataPerInterval"].type()) {
        DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OriginBpsDataPerInterval"]));
        originBpsDataPerInterval = make_shared<DescribeDcdnDomainOriginBpsDataResponseBodyOriginBpsDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainOriginBpsDataResponseBody() = default;
};
class DescribeDcdnDomainOriginBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainOriginBpsDataResponseBody> body{};

  DescribeDcdnDomainOriginBpsDataResponse() {}

  explicit DescribeDcdnDomainOriginBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainOriginBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainOriginBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainOriginBpsDataResponse() = default;
};
class DescribeDcdnDomainOriginTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};

  DescribeDcdnDomainOriginTrafficDataRequest() {}

  explicit DescribeDcdnDomainOriginTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
  }


  virtual ~DescribeDcdnDomainOriginTrafficDataRequest() = default;
};
class DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<double> dynamicHttpOriginTraffic{};
  shared_ptr<double> staticHttpsOriginTraffic{};
  shared_ptr<double> originTraffic{};
  shared_ptr<double> staticHttpOriginTraffic{};
  shared_ptr<double> dynamicHttpsOriginTraffic{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicHttpOriginTraffic) {
      res["DynamicHttpOriginTraffic"] = boost::any(*dynamicHttpOriginTraffic);
    }
    if (staticHttpsOriginTraffic) {
      res["StaticHttpsOriginTraffic"] = boost::any(*staticHttpsOriginTraffic);
    }
    if (originTraffic) {
      res["OriginTraffic"] = boost::any(*originTraffic);
    }
    if (staticHttpOriginTraffic) {
      res["StaticHttpOriginTraffic"] = boost::any(*staticHttpOriginTraffic);
    }
    if (dynamicHttpsOriginTraffic) {
      res["DynamicHttpsOriginTraffic"] = boost::any(*dynamicHttpsOriginTraffic);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicHttpOriginTraffic") != m.end() && !m["DynamicHttpOriginTraffic"].empty()) {
      dynamicHttpOriginTraffic = make_shared<double>(boost::any_cast<double>(m["DynamicHttpOriginTraffic"]));
    }
    if (m.find("StaticHttpsOriginTraffic") != m.end() && !m["StaticHttpsOriginTraffic"].empty()) {
      staticHttpsOriginTraffic = make_shared<double>(boost::any_cast<double>(m["StaticHttpsOriginTraffic"]));
    }
    if (m.find("OriginTraffic") != m.end() && !m["OriginTraffic"].empty()) {
      originTraffic = make_shared<double>(boost::any_cast<double>(m["OriginTraffic"]));
    }
    if (m.find("StaticHttpOriginTraffic") != m.end() && !m["StaticHttpOriginTraffic"].empty()) {
      staticHttpOriginTraffic = make_shared<double>(boost::any_cast<double>(m["StaticHttpOriginTraffic"]));
    }
    if (m.find("DynamicHttpsOriginTraffic") != m.end() && !m["DynamicHttpsOriginTraffic"].empty()) {
      dynamicHttpsOriginTraffic = make_shared<double>(boost::any_cast<double>(m["DynamicHttpsOriginTraffic"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval() {}

  explicit DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval() = default;
};
class DescribeDcdnDomainOriginTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval> originTrafficDataPerInterval{};

  DescribeDcdnDomainOriginTrafficDataResponseBody() {}

  explicit DescribeDcdnDomainOriginTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (originTrafficDataPerInterval) {
      res["OriginTrafficDataPerInterval"] = originTrafficDataPerInterval ? boost::any(originTrafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("OriginTrafficDataPerInterval") != m.end() && !m["OriginTrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["OriginTrafficDataPerInterval"].type()) {
        DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OriginTrafficDataPerInterval"]));
        originTrafficDataPerInterval = make_shared<DescribeDcdnDomainOriginTrafficDataResponseBodyOriginTrafficDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainOriginTrafficDataResponseBody() = default;
};
class DescribeDcdnDomainOriginTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainOriginTrafficDataResponseBody> body{};

  DescribeDcdnDomainOriginTrafficDataResponse() {}

  explicit DescribeDcdnDomainOriginTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainOriginTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainOriginTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainOriginTrafficDataResponse() = default;
};
class DescribeDcdnDomainPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};

  DescribeDcdnDomainPropertyRequest() {}

  explicit DescribeDcdnDomainPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnDomainPropertyRequest() = default;
};
class DescribeDcdnDomainPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> protocol{};

  DescribeDcdnDomainPropertyResponseBody() {}

  explicit DescribeDcdnDomainPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~DescribeDcdnDomainPropertyResponseBody() = default;
};
class DescribeDcdnDomainPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainPropertyResponseBody> body{};

  DescribeDcdnDomainPropertyResponse() {}

  explicit DescribeDcdnDomainPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainPropertyResponse() = default;
};
class DescribeDcdnDomainPvDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnDomainPvDataRequest() {}

  explicit DescribeDcdnDomainPvDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnDomainPvDataRequest() = default;
};
class DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData : public Darabonba::Model {
public:
  shared_ptr<string> value{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData() {}

  explicit DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData() = default;
};
class DescribeDcdnDomainPvDataResponseBodyPvDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData>> usageData{};

  DescribeDcdnDomainPvDataResponseBodyPvDataInterval() {}

  explicit DescribeDcdnDomainPvDataResponseBodyPvDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeDcdnDomainPvDataResponseBodyPvDataIntervalUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainPvDataResponseBodyPvDataInterval() = default;
};
class DescribeDcdnDomainPvDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainPvDataResponseBodyPvDataInterval> pvDataInterval{};

  DescribeDcdnDomainPvDataResponseBody() {}

  explicit DescribeDcdnDomainPvDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (pvDataInterval) {
      res["PvDataInterval"] = pvDataInterval ? boost::any(pvDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("PvDataInterval") != m.end() && !m["PvDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["PvDataInterval"].type()) {
        DescribeDcdnDomainPvDataResponseBodyPvDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PvDataInterval"]));
        pvDataInterval = make_shared<DescribeDcdnDomainPvDataResponseBodyPvDataInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainPvDataResponseBody() = default;
};
class DescribeDcdnDomainPvDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainPvDataResponseBody> body{};

  DescribeDcdnDomainPvDataResponse() {}

  explicit DescribeDcdnDomainPvDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainPvDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainPvDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainPvDataResponse() = default;
};
class DescribeDcdnDomainQpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};

  DescribeDcdnDomainQpsDataRequest() {}

  explicit DescribeDcdnDomainQpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
  }


  virtual ~DescribeDcdnDomainQpsDataRequest() = default;
};
class DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<double> dynamicHttpsAcc{};
  shared_ptr<double> dynamicHttpAcc{};
  shared_ptr<double> qps{};
  shared_ptr<double> staticHttpsAcc{};
  shared_ptr<double> staticHttpQps{};
  shared_ptr<double> staticHttpAcc{};
  shared_ptr<double> dynamicHttpsQps{};
  shared_ptr<double> acc{};
  shared_ptr<double> staticHttpsQps{};
  shared_ptr<double> dynamicHttpQps{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicHttpsAcc) {
      res["DynamicHttpsAcc"] = boost::any(*dynamicHttpsAcc);
    }
    if (dynamicHttpAcc) {
      res["DynamicHttpAcc"] = boost::any(*dynamicHttpAcc);
    }
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (staticHttpsAcc) {
      res["StaticHttpsAcc"] = boost::any(*staticHttpsAcc);
    }
    if (staticHttpQps) {
      res["StaticHttpQps"] = boost::any(*staticHttpQps);
    }
    if (staticHttpAcc) {
      res["StaticHttpAcc"] = boost::any(*staticHttpAcc);
    }
    if (dynamicHttpsQps) {
      res["DynamicHttpsQps"] = boost::any(*dynamicHttpsQps);
    }
    if (acc) {
      res["Acc"] = boost::any(*acc);
    }
    if (staticHttpsQps) {
      res["StaticHttpsQps"] = boost::any(*staticHttpsQps);
    }
    if (dynamicHttpQps) {
      res["DynamicHttpQps"] = boost::any(*dynamicHttpQps);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicHttpsAcc") != m.end() && !m["DynamicHttpsAcc"].empty()) {
      dynamicHttpsAcc = make_shared<double>(boost::any_cast<double>(m["DynamicHttpsAcc"]));
    }
    if (m.find("DynamicHttpAcc") != m.end() && !m["DynamicHttpAcc"].empty()) {
      dynamicHttpAcc = make_shared<double>(boost::any_cast<double>(m["DynamicHttpAcc"]));
    }
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<double>(boost::any_cast<double>(m["Qps"]));
    }
    if (m.find("StaticHttpsAcc") != m.end() && !m["StaticHttpsAcc"].empty()) {
      staticHttpsAcc = make_shared<double>(boost::any_cast<double>(m["StaticHttpsAcc"]));
    }
    if (m.find("StaticHttpQps") != m.end() && !m["StaticHttpQps"].empty()) {
      staticHttpQps = make_shared<double>(boost::any_cast<double>(m["StaticHttpQps"]));
    }
    if (m.find("StaticHttpAcc") != m.end() && !m["StaticHttpAcc"].empty()) {
      staticHttpAcc = make_shared<double>(boost::any_cast<double>(m["StaticHttpAcc"]));
    }
    if (m.find("DynamicHttpsQps") != m.end() && !m["DynamicHttpsQps"].empty()) {
      dynamicHttpsQps = make_shared<double>(boost::any_cast<double>(m["DynamicHttpsQps"]));
    }
    if (m.find("Acc") != m.end() && !m["Acc"].empty()) {
      acc = make_shared<double>(boost::any_cast<double>(m["Acc"]));
    }
    if (m.find("StaticHttpsQps") != m.end() && !m["StaticHttpsQps"].empty()) {
      staticHttpsQps = make_shared<double>(boost::any_cast<double>(m["StaticHttpsQps"]));
    }
    if (m.find("DynamicHttpQps") != m.end() && !m["DynamicHttpQps"].empty()) {
      dynamicHttpQps = make_shared<double>(boost::any_cast<double>(m["DynamicHttpQps"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval() {}

  explicit DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainQpsDataResponseBodyQpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval() = default;
};
class DescribeDcdnDomainQpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval> qpsDataPerInterval{};

  DescribeDcdnDomainQpsDataResponseBody() {}

  explicit DescribeDcdnDomainQpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (qpsDataPerInterval) {
      res["QpsDataPerInterval"] = qpsDataPerInterval ? boost::any(qpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("QpsDataPerInterval") != m.end() && !m["QpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["QpsDataPerInterval"].type()) {
        DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QpsDataPerInterval"]));
        qpsDataPerInterval = make_shared<DescribeDcdnDomainQpsDataResponseBodyQpsDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainQpsDataResponseBody() = default;
};
class DescribeDcdnDomainQpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainQpsDataResponseBody> body{};

  DescribeDcdnDomainQpsDataResponse() {}

  explicit DescribeDcdnDomainQpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainQpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainQpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainQpsDataResponse() = default;
};
class DescribeDcdnDomainRealTimeBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnDomainRealTimeBpsDataRequest() {}

  explicit DescribeDcdnDomainRealTimeBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeBpsDataRequest() = default;
};
class DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel : public Darabonba::Model {
public:
  shared_ptr<double> bps{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel() {}

  explicit DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<double>(boost::any_cast<double>(m["Bps"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel() = default;
};
class DescribeDcdnDomainRealTimeBpsDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel>> bpsModel{};

  DescribeDcdnDomainRealTimeBpsDataResponseBodyData() {}

  explicit DescribeDcdnDomainRealTimeBpsDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bpsModel) {
      vector<boost::any> temp1;
      for(auto item1:*bpsModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BpsModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BpsModel") != m.end() && !m["BpsModel"].empty()) {
      if (typeid(vector<boost::any>) == m["BpsModel"].type()) {
        vector<DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BpsModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bpsModel = make_shared<vector<DescribeDcdnDomainRealTimeBpsDataResponseBodyDataBpsModel>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeBpsDataResponseBodyData() = default;
};
class DescribeDcdnDomainRealTimeBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnDomainRealTimeBpsDataResponseBodyData> data{};

  DescribeDcdnDomainRealTimeBpsDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeDcdnDomainRealTimeBpsDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeDcdnDomainRealTimeBpsDataResponseBodyData>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeBpsDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainRealTimeBpsDataResponseBody> body{};

  DescribeDcdnDomainRealTimeBpsDataResponse() {}

  explicit DescribeDcdnDomainRealTimeBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeBpsDataResponse() = default;
};
class DescribeDcdnDomainRealTimeByteHitRateDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnDomainRealTimeByteHitRateDataRequest() {}

  explicit DescribeDcdnDomainRealTimeByteHitRateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeByteHitRateDataRequest() = default;
};
class DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel : public Darabonba::Model {
public:
  shared_ptr<double> byteHitRate{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel() {}

  explicit DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (byteHitRate) {
      res["ByteHitRate"] = boost::any(*byteHitRate);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ByteHitRate") != m.end() && !m["ByteHitRate"].empty()) {
      byteHitRate = make_shared<double>(boost::any_cast<double>(m["ByteHitRate"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel() = default;
};
class DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel>> byteHitRateDataModel{};

  DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData() {}

  explicit DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (byteHitRateDataModel) {
      vector<boost::any> temp1;
      for(auto item1:*byteHitRateDataModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ByteHitRateDataModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ByteHitRateDataModel") != m.end() && !m["ByteHitRateDataModel"].empty()) {
      if (typeid(vector<boost::any>) == m["ByteHitRateDataModel"].type()) {
        vector<DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ByteHitRateDataModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        byteHitRateDataModel = make_shared<vector<DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData() = default;
};
class DescribeDcdnDomainRealTimeByteHitRateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData> data{};

  DescribeDcdnDomainRealTimeByteHitRateDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeByteHitRateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeDcdnDomainRealTimeByteHitRateDataResponseBodyData>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeByteHitRateDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeByteHitRateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainRealTimeByteHitRateDataResponseBody> body{};

  DescribeDcdnDomainRealTimeByteHitRateDataResponse() {}

  explicit DescribeDcdnDomainRealTimeByteHitRateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeByteHitRateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeByteHitRateDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeByteHitRateDataResponse() = default;
};
class DescribeDcdnDomainRealTimeDetailDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> field{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> merge{};
  shared_ptr<string> mergeLocIsp{};

  DescribeDcdnDomainRealTimeDetailDataRequest() {}

  explicit DescribeDcdnDomainRealTimeDetailDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (merge) {
      res["Merge"] = boost::any(*merge);
    }
    if (mergeLocIsp) {
      res["MergeLocIsp"] = boost::any(*mergeLocIsp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("Merge") != m.end() && !m["Merge"].empty()) {
      merge = make_shared<string>(boost::any_cast<string>(m["Merge"]));
    }
    if (m.find("MergeLocIsp") != m.end() && !m["MergeLocIsp"].empty()) {
      mergeLocIsp = make_shared<string>(boost::any_cast<string>(m["MergeLocIsp"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeDetailDataRequest() = default;
};
class DescribeDcdnDomainRealTimeDetailDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  DescribeDcdnDomainRealTimeDetailDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeDetailDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeDetailDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeDetailDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainRealTimeDetailDataResponseBody> body{};

  DescribeDcdnDomainRealTimeDetailDataResponse() {}

  explicit DescribeDcdnDomainRealTimeDetailDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeDetailDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeDetailDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeDetailDataResponse() = default;
};
class DescribeDcdnDomainRealTimeHttpCodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};

  DescribeDcdnDomainRealTimeHttpCodeDataRequest() {}

  explicit DescribeDcdnDomainRealTimeHttpCodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeHttpCodeDataRequest() = default;
};
class DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> proportion{};
  shared_ptr<string> count{};

  DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData() {}

  explicit DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData() = default;
};
class DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData>> realTimeCodeProportionData{};

  DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue() {}

  explicit DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realTimeCodeProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*realTimeCodeProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealTimeCodeProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealTimeCodeProportionData") != m.end() && !m["RealTimeCodeProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["RealTimeCodeProportionData"].type()) {
        vector<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealTimeCodeProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realTimeCodeProportionData = make_shared<vector<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue() = default;
};
class DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue> value{};

  DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData() {}

  explicit DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData() = default;
};
class DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData>> usageData{};

  DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData() {}

  explicit DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData() = default;
};
class DescribeDcdnDomainRealTimeHttpCodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData> realTimeHttpCodeData{};

  DescribeDcdnDomainRealTimeHttpCodeDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeHttpCodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (realTimeHttpCodeData) {
      res["RealTimeHttpCodeData"] = realTimeHttpCodeData ? boost::any(realTimeHttpCodeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("RealTimeHttpCodeData") != m.end() && !m["RealTimeHttpCodeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeHttpCodeData"].type()) {
        DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeHttpCodeData"]));
        realTimeHttpCodeData = make_shared<DescribeDcdnDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeHttpCodeDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeHttpCodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainRealTimeHttpCodeDataResponseBody> body{};

  DescribeDcdnDomainRealTimeHttpCodeDataResponse() {}

  explicit DescribeDcdnDomainRealTimeHttpCodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeHttpCodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeHttpCodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeHttpCodeDataResponse() = default;
};
class DescribeDcdnDomainRealTimeQpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnDomainRealTimeQpsDataRequest() {}

  explicit DescribeDcdnDomainRealTimeQpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeQpsDataRequest() = default;
};
class DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel : public Darabonba::Model {
public:
  shared_ptr<double> qps{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel() {}

  explicit DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<double>(boost::any_cast<double>(m["Qps"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel() = default;
};
class DescribeDcdnDomainRealTimeQpsDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel>> qpsModel{};

  DescribeDcdnDomainRealTimeQpsDataResponseBodyData() {}

  explicit DescribeDcdnDomainRealTimeQpsDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qpsModel) {
      vector<boost::any> temp1;
      for(auto item1:*qpsModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QpsModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QpsModel") != m.end() && !m["QpsModel"].empty()) {
      if (typeid(vector<boost::any>) == m["QpsModel"].type()) {
        vector<DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QpsModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        qpsModel = make_shared<vector<DescribeDcdnDomainRealTimeQpsDataResponseBodyDataQpsModel>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeQpsDataResponseBodyData() = default;
};
class DescribeDcdnDomainRealTimeQpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnDomainRealTimeQpsDataResponseBodyData> data{};

  DescribeDcdnDomainRealTimeQpsDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeQpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeDcdnDomainRealTimeQpsDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeDcdnDomainRealTimeQpsDataResponseBodyData>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeQpsDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeQpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainRealTimeQpsDataResponseBody> body{};

  DescribeDcdnDomainRealTimeQpsDataResponse() {}

  explicit DescribeDcdnDomainRealTimeQpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeQpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeQpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeQpsDataResponse() = default;
};
class DescribeDcdnDomainRealTimeReqHitRateDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnDomainRealTimeReqHitRateDataRequest() {}

  explicit DescribeDcdnDomainRealTimeReqHitRateDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeReqHitRateDataRequest() = default;
};
class DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel : public Darabonba::Model {
public:
  shared_ptr<double> reqHitRate{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel() {}

  explicit DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reqHitRate) {
      res["ReqHitRate"] = boost::any(*reqHitRate);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReqHitRate") != m.end() && !m["ReqHitRate"].empty()) {
      reqHitRate = make_shared<double>(boost::any_cast<double>(m["ReqHitRate"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel() = default;
};
class DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel>> reqHitRateDataModel{};

  DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData() {}

  explicit DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (reqHitRateDataModel) {
      vector<boost::any> temp1;
      for(auto item1:*reqHitRateDataModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReqHitRateDataModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReqHitRateDataModel") != m.end() && !m["ReqHitRateDataModel"].empty()) {
      if (typeid(vector<boost::any>) == m["ReqHitRateDataModel"].type()) {
        vector<DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReqHitRateDataModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reqHitRateDataModel = make_shared<vector<DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData() = default;
};
class DescribeDcdnDomainRealTimeReqHitRateDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData> data{};

  DescribeDcdnDomainRealTimeReqHitRateDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeReqHitRateDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeDcdnDomainRealTimeReqHitRateDataResponseBodyData>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeReqHitRateDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeReqHitRateDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainRealTimeReqHitRateDataResponseBody> body{};

  DescribeDcdnDomainRealTimeReqHitRateDataResponse() {}

  explicit DescribeDcdnDomainRealTimeReqHitRateDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeReqHitRateDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeReqHitRateDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeReqHitRateDataResponse() = default;
};
class DescribeDcdnDomainRealTimeSrcBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnDomainRealTimeSrcBpsDataRequest() {}

  explicit DescribeDcdnDomainRealTimeSrcBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcBpsDataRequest() = default;
};
class DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> value{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval() {}

  explicit DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval() = default;
};
class DescribeDcdnDomainRealTimeSrcBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval> realTimeSrcBpsDataPerInterval{};

  DescribeDcdnDomainRealTimeSrcBpsDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeSrcBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (realTimeSrcBpsDataPerInterval) {
      res["RealTimeSrcBpsDataPerInterval"] = realTimeSrcBpsDataPerInterval ? boost::any(realTimeSrcBpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("RealTimeSrcBpsDataPerInterval") != m.end() && !m["RealTimeSrcBpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeSrcBpsDataPerInterval"].type()) {
        DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeSrcBpsDataPerInterval"]));
        realTimeSrcBpsDataPerInterval = make_shared<DescribeDcdnDomainRealTimeSrcBpsDataResponseBodyRealTimeSrcBpsDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcBpsDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeSrcBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainRealTimeSrcBpsDataResponseBody> body{};

  DescribeDcdnDomainRealTimeSrcBpsDataResponse() {}

  explicit DescribeDcdnDomainRealTimeSrcBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeSrcBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeSrcBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcBpsDataResponse() = default;
};
class DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};

  DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest() {}

  explicit DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest() = default;
};
class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> proportion{};
  shared_ptr<string> count{};

  DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData() {}

  explicit DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<string>(boost::any_cast<string>(m["Count"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData() = default;
};
class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData>> realTimeSrcCodeProportionData{};

  DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue() {}

  explicit DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realTimeSrcCodeProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*realTimeSrcCodeProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealTimeSrcCodeProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealTimeSrcCodeProportionData") != m.end() && !m["RealTimeSrcCodeProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["RealTimeSrcCodeProportionData"].type()) {
        vector<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealTimeSrcCodeProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realTimeSrcCodeProportionData = make_shared<vector<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValueRealTimeSrcCodeProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue() = default;
};
class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue> value{};

  DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData() {}

  explicit DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageDataValue>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData() = default;
};
class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData>> usageData{};

  DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData() {}

  explicit DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeDataUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData() = default;
};
class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData> realTimeSrcHttpCodeData{};

  DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (realTimeSrcHttpCodeData) {
      res["RealTimeSrcHttpCodeData"] = realTimeSrcHttpCodeData ? boost::any(realTimeSrcHttpCodeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("RealTimeSrcHttpCodeData") != m.end() && !m["RealTimeSrcHttpCodeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeSrcHttpCodeData"].type()) {
        DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeSrcHttpCodeData"]));
        realTimeSrcHttpCodeData = make_shared<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBodyRealTimeSrcHttpCodeData>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody> body{};

  DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse() {}

  explicit DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse() = default;
};
class DescribeDcdnDomainRealTimeSrcTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnDomainRealTimeSrcTrafficDataRequest() {}

  explicit DescribeDcdnDomainRealTimeSrcTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcTrafficDataRequest() = default;
};
class DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> value{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval() {}

  explicit DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval() = default;
};
class DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval> realTimeSrcTrafficDataPerInterval{};

  DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (realTimeSrcTrafficDataPerInterval) {
      res["RealTimeSrcTrafficDataPerInterval"] = realTimeSrcTrafficDataPerInterval ? boost::any(realTimeSrcTrafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("RealTimeSrcTrafficDataPerInterval") != m.end() && !m["RealTimeSrcTrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeSrcTrafficDataPerInterval"].type()) {
        DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeSrcTrafficDataPerInterval"]));
        realTimeSrcTrafficDataPerInterval = make_shared<DescribeDcdnDomainRealTimeSrcTrafficDataResponseBodyRealTimeSrcTrafficDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeSrcTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody> body{};

  DescribeDcdnDomainRealTimeSrcTrafficDataResponse() {}

  explicit DescribeDcdnDomainRealTimeSrcTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeSrcTrafficDataResponse() = default;
};
class DescribeDcdnDomainRealTimeTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnDomainRealTimeTrafficDataRequest() {}

  explicit DescribeDcdnDomainRealTimeTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeTrafficDataRequest() = default;
};
class DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> value{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval() {}

  explicit DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval() = default;
};
class DescribeDcdnDomainRealTimeTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval> realTimeTrafficDataPerInterval{};

  DescribeDcdnDomainRealTimeTrafficDataResponseBody() {}

  explicit DescribeDcdnDomainRealTimeTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (realTimeTrafficDataPerInterval) {
      res["RealTimeTrafficDataPerInterval"] = realTimeTrafficDataPerInterval ? boost::any(realTimeTrafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("RealTimeTrafficDataPerInterval") != m.end() && !m["RealTimeTrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeTrafficDataPerInterval"].type()) {
        DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeTrafficDataPerInterval"]));
        realTimeTrafficDataPerInterval = make_shared<DescribeDcdnDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeTrafficDataResponseBody() = default;
};
class DescribeDcdnDomainRealTimeTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainRealTimeTrafficDataResponseBody> body{};

  DescribeDcdnDomainRealTimeTrafficDataResponse() {}

  explicit DescribeDcdnDomainRealTimeTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRealTimeTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRealTimeTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRealTimeTrafficDataResponse() = default;
};
class DescribeDcdnDomainRegionDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnDomainRegionDataRequest() {}

  explicit DescribeDcdnDomainRegionDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnDomainRegionDataRequest() = default;
};
class DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData : public Darabonba::Model {
public:
  shared_ptr<string> qps{};
  shared_ptr<string> totalQuery{};
  shared_ptr<string> totalBytes{};
  shared_ptr<string> regionEname{};
  shared_ptr<string> region{};
  shared_ptr<string> avgResponseRate{};
  shared_ptr<string> avgResponseTime{};
  shared_ptr<string> proportion{};
  shared_ptr<string> avgObjectSize{};
  shared_ptr<string> bps{};
  shared_ptr<string> bytesProportion{};

  DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData() {}

  explicit DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qps) {
      res["Qps"] = boost::any(*qps);
    }
    if (totalQuery) {
      res["TotalQuery"] = boost::any(*totalQuery);
    }
    if (totalBytes) {
      res["TotalBytes"] = boost::any(*totalBytes);
    }
    if (regionEname) {
      res["RegionEname"] = boost::any(*regionEname);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (avgResponseRate) {
      res["AvgResponseRate"] = boost::any(*avgResponseRate);
    }
    if (avgResponseTime) {
      res["AvgResponseTime"] = boost::any(*avgResponseTime);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    if (avgObjectSize) {
      res["AvgObjectSize"] = boost::any(*avgObjectSize);
    }
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (bytesProportion) {
      res["BytesProportion"] = boost::any(*bytesProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Qps") != m.end() && !m["Qps"].empty()) {
      qps = make_shared<string>(boost::any_cast<string>(m["Qps"]));
    }
    if (m.find("TotalQuery") != m.end() && !m["TotalQuery"].empty()) {
      totalQuery = make_shared<string>(boost::any_cast<string>(m["TotalQuery"]));
    }
    if (m.find("TotalBytes") != m.end() && !m["TotalBytes"].empty()) {
      totalBytes = make_shared<string>(boost::any_cast<string>(m["TotalBytes"]));
    }
    if (m.find("RegionEname") != m.end() && !m["RegionEname"].empty()) {
      regionEname = make_shared<string>(boost::any_cast<string>(m["RegionEname"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("AvgResponseRate") != m.end() && !m["AvgResponseRate"].empty()) {
      avgResponseRate = make_shared<string>(boost::any_cast<string>(m["AvgResponseRate"]));
    }
    if (m.find("AvgResponseTime") != m.end() && !m["AvgResponseTime"].empty()) {
      avgResponseTime = make_shared<string>(boost::any_cast<string>(m["AvgResponseTime"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<string>(boost::any_cast<string>(m["Proportion"]));
    }
    if (m.find("AvgObjectSize") != m.end() && !m["AvgObjectSize"].empty()) {
      avgObjectSize = make_shared<string>(boost::any_cast<string>(m["AvgObjectSize"]));
    }
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<string>(boost::any_cast<string>(m["Bps"]));
    }
    if (m.find("BytesProportion") != m.end() && !m["BytesProportion"].empty()) {
      bytesProportion = make_shared<string>(boost::any_cast<string>(m["BytesProportion"]));
    }
  }


  virtual ~DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData() = default;
};
class DescribeDcdnDomainRegionDataResponseBodyValue : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData>> regionProportionData{};

  DescribeDcdnDomainRegionDataResponseBodyValue() {}

  explicit DescribeDcdnDomainRegionDataResponseBodyValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionProportionData) {
      vector<boost::any> temp1;
      for(auto item1:*regionProportionData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegionProportionData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionProportionData") != m.end() && !m["RegionProportionData"].empty()) {
      if (typeid(vector<boost::any>) == m["RegionProportionData"].type()) {
        vector<DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegionProportionData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regionProportionData = make_shared<vector<DescribeDcdnDomainRegionDataResponseBodyValueRegionProportionData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRegionDataResponseBodyValue() = default;
};
class DescribeDcdnDomainRegionDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainRegionDataResponseBodyValue> value{};

  DescribeDcdnDomainRegionDataResponseBody() {}

  explicit DescribeDcdnDomainRegionDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (value) {
      res["Value"] = value ? boost::any(value->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      if (typeid(map<string, boost::any>) == m["Value"].type()) {
        DescribeDcdnDomainRegionDataResponseBodyValue model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Value"]));
        value = make_shared<DescribeDcdnDomainRegionDataResponseBodyValue>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRegionDataResponseBody() = default;
};
class DescribeDcdnDomainRegionDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainRegionDataResponseBody> body{};

  DescribeDcdnDomainRegionDataResponse() {}

  explicit DescribeDcdnDomainRegionDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainRegionDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainRegionDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainRegionDataResponse() = default;
};
class DescribeDcdnDomainStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> functionNames{};

  DescribeDcdnDomainStagingConfigRequest() {}

  explicit DescribeDcdnDomainStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
  }


  virtual ~DescribeDcdnDomainStagingConfigRequest() = default;
};
class DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};

  DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs() {}

  explicit DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
  }


  virtual ~DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs() = default;
};
class DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> configId{};
  shared_ptr<string> functionName{};
  shared_ptr<vector<DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs>> functionArgs{};

  DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs() {}

  explicit DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (functionArgs) {
      vector<boost::any> temp1;
      for(auto item1:*functionArgs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FunctionArgs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      if (typeid(vector<boost::any>) == m["FunctionArgs"].type()) {
        vector<DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FunctionArgs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functionArgs = make_shared<vector<DescribeDcdnDomainStagingConfigResponseBodyDomainConfigsFunctionArgs>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs() = default;
};
class DescribeDcdnDomainStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs>> domainConfigs{};

  DescribeDcdnDomainStagingConfigResponseBody() {}

  explicit DescribeDcdnDomainStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainConfigs") != m.end() && !m["DomainConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfigs"].type()) {
        vector<DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfigs = make_shared<vector<DescribeDcdnDomainStagingConfigResponseBodyDomainConfigs>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainStagingConfigResponseBody() = default;
};
class DescribeDcdnDomainStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainStagingConfigResponseBody> body{};

  DescribeDcdnDomainStagingConfigResponse() {}

  explicit DescribeDcdnDomainStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainStagingConfigResponse() = default;
};
class DescribeDcdnDomainTopReferVisitRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> sortBy{};

  DescribeDcdnDomainTopReferVisitRequest() {}

  explicit DescribeDcdnDomainTopReferVisitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~DescribeDcdnDomainTopReferVisitRequest() = default;
};
class DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> visitData{};
  shared_ptr<string> referDetail{};
  shared_ptr<double> visitProportion{};

  DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList() {}

  explicit DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (referDetail) {
      res["ReferDetail"] = boost::any(*referDetail);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("ReferDetail") != m.end() && !m["ReferDetail"].empty()) {
      referDetail = make_shared<string>(boost::any_cast<string>(m["ReferDetail"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList() = default;
};
class DescribeDcdnDomainTopReferVisitResponseBodyTopReferList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList>> referList{};

  DescribeDcdnDomainTopReferVisitResponseBodyTopReferList() {}

  explicit DescribeDcdnDomainTopReferVisitResponseBodyTopReferList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referList) {
      vector<boost::any> temp1;
      for(auto item1:*referList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReferList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferList") != m.end() && !m["ReferList"].empty()) {
      if (typeid(vector<boost::any>) == m["ReferList"].type()) {
        vector<DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReferList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        referList = make_shared<vector<DescribeDcdnDomainTopReferVisitResponseBodyTopReferListReferList>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopReferVisitResponseBodyTopReferList() = default;
};
class DescribeDcdnDomainTopReferVisitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<DescribeDcdnDomainTopReferVisitResponseBodyTopReferList> topReferList{};

  DescribeDcdnDomainTopReferVisitResponseBody() {}

  explicit DescribeDcdnDomainTopReferVisitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (topReferList) {
      res["TopReferList"] = topReferList ? boost::any(topReferList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("TopReferList") != m.end() && !m["TopReferList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TopReferList"].type()) {
        DescribeDcdnDomainTopReferVisitResponseBodyTopReferList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TopReferList"]));
        topReferList = make_shared<DescribeDcdnDomainTopReferVisitResponseBodyTopReferList>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopReferVisitResponseBody() = default;
};
class DescribeDcdnDomainTopReferVisitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainTopReferVisitResponseBody> body{};

  DescribeDcdnDomainTopReferVisitResponse() {}

  explicit DescribeDcdnDomainTopReferVisitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainTopReferVisitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainTopReferVisitResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopReferVisitResponse() = default;
};
class DescribeDcdnDomainTopUrlVisitRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> sortBy{};

  DescribeDcdnDomainTopUrlVisitRequest() {}

  explicit DescribeDcdnDomainTopUrlVisitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitRequest() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<string> urlDetail{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList>> urlList{};

  DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<string> urlDetail{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList>> urlList{};

  DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl200ListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<string> urlDetail{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList>> urlList{};

  DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl300ListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<string> urlDetail{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList>> urlList{};

  DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl400ListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList : public Darabonba::Model {
public:
  shared_ptr<string> flow{};
  shared_ptr<string> urlDetail{};
  shared_ptr<double> flowProportion{};
  shared_ptr<string> visitData{};
  shared_ptr<double> visitProportion{};

  DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (urlDetail) {
      res["UrlDetail"] = boost::any(*urlDetail);
    }
    if (flowProportion) {
      res["FlowProportion"] = boost::any(*flowProportion);
    }
    if (visitData) {
      res["VisitData"] = boost::any(*visitData);
    }
    if (visitProportion) {
      res["VisitProportion"] = boost::any(*visitProportion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<string>(boost::any_cast<string>(m["Flow"]));
    }
    if (m.find("UrlDetail") != m.end() && !m["UrlDetail"].empty()) {
      urlDetail = make_shared<string>(boost::any_cast<string>(m["UrlDetail"]));
    }
    if (m.find("FlowProportion") != m.end() && !m["FlowProportion"].empty()) {
      flowProportion = make_shared<double>(boost::any_cast<double>(m["FlowProportion"]));
    }
    if (m.find("VisitData") != m.end() && !m["VisitData"].empty()) {
      visitData = make_shared<string>(boost::any_cast<string>(m["VisitData"]));
    }
    if (m.find("VisitProportion") != m.end() && !m["VisitProportion"].empty()) {
      visitProportion = make_shared<double>(boost::any_cast<double>(m["VisitProportion"]));
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList>> urlList{};

  DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (urlList) {
      vector<boost::any> temp1;
      for(auto item1:*urlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UrlList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UrlList") != m.end() && !m["UrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["UrlList"].type()) {
        vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        urlList = make_shared<vector<DescribeDcdnDomainTopUrlVisitResponseBodyUrl500ListUrlList>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List() = default;
};
class DescribeDcdnDomainTopUrlVisitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList> allUrlList{};
  shared_ptr<DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List> url200List{};
  shared_ptr<DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List> url300List{};
  shared_ptr<DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List> url400List{};
  shared_ptr<DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List> url500List{};

  DescribeDcdnDomainTopUrlVisitResponseBody() {}

  explicit DescribeDcdnDomainTopUrlVisitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (allUrlList) {
      res["AllUrlList"] = allUrlList ? boost::any(allUrlList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url200List) {
      res["Url200List"] = url200List ? boost::any(url200List->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url300List) {
      res["Url300List"] = url300List ? boost::any(url300List->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url400List) {
      res["Url400List"] = url400List ? boost::any(url400List->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (url500List) {
      res["Url500List"] = url500List ? boost::any(url500List->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("AllUrlList") != m.end() && !m["AllUrlList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AllUrlList"].type()) {
        DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AllUrlList"]));
        allUrlList = make_shared<DescribeDcdnDomainTopUrlVisitResponseBodyAllUrlList>(model1);
      }
    }
    if (m.find("Url200List") != m.end() && !m["Url200List"].empty()) {
      if (typeid(map<string, boost::any>) == m["Url200List"].type()) {
        DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Url200List"]));
        url200List = make_shared<DescribeDcdnDomainTopUrlVisitResponseBodyUrl200List>(model1);
      }
    }
    if (m.find("Url300List") != m.end() && !m["Url300List"].empty()) {
      if (typeid(map<string, boost::any>) == m["Url300List"].type()) {
        DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Url300List"]));
        url300List = make_shared<DescribeDcdnDomainTopUrlVisitResponseBodyUrl300List>(model1);
      }
    }
    if (m.find("Url400List") != m.end() && !m["Url400List"].empty()) {
      if (typeid(map<string, boost::any>) == m["Url400List"].type()) {
        DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Url400List"]));
        url400List = make_shared<DescribeDcdnDomainTopUrlVisitResponseBodyUrl400List>(model1);
      }
    }
    if (m.find("Url500List") != m.end() && !m["Url500List"].empty()) {
      if (typeid(map<string, boost::any>) == m["Url500List"].type()) {
        DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Url500List"]));
        url500List = make_shared<DescribeDcdnDomainTopUrlVisitResponseBodyUrl500List>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponseBody() = default;
};
class DescribeDcdnDomainTopUrlVisitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainTopUrlVisitResponseBody> body{};

  DescribeDcdnDomainTopUrlVisitResponse() {}

  explicit DescribeDcdnDomainTopUrlVisitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainTopUrlVisitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainTopUrlVisitResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTopUrlVisitResponse() = default;
};
class DescribeDcdnDomainTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};

  DescribeDcdnDomainTrafficDataRequest() {}

  explicit DescribeDcdnDomainTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
  }


  virtual ~DescribeDcdnDomainTrafficDataRequest() = default;
};
class DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<double> staticHttpTraffic{};
  shared_ptr<double> dynamicHttpsTraffic{};
  shared_ptr<double> traffic{};
  shared_ptr<double> dynamicHttpTraffic{};
  shared_ptr<string> timeStamp{};
  shared_ptr<double> staticHttpsTraffic{};

  DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (staticHttpTraffic) {
      res["StaticHttpTraffic"] = boost::any(*staticHttpTraffic);
    }
    if (dynamicHttpsTraffic) {
      res["DynamicHttpsTraffic"] = boost::any(*dynamicHttpsTraffic);
    }
    if (traffic) {
      res["Traffic"] = boost::any(*traffic);
    }
    if (dynamicHttpTraffic) {
      res["DynamicHttpTraffic"] = boost::any(*dynamicHttpTraffic);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (staticHttpsTraffic) {
      res["StaticHttpsTraffic"] = boost::any(*staticHttpsTraffic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StaticHttpTraffic") != m.end() && !m["StaticHttpTraffic"].empty()) {
      staticHttpTraffic = make_shared<double>(boost::any_cast<double>(m["StaticHttpTraffic"]));
    }
    if (m.find("DynamicHttpsTraffic") != m.end() && !m["DynamicHttpsTraffic"].empty()) {
      dynamicHttpsTraffic = make_shared<double>(boost::any_cast<double>(m["DynamicHttpsTraffic"]));
    }
    if (m.find("Traffic") != m.end() && !m["Traffic"].empty()) {
      traffic = make_shared<double>(boost::any_cast<double>(m["Traffic"]));
    }
    if (m.find("DynamicHttpTraffic") != m.end() && !m["DynamicHttpTraffic"].empty()) {
      dynamicHttpTraffic = make_shared<double>(boost::any_cast<double>(m["DynamicHttpTraffic"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("StaticHttpsTraffic") != m.end() && !m["StaticHttpsTraffic"].empty()) {
      staticHttpsTraffic = make_shared<double>(boost::any_cast<double>(m["StaticHttpsTraffic"]));
    }
  }


  virtual ~DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval() {}

  explicit DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval() = default;
};
class DescribeDcdnDomainTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval> trafficDataPerInterval{};

  DescribeDcdnDomainTrafficDataResponseBody() {}

  explicit DescribeDcdnDomainTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (trafficDataPerInterval) {
      res["TrafficDataPerInterval"] = trafficDataPerInterval ? boost::any(trafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("TrafficDataPerInterval") != m.end() && !m["TrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficDataPerInterval"].type()) {
        DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficDataPerInterval"]));
        trafficDataPerInterval = make_shared<DescribeDcdnDomainTrafficDataResponseBodyTrafficDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTrafficDataResponseBody() = default;
};
class DescribeDcdnDomainTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainTrafficDataResponseBody> body{};

  DescribeDcdnDomainTrafficDataResponse() {}

  explicit DescribeDcdnDomainTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainTrafficDataResponse() = default;
};
class DescribeDcdnDomainUvDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnDomainUvDataRequest() {}

  explicit DescribeDcdnDomainUvDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnDomainUvDataRequest() = default;
};
class DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData : public Darabonba::Model {
public:
  shared_ptr<string> value{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData() {}

  explicit DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData() = default;
};
class DescribeDcdnDomainUvDataResponseBodyUvDataInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData>> usageData{};

  DescribeDcdnDomainUvDataResponseBodyUvDataInterval() {}

  explicit DescribeDcdnDomainUvDataResponseBodyUvDataInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageData) {
      vector<boost::any> temp1;
      for(auto item1:*usageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UsageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsageData") != m.end() && !m["UsageData"].empty()) {
      if (typeid(vector<boost::any>) == m["UsageData"].type()) {
        vector<DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UsageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usageData = make_shared<vector<DescribeDcdnDomainUvDataResponseBodyUvDataIntervalUsageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainUvDataResponseBodyUvDataInterval() = default;
};
class DescribeDcdnDomainUvDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainUvDataResponseBodyUvDataInterval> uvDataInterval{};

  DescribeDcdnDomainUvDataResponseBody() {}

  explicit DescribeDcdnDomainUvDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (uvDataInterval) {
      res["UvDataInterval"] = uvDataInterval ? boost::any(uvDataInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("UvDataInterval") != m.end() && !m["UvDataInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["UvDataInterval"].type()) {
        DescribeDcdnDomainUvDataResponseBodyUvDataInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UvDataInterval"]));
        uvDataInterval = make_shared<DescribeDcdnDomainUvDataResponseBodyUvDataInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainUvDataResponseBody() = default;
};
class DescribeDcdnDomainUvDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainUvDataResponseBody> body{};

  DescribeDcdnDomainUvDataResponse() {}

  explicit DescribeDcdnDomainUvDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainUvDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainUvDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainUvDataResponse() = default;
};
class DescribeDcdnDomainWebsocketBpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};

  DescribeDcdnDomainWebsocketBpsDataRequest() {}

  explicit DescribeDcdnDomainWebsocketBpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
  }


  virtual ~DescribeDcdnDomainWebsocketBpsDataRequest() = default;
};
class DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<double> websocketBps{};

  DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (websocketBps) {
      res["WebsocketBps"] = boost::any(*websocketBps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("WebsocketBps") != m.end() && !m["WebsocketBps"].empty()) {
      websocketBps = make_shared<double>(boost::any_cast<double>(m["WebsocketBps"]));
    }
  }


  virtual ~DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval() {}

  explicit DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval() = default;
};
class DescribeDcdnDomainWebsocketBpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval> bpsDataPerInterval{};

  DescribeDcdnDomainWebsocketBpsDataResponseBody() {}

  explicit DescribeDcdnDomainWebsocketBpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (bpsDataPerInterval) {
      res["BpsDataPerInterval"] = bpsDataPerInterval ? boost::any(bpsDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("BpsDataPerInterval") != m.end() && !m["BpsDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["BpsDataPerInterval"].type()) {
        DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BpsDataPerInterval"]));
        bpsDataPerInterval = make_shared<DescribeDcdnDomainWebsocketBpsDataResponseBodyBpsDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketBpsDataResponseBody() = default;
};
class DescribeDcdnDomainWebsocketBpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainWebsocketBpsDataResponseBody> body{};

  DescribeDcdnDomainWebsocketBpsDataResponse() {}

  explicit DescribeDcdnDomainWebsocketBpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainWebsocketBpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainWebsocketBpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketBpsDataResponse() = default;
};
class DescribeDcdnDomainWebsocketHttpCodeDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};

  DescribeDcdnDomainWebsocketHttpCodeDataRequest() {}

  explicit DescribeDcdnDomainWebsocketHttpCodeDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
  }


  virtual ~DescribeDcdnDomainWebsocketHttpCodeDataRequest() = default;
};
class DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModuleWebsocketHttpCodeDataPerIntervalHttpCodeDataModule : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<double> proportion{};
  shared_ptr<double> count{};

  DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModuleWebsocketHttpCodeDataPerIntervalHttpCodeDataModule() {}

  explicit DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModuleWebsocketHttpCodeDataPerIntervalHttpCodeDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (proportion) {
      res["Proportion"] = boost::any(*proportion);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Proportion") != m.end() && !m["Proportion"].empty()) {
      proportion = make_shared<double>(boost::any_cast<double>(m["Proportion"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<double>(boost::any_cast<double>(m["Count"]));
    }
  }


  virtual ~DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModuleWebsocketHttpCodeDataPerIntervalHttpCodeDataModule() = default;
};
class DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModuleWebsocketHttpCodeDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModuleWebsocketHttpCodeDataPerIntervalHttpCodeDataModule>> httpCodeDataModule{};

  DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModuleWebsocketHttpCodeDataPerInterval() {}

  explicit DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModuleWebsocketHttpCodeDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpCodeDataModule) {
      vector<boost::any> temp1;
      for(auto item1:*httpCodeDataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HttpCodeDataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpCodeDataModule") != m.end() && !m["HttpCodeDataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["HttpCodeDataModule"].type()) {
        vector<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModuleWebsocketHttpCodeDataPerIntervalHttpCodeDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HttpCodeDataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModuleWebsocketHttpCodeDataPerIntervalHttpCodeDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        httpCodeDataModule = make_shared<vector<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModuleWebsocketHttpCodeDataPerIntervalHttpCodeDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModuleWebsocketHttpCodeDataPerInterval() = default;
};
class DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<string> timeStamp{};
  shared_ptr<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModuleWebsocketHttpCodeDataPerInterval> websocketHttpCodeDataPerInterval{};

  DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (websocketHttpCodeDataPerInterval) {
      res["WebsocketHttpCodeDataPerInterval"] = websocketHttpCodeDataPerInterval ? boost::any(websocketHttpCodeDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("WebsocketHttpCodeDataPerInterval") != m.end() && !m["WebsocketHttpCodeDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebsocketHttpCodeDataPerInterval"].type()) {
        DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModuleWebsocketHttpCodeDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebsocketHttpCodeDataPerInterval"]));
        websocketHttpCodeDataPerInterval = make_shared<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModuleWebsocketHttpCodeDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerInterval() {}

  explicit DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerInterval() = default;
};
class DescribeDcdnDomainWebsocketHttpCodeDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerInterval> dataPerInterval{};

  DescribeDcdnDomainWebsocketHttpCodeDataResponseBody() {}

  explicit DescribeDcdnDomainWebsocketHttpCodeDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (dataPerInterval) {
      res["DataPerInterval"] = dataPerInterval ? boost::any(dataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("DataPerInterval") != m.end() && !m["DataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataPerInterval"].type()) {
        DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataPerInterval"]));
        dataPerInterval = make_shared<DescribeDcdnDomainWebsocketHttpCodeDataResponseBodyDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketHttpCodeDataResponseBody() = default;
};
class DescribeDcdnDomainWebsocketHttpCodeDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainWebsocketHttpCodeDataResponseBody> body{};

  DescribeDcdnDomainWebsocketHttpCodeDataResponse() {}

  explicit DescribeDcdnDomainWebsocketHttpCodeDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainWebsocketHttpCodeDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainWebsocketHttpCodeDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketHttpCodeDataResponse() = default;
};
class DescribeDcdnDomainWebsocketTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> interval{};
  shared_ptr<string> ispNameEn{};
  shared_ptr<string> locationNameEn{};

  DescribeDcdnDomainWebsocketTrafficDataRequest() {}

  explicit DescribeDcdnDomainWebsocketTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (ispNameEn) {
      res["IspNameEn"] = boost::any(*ispNameEn);
    }
    if (locationNameEn) {
      res["LocationNameEn"] = boost::any(*locationNameEn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("IspNameEn") != m.end() && !m["IspNameEn"].empty()) {
      ispNameEn = make_shared<string>(boost::any_cast<string>(m["IspNameEn"]));
    }
    if (m.find("LocationNameEn") != m.end() && !m["LocationNameEn"].empty()) {
      locationNameEn = make_shared<string>(boost::any_cast<string>(m["LocationNameEn"]));
    }
  }


  virtual ~DescribeDcdnDomainWebsocketTrafficDataRequest() = default;
};
class DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule : public Darabonba::Model {
public:
  shared_ptr<double> websocketTraffic{};
  shared_ptr<string> timeStamp{};

  DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule() {}

  explicit DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (websocketTraffic) {
      res["WebsocketTraffic"] = boost::any(*websocketTraffic);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WebsocketTraffic") != m.end() && !m["WebsocketTraffic"].empty()) {
      websocketTraffic = make_shared<double>(boost::any_cast<double>(m["WebsocketTraffic"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule() = default;
};
class DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule>> dataModule{};

  DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval() {}

  explicit DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataModule) {
      vector<boost::any> temp1;
      for(auto item1:*dataModule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataModule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataModule") != m.end() && !m["DataModule"].empty()) {
      if (typeid(vector<boost::any>) == m["DataModule"].type()) {
        vector<DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataModule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataModule = make_shared<vector<DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerIntervalDataModule>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval() = default;
};
class DescribeDcdnDomainWebsocketTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> dataInterval{};
  shared_ptr<DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval> trafficDataPerInterval{};

  DescribeDcdnDomainWebsocketTrafficDataResponseBody() {}

  explicit DescribeDcdnDomainWebsocketTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (dataInterval) {
      res["DataInterval"] = boost::any(*dataInterval);
    }
    if (trafficDataPerInterval) {
      res["TrafficDataPerInterval"] = trafficDataPerInterval ? boost::any(trafficDataPerInterval->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DataInterval") != m.end() && !m["DataInterval"].empty()) {
      dataInterval = make_shared<string>(boost::any_cast<string>(m["DataInterval"]));
    }
    if (m.find("TrafficDataPerInterval") != m.end() && !m["TrafficDataPerInterval"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficDataPerInterval"].type()) {
        DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficDataPerInterval"]));
        trafficDataPerInterval = make_shared<DescribeDcdnDomainWebsocketTrafficDataResponseBodyTrafficDataPerInterval>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketTrafficDataResponseBody() = default;
};
class DescribeDcdnDomainWebsocketTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnDomainWebsocketTrafficDataResponseBody> body{};

  DescribeDcdnDomainWebsocketTrafficDataResponse() {}

  explicit DescribeDcdnDomainWebsocketTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnDomainWebsocketTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnDomainWebsocketTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnDomainWebsocketTrafficDataResponse() = default;
};
class DescribeDcdnHttpsDomainListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> keyword{};

  DescribeDcdnHttpsDomainListRequest() {}

  explicit DescribeDcdnHttpsDomainListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
  }


  virtual ~DescribeDcdnHttpsDomainListRequest() = default;
};
class DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo : public Darabonba::Model {
public:
  shared_ptr<string> certStartTime{};
  shared_ptr<string> certExpireTime{};
  shared_ptr<string> certUpdateTime{};
  shared_ptr<string> certType{};
  shared_ptr<string> certName{};
  shared_ptr<string> certStatus{};
  shared_ptr<string> domainName{};
  shared_ptr<string> certCommonName{};

  DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo() {}

  explicit DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certStartTime) {
      res["CertStartTime"] = boost::any(*certStartTime);
    }
    if (certExpireTime) {
      res["CertExpireTime"] = boost::any(*certExpireTime);
    }
    if (certUpdateTime) {
      res["CertUpdateTime"] = boost::any(*certUpdateTime);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certStatus) {
      res["CertStatus"] = boost::any(*certStatus);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (certCommonName) {
      res["CertCommonName"] = boost::any(*certCommonName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertStartTime") != m.end() && !m["CertStartTime"].empty()) {
      certStartTime = make_shared<string>(boost::any_cast<string>(m["CertStartTime"]));
    }
    if (m.find("CertExpireTime") != m.end() && !m["CertExpireTime"].empty()) {
      certExpireTime = make_shared<string>(boost::any_cast<string>(m["CertExpireTime"]));
    }
    if (m.find("CertUpdateTime") != m.end() && !m["CertUpdateTime"].empty()) {
      certUpdateTime = make_shared<string>(boost::any_cast<string>(m["CertUpdateTime"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertStatus") != m.end() && !m["CertStatus"].empty()) {
      certStatus = make_shared<string>(boost::any_cast<string>(m["CertStatus"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("CertCommonName") != m.end() && !m["CertCommonName"].empty()) {
      certCommonName = make_shared<string>(boost::any_cast<string>(m["CertCommonName"]));
    }
  }


  virtual ~DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo() = default;
};
class DescribeDcdnHttpsDomainListResponseBodyCertInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo>> certInfo{};

  DescribeDcdnHttpsDomainListResponseBodyCertInfos() {}

  explicit DescribeDcdnHttpsDomainListResponseBodyCertInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certInfo) {
      vector<boost::any> temp1;
      for(auto item1:*certInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertInfo") != m.end() && !m["CertInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["CertInfo"].type()) {
        vector<DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certInfo = make_shared<vector<DescribeDcdnHttpsDomainListResponseBodyCertInfosCertInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnHttpsDomainListResponseBodyCertInfos() = default;
};
class DescribeDcdnHttpsDomainListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnHttpsDomainListResponseBodyCertInfos> certInfos{};

  DescribeDcdnHttpsDomainListResponseBody() {}

  explicit DescribeDcdnHttpsDomainListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (certInfos) {
      res["CertInfos"] = certInfos ? boost::any(certInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CertInfos") != m.end() && !m["CertInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertInfos"].type()) {
        DescribeDcdnHttpsDomainListResponseBodyCertInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertInfos"]));
        certInfos = make_shared<DescribeDcdnHttpsDomainListResponseBodyCertInfos>(model1);
      }
    }
  }


  virtual ~DescribeDcdnHttpsDomainListResponseBody() = default;
};
class DescribeDcdnHttpsDomainListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnHttpsDomainListResponseBody> body{};

  DescribeDcdnHttpsDomainListResponse() {}

  explicit DescribeDcdnHttpsDomainListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnHttpsDomainListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnHttpsDomainListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnHttpsDomainListResponse() = default;
};
class DescribeDcdnIpaDomainConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};
  shared_ptr<string> functionNames{};

  DescribeDcdnIpaDomainConfigsRequest() {}

  explicit DescribeDcdnIpaDomainConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionNames) {
      res["FunctionNames"] = boost::any(*functionNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionNames") != m.end() && !m["FunctionNames"].empty()) {
      functionNames = make_shared<string>(boost::any_cast<string>(m["FunctionNames"]));
    }
  }


  virtual ~DescribeDcdnIpaDomainConfigsRequest() = default;
};
class DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg : public Darabonba::Model {
public:
  shared_ptr<string> argName{};
  shared_ptr<string> argValue{};

  DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg() {}

  explicit DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (argName) {
      res["ArgName"] = boost::any(*argName);
    }
    if (argValue) {
      res["ArgValue"] = boost::any(*argValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArgName") != m.end() && !m["ArgName"].empty()) {
      argName = make_shared<string>(boost::any_cast<string>(m["ArgName"]));
    }
    if (m.find("ArgValue") != m.end() && !m["ArgValue"].empty()) {
      argValue = make_shared<string>(boost::any_cast<string>(m["ArgValue"]));
    }
  }


  virtual ~DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg() = default;
};
class DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg>> functionArg{};

  DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs() {}

  explicit DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionArg) {
      vector<boost::any> temp1;
      for(auto item1:*functionArg){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FunctionArg"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionArg") != m.end() && !m["FunctionArg"].empty()) {
      if (typeid(vector<boost::any>) == m["FunctionArg"].type()) {
        vector<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FunctionArg"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functionArg = make_shared<vector<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs() = default;
};
class DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> configId{};
  shared_ptr<string> functionName{};
  shared_ptr<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs> functionArgs{};

  DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig() {}

  explicit DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (functionArgs) {
      res["FunctionArgs"] = functionArgs ? boost::any(functionArgs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionArgs"].type()) {
        DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionArgs"]));
        functionArgs = make_shared<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig() = default;
};
class DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig>> domainConfig{};

  DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs() {}

  explicit DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainConfig) {
      vector<boost::any> temp1;
      for(auto item1:*domainConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainConfig") != m.end() && !m["DomainConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainConfig"].type()) {
        vector<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainConfig = make_shared<vector<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigsDomainConfig>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs() = default;
};
class DescribeDcdnIpaDomainConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs> domainConfigs{};

  DescribeDcdnIpaDomainConfigsResponseBody() {}

  explicit DescribeDcdnIpaDomainConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainConfigs) {
      res["DomainConfigs"] = domainConfigs ? boost::any(domainConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainConfigs") != m.end() && !m["DomainConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainConfigs"].type()) {
        DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainConfigs"]));
        domainConfigs = make_shared<DescribeDcdnIpaDomainConfigsResponseBodyDomainConfigs>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaDomainConfigsResponseBody() = default;
};
class DescribeDcdnIpaDomainConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnIpaDomainConfigsResponseBody> body{};

  DescribeDcdnIpaDomainConfigsResponse() {}

  explicit DescribeDcdnIpaDomainConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnIpaDomainConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnIpaDomainConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaDomainConfigsResponse() = default;
};
class DescribeDcdnIpaDomainDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};

  DescribeDcdnIpaDomainDetailRequest() {}

  explicit DescribeDcdnIpaDomainDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnIpaDomainDetailRequest() = default;
};
class DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> weight{};
  shared_ptr<string> enabled{};
  shared_ptr<string> priority{};
  shared_ptr<long> port{};
  shared_ptr<string> content{};

  DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource() {}

  explicit DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<string>(boost::any_cast<string>(m["Enabled"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource() = default;
};
class DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource>> source{};

  DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources() {}

  explicit DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      vector<boost::any> temp1;
      for(auto item1:*source){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Source"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(vector<boost::any>) == m["Source"].type()) {
        vector<DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Source"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        source = make_shared<vector<DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSourcesSource>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources() = default;
};
class DescribeDcdnIpaDomainDetailResponseBodyDomainDetail : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> description{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> certName{};
  shared_ptr<string> scope{};
  shared_ptr<string> cname{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> domainName{};
  shared_ptr<DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources> sources{};

  DescribeDcdnIpaDomainDetailResponseBodyDomainDetail() {}

  explicit DescribeDcdnIpaDomainDetailResponseBodyDomainDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (sources) {
      res["Sources"] = sources ? boost::any(sources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sources"].type()) {
        DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sources"]));
        sources = make_shared<DescribeDcdnIpaDomainDetailResponseBodyDomainDetailSources>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaDomainDetailResponseBodyDomainDetail() = default;
};
class DescribeDcdnIpaDomainDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnIpaDomainDetailResponseBodyDomainDetail> domainDetail{};

  DescribeDcdnIpaDomainDetailResponseBody() {}

  explicit DescribeDcdnIpaDomainDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainDetail) {
      res["DomainDetail"] = domainDetail ? boost::any(domainDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainDetail") != m.end() && !m["DomainDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainDetail"].type()) {
        DescribeDcdnIpaDomainDetailResponseBodyDomainDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainDetail"]));
        domainDetail = make_shared<DescribeDcdnIpaDomainDetailResponseBodyDomainDetail>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaDomainDetailResponseBody() = default;
};
class DescribeDcdnIpaDomainDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnIpaDomainDetailResponseBody> body{};

  DescribeDcdnIpaDomainDetailResponse() {}

  explicit DescribeDcdnIpaDomainDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnIpaDomainDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnIpaDomainDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaDomainDetailResponse() = default;
};
class DescribeDcdnIpaServiceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnIpaServiceRequest() {}

  explicit DescribeDcdnIpaServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnIpaServiceRequest() = default;
};
class DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason : public Darabonba::Model {
public:
  shared_ptr<string> lockReason{};

  DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason() {}

  explicit DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
  }


  virtual ~DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason() = default;
};
class DescribeDcdnIpaServiceResponseBodyOperationLocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason>> lockReason{};

  DescribeDcdnIpaServiceResponseBodyOperationLocks() {}

  explicit DescribeDcdnIpaServiceResponseBodyOperationLocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      vector<boost::any> temp1;
      for(auto item1:*lockReason){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LockReason"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      if (typeid(vector<boost::any>) == m["LockReason"].type()) {
        vector<DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LockReason"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lockReason = make_shared<vector<DescribeDcdnIpaServiceResponseBodyOperationLocksLockReason>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnIpaServiceResponseBodyOperationLocks() = default;
};
class DescribeDcdnIpaServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> changingAffectTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> changingChargeType{};
  shared_ptr<string> openingTime{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> instanceId{};
  shared_ptr<DescribeDcdnIpaServiceResponseBodyOperationLocks> operationLocks{};

  DescribeDcdnIpaServiceResponseBody() {}

  explicit DescribeDcdnIpaServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changingAffectTime) {
      res["ChangingAffectTime"] = boost::any(*changingAffectTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (changingChargeType) {
      res["ChangingChargeType"] = boost::any(*changingChargeType);
    }
    if (openingTime) {
      res["OpeningTime"] = boost::any(*openingTime);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (operationLocks) {
      res["OperationLocks"] = operationLocks ? boost::any(operationLocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangingAffectTime") != m.end() && !m["ChangingAffectTime"].empty()) {
      changingAffectTime = make_shared<string>(boost::any_cast<string>(m["ChangingAffectTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ChangingChargeType") != m.end() && !m["ChangingChargeType"].empty()) {
      changingChargeType = make_shared<string>(boost::any_cast<string>(m["ChangingChargeType"]));
    }
    if (m.find("OpeningTime") != m.end() && !m["OpeningTime"].empty()) {
      openingTime = make_shared<string>(boost::any_cast<string>(m["OpeningTime"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OperationLocks") != m.end() && !m["OperationLocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationLocks"].type()) {
        DescribeDcdnIpaServiceResponseBodyOperationLocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationLocks"]));
        operationLocks = make_shared<DescribeDcdnIpaServiceResponseBodyOperationLocks>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaServiceResponseBody() = default;
};
class DescribeDcdnIpaServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnIpaServiceResponseBody> body{};

  DescribeDcdnIpaServiceResponse() {}

  explicit DescribeDcdnIpaServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnIpaServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnIpaServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaServiceResponse() = default;
};
class DescribeDcdnIpaUserDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> domainSearchType{};
  shared_ptr<bool> checkDomainShow{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> funcId{};
  shared_ptr<string> funcFilter{};

  DescribeDcdnIpaUserDomainsRequest() {}

  explicit DescribeDcdnIpaUserDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (domainSearchType) {
      res["DomainSearchType"] = boost::any(*domainSearchType);
    }
    if (checkDomainShow) {
      res["CheckDomainShow"] = boost::any(*checkDomainShow);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (funcId) {
      res["FuncId"] = boost::any(*funcId);
    }
    if (funcFilter) {
      res["FuncFilter"] = boost::any(*funcFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("DomainSearchType") != m.end() && !m["DomainSearchType"].empty()) {
      domainSearchType = make_shared<string>(boost::any_cast<string>(m["DomainSearchType"]));
    }
    if (m.find("CheckDomainShow") != m.end() && !m["CheckDomainShow"].empty()) {
      checkDomainShow = make_shared<bool>(boost::any_cast<bool>(m["CheckDomainShow"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("FuncId") != m.end() && !m["FuncId"].empty()) {
      funcId = make_shared<string>(boost::any_cast<string>(m["FuncId"]));
    }
    if (m.find("FuncFilter") != m.end() && !m["FuncFilter"].empty()) {
      funcFilter = make_shared<string>(boost::any_cast<string>(m["FuncFilter"]));
    }
  }


  virtual ~DescribeDcdnIpaUserDomainsRequest() = default;
};
class DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> weight{};
  shared_ptr<string> priority{};
  shared_ptr<long> port{};
  shared_ptr<string> content{};

  DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource() {}

  explicit DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource() = default;
};
class DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource>> source{};

  DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources() {}

  explicit DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      vector<boost::any> temp1;
      for(auto item1:*source){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Source"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(vector<boost::any>) == m["Source"].type()) {
        vector<DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Source"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        source = make_shared<vector<DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSourcesSource>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources() = default;
};
class DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> description{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sandbox{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> cname{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> domainName{};
  shared_ptr<DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources> sources{};

  DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData() {}

  explicit DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sandbox) {
      res["Sandbox"] = boost::any(*sandbox);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (sources) {
      res["Sources"] = sources ? boost::any(sources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Sandbox") != m.end() && !m["Sandbox"].empty()) {
      sandbox = make_shared<string>(boost::any_cast<string>(m["Sandbox"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sources"].type()) {
        DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sources"]));
        sources = make_shared<DescribeDcdnIpaUserDomainsResponseBodyDomainsPageDataSources>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData() = default;
};
class DescribeDcdnIpaUserDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData>> pageData{};

  DescribeDcdnIpaUserDomainsResponseBodyDomains() {}

  explicit DescribeDcdnIpaUserDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageData) {
      vector<boost::any> temp1;
      for(auto item1:*pageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageData") != m.end() && !m["PageData"].empty()) {
      if (typeid(vector<boost::any>) == m["PageData"].type()) {
        vector<DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pageData = make_shared<vector<DescribeDcdnIpaUserDomainsResponseBodyDomainsPageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnIpaUserDomainsResponseBodyDomains() = default;
};
class DescribeDcdnIpaUserDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeDcdnIpaUserDomainsResponseBodyDomains> domains{};

  DescribeDcdnIpaUserDomainsResponseBody() {}

  explicit DescribeDcdnIpaUserDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribeDcdnIpaUserDomainsResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribeDcdnIpaUserDomainsResponseBodyDomains>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaUserDomainsResponseBody() = default;
};
class DescribeDcdnIpaUserDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnIpaUserDomainsResponseBody> body{};

  DescribeDcdnIpaUserDomainsResponse() {}

  explicit DescribeDcdnIpaUserDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnIpaUserDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnIpaUserDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpaUserDomainsResponse() = default;
};
class DescribeDcdnIpInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> IP{};

  DescribeDcdnIpInfoRequest() {}

  explicit DescribeDcdnIpInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
  }


  virtual ~DescribeDcdnIpInfoRequest() = default;
};
class DescribeDcdnIpInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> regionEname{};
  shared_ptr<string> region{};
  shared_ptr<string> ispEname{};
  shared_ptr<string> dcdnIp{};
  shared_ptr<string> ISP{};

  DescribeDcdnIpInfoResponseBody() {}

  explicit DescribeDcdnIpInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (regionEname) {
      res["RegionEname"] = boost::any(*regionEname);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (ispEname) {
      res["IspEname"] = boost::any(*ispEname);
    }
    if (dcdnIp) {
      res["DcdnIp"] = boost::any(*dcdnIp);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RegionEname") != m.end() && !m["RegionEname"].empty()) {
      regionEname = make_shared<string>(boost::any_cast<string>(m["RegionEname"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("IspEname") != m.end() && !m["IspEname"].empty()) {
      ispEname = make_shared<string>(boost::any_cast<string>(m["IspEname"]));
    }
    if (m.find("DcdnIp") != m.end() && !m["DcdnIp"].empty()) {
      dcdnIp = make_shared<string>(boost::any_cast<string>(m["DcdnIp"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
  }


  virtual ~DescribeDcdnIpInfoResponseBody() = default;
};
class DescribeDcdnIpInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnIpInfoResponseBody> body{};

  DescribeDcdnIpInfoResponse() {}

  explicit DescribeDcdnIpInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnIpInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnIpInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnIpInfoResponse() = default;
};
class DescribeDcdnOfflineLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  DescribeDcdnOfflineLogDeliveryRequest() {}

  explicit DescribeDcdnOfflineLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryRequest() = default;
};
class DescribeDcdnOfflineLogDeliveryResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  DescribeDcdnOfflineLogDeliveryResponseBodyDomains() {}

  explicit DescribeDcdnOfflineLogDeliveryResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryResponseBodyDomains() = default;
};
class DescribeDcdnOfflineLogDeliveryResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<long> ossId{};
  shared_ptr<string> ossPathPrefix{};
  shared_ptr<string> regionId{};
  shared_ptr<string> areaName{};
  shared_ptr<string> dlaTableName{};
  shared_ptr<string> dlaVcName{};
  shared_ptr<string> dlaDbName{};
  shared_ptr<string> regionName{};
  shared_ptr<string> areaId{};
  shared_ptr<string> isOverseas{};
  shared_ptr<string> ossBucketName{};
  shared_ptr<string> ossEndpoint{};

  DescribeDcdnOfflineLogDeliveryResponseBodyRegions() {}

  explicit DescribeDcdnOfflineLogDeliveryResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ossId) {
      res["OssId"] = boost::any(*ossId);
    }
    if (ossPathPrefix) {
      res["OssPathPrefix"] = boost::any(*ossPathPrefix);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (areaName) {
      res["AreaName"] = boost::any(*areaName);
    }
    if (dlaTableName) {
      res["DlaTableName"] = boost::any(*dlaTableName);
    }
    if (dlaVcName) {
      res["DlaVcName"] = boost::any(*dlaVcName);
    }
    if (dlaDbName) {
      res["DlaDbName"] = boost::any(*dlaDbName);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (areaId) {
      res["AreaId"] = boost::any(*areaId);
    }
    if (isOverseas) {
      res["IsOverseas"] = boost::any(*isOverseas);
    }
    if (ossBucketName) {
      res["OssBucketName"] = boost::any(*ossBucketName);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OssId") != m.end() && !m["OssId"].empty()) {
      ossId = make_shared<long>(boost::any_cast<long>(m["OssId"]));
    }
    if (m.find("OssPathPrefix") != m.end() && !m["OssPathPrefix"].empty()) {
      ossPathPrefix = make_shared<string>(boost::any_cast<string>(m["OssPathPrefix"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AreaName") != m.end() && !m["AreaName"].empty()) {
      areaName = make_shared<string>(boost::any_cast<string>(m["AreaName"]));
    }
    if (m.find("DlaTableName") != m.end() && !m["DlaTableName"].empty()) {
      dlaTableName = make_shared<string>(boost::any_cast<string>(m["DlaTableName"]));
    }
    if (m.find("DlaVcName") != m.end() && !m["DlaVcName"].empty()) {
      dlaVcName = make_shared<string>(boost::any_cast<string>(m["DlaVcName"]));
    }
    if (m.find("DlaDbName") != m.end() && !m["DlaDbName"].empty()) {
      dlaDbName = make_shared<string>(boost::any_cast<string>(m["DlaDbName"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("AreaId") != m.end() && !m["AreaId"].empty()) {
      areaId = make_shared<string>(boost::any_cast<string>(m["AreaId"]));
    }
    if (m.find("IsOverseas") != m.end() && !m["IsOverseas"].empty()) {
      isOverseas = make_shared<string>(boost::any_cast<string>(m["IsOverseas"]));
    }
    if (m.find("OssBucketName") != m.end() && !m["OssBucketName"].empty()) {
      ossBucketName = make_shared<string>(boost::any_cast<string>(m["OssBucketName"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryResponseBodyRegions() = default;
};
class DescribeDcdnOfflineLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> fields{};
  shared_ptr<vector<DescribeDcdnOfflineLogDeliveryResponseBodyDomains>> domains{};
  shared_ptr<vector<DescribeDcdnOfflineLogDeliveryResponseBodyRegions>> regions{};

  DescribeDcdnOfflineLogDeliveryResponseBody() {}

  explicit DescribeDcdnOfflineLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (fields) {
      res["Fields"] = boost::any(*fields);
    }
    if (domains) {
      vector<boost::any> temp1;
      for(auto item1:*domains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Domains"] = boost::any(temp1);
    }
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Fields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Fields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fields = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<DescribeDcdnOfflineLogDeliveryResponseBodyDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Domains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnOfflineLogDeliveryResponseBodyDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domains = make_shared<vector<DescribeDcdnOfflineLogDeliveryResponseBodyDomains>>(expect1);
      }
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<DescribeDcdnOfflineLogDeliveryResponseBodyRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnOfflineLogDeliveryResponseBodyRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<DescribeDcdnOfflineLogDeliveryResponseBodyRegions>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryResponseBody() = default;
};
class DescribeDcdnOfflineLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnOfflineLogDeliveryResponseBody> body{};

  DescribeDcdnOfflineLogDeliveryResponse() {}

  explicit DescribeDcdnOfflineLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnOfflineLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnOfflineLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryResponse() = default;
};
class DescribeDcdnOfflineLogDeliveryFieldRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  DescribeDcdnOfflineLogDeliveryFieldRequest() {}

  explicit DescribeDcdnOfflineLogDeliveryFieldRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryFieldRequest() = default;
};
class DescribeDcdnOfflineLogDeliveryFieldResponseBodyFields : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> fieldId{};
  shared_ptr<string> fieldName{};

  DescribeDcdnOfflineLogDeliveryFieldResponseBodyFields() {}

  explicit DescribeDcdnOfflineLogDeliveryFieldResponseBodyFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fieldId) {
      res["FieldId"] = boost::any(*fieldId);
    }
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FieldId") != m.end() && !m["FieldId"].empty()) {
      fieldId = make_shared<string>(boost::any_cast<string>(m["FieldId"]));
    }
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryFieldResponseBodyFields() = default;
};
class DescribeDcdnOfflineLogDeliveryFieldResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnOfflineLogDeliveryFieldResponseBodyFields>> fields{};

  DescribeDcdnOfflineLogDeliveryFieldResponseBody() {}

  explicit DescribeDcdnOfflineLogDeliveryFieldResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (fields) {
      vector<boost::any> temp1;
      for(auto item1:*fields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Fields"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Fields") != m.end() && !m["Fields"].empty()) {
      if (typeid(vector<boost::any>) == m["Fields"].type()) {
        vector<DescribeDcdnOfflineLogDeliveryFieldResponseBodyFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Fields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnOfflineLogDeliveryFieldResponseBodyFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fields = make_shared<vector<DescribeDcdnOfflineLogDeliveryFieldResponseBodyFields>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryFieldResponseBody() = default;
};
class DescribeDcdnOfflineLogDeliveryFieldResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnOfflineLogDeliveryFieldResponseBody> body{};

  DescribeDcdnOfflineLogDeliveryFieldResponse() {}

  explicit DescribeDcdnOfflineLogDeliveryFieldResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnOfflineLogDeliveryFieldResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnOfflineLogDeliveryFieldResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryFieldResponse() = default;
};
class DescribeDcdnOfflineLogDeliveryRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  DescribeDcdnOfflineLogDeliveryRegionsRequest() {}

  explicit DescribeDcdnOfflineLogDeliveryRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryRegionsRequest() = default;
};
class DescribeDcdnOfflineLogDeliveryRegionsResponseBodyAreasRegionInfos : public Darabonba::Model {
public:
  shared_ptr<string> isOverseas{};
  shared_ptr<string> regionName{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> regionId{};

  DescribeDcdnOfflineLogDeliveryRegionsResponseBodyAreasRegionInfos() {}

  explicit DescribeDcdnOfflineLogDeliveryRegionsResponseBodyAreasRegionInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isOverseas) {
      res["IsOverseas"] = boost::any(*isOverseas);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsOverseas") != m.end() && !m["IsOverseas"].empty()) {
      isOverseas = make_shared<string>(boost::any_cast<string>(m["IsOverseas"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryRegionsResponseBodyAreasRegionInfos() = default;
};
class DescribeDcdnOfflineLogDeliveryRegionsResponseBodyAreas : public Darabonba::Model {
public:
  shared_ptr<string> areaName{};
  shared_ptr<string> areaId{};
  shared_ptr<vector<DescribeDcdnOfflineLogDeliveryRegionsResponseBodyAreasRegionInfos>> regionInfos{};

  DescribeDcdnOfflineLogDeliveryRegionsResponseBodyAreas() {}

  explicit DescribeDcdnOfflineLogDeliveryRegionsResponseBodyAreas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (areaName) {
      res["AreaName"] = boost::any(*areaName);
    }
    if (areaId) {
      res["AreaId"] = boost::any(*areaId);
    }
    if (regionInfos) {
      vector<boost::any> temp1;
      for(auto item1:*regionInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegionInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AreaName") != m.end() && !m["AreaName"].empty()) {
      areaName = make_shared<string>(boost::any_cast<string>(m["AreaName"]));
    }
    if (m.find("AreaId") != m.end() && !m["AreaId"].empty()) {
      areaId = make_shared<string>(boost::any_cast<string>(m["AreaId"]));
    }
    if (m.find("RegionInfos") != m.end() && !m["RegionInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["RegionInfos"].type()) {
        vector<DescribeDcdnOfflineLogDeliveryRegionsResponseBodyAreasRegionInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegionInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnOfflineLogDeliveryRegionsResponseBodyAreasRegionInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regionInfos = make_shared<vector<DescribeDcdnOfflineLogDeliveryRegionsResponseBodyAreasRegionInfos>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryRegionsResponseBodyAreas() = default;
};
class DescribeDcdnOfflineLogDeliveryRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnOfflineLogDeliveryRegionsResponseBodyAreas>> areas{};

  DescribeDcdnOfflineLogDeliveryRegionsResponseBody() {}

  explicit DescribeDcdnOfflineLogDeliveryRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (areas) {
      vector<boost::any> temp1;
      for(auto item1:*areas){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Areas"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Areas") != m.end() && !m["Areas"].empty()) {
      if (typeid(vector<boost::any>) == m["Areas"].type()) {
        vector<DescribeDcdnOfflineLogDeliveryRegionsResponseBodyAreas> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Areas"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnOfflineLogDeliveryRegionsResponseBodyAreas model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        areas = make_shared<vector<DescribeDcdnOfflineLogDeliveryRegionsResponseBodyAreas>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryRegionsResponseBody() = default;
};
class DescribeDcdnOfflineLogDeliveryRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnOfflineLogDeliveryRegionsResponseBody> body{};

  DescribeDcdnOfflineLogDeliveryRegionsResponse() {}

  explicit DescribeDcdnOfflineLogDeliveryRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnOfflineLogDeliveryRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnOfflineLogDeliveryRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryRegionsResponse() = default;
};
class DescribeDcdnOfflineLogDeliveryStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  DescribeDcdnOfflineLogDeliveryStatusRequest() {}

  explicit DescribeDcdnOfflineLogDeliveryStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryStatusRequest() = default;
};
class DescribeDcdnOfflineLogDeliveryStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> openStatus{};
  shared_ptr<string> requestId{};

  DescribeDcdnOfflineLogDeliveryStatusResponseBody() {}

  explicit DescribeDcdnOfflineLogDeliveryStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openStatus) {
      res["OpenStatus"] = boost::any(*openStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenStatus") != m.end() && !m["OpenStatus"].empty()) {
      openStatus = make_shared<string>(boost::any_cast<string>(m["OpenStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryStatusResponseBody() = default;
};
class DescribeDcdnOfflineLogDeliveryStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnOfflineLogDeliveryStatusResponseBody> body{};

  DescribeDcdnOfflineLogDeliveryStatusResponse() {}

  explicit DescribeDcdnOfflineLogDeliveryStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnOfflineLogDeliveryStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnOfflineLogDeliveryStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnOfflineLogDeliveryStatusResponse() = default;
};
class DescribeDcdnRefreshQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnRefreshQuotaRequest() {}

  explicit DescribeDcdnRefreshQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnRefreshQuotaRequest() = default;
};
class DescribeDcdnRefreshQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> blockQuota{};
  shared_ptr<string> preloadRemain{};
  shared_ptr<string> requestId{};
  shared_ptr<string> blockRemain{};
  shared_ptr<string> dirRemain{};
  shared_ptr<string> urlRemain{};
  shared_ptr<string> dirQuota{};
  shared_ptr<string> urlQuota{};
  shared_ptr<string> preloadQuota{};

  DescribeDcdnRefreshQuotaResponseBody() {}

  explicit DescribeDcdnRefreshQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockQuota) {
      res["BlockQuota"] = boost::any(*blockQuota);
    }
    if (preloadRemain) {
      res["PreloadRemain"] = boost::any(*preloadRemain);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (blockRemain) {
      res["blockRemain"] = boost::any(*blockRemain);
    }
    if (dirRemain) {
      res["DirRemain"] = boost::any(*dirRemain);
    }
    if (urlRemain) {
      res["UrlRemain"] = boost::any(*urlRemain);
    }
    if (dirQuota) {
      res["DirQuota"] = boost::any(*dirQuota);
    }
    if (urlQuota) {
      res["UrlQuota"] = boost::any(*urlQuota);
    }
    if (preloadQuota) {
      res["PreloadQuota"] = boost::any(*preloadQuota);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockQuota") != m.end() && !m["BlockQuota"].empty()) {
      blockQuota = make_shared<string>(boost::any_cast<string>(m["BlockQuota"]));
    }
    if (m.find("PreloadRemain") != m.end() && !m["PreloadRemain"].empty()) {
      preloadRemain = make_shared<string>(boost::any_cast<string>(m["PreloadRemain"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("blockRemain") != m.end() && !m["blockRemain"].empty()) {
      blockRemain = make_shared<string>(boost::any_cast<string>(m["blockRemain"]));
    }
    if (m.find("DirRemain") != m.end() && !m["DirRemain"].empty()) {
      dirRemain = make_shared<string>(boost::any_cast<string>(m["DirRemain"]));
    }
    if (m.find("UrlRemain") != m.end() && !m["UrlRemain"].empty()) {
      urlRemain = make_shared<string>(boost::any_cast<string>(m["UrlRemain"]));
    }
    if (m.find("DirQuota") != m.end() && !m["DirQuota"].empty()) {
      dirQuota = make_shared<string>(boost::any_cast<string>(m["DirQuota"]));
    }
    if (m.find("UrlQuota") != m.end() && !m["UrlQuota"].empty()) {
      urlQuota = make_shared<string>(boost::any_cast<string>(m["UrlQuota"]));
    }
    if (m.find("PreloadQuota") != m.end() && !m["PreloadQuota"].empty()) {
      preloadQuota = make_shared<string>(boost::any_cast<string>(m["PreloadQuota"]));
    }
  }


  virtual ~DescribeDcdnRefreshQuotaResponseBody() = default;
};
class DescribeDcdnRefreshQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnRefreshQuotaResponseBody> body{};

  DescribeDcdnRefreshQuotaResponse() {}

  explicit DescribeDcdnRefreshQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnRefreshQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnRefreshQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnRefreshQuotaResponse() = default;
};
class DescribeDcdnRefreshTaskByIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> taskId{};

  DescribeDcdnRefreshTaskByIdRequest() {}

  explicit DescribeDcdnRefreshTaskByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeDcdnRefreshTaskByIdRequest() = default;
};
class DescribeDcdnRefreshTaskByIdResponseBodyTasks : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> objectType{};
  shared_ptr<string> process{};
  shared_ptr<string> description{};
  shared_ptr<string> objectPath{};
  shared_ptr<string> taskId{};

  DescribeDcdnRefreshTaskByIdResponseBodyTasks() {}

  explicit DescribeDcdnRefreshTaskByIdResponseBodyTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (process) {
      res["Process"] = boost::any(*process);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      process = make_shared<string>(boost::any_cast<string>(m["Process"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeDcdnRefreshTaskByIdResponseBodyTasks() = default;
};
class DescribeDcdnRefreshTaskByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnRefreshTaskByIdResponseBodyTasks>> tasks{};

  DescribeDcdnRefreshTaskByIdResponseBody() {}

  explicit DescribeDcdnRefreshTaskByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<DescribeDcdnRefreshTaskByIdResponseBodyTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnRefreshTaskByIdResponseBodyTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<DescribeDcdnRefreshTaskByIdResponseBodyTasks>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnRefreshTaskByIdResponseBody() = default;
};
class DescribeDcdnRefreshTaskByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnRefreshTaskByIdResponseBody> body{};

  DescribeDcdnRefreshTaskByIdResponse() {}

  explicit DescribeDcdnRefreshTaskByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnRefreshTaskByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnRefreshTaskByIdResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnRefreshTaskByIdResponse() = default;
};
class DescribeDcdnRefreshTasksRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> taskId{};
  shared_ptr<string> objectPath{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> objectType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> status{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnRefreshTasksRequest() {}

  explicit DescribeDcdnRefreshTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnRefreshTasksRequest() = default;
};
class DescribeDcdnRefreshTasksResponseBodyTasksTask : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> objectType{};
  shared_ptr<string> process{};
  shared_ptr<string> description{};
  shared_ptr<string> objectPath{};
  shared_ptr<string> taskId{};

  DescribeDcdnRefreshTasksResponseBodyTasksTask() {}

  explicit DescribeDcdnRefreshTasksResponseBodyTasksTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (process) {
      res["Process"] = boost::any(*process);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      process = make_shared<string>(boost::any_cast<string>(m["Process"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeDcdnRefreshTasksResponseBodyTasksTask() = default;
};
class DescribeDcdnRefreshTasksResponseBodyTasks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnRefreshTasksResponseBodyTasksTask>> task{};

  DescribeDcdnRefreshTasksResponseBodyTasks() {}

  explicit DescribeDcdnRefreshTasksResponseBodyTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (task) {
      vector<boost::any> temp1;
      for(auto item1:*task){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Task"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      if (typeid(vector<boost::any>) == m["Task"].type()) {
        vector<DescribeDcdnRefreshTasksResponseBodyTasksTask> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Task"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnRefreshTasksResponseBodyTasksTask model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        task = make_shared<vector<DescribeDcdnRefreshTasksResponseBodyTasksTask>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnRefreshTasksResponseBodyTasks() = default;
};
class DescribeDcdnRefreshTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeDcdnRefreshTasksResponseBodyTasks> tasks{};

  DescribeDcdnRefreshTasksResponseBody() {}

  explicit DescribeDcdnRefreshTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (tasks) {
      res["Tasks"] = tasks ? boost::any(tasks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tasks"].type()) {
        DescribeDcdnRefreshTasksResponseBodyTasks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tasks"]));
        tasks = make_shared<DescribeDcdnRefreshTasksResponseBodyTasks>(model1);
      }
    }
  }


  virtual ~DescribeDcdnRefreshTasksResponseBody() = default;
};
class DescribeDcdnRefreshTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnRefreshTasksResponseBody> body{};

  DescribeDcdnRefreshTasksResponse() {}

  explicit DescribeDcdnRefreshTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnRefreshTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnRefreshTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnRefreshTasksResponse() = default;
};
class DescribeDcdnRegionAndIspRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnRegionAndIspRequest() {}

  explicit DescribeDcdnRegionAndIspRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnRegionAndIspRequest() = default;
};
class DescribeDcdnRegionAndIspResponseBodyRegionsRegion : public Darabonba::Model {
public:
  shared_ptr<string> nameEn{};
  shared_ptr<string> nameZh{};

  DescribeDcdnRegionAndIspResponseBodyRegionsRegion() {}

  explicit DescribeDcdnRegionAndIspResponseBodyRegionsRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameEn) {
      res["NameEn"] = boost::any(*nameEn);
    }
    if (nameZh) {
      res["NameZh"] = boost::any(*nameZh);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameEn") != m.end() && !m["NameEn"].empty()) {
      nameEn = make_shared<string>(boost::any_cast<string>(m["NameEn"]));
    }
    if (m.find("NameZh") != m.end() && !m["NameZh"].empty()) {
      nameZh = make_shared<string>(boost::any_cast<string>(m["NameZh"]));
    }
  }


  virtual ~DescribeDcdnRegionAndIspResponseBodyRegionsRegion() = default;
};
class DescribeDcdnRegionAndIspResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnRegionAndIspResponseBodyRegionsRegion>> region{};

  DescribeDcdnRegionAndIspResponseBodyRegions() {}

  explicit DescribeDcdnRegionAndIspResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      vector<boost::any> temp1;
      for(auto item1:*region){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Region"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      if (typeid(vector<boost::any>) == m["Region"].type()) {
        vector<DescribeDcdnRegionAndIspResponseBodyRegionsRegion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Region"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnRegionAndIspResponseBodyRegionsRegion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        region = make_shared<vector<DescribeDcdnRegionAndIspResponseBodyRegionsRegion>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnRegionAndIspResponseBodyRegions() = default;
};
class DescribeDcdnRegionAndIspResponseBodyIspsIsp : public Darabonba::Model {
public:
  shared_ptr<string> nameEn{};
  shared_ptr<string> nameZh{};

  DescribeDcdnRegionAndIspResponseBodyIspsIsp() {}

  explicit DescribeDcdnRegionAndIspResponseBodyIspsIsp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nameEn) {
      res["NameEn"] = boost::any(*nameEn);
    }
    if (nameZh) {
      res["NameZh"] = boost::any(*nameZh);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NameEn") != m.end() && !m["NameEn"].empty()) {
      nameEn = make_shared<string>(boost::any_cast<string>(m["NameEn"]));
    }
    if (m.find("NameZh") != m.end() && !m["NameZh"].empty()) {
      nameZh = make_shared<string>(boost::any_cast<string>(m["NameZh"]));
    }
  }


  virtual ~DescribeDcdnRegionAndIspResponseBodyIspsIsp() = default;
};
class DescribeDcdnRegionAndIspResponseBodyIsps : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnRegionAndIspResponseBodyIspsIsp>> isp{};

  DescribeDcdnRegionAndIspResponseBodyIsps() {}

  explicit DescribeDcdnRegionAndIspResponseBodyIsps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isp) {
      vector<boost::any> temp1;
      for(auto item1:*isp){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Isp"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      if (typeid(vector<boost::any>) == m["Isp"].type()) {
        vector<DescribeDcdnRegionAndIspResponseBodyIspsIsp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Isp"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnRegionAndIspResponseBodyIspsIsp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        isp = make_shared<vector<DescribeDcdnRegionAndIspResponseBodyIspsIsp>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnRegionAndIspResponseBodyIsps() = default;
};
class DescribeDcdnRegionAndIspResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnRegionAndIspResponseBodyRegions> regions{};
  shared_ptr<DescribeDcdnRegionAndIspResponseBodyIsps> isps{};

  DescribeDcdnRegionAndIspResponseBody() {}

  explicit DescribeDcdnRegionAndIspResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (regions) {
      res["Regions"] = regions ? boost::any(regions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isps) {
      res["Isps"] = isps ? boost::any(isps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Regions"].type()) {
        DescribeDcdnRegionAndIspResponseBodyRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Regions"]));
        regions = make_shared<DescribeDcdnRegionAndIspResponseBodyRegions>(model1);
      }
    }
    if (m.find("Isps") != m.end() && !m["Isps"].empty()) {
      if (typeid(map<string, boost::any>) == m["Isps"].type()) {
        DescribeDcdnRegionAndIspResponseBodyIsps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Isps"]));
        isps = make_shared<DescribeDcdnRegionAndIspResponseBodyIsps>(model1);
      }
    }
  }


  virtual ~DescribeDcdnRegionAndIspResponseBody() = default;
};
class DescribeDcdnRegionAndIspResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnRegionAndIspResponseBody> body{};

  DescribeDcdnRegionAndIspResponse() {}

  explicit DescribeDcdnRegionAndIspResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnRegionAndIspResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnRegionAndIspResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnRegionAndIspResponse() = default;
};
class DescribeDcdnReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<long> reportId{};
  shared_ptr<string> area{};
  shared_ptr<string> isOverseas{};
  shared_ptr<string> httpCode{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnReportRequest() {}

  explicit DescribeDcdnReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (isOverseas) {
      res["IsOverseas"] = boost::any(*isOverseas);
    }
    if (httpCode) {
      res["HttpCode"] = boost::any(*httpCode);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<long>(boost::any_cast<long>(m["ReportId"]));
    }
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("IsOverseas") != m.end() && !m["IsOverseas"].empty()) {
      isOverseas = make_shared<string>(boost::any_cast<string>(m["IsOverseas"]));
    }
    if (m.find("HttpCode") != m.end() && !m["HttpCode"].empty()) {
      httpCode = make_shared<string>(boost::any_cast<string>(m["HttpCode"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnReportRequest() = default;
};
class DescribeDcdnReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnReportResponseBody() {}

  explicit DescribeDcdnReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnReportResponseBody() = default;
};
class DescribeDcdnReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnReportResponseBody> body{};

  DescribeDcdnReportResponse() {}

  explicit DescribeDcdnReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnReportResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnReportResponse() = default;
};
class DescribeDcdnReportListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> reportId{};
  shared_ptr<string> status{};
  shared_ptr<string> permission{};

  DescribeDcdnReportListRequest() {}

  explicit DescribeDcdnReportListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (reportId) {
      res["ReportId"] = boost::any(*reportId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (permission) {
      res["Permission"] = boost::any(*permission);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ReportId") != m.end() && !m["ReportId"].empty()) {
      reportId = make_shared<long>(boost::any_cast<long>(m["ReportId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Permission") != m.end() && !m["Permission"].empty()) {
      permission = make_shared<string>(boost::any_cast<string>(m["Permission"]));
    }
  }


  virtual ~DescribeDcdnReportListRequest() = default;
};
class DescribeDcdnReportListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnReportListResponseBody() {}

  explicit DescribeDcdnReportListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnReportListResponseBody() = default;
};
class DescribeDcdnReportListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnReportListResponseBody> body{};

  DescribeDcdnReportListResponse() {}

  explicit DescribeDcdnReportListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnReportListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnReportListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnReportListResponse() = default;
};
class DescribeDcdnSecFuncInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> secFuncType{};
  shared_ptr<string> lang{};

  DescribeDcdnSecFuncInfoRequest() {}

  explicit DescribeDcdnSecFuncInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (secFuncType) {
      res["SecFuncType"] = boost::any(*secFuncType);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecFuncType") != m.end() && !m["SecFuncType"].empty()) {
      secFuncType = make_shared<string>(boost::any_cast<string>(m["SecFuncType"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeDcdnSecFuncInfoRequest() = default;
};
class DescribeDcdnSecFuncInfoResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> value{};

  DescribeDcdnSecFuncInfoResponseBodyContent() {}

  explicit DescribeDcdnSecFuncInfoResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnSecFuncInfoResponseBodyContent() = default;
};
class DescribeDcdnSecFuncInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> description{};
  shared_ptr<string> retCode{};
  shared_ptr<string> httpStatus{};
  shared_ptr<vector<DescribeDcdnSecFuncInfoResponseBodyContent>> content{};

  DescribeDcdnSecFuncInfoResponseBody() {}

  explicit DescribeDcdnSecFuncInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    if (httpStatus) {
      res["HttpStatus"] = boost::any(*httpStatus);
    }
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<string>(boost::any_cast<string>(m["RetCode"]));
    }
    if (m.find("HttpStatus") != m.end() && !m["HttpStatus"].empty()) {
      httpStatus = make_shared<string>(boost::any_cast<string>(m["HttpStatus"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<DescribeDcdnSecFuncInfoResponseBodyContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnSecFuncInfoResponseBodyContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<DescribeDcdnSecFuncInfoResponseBodyContent>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnSecFuncInfoResponseBody() = default;
};
class DescribeDcdnSecFuncInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnSecFuncInfoResponseBody> body{};

  DescribeDcdnSecFuncInfoResponse() {}

  explicit DescribeDcdnSecFuncInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnSecFuncInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnSecFuncInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnSecFuncInfoResponse() = default;
};
class DescribeDcdnServiceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnServiceRequest() {}

  explicit DescribeDcdnServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnServiceRequest() = default;
};
class DescribeDcdnServiceResponseBodyOperationLocksLockReason : public Darabonba::Model {
public:
  shared_ptr<string> lockReason{};

  DescribeDcdnServiceResponseBodyOperationLocksLockReason() {}

  explicit DescribeDcdnServiceResponseBodyOperationLocksLockReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
  }


  virtual ~DescribeDcdnServiceResponseBodyOperationLocksLockReason() = default;
};
class DescribeDcdnServiceResponseBodyOperationLocks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnServiceResponseBodyOperationLocksLockReason>> lockReason{};

  DescribeDcdnServiceResponseBodyOperationLocks() {}

  explicit DescribeDcdnServiceResponseBodyOperationLocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockReason) {
      vector<boost::any> temp1;
      for(auto item1:*lockReason){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LockReason"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      if (typeid(vector<boost::any>) == m["LockReason"].type()) {
        vector<DescribeDcdnServiceResponseBodyOperationLocksLockReason> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LockReason"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnServiceResponseBodyOperationLocksLockReason model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lockReason = make_shared<vector<DescribeDcdnServiceResponseBodyOperationLocksLockReason>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnServiceResponseBodyOperationLocks() = default;
};
class DescribeDcdnServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> websocketChangingTime{};
  shared_ptr<string> websocketChangingType{};
  shared_ptr<string> changingAffectTime{};
  shared_ptr<string> changingChargeType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> openingTime{};
  shared_ptr<string> internetChargeType{};
  shared_ptr<string> websocketType{};
  shared_ptr<string> instanceId{};
  shared_ptr<DescribeDcdnServiceResponseBodyOperationLocks> operationLocks{};

  DescribeDcdnServiceResponseBody() {}

  explicit DescribeDcdnServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (websocketChangingTime) {
      res["WebsocketChangingTime"] = boost::any(*websocketChangingTime);
    }
    if (websocketChangingType) {
      res["WebsocketChangingType"] = boost::any(*websocketChangingType);
    }
    if (changingAffectTime) {
      res["ChangingAffectTime"] = boost::any(*changingAffectTime);
    }
    if (changingChargeType) {
      res["ChangingChargeType"] = boost::any(*changingChargeType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (openingTime) {
      res["OpeningTime"] = boost::any(*openingTime);
    }
    if (internetChargeType) {
      res["InternetChargeType"] = boost::any(*internetChargeType);
    }
    if (websocketType) {
      res["WebsocketType"] = boost::any(*websocketType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (operationLocks) {
      res["OperationLocks"] = operationLocks ? boost::any(operationLocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WebsocketChangingTime") != m.end() && !m["WebsocketChangingTime"].empty()) {
      websocketChangingTime = make_shared<string>(boost::any_cast<string>(m["WebsocketChangingTime"]));
    }
    if (m.find("WebsocketChangingType") != m.end() && !m["WebsocketChangingType"].empty()) {
      websocketChangingType = make_shared<string>(boost::any_cast<string>(m["WebsocketChangingType"]));
    }
    if (m.find("ChangingAffectTime") != m.end() && !m["ChangingAffectTime"].empty()) {
      changingAffectTime = make_shared<string>(boost::any_cast<string>(m["ChangingAffectTime"]));
    }
    if (m.find("ChangingChargeType") != m.end() && !m["ChangingChargeType"].empty()) {
      changingChargeType = make_shared<string>(boost::any_cast<string>(m["ChangingChargeType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OpeningTime") != m.end() && !m["OpeningTime"].empty()) {
      openingTime = make_shared<string>(boost::any_cast<string>(m["OpeningTime"]));
    }
    if (m.find("InternetChargeType") != m.end() && !m["InternetChargeType"].empty()) {
      internetChargeType = make_shared<string>(boost::any_cast<string>(m["InternetChargeType"]));
    }
    if (m.find("WebsocketType") != m.end() && !m["WebsocketType"].empty()) {
      websocketType = make_shared<string>(boost::any_cast<string>(m["WebsocketType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OperationLocks") != m.end() && !m["OperationLocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationLocks"].type()) {
        DescribeDcdnServiceResponseBodyOperationLocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationLocks"]));
        operationLocks = make_shared<DescribeDcdnServiceResponseBodyOperationLocks>(model1);
      }
    }
  }


  virtual ~DescribeDcdnServiceResponseBody() = default;
};
class DescribeDcdnServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnServiceResponseBody> body{};

  DescribeDcdnServiceResponse() {}

  explicit DescribeDcdnServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnServiceResponse() = default;
};
class DescribeDcdnStagingIpRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  DescribeDcdnStagingIpRequest() {}

  explicit DescribeDcdnStagingIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeDcdnStagingIpRequest() = default;
};
class DescribeDcdnStagingIpResponseBodyIPV4s : public Darabonba::Model {
public:
  shared_ptr<vector<string>> IPV4{};

  DescribeDcdnStagingIpResponseBodyIPV4s() {}

  explicit DescribeDcdnStagingIpResponseBodyIPV4s(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPV4) {
      res["IPV4"] = boost::any(*IPV4);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPV4") != m.end() && !m["IPV4"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPV4"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPV4"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPV4 = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDcdnStagingIpResponseBodyIPV4s() = default;
};
class DescribeDcdnStagingIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnStagingIpResponseBodyIPV4s> IPV4s{};

  DescribeDcdnStagingIpResponseBody() {}

  explicit DescribeDcdnStagingIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (IPV4s) {
      res["IPV4s"] = IPV4s ? boost::any(IPV4s->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("IPV4s") != m.end() && !m["IPV4s"].empty()) {
      if (typeid(map<string, boost::any>) == m["IPV4s"].type()) {
        DescribeDcdnStagingIpResponseBodyIPV4s model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IPV4s"]));
        IPV4s = make_shared<DescribeDcdnStagingIpResponseBodyIPV4s>(model1);
      }
    }
  }


  virtual ~DescribeDcdnStagingIpResponseBody() = default;
};
class DescribeDcdnStagingIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnStagingIpResponseBody> body{};

  DescribeDcdnStagingIpResponse() {}

  explicit DescribeDcdnStagingIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnStagingIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnStagingIpResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnStagingIpResponse() = default;
};
class DescribeDcdnSubListRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> status{};

  DescribeDcdnSubListRequest() {}

  explicit DescribeDcdnSubListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDcdnSubListRequest() = default;
};
class DescribeDcdnSubListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnSubListResponseBody() {}

  explicit DescribeDcdnSubListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnSubListResponseBody() = default;
};
class DescribeDcdnSubListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnSubListResponseBody> body{};

  DescribeDcdnSubListResponse() {}

  explicit DescribeDcdnSubListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnSubListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnSubListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnSubListResponse() = default;
};
class DescribeDcdnTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDcdnTagResourcesRequestTag() {}

  explicit DescribeDcdnTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnTagResourcesRequestTag() = default;
};
class DescribeDcdnTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<vector<DescribeDcdnTagResourcesRequestTag>> tag{};

  DescribeDcdnTagResourcesRequest() {}

  explicit DescribeDcdnTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDcdnTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDcdnTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnTagResourcesRequest() = default;
};
class DescribeDcdnTagResourcesResponseBodyTagResourcesTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDcdnTagResourcesResponseBodyTagResourcesTag() {}

  explicit DescribeDcdnTagResourcesResponseBodyTagResourcesTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnTagResourcesResponseBodyTagResourcesTag() = default;
};
class DescribeDcdnTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<vector<DescribeDcdnTagResourcesResponseBodyTagResourcesTag>> tag{};

  DescribeDcdnTagResourcesResponseBodyTagResources() {}

  explicit DescribeDcdnTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDcdnTagResourcesResponseBodyTagResourcesTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnTagResourcesResponseBodyTagResourcesTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDcdnTagResourcesResponseBodyTagResourcesTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnTagResourcesResponseBodyTagResources() = default;
};
class DescribeDcdnTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnTagResourcesResponseBodyTagResources>> tagResources{};

  DescribeDcdnTagResourcesResponseBody() {}

  explicit DescribeDcdnTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<DescribeDcdnTagResourcesResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnTagResourcesResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<DescribeDcdnTagResourcesResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnTagResourcesResponseBody() = default;
};
class DescribeDcdnTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnTagResourcesResponseBody> body{};

  DescribeDcdnTagResourcesResponse() {}

  explicit DescribeDcdnTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnTagResourcesResponse() = default;
};
class DescribeDcdnTopDomainsByFlowRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> limit{};

  DescribeDcdnTopDomainsByFlowRequest() {}

  explicit DescribeDcdnTopDomainsByFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
  }


  virtual ~DescribeDcdnTopDomainsByFlowRequest() = default;
};
class DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain : public Darabonba::Model {
public:
  shared_ptr<long> maxBps{};
  shared_ptr<long> rank{};
  shared_ptr<long> totalAccess{};
  shared_ptr<string> trafficPercent{};
  shared_ptr<string> domainName{};
  shared_ptr<string> totalTraffic{};
  shared_ptr<string> maxBpsTime{};

  DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain() {}

  explicit DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxBps) {
      res["MaxBps"] = boost::any(*maxBps);
    }
    if (rank) {
      res["Rank"] = boost::any(*rank);
    }
    if (totalAccess) {
      res["TotalAccess"] = boost::any(*totalAccess);
    }
    if (trafficPercent) {
      res["TrafficPercent"] = boost::any(*trafficPercent);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (totalTraffic) {
      res["TotalTraffic"] = boost::any(*totalTraffic);
    }
    if (maxBpsTime) {
      res["MaxBpsTime"] = boost::any(*maxBpsTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxBps") != m.end() && !m["MaxBps"].empty()) {
      maxBps = make_shared<long>(boost::any_cast<long>(m["MaxBps"]));
    }
    if (m.find("Rank") != m.end() && !m["Rank"].empty()) {
      rank = make_shared<long>(boost::any_cast<long>(m["Rank"]));
    }
    if (m.find("TotalAccess") != m.end() && !m["TotalAccess"].empty()) {
      totalAccess = make_shared<long>(boost::any_cast<long>(m["TotalAccess"]));
    }
    if (m.find("TrafficPercent") != m.end() && !m["TrafficPercent"].empty()) {
      trafficPercent = make_shared<string>(boost::any_cast<string>(m["TrafficPercent"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("TotalTraffic") != m.end() && !m["TotalTraffic"].empty()) {
      totalTraffic = make_shared<string>(boost::any_cast<string>(m["TotalTraffic"]));
    }
    if (m.find("MaxBpsTime") != m.end() && !m["MaxBpsTime"].empty()) {
      maxBpsTime = make_shared<string>(boost::any_cast<string>(m["MaxBpsTime"]));
    }
  }


  virtual ~DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain() = default;
};
class DescribeDcdnTopDomainsByFlowResponseBodyTopDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain>> topDomain{};

  DescribeDcdnTopDomainsByFlowResponseBodyTopDomains() {}

  explicit DescribeDcdnTopDomainsByFlowResponseBodyTopDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topDomain) {
      vector<boost::any> temp1;
      for(auto item1:*topDomain){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopDomain"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopDomain") != m.end() && !m["TopDomain"].empty()) {
      if (typeid(vector<boost::any>) == m["TopDomain"].type()) {
        vector<DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopDomain"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topDomain = make_shared<vector<DescribeDcdnTopDomainsByFlowResponseBodyTopDomainsTopDomain>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnTopDomainsByFlowResponseBodyTopDomains() = default;
};
class DescribeDcdnTopDomainsByFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> domainOnlineCount{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> requestId{};
  shared_ptr<long> domainCount{};
  shared_ptr<DescribeDcdnTopDomainsByFlowResponseBodyTopDomains> topDomains{};

  DescribeDcdnTopDomainsByFlowResponseBody() {}

  explicit DescribeDcdnTopDomainsByFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainOnlineCount) {
      res["DomainOnlineCount"] = boost::any(*domainOnlineCount);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (domainCount) {
      res["DomainCount"] = boost::any(*domainCount);
    }
    if (topDomains) {
      res["TopDomains"] = topDomains ? boost::any(topDomains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainOnlineCount") != m.end() && !m["DomainOnlineCount"].empty()) {
      domainOnlineCount = make_shared<long>(boost::any_cast<long>(m["DomainOnlineCount"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DomainCount") != m.end() && !m["DomainCount"].empty()) {
      domainCount = make_shared<long>(boost::any_cast<long>(m["DomainCount"]));
    }
    if (m.find("TopDomains") != m.end() && !m["TopDomains"].empty()) {
      if (typeid(map<string, boost::any>) == m["TopDomains"].type()) {
        DescribeDcdnTopDomainsByFlowResponseBodyTopDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TopDomains"]));
        topDomains = make_shared<DescribeDcdnTopDomainsByFlowResponseBodyTopDomains>(model1);
      }
    }
  }


  virtual ~DescribeDcdnTopDomainsByFlowResponseBody() = default;
};
class DescribeDcdnTopDomainsByFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnTopDomainsByFlowResponseBody> body{};

  DescribeDcdnTopDomainsByFlowResponse() {}

  explicit DescribeDcdnTopDomainsByFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnTopDomainsByFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnTopDomainsByFlowResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnTopDomainsByFlowResponse() = default;
};
class DescribeDcdnUserBillHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnUserBillHistoryRequest() {}

  explicit DescribeDcdnUserBillHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnUserBillHistoryRequest() = default;
};
class DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem : public Darabonba::Model {
public:
  shared_ptr<double> flow{};
  shared_ptr<double> bandwidth{};
  shared_ptr<double> count{};
  shared_ptr<string> cdnRegion{};
  shared_ptr<string> chargeType{};

  DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem() {}

  explicit DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flow) {
      res["Flow"] = boost::any(*flow);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (cdnRegion) {
      res["CdnRegion"] = boost::any(*cdnRegion);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      flow = make_shared<double>(boost::any_cast<double>(m["Flow"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<double>(boost::any_cast<double>(m["Bandwidth"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<double>(boost::any_cast<double>(m["Count"]));
    }
    if (m.find("CdnRegion") != m.end() && !m["CdnRegion"].empty()) {
      cdnRegion = make_shared<string>(boost::any_cast<string>(m["CdnRegion"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
  }


  virtual ~DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem() = default;
};
class DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem>> billingDataItem{};

  DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData() {}

  explicit DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billingDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*billingDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BillingDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillingDataItem") != m.end() && !m["BillingDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["BillingDataItem"].type()) {
        vector<DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BillingDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        billingDataItem = make_shared<vector<DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingDataBillingDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData() = default;
};
class DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem : public Darabonba::Model {
public:
  shared_ptr<string> dimension{};
  shared_ptr<string> billType{};
  shared_ptr<string> billTime{};
  shared_ptr<DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData> billingData{};

  DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem() {}

  explicit DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    if (billType) {
      res["BillType"] = boost::any(*billType);
    }
    if (billTime) {
      res["BillTime"] = boost::any(*billTime);
    }
    if (billingData) {
      res["BillingData"] = billingData ? boost::any(billingData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
    if (m.find("BillType") != m.end() && !m["BillType"].empty()) {
      billType = make_shared<string>(boost::any_cast<string>(m["BillType"]));
    }
    if (m.find("BillTime") != m.end() && !m["BillTime"].empty()) {
      billTime = make_shared<string>(boost::any_cast<string>(m["BillTime"]));
    }
    if (m.find("BillingData") != m.end() && !m["BillingData"].empty()) {
      if (typeid(map<string, boost::any>) == m["BillingData"].type()) {
        DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BillingData"]));
        billingData = make_shared<DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItemBillingData>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem() = default;
};
class DescribeDcdnUserBillHistoryResponseBodyBillHistoryData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem>> billHistoryDataItem{};

  DescribeDcdnUserBillHistoryResponseBodyBillHistoryData() {}

  explicit DescribeDcdnUserBillHistoryResponseBodyBillHistoryData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billHistoryDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*billHistoryDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BillHistoryDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillHistoryDataItem") != m.end() && !m["BillHistoryDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["BillHistoryDataItem"].type()) {
        vector<DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BillHistoryDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        billHistoryDataItem = make_shared<vector<DescribeDcdnUserBillHistoryResponseBodyBillHistoryDataBillHistoryDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserBillHistoryResponseBodyBillHistoryData() = default;
};
class DescribeDcdnUserBillHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnUserBillHistoryResponseBodyBillHistoryData> billHistoryData{};

  DescribeDcdnUserBillHistoryResponseBody() {}

  explicit DescribeDcdnUserBillHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (billHistoryData) {
      res["BillHistoryData"] = billHistoryData ? boost::any(billHistoryData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("BillHistoryData") != m.end() && !m["BillHistoryData"].empty()) {
      if (typeid(map<string, boost::any>) == m["BillHistoryData"].type()) {
        DescribeDcdnUserBillHistoryResponseBodyBillHistoryData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BillHistoryData"]));
        billHistoryData = make_shared<DescribeDcdnUserBillHistoryResponseBodyBillHistoryData>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserBillHistoryResponseBody() = default;
};
class DescribeDcdnUserBillHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnUserBillHistoryResponseBody> body{};

  DescribeDcdnUserBillHistoryResponse() {}

  explicit DescribeDcdnUserBillHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserBillHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserBillHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserBillHistoryResponse() = default;
};
class DescribeDcdnUserBillTypeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DescribeDcdnUserBillTypeRequest() {}

  explicit DescribeDcdnUserBillTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DescribeDcdnUserBillTypeRequest() = default;
};
class DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> billingCycle{};
  shared_ptr<string> product{};
  shared_ptr<string> billType{};
  shared_ptr<string> dimension{};

  DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem() {}

  explicit DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (billingCycle) {
      res["BillingCycle"] = boost::any(*billingCycle);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (billType) {
      res["BillType"] = boost::any(*billType);
    }
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("BillingCycle") != m.end() && !m["BillingCycle"].empty()) {
      billingCycle = make_shared<string>(boost::any_cast<string>(m["BillingCycle"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("BillType") != m.end() && !m["BillType"].empty()) {
      billType = make_shared<string>(boost::any_cast<string>(m["BillType"]));
    }
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
  }


  virtual ~DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem() = default;
};
class DescribeDcdnUserBillTypeResponseBodyBillTypeData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem>> billTypeDataItem{};

  DescribeDcdnUserBillTypeResponseBodyBillTypeData() {}

  explicit DescribeDcdnUserBillTypeResponseBodyBillTypeData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billTypeDataItem) {
      vector<boost::any> temp1;
      for(auto item1:*billTypeDataItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BillTypeDataItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillTypeDataItem") != m.end() && !m["BillTypeDataItem"].empty()) {
      if (typeid(vector<boost::any>) == m["BillTypeDataItem"].type()) {
        vector<DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BillTypeDataItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        billTypeDataItem = make_shared<vector<DescribeDcdnUserBillTypeResponseBodyBillTypeDataBillTypeDataItem>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserBillTypeResponseBodyBillTypeData() = default;
};
class DescribeDcdnUserBillTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnUserBillTypeResponseBodyBillTypeData> billTypeData{};

  DescribeDcdnUserBillTypeResponseBody() {}

  explicit DescribeDcdnUserBillTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (billTypeData) {
      res["BillTypeData"] = billTypeData ? boost::any(billTypeData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("BillTypeData") != m.end() && !m["BillTypeData"].empty()) {
      if (typeid(map<string, boost::any>) == m["BillTypeData"].type()) {
        DescribeDcdnUserBillTypeResponseBodyBillTypeData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BillTypeData"]));
        billTypeData = make_shared<DescribeDcdnUserBillTypeResponseBodyBillTypeData>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserBillTypeResponseBody() = default;
};
class DescribeDcdnUserBillTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnUserBillTypeResponseBody> body{};

  DescribeDcdnUserBillTypeResponse() {}

  explicit DescribeDcdnUserBillTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserBillTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserBillTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserBillTypeResponse() = default;
};
class DescribeDcdnUserDomainsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDcdnUserDomainsRequestTag() {}

  explicit DescribeDcdnUserDomainsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDcdnUserDomainsRequestTag() = default;
};
class DescribeDcdnUserDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> domainSearchType{};
  shared_ptr<bool> checkDomainShow{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> changeStartTime{};
  shared_ptr<string> changeEndTime{};
  shared_ptr<vector<DescribeDcdnUserDomainsRequestTag>> tag{};

  DescribeDcdnUserDomainsRequest() {}

  explicit DescribeDcdnUserDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (domainSearchType) {
      res["DomainSearchType"] = boost::any(*domainSearchType);
    }
    if (checkDomainShow) {
      res["CheckDomainShow"] = boost::any(*checkDomainShow);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (changeStartTime) {
      res["ChangeStartTime"] = boost::any(*changeStartTime);
    }
    if (changeEndTime) {
      res["ChangeEndTime"] = boost::any(*changeEndTime);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("DomainSearchType") != m.end() && !m["DomainSearchType"].empty()) {
      domainSearchType = make_shared<string>(boost::any_cast<string>(m["DomainSearchType"]));
    }
    if (m.find("CheckDomainShow") != m.end() && !m["CheckDomainShow"].empty()) {
      checkDomainShow = make_shared<bool>(boost::any_cast<bool>(m["CheckDomainShow"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("ChangeStartTime") != m.end() && !m["ChangeStartTime"].empty()) {
      changeStartTime = make_shared<string>(boost::any_cast<string>(m["ChangeStartTime"]));
    }
    if (m.find("ChangeEndTime") != m.end() && !m["ChangeEndTime"].empty()) {
      changeEndTime = make_shared<string>(boost::any_cast<string>(m["ChangeEndTime"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDcdnUserDomainsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserDomainsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDcdnUserDomainsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsRequest() = default;
};
class DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> weight{};
  shared_ptr<string> priority{};
  shared_ptr<long> port{};
  shared_ptr<string> content{};

  DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource() {}

  explicit DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource() = default;
};
class DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource>> source{};

  DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources() {}

  explicit DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      vector<boost::any> temp1;
      for(auto item1:*source){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Source"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(vector<boost::any>) == m["Source"].type()) {
        vector<DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Source"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        source = make_shared<vector<DescribeDcdnUserDomainsResponseBodyDomainsPageDataSourcesSource>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources() = default;
};
class DescribeDcdnUserDomainsResponseBodyDomainsPageData : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> description{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sandbox{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> cname{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> domainName{};
  shared_ptr<DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources> sources{};

  DescribeDcdnUserDomainsResponseBodyDomainsPageData() {}

  explicit DescribeDcdnUserDomainsResponseBodyDomainsPageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sandbox) {
      res["Sandbox"] = boost::any(*sandbox);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (sources) {
      res["Sources"] = sources ? boost::any(sources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Sandbox") != m.end() && !m["Sandbox"].empty()) {
      sandbox = make_shared<string>(boost::any_cast<string>(m["Sandbox"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sources"].type()) {
        DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sources"]));
        sources = make_shared<DescribeDcdnUserDomainsResponseBodyDomainsPageDataSources>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsResponseBodyDomainsPageData() = default;
};
class DescribeDcdnUserDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserDomainsResponseBodyDomainsPageData>> pageData{};

  DescribeDcdnUserDomainsResponseBodyDomains() {}

  explicit DescribeDcdnUserDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageData) {
      vector<boost::any> temp1;
      for(auto item1:*pageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageData") != m.end() && !m["PageData"].empty()) {
      if (typeid(vector<boost::any>) == m["PageData"].type()) {
        vector<DescribeDcdnUserDomainsResponseBodyDomainsPageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserDomainsResponseBodyDomainsPageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pageData = make_shared<vector<DescribeDcdnUserDomainsResponseBodyDomainsPageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsResponseBodyDomains() = default;
};
class DescribeDcdnUserDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeDcdnUserDomainsResponseBodyDomains> domains{};

  DescribeDcdnUserDomainsResponseBody() {}

  explicit DescribeDcdnUserDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribeDcdnUserDomainsResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribeDcdnUserDomainsResponseBodyDomains>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsResponseBody() = default;
};
class DescribeDcdnUserDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnUserDomainsResponseBody> body{};

  DescribeDcdnUserDomainsResponse() {}

  explicit DescribeDcdnUserDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsResponse() = default;
};
class DescribeDcdnUserDomainsByFuncRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> funcId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};

  DescribeDcdnUserDomainsByFuncRequest() {}

  explicit DescribeDcdnUserDomainsByFuncRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (funcId) {
      res["FuncId"] = boost::any(*funcId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("FuncId") != m.end() && !m["FuncId"].empty()) {
      funcId = make_shared<long>(boost::any_cast<long>(m["FuncId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeDcdnUserDomainsByFuncRequest() = default;
};
class DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> weight{};
  shared_ptr<string> priority{};
  shared_ptr<long> port{};
  shared_ptr<string> content{};

  DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource() {}

  explicit DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<string>(boost::any_cast<string>(m["Weight"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource() = default;
};
class DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource>> source{};

  DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources() {}

  explicit DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      vector<boost::any> temp1;
      for(auto item1:*source){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Source"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(vector<boost::any>) == m["Source"].type()) {
        vector<DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Source"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        source = make_shared<vector<DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSourcesSource>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources() = default;
};
class DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreated{};
  shared_ptr<string> sslProtocol{};
  shared_ptr<string> description{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> sandbox{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> cname{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> cdnType{};
  shared_ptr<string> domainName{};
  shared_ptr<DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources> sources{};

  DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData() {}

  explicit DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreated) {
      res["GmtCreated"] = boost::any(*gmtCreated);
    }
    if (sslProtocol) {
      res["SslProtocol"] = boost::any(*sslProtocol);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (sandbox) {
      res["Sandbox"] = boost::any(*sandbox);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (cdnType) {
      res["CdnType"] = boost::any(*cdnType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (sources) {
      res["Sources"] = sources ? boost::any(sources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreated") != m.end() && !m["GmtCreated"].empty()) {
      gmtCreated = make_shared<string>(boost::any_cast<string>(m["GmtCreated"]));
    }
    if (m.find("SslProtocol") != m.end() && !m["SslProtocol"].empty()) {
      sslProtocol = make_shared<string>(boost::any_cast<string>(m["SslProtocol"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Sandbox") != m.end() && !m["Sandbox"].empty()) {
      sandbox = make_shared<string>(boost::any_cast<string>(m["Sandbox"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("CdnType") != m.end() && !m["CdnType"].empty()) {
      cdnType = make_shared<string>(boost::any_cast<string>(m["CdnType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sources"].type()) {
        DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sources"]));
        sources = make_shared<DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageDataSources>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData() = default;
};
class DescribeDcdnUserDomainsByFuncResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData>> pageData{};

  DescribeDcdnUserDomainsByFuncResponseBodyDomains() {}

  explicit DescribeDcdnUserDomainsByFuncResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageData) {
      vector<boost::any> temp1;
      for(auto item1:*pageData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PageData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageData") != m.end() && !m["PageData"].empty()) {
      if (typeid(vector<boost::any>) == m["PageData"].type()) {
        vector<DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PageData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pageData = make_shared<vector<DescribeDcdnUserDomainsByFuncResponseBodyDomainsPageData>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsByFuncResponseBodyDomains() = default;
};
class DescribeDcdnUserDomainsByFuncResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeDcdnUserDomainsByFuncResponseBodyDomains> domains{};

  DescribeDcdnUserDomainsByFuncResponseBody() {}

  explicit DescribeDcdnUserDomainsByFuncResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribeDcdnUserDomainsByFuncResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribeDcdnUserDomainsByFuncResponseBodyDomains>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsByFuncResponseBody() = default;
};
class DescribeDcdnUserDomainsByFuncResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnUserDomainsByFuncResponseBody> body{};

  DescribeDcdnUserDomainsByFuncResponse() {}

  explicit DescribeDcdnUserDomainsByFuncResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserDomainsByFuncResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserDomainsByFuncResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserDomainsByFuncResponse() = default;
};
class DescribeDcdnUserQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnUserQuotaRequest() {}

  explicit DescribeDcdnUserQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnUserQuotaRequest() = default;
};
class DescribeDcdnUserQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> blockQuota{};
  shared_ptr<long> refreshUrlRemain{};
  shared_ptr<long> domainQuota{};
  shared_ptr<long> blockRemain{};
  shared_ptr<long> preloadRemain{};
  shared_ptr<string> requestId{};
  shared_ptr<long> refreshUrlQuota{};
  shared_ptr<long> preloadQuota{};
  shared_ptr<long> refreshDirQuota{};
  shared_ptr<long> refreshDirRemain{};

  DescribeDcdnUserQuotaResponseBody() {}

  explicit DescribeDcdnUserQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockQuota) {
      res["BlockQuota"] = boost::any(*blockQuota);
    }
    if (refreshUrlRemain) {
      res["RefreshUrlRemain"] = boost::any(*refreshUrlRemain);
    }
    if (domainQuota) {
      res["DomainQuota"] = boost::any(*domainQuota);
    }
    if (blockRemain) {
      res["BlockRemain"] = boost::any(*blockRemain);
    }
    if (preloadRemain) {
      res["PreloadRemain"] = boost::any(*preloadRemain);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (refreshUrlQuota) {
      res["RefreshUrlQuota"] = boost::any(*refreshUrlQuota);
    }
    if (preloadQuota) {
      res["PreloadQuota"] = boost::any(*preloadQuota);
    }
    if (refreshDirQuota) {
      res["RefreshDirQuota"] = boost::any(*refreshDirQuota);
    }
    if (refreshDirRemain) {
      res["RefreshDirRemain"] = boost::any(*refreshDirRemain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockQuota") != m.end() && !m["BlockQuota"].empty()) {
      blockQuota = make_shared<long>(boost::any_cast<long>(m["BlockQuota"]));
    }
    if (m.find("RefreshUrlRemain") != m.end() && !m["RefreshUrlRemain"].empty()) {
      refreshUrlRemain = make_shared<long>(boost::any_cast<long>(m["RefreshUrlRemain"]));
    }
    if (m.find("DomainQuota") != m.end() && !m["DomainQuota"].empty()) {
      domainQuota = make_shared<long>(boost::any_cast<long>(m["DomainQuota"]));
    }
    if (m.find("BlockRemain") != m.end() && !m["BlockRemain"].empty()) {
      blockRemain = make_shared<long>(boost::any_cast<long>(m["BlockRemain"]));
    }
    if (m.find("PreloadRemain") != m.end() && !m["PreloadRemain"].empty()) {
      preloadRemain = make_shared<long>(boost::any_cast<long>(m["PreloadRemain"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RefreshUrlQuota") != m.end() && !m["RefreshUrlQuota"].empty()) {
      refreshUrlQuota = make_shared<long>(boost::any_cast<long>(m["RefreshUrlQuota"]));
    }
    if (m.find("PreloadQuota") != m.end() && !m["PreloadQuota"].empty()) {
      preloadQuota = make_shared<long>(boost::any_cast<long>(m["PreloadQuota"]));
    }
    if (m.find("RefreshDirQuota") != m.end() && !m["RefreshDirQuota"].empty()) {
      refreshDirQuota = make_shared<long>(boost::any_cast<long>(m["RefreshDirQuota"]));
    }
    if (m.find("RefreshDirRemain") != m.end() && !m["RefreshDirRemain"].empty()) {
      refreshDirRemain = make_shared<long>(boost::any_cast<long>(m["RefreshDirRemain"]));
    }
  }


  virtual ~DescribeDcdnUserQuotaResponseBody() = default;
};
class DescribeDcdnUserQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnUserQuotaResponseBody> body{};

  DescribeDcdnUserQuotaResponse() {}

  explicit DescribeDcdnUserQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserQuotaResponse() = default;
};
class DescribeDcdnUserResourcePackageRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeDcdnUserResourcePackageRequest() {}

  explicit DescribeDcdnUserResourcePackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDcdnUserResourcePackageRequest() = default;
};
class DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> status{};
  shared_ptr<string> displayName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> currCapacity{};
  shared_ptr<string> initCapacity{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> templateName{};

  DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo() {}

  explicit DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (currCapacity) {
      res["CurrCapacity"] = boost::any(*currCapacity);
    }
    if (initCapacity) {
      res["InitCapacity"] = boost::any(*initCapacity);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CurrCapacity") != m.end() && !m["CurrCapacity"].empty()) {
      currCapacity = make_shared<string>(boost::any_cast<string>(m["CurrCapacity"]));
    }
    if (m.find("InitCapacity") != m.end() && !m["InitCapacity"].empty()) {
      initCapacity = make_shared<string>(boost::any_cast<string>(m["InitCapacity"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo() = default;
};
class DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo>> resourcePackageInfo{};

  DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos() {}

  explicit DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourcePackageInfo) {
      vector<boost::any> temp1;
      for(auto item1:*resourcePackageInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourcePackageInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourcePackageInfo") != m.end() && !m["ResourcePackageInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourcePackageInfo"].type()) {
        vector<DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourcePackageInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourcePackageInfo = make_shared<vector<DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfosResourcePackageInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos() = default;
};
class DescribeDcdnUserResourcePackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos> resourcePackageInfos{};

  DescribeDcdnUserResourcePackageResponseBody() {}

  explicit DescribeDcdnUserResourcePackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourcePackageInfos) {
      res["ResourcePackageInfos"] = resourcePackageInfos ? boost::any(resourcePackageInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourcePackageInfos") != m.end() && !m["ResourcePackageInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourcePackageInfos"].type()) {
        DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourcePackageInfos"]));
        resourcePackageInfos = make_shared<DescribeDcdnUserResourcePackageResponseBodyResourcePackageInfos>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserResourcePackageResponseBody() = default;
};
class DescribeDcdnUserResourcePackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnUserResourcePackageResponseBody> body{};

  DescribeDcdnUserResourcePackageResponse() {}

  explicit DescribeDcdnUserResourcePackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserResourcePackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserResourcePackageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserResourcePackageResponse() = default;
};
class DescribeDcdnUserSecDropRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> data{};
  shared_ptr<string> secFunc{};
  shared_ptr<string> metric{};

  DescribeDcdnUserSecDropRequest() {}

  explicit DescribeDcdnUserSecDropRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (secFunc) {
      res["SecFunc"] = boost::any(*secFunc);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("SecFunc") != m.end() && !m["SecFunc"].empty()) {
      secFunc = make_shared<string>(boost::any_cast<string>(m["SecFunc"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
  }


  virtual ~DescribeDcdnUserSecDropRequest() = default;
};
class DescribeDcdnUserSecDropResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> msg{};
  shared_ptr<string> requestId{};
  shared_ptr<long> drops{};
  shared_ptr<string> uuidStr{};

  DescribeDcdnUserSecDropResponseBody() {}

  explicit DescribeDcdnUserSecDropResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (drops) {
      res["Drops"] = boost::any(*drops);
    }
    if (uuidStr) {
      res["UuidStr"] = boost::any(*uuidStr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Drops") != m.end() && !m["Drops"].empty()) {
      drops = make_shared<long>(boost::any_cast<long>(m["Drops"]));
    }
    if (m.find("UuidStr") != m.end() && !m["UuidStr"].empty()) {
      uuidStr = make_shared<string>(boost::any_cast<string>(m["UuidStr"]));
    }
  }


  virtual ~DescribeDcdnUserSecDropResponseBody() = default;
};
class DescribeDcdnUserSecDropResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnUserSecDropResponseBody> body{};

  DescribeDcdnUserSecDropResponse() {}

  explicit DescribeDcdnUserSecDropResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserSecDropResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserSecDropResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserSecDropResponse() = default;
};
class DescribeDcdnUserSecDropByMinuteRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> secFunc{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> object{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> lang{};

  DescribeDcdnUserSecDropByMinuteRequest() {}

  explicit DescribeDcdnUserSecDropByMinuteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (secFunc) {
      res["SecFunc"] = boost::any(*secFunc);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecFunc") != m.end() && !m["SecFunc"].empty()) {
      secFunc = make_shared<string>(boost::any_cast<string>(m["SecFunc"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
  }


  virtual ~DescribeDcdnUserSecDropByMinuteRequest() = default;
};
class DescribeDcdnUserSecDropByMinuteResponseBodyRows : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> tmStr{};
  shared_ptr<long> drops{};
  shared_ptr<string> object{};
  shared_ptr<string> secFunc{};
  shared_ptr<string> ruleName{};

  DescribeDcdnUserSecDropByMinuteResponseBodyRows() {}

  explicit DescribeDcdnUserSecDropByMinuteResponseBodyRows(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (tmStr) {
      res["TmStr"] = boost::any(*tmStr);
    }
    if (drops) {
      res["Drops"] = boost::any(*drops);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (secFunc) {
      res["SecFunc"] = boost::any(*secFunc);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("TmStr") != m.end() && !m["TmStr"].empty()) {
      tmStr = make_shared<string>(boost::any_cast<string>(m["TmStr"]));
    }
    if (m.find("Drops") != m.end() && !m["Drops"].empty()) {
      drops = make_shared<long>(boost::any_cast<long>(m["Drops"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("SecFunc") != m.end() && !m["SecFunc"].empty()) {
      secFunc = make_shared<string>(boost::any_cast<string>(m["SecFunc"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~DescribeDcdnUserSecDropByMinuteResponseBodyRows() = default;
};
class DescribeDcdnUserSecDropByMinuteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> description{};
  shared_ptr<long> len{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeDcdnUserSecDropByMinuteResponseBodyRows>> rows{};

  DescribeDcdnUserSecDropByMinuteResponseBody() {}

  explicit DescribeDcdnUserSecDropByMinuteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (len) {
      res["Len"] = boost::any(*len);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (rows) {
      vector<boost::any> temp1;
      for(auto item1:*rows){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rows"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Len") != m.end() && !m["Len"].empty()) {
      len = make_shared<long>(boost::any_cast<long>(m["Len"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Rows") != m.end() && !m["Rows"].empty()) {
      if (typeid(vector<boost::any>) == m["Rows"].type()) {
        vector<DescribeDcdnUserSecDropByMinuteResponseBodyRows> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rows"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserSecDropByMinuteResponseBodyRows model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rows = make_shared<vector<DescribeDcdnUserSecDropByMinuteResponseBodyRows>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserSecDropByMinuteResponseBody() = default;
};
class DescribeDcdnUserSecDropByMinuteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnUserSecDropByMinuteResponseBody> body{};

  DescribeDcdnUserSecDropByMinuteResponse() {}

  explicit DescribeDcdnUserSecDropByMinuteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserSecDropByMinuteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserSecDropByMinuteResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserSecDropByMinuteResponse() = default;
};
class DescribeDcdnUserTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  DescribeDcdnUserTagsRequest() {}

  explicit DescribeDcdnUserTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeDcdnUserTagsRequest() = default;
};
class DescribeDcdnUserTagsResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> value{};

  DescribeDcdnUserTagsResponseBodyTags() {}

  explicit DescribeDcdnUserTagsResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Value"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Value"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      value = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDcdnUserTagsResponseBodyTags() = default;
};
class DescribeDcdnUserTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnUserTagsResponseBodyTags>> tags{};

  DescribeDcdnUserTagsResponseBody() {}

  explicit DescribeDcdnUserTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeDcdnUserTagsResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnUserTagsResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeDcdnUserTagsResponseBodyTags>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnUserTagsResponseBody() = default;
};
class DescribeDcdnUserTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnUserTagsResponseBody> body{};

  DescribeDcdnUserTagsResponse() {}

  explicit DescribeDcdnUserTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnUserTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnUserTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnUserTagsResponse() = default;
};
class DescribeDcdnVerifyContentRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};

  DescribeDcdnVerifyContentRequest() {}

  explicit DescribeDcdnVerifyContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnVerifyContentRequest() = default;
};
class DescribeDcdnVerifyContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  DescribeDcdnVerifyContentResponseBody() {}

  explicit DescribeDcdnVerifyContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDcdnVerifyContentResponseBody() = default;
};
class DescribeDcdnVerifyContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnVerifyContentResponseBody> body{};

  DescribeDcdnVerifyContentResponse() {}

  explicit DescribeDcdnVerifyContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnVerifyContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnVerifyContentResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnVerifyContentResponse() = default;
};
class DescribeDcdnWafDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> domainName{};

  DescribeDcdnWafDomainRequest() {}

  explicit DescribeDcdnWafDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribeDcdnWafDomainRequest() = default;
};
class DescribeDcdnWafDomainResponseBodyOutPutDomains : public Darabonba::Model {
public:
  shared_ptr<long> aclStatus{};
  shared_ptr<long> status{};
  shared_ptr<string> domain{};
  shared_ptr<long> ccStatus{};
  shared_ptr<long> wafStatus{};

  DescribeDcdnWafDomainResponseBodyOutPutDomains() {}

  explicit DescribeDcdnWafDomainResponseBodyOutPutDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclStatus) {
      res["AclStatus"] = boost::any(*aclStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (ccStatus) {
      res["CcStatus"] = boost::any(*ccStatus);
    }
    if (wafStatus) {
      res["WafStatus"] = boost::any(*wafStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclStatus") != m.end() && !m["AclStatus"].empty()) {
      aclStatus = make_shared<long>(boost::any_cast<long>(m["AclStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("CcStatus") != m.end() && !m["CcStatus"].empty()) {
      ccStatus = make_shared<long>(boost::any_cast<long>(m["CcStatus"]));
    }
    if (m.find("WafStatus") != m.end() && !m["WafStatus"].empty()) {
      wafStatus = make_shared<long>(boost::any_cast<long>(m["WafStatus"]));
    }
  }


  virtual ~DescribeDcdnWafDomainResponseBodyOutPutDomains() = default;
};
class DescribeDcdnWafDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDcdnWafDomainResponseBodyOutPutDomains>> outPutDomains{};

  DescribeDcdnWafDomainResponseBody() {}

  explicit DescribeDcdnWafDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (outPutDomains) {
      vector<boost::any> temp1;
      for(auto item1:*outPutDomains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutPutDomains"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OutPutDomains") != m.end() && !m["OutPutDomains"].empty()) {
      if (typeid(vector<boost::any>) == m["OutPutDomains"].type()) {
        vector<DescribeDcdnWafDomainResponseBodyOutPutDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutPutDomains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDcdnWafDomainResponseBodyOutPutDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outPutDomains = make_shared<vector<DescribeDcdnWafDomainResponseBodyOutPutDomains>>(expect1);
      }
    }
  }


  virtual ~DescribeDcdnWafDomainResponseBody() = default;
};
class DescribeDcdnWafDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDcdnWafDomainResponseBody> body{};

  DescribeDcdnWafDomainResponse() {}

  explicit DescribeDcdnWafDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDcdnWafDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDcdnWafDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDcdnWafDomainResponse() = default;
};
class DescribeRoutineRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};

  DescribeRoutineRequest() {}

  explicit DescribeRoutineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeRoutineRequest() = default;
};
class DescribeRoutineResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DescribeRoutineResponseBody() {}

  explicit DescribeRoutineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRoutineResponseBody() = default;
};
class DescribeRoutineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRoutineResponseBody> body{};

  DescribeRoutineResponse() {}

  explicit DescribeRoutineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRoutineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRoutineResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRoutineResponse() = default;
};
class DescribeRoutineCanaryEnvsRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  DescribeRoutineCanaryEnvsRequest() {}

  explicit DescribeRoutineCanaryEnvsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeRoutineCanaryEnvsRequest() = default;
};
class DescribeRoutineCanaryEnvsResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DescribeRoutineCanaryEnvsResponseBody() {}

  explicit DescribeRoutineCanaryEnvsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRoutineCanaryEnvsResponseBody() = default;
};
class DescribeRoutineCanaryEnvsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRoutineCanaryEnvsResponseBody> body{};

  DescribeRoutineCanaryEnvsResponse() {}

  explicit DescribeRoutineCanaryEnvsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRoutineCanaryEnvsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRoutineCanaryEnvsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRoutineCanaryEnvsResponse() = default;
};
class DescribeRoutineCodeRevisionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};
  shared_ptr<string> selectCodeRevision{};

  DescribeRoutineCodeRevisionRequest() {}

  explicit DescribeRoutineCodeRevisionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (selectCodeRevision) {
      res["SelectCodeRevision"] = boost::any(*selectCodeRevision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SelectCodeRevision") != m.end() && !m["SelectCodeRevision"].empty()) {
      selectCodeRevision = make_shared<string>(boost::any_cast<string>(m["SelectCodeRevision"]));
    }
  }


  virtual ~DescribeRoutineCodeRevisionRequest() = default;
};
class DescribeRoutineCodeRevisionResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DescribeRoutineCodeRevisionResponseBody() {}

  explicit DescribeRoutineCodeRevisionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRoutineCodeRevisionResponseBody() = default;
};
class DescribeRoutineCodeRevisionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRoutineCodeRevisionResponseBody> body{};

  DescribeRoutineCodeRevisionResponse() {}

  explicit DescribeRoutineCodeRevisionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRoutineCodeRevisionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRoutineCodeRevisionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRoutineCodeRevisionResponse() = default;
};
class DescribeRoutineSpecRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  DescribeRoutineSpecRequest() {}

  explicit DescribeRoutineSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeRoutineSpecRequest() = default;
};
class DescribeRoutineSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DescribeRoutineSpecResponseBody() {}

  explicit DescribeRoutineSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRoutineSpecResponseBody() = default;
};
class DescribeRoutineSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRoutineSpecResponseBody> body{};

  DescribeRoutineSpecResponse() {}

  explicit DescribeRoutineSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRoutineSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRoutineSpecResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRoutineSpecResponse() = default;
};
class DescribeRoutineUserInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  DescribeRoutineUserInfoRequest() {}

  explicit DescribeRoutineUserInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DescribeRoutineUserInfoRequest() = default;
};
class DescribeRoutineUserInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  DescribeRoutineUserInfoResponseBody() {}

  explicit DescribeRoutineUserInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRoutineUserInfoResponseBody() = default;
};
class DescribeRoutineUserInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRoutineUserInfoResponseBody> body{};

  DescribeRoutineUserInfoResponse() {}

  explicit DescribeRoutineUserInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRoutineUserInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRoutineUserInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRoutineUserInfoResponse() = default;
};
class DescribeUserDcdnIpaStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeUserDcdnIpaStatusRequest() {}

  explicit DescribeUserDcdnIpaStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeUserDcdnIpaStatusRequest() = default;
};
class DescribeUserDcdnIpaStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> inDebt{};
  shared_ptr<bool> onService{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> inDebtOverdue{};
  shared_ptr<bool> enabled{};

  DescribeUserDcdnIpaStatusResponseBody() {}

  explicit DescribeUserDcdnIpaStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inDebt) {
      res["InDebt"] = boost::any(*inDebt);
    }
    if (onService) {
      res["OnService"] = boost::any(*onService);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (inDebtOverdue) {
      res["InDebtOverdue"] = boost::any(*inDebtOverdue);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InDebt") != m.end() && !m["InDebt"].empty()) {
      inDebt = make_shared<bool>(boost::any_cast<bool>(m["InDebt"]));
    }
    if (m.find("OnService") != m.end() && !m["OnService"].empty()) {
      onService = make_shared<bool>(boost::any_cast<bool>(m["OnService"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InDebtOverdue") != m.end() && !m["InDebtOverdue"].empty()) {
      inDebtOverdue = make_shared<bool>(boost::any_cast<bool>(m["InDebtOverdue"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
  }


  virtual ~DescribeUserDcdnIpaStatusResponseBody() = default;
};
class DescribeUserDcdnIpaStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeUserDcdnIpaStatusResponseBody> body{};

  DescribeUserDcdnIpaStatusResponse() {}

  explicit DescribeUserDcdnIpaStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserDcdnIpaStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserDcdnIpaStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserDcdnIpaStatusResponse() = default;
};
class DescribeUserDcdnStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeUserDcdnStatusRequest() {}

  explicit DescribeUserDcdnStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeUserDcdnStatusRequest() = default;
};
class DescribeUserDcdnStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> inDebt{};
  shared_ptr<bool> onService{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> inDebtOverdue{};
  shared_ptr<bool> enabled{};

  DescribeUserDcdnStatusResponseBody() {}

  explicit DescribeUserDcdnStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inDebt) {
      res["InDebt"] = boost::any(*inDebt);
    }
    if (onService) {
      res["OnService"] = boost::any(*onService);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (inDebtOverdue) {
      res["InDebtOverdue"] = boost::any(*inDebtOverdue);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InDebt") != m.end() && !m["InDebt"].empty()) {
      inDebt = make_shared<bool>(boost::any_cast<bool>(m["InDebt"]));
    }
    if (m.find("OnService") != m.end() && !m["OnService"].empty()) {
      onService = make_shared<bool>(boost::any_cast<bool>(m["OnService"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InDebtOverdue") != m.end() && !m["InDebtOverdue"].empty()) {
      inDebtOverdue = make_shared<bool>(boost::any_cast<bool>(m["InDebtOverdue"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
  }


  virtual ~DescribeUserDcdnStatusResponseBody() = default;
};
class DescribeUserDcdnStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeUserDcdnStatusResponseBody> body{};

  DescribeUserDcdnStatusResponse() {}

  explicit DescribeUserDcdnStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserDcdnStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserDcdnStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserDcdnStatusResponse() = default;
};
class DescribeUserErStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeUserErStatusRequest() {}

  explicit DescribeUserErStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeUserErStatusRequest() = default;
};
class DescribeUserErStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> inDebt{};
  shared_ptr<bool> onService{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> inDebtOverdue{};
  shared_ptr<bool> enabled{};

  DescribeUserErStatusResponseBody() {}

  explicit DescribeUserErStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inDebt) {
      res["InDebt"] = boost::any(*inDebt);
    }
    if (onService) {
      res["OnService"] = boost::any(*onService);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (inDebtOverdue) {
      res["InDebtOverdue"] = boost::any(*inDebtOverdue);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InDebt") != m.end() && !m["InDebt"].empty()) {
      inDebt = make_shared<bool>(boost::any_cast<bool>(m["InDebt"]));
    }
    if (m.find("OnService") != m.end() && !m["OnService"].empty()) {
      onService = make_shared<bool>(boost::any_cast<bool>(m["OnService"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InDebtOverdue") != m.end() && !m["InDebtOverdue"].empty()) {
      inDebtOverdue = make_shared<bool>(boost::any_cast<bool>(m["InDebtOverdue"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
  }


  virtual ~DescribeUserErStatusResponseBody() = default;
};
class DescribeUserErStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeUserErStatusResponseBody> body{};

  DescribeUserErStatusResponse() {}

  explicit DescribeUserErStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserErStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserErStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserErStatusResponse() = default;
};
class DescribeUserLogserviceStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};

  DescribeUserLogserviceStatusRequest() {}

  explicit DescribeUserLogserviceStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeUserLogserviceStatusRequest() = default;
};
class DescribeUserLogserviceStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> inDebt{};
  shared_ptr<bool> onService{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> inDebtOverdue{};
  shared_ptr<bool> enabled{};

  DescribeUserLogserviceStatusResponseBody() {}

  explicit DescribeUserLogserviceStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inDebt) {
      res["InDebt"] = boost::any(*inDebt);
    }
    if (onService) {
      res["OnService"] = boost::any(*onService);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (inDebtOverdue) {
      res["InDebtOverdue"] = boost::any(*inDebtOverdue);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InDebt") != m.end() && !m["InDebt"].empty()) {
      inDebt = make_shared<bool>(boost::any_cast<bool>(m["InDebt"]));
    }
    if (m.find("OnService") != m.end() && !m["OnService"].empty()) {
      onService = make_shared<bool>(boost::any_cast<bool>(m["OnService"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InDebtOverdue") != m.end() && !m["InDebtOverdue"].empty()) {
      inDebtOverdue = make_shared<bool>(boost::any_cast<bool>(m["InDebtOverdue"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
  }


  virtual ~DescribeUserLogserviceStatusResponseBody() = default;
};
class DescribeUserLogserviceStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeUserLogserviceStatusResponseBody> body{};

  DescribeUserLogserviceStatusResponse() {}

  explicit DescribeUserLogserviceStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserLogserviceStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserLogserviceStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserLogserviceStatusResponse() = default;
};
class DisableDcdnDomainOfflineLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};

  DisableDcdnDomainOfflineLogDeliveryRequest() {}

  explicit DisableDcdnDomainOfflineLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DisableDcdnDomainOfflineLogDeliveryRequest() = default;
};
class DisableDcdnDomainOfflineLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableDcdnDomainOfflineLogDeliveryResponseBody() {}

  explicit DisableDcdnDomainOfflineLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableDcdnDomainOfflineLogDeliveryResponseBody() = default;
};
class DisableDcdnDomainOfflineLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DisableDcdnDomainOfflineLogDeliveryResponseBody> body{};

  DisableDcdnDomainOfflineLogDeliveryResponse() {}

  explicit DisableDcdnDomainOfflineLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableDcdnDomainOfflineLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableDcdnDomainOfflineLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~DisableDcdnDomainOfflineLogDeliveryResponse() = default;
};
class DisableDcdnOfflineLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};

  DisableDcdnOfflineLogDeliveryRequest() {}

  explicit DisableDcdnOfflineLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
  }


  virtual ~DisableDcdnOfflineLogDeliveryRequest() = default;
};
class DisableDcdnOfflineLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableDcdnOfflineLogDeliveryResponseBody() {}

  explicit DisableDcdnOfflineLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableDcdnOfflineLogDeliveryResponseBody() = default;
};
class DisableDcdnOfflineLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DisableDcdnOfflineLogDeliveryResponseBody> body{};

  DisableDcdnOfflineLogDeliveryResponse() {}

  explicit DisableDcdnOfflineLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableDcdnOfflineLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableDcdnOfflineLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~DisableDcdnOfflineLogDeliveryResponse() = default;
};
class EditRoutineConfRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> envConf{};

  EditRoutineConfRequest() {}

  explicit EditRoutineConfRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envConf) {
      res["EnvConf"] = boost::any(*envConf);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["EnvConf"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      envConf = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~EditRoutineConfRequest() = default;
};
class EditRoutineConfShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> envConfShrink{};

  EditRoutineConfShrinkRequest() {}

  explicit EditRoutineConfShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (envConfShrink) {
      res["EnvConf"] = boost::any(*envConfShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnvConf") != m.end() && !m["EnvConf"].empty()) {
      envConfShrink = make_shared<string>(boost::any_cast<string>(m["EnvConf"]));
    }
  }


  virtual ~EditRoutineConfShrinkRequest() = default;
};
class EditRoutineConfResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  EditRoutineConfResponseBody() {}

  explicit EditRoutineConfResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EditRoutineConfResponseBody() = default;
};
class EditRoutineConfResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EditRoutineConfResponseBody> body{};

  EditRoutineConfResponse() {}

  explicit EditRoutineConfResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EditRoutineConfResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EditRoutineConfResponseBody>(model1);
      }
    }
  }


  virtual ~EditRoutineConfResponse() = default;
};
class EnableDcdnDomainOfflineLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};

  EnableDcdnDomainOfflineLogDeliveryRequest() {}

  explicit EnableDcdnDomainOfflineLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~EnableDcdnDomainOfflineLogDeliveryRequest() = default;
};
class EnableDcdnDomainOfflineLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableDcdnDomainOfflineLogDeliveryResponseBody() {}

  explicit EnableDcdnDomainOfflineLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableDcdnDomainOfflineLogDeliveryResponseBody() = default;
};
class EnableDcdnDomainOfflineLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EnableDcdnDomainOfflineLogDeliveryResponseBody> body{};

  EnableDcdnDomainOfflineLogDeliveryResponse() {}

  explicit EnableDcdnDomainOfflineLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableDcdnDomainOfflineLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableDcdnDomainOfflineLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~EnableDcdnDomainOfflineLogDeliveryResponse() = default;
};
class ModifyDCdnDomainSchdmByPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> property{};

  ModifyDCdnDomainSchdmByPropertyRequest() {}

  explicit ModifyDCdnDomainSchdmByPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (property) {
      res["Property"] = boost::any(*property);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Property") != m.end() && !m["Property"].empty()) {
      property = make_shared<string>(boost::any_cast<string>(m["Property"]));
    }
  }


  virtual ~ModifyDCdnDomainSchdmByPropertyRequest() = default;
};
class ModifyDCdnDomainSchdmByPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDCdnDomainSchdmByPropertyResponseBody() {}

  explicit ModifyDCdnDomainSchdmByPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDCdnDomainSchdmByPropertyResponseBody() = default;
};
class ModifyDCdnDomainSchdmByPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDCdnDomainSchdmByPropertyResponseBody> body{};

  ModifyDCdnDomainSchdmByPropertyResponse() {}

  explicit ModifyDCdnDomainSchdmByPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDCdnDomainSchdmByPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDCdnDomainSchdmByPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDCdnDomainSchdmByPropertyResponse() = default;
};
class OpenDcdnServiceRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> billType{};
  shared_ptr<string> websocketBillType{};

  OpenDcdnServiceRequest() {}

  explicit OpenDcdnServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (billType) {
      res["BillType"] = boost::any(*billType);
    }
    if (websocketBillType) {
      res["WebsocketBillType"] = boost::any(*websocketBillType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("BillType") != m.end() && !m["BillType"].empty()) {
      billType = make_shared<string>(boost::any_cast<string>(m["BillType"]));
    }
    if (m.find("WebsocketBillType") != m.end() && !m["WebsocketBillType"].empty()) {
      websocketBillType = make_shared<string>(boost::any_cast<string>(m["WebsocketBillType"]));
    }
  }


  virtual ~OpenDcdnServiceRequest() = default;
};
class OpenDcdnServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  OpenDcdnServiceResponseBody() {}

  explicit OpenDcdnServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenDcdnServiceResponseBody() = default;
};
class OpenDcdnServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<OpenDcdnServiceResponseBody> body{};

  OpenDcdnServiceResponse() {}

  explicit OpenDcdnServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenDcdnServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenDcdnServiceResponseBody>(model1);
      }
    }
  }


  virtual ~OpenDcdnServiceResponse() = default;
};
class PreloadDcdnObjectCachesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> objectPath{};
  shared_ptr<string> area{};

  PreloadDcdnObjectCachesRequest() {}

  explicit PreloadDcdnObjectCachesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (area) {
      res["Area"] = boost::any(*area);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
  }


  virtual ~PreloadDcdnObjectCachesRequest() = default;
};
class PreloadDcdnObjectCachesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> preloadTaskId{};
  shared_ptr<string> requestId{};

  PreloadDcdnObjectCachesResponseBody() {}

  explicit PreloadDcdnObjectCachesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (preloadTaskId) {
      res["PreloadTaskId"] = boost::any(*preloadTaskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PreloadTaskId") != m.end() && !m["PreloadTaskId"].empty()) {
      preloadTaskId = make_shared<string>(boost::any_cast<string>(m["PreloadTaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PreloadDcdnObjectCachesResponseBody() = default;
};
class PreloadDcdnObjectCachesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PreloadDcdnObjectCachesResponseBody> body{};

  PreloadDcdnObjectCachesResponse() {}

  explicit PreloadDcdnObjectCachesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PreloadDcdnObjectCachesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PreloadDcdnObjectCachesResponseBody>(model1);
      }
    }
  }


  virtual ~PreloadDcdnObjectCachesResponse() = default;
};
class PublishDcdnStagingConfigToProductionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> functionName{};

  PublishDcdnStagingConfigToProductionRequest() {}

  explicit PublishDcdnStagingConfigToProductionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
  }


  virtual ~PublishDcdnStagingConfigToProductionRequest() = default;
};
class PublishDcdnStagingConfigToProductionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PublishDcdnStagingConfigToProductionResponseBody() {}

  explicit PublishDcdnStagingConfigToProductionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PublishDcdnStagingConfigToProductionResponseBody() = default;
};
class PublishDcdnStagingConfigToProductionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PublishDcdnStagingConfigToProductionResponseBody> body{};

  PublishDcdnStagingConfigToProductionResponse() {}

  explicit PublishDcdnStagingConfigToProductionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishDcdnStagingConfigToProductionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishDcdnStagingConfigToProductionResponseBody>(model1);
      }
    }
  }


  virtual ~PublishDcdnStagingConfigToProductionResponse() = default;
};
class PublishRoutineCodeRevisionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};
  shared_ptr<string> selectCodeRevision{};
  shared_ptr<map<string, boost::any>> envs{};

  PublishRoutineCodeRevisionRequest() {}

  explicit PublishRoutineCodeRevisionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (selectCodeRevision) {
      res["SelectCodeRevision"] = boost::any(*selectCodeRevision);
    }
    if (envs) {
      res["Envs"] = boost::any(*envs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SelectCodeRevision") != m.end() && !m["SelectCodeRevision"].empty()) {
      selectCodeRevision = make_shared<string>(boost::any_cast<string>(m["SelectCodeRevision"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Envs"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      envs = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~PublishRoutineCodeRevisionRequest() = default;
};
class PublishRoutineCodeRevisionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};
  shared_ptr<string> selectCodeRevision{};
  shared_ptr<string> envsShrink{};

  PublishRoutineCodeRevisionShrinkRequest() {}

  explicit PublishRoutineCodeRevisionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (selectCodeRevision) {
      res["SelectCodeRevision"] = boost::any(*selectCodeRevision);
    }
    if (envsShrink) {
      res["Envs"] = boost::any(*envsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SelectCodeRevision") != m.end() && !m["SelectCodeRevision"].empty()) {
      selectCodeRevision = make_shared<string>(boost::any_cast<string>(m["SelectCodeRevision"]));
    }
    if (m.find("Envs") != m.end() && !m["Envs"].empty()) {
      envsShrink = make_shared<string>(boost::any_cast<string>(m["Envs"]));
    }
  }


  virtual ~PublishRoutineCodeRevisionShrinkRequest() = default;
};
class PublishRoutineCodeRevisionResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  PublishRoutineCodeRevisionResponseBody() {}

  explicit PublishRoutineCodeRevisionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PublishRoutineCodeRevisionResponseBody() = default;
};
class PublishRoutineCodeRevisionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PublishRoutineCodeRevisionResponseBody> body{};

  PublishRoutineCodeRevisionResponse() {}

  explicit PublishRoutineCodeRevisionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishRoutineCodeRevisionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishRoutineCodeRevisionResponseBody>(model1);
      }
    }
  }


  virtual ~PublishRoutineCodeRevisionResponse() = default;
};
class RefreshDcdnObjectCachesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> objectPath{};
  shared_ptr<string> objectType{};

  RefreshDcdnObjectCachesRequest() {}

  explicit RefreshDcdnObjectCachesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (objectPath) {
      res["ObjectPath"] = boost::any(*objectPath);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("ObjectPath") != m.end() && !m["ObjectPath"].empty()) {
      objectPath = make_shared<string>(boost::any_cast<string>(m["ObjectPath"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
  }


  virtual ~RefreshDcdnObjectCachesRequest() = default;
};
class RefreshDcdnObjectCachesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> refreshTaskId{};
  shared_ptr<string> requestId{};

  RefreshDcdnObjectCachesResponseBody() {}

  explicit RefreshDcdnObjectCachesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (refreshTaskId) {
      res["RefreshTaskId"] = boost::any(*refreshTaskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RefreshTaskId") != m.end() && !m["RefreshTaskId"].empty()) {
      refreshTaskId = make_shared<string>(boost::any_cast<string>(m["RefreshTaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RefreshDcdnObjectCachesResponseBody() = default;
};
class RefreshDcdnObjectCachesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RefreshDcdnObjectCachesResponseBody> body{};

  RefreshDcdnObjectCachesResponse() {}

  explicit RefreshDcdnObjectCachesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshDcdnObjectCachesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshDcdnObjectCachesResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshDcdnObjectCachesResponse() = default;
};
class RollbackDcdnStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};

  RollbackDcdnStagingConfigRequest() {}

  explicit RollbackDcdnStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~RollbackDcdnStagingConfigRequest() = default;
};
class RollbackDcdnStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RollbackDcdnStagingConfigResponseBody() {}

  explicit RollbackDcdnStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RollbackDcdnStagingConfigResponseBody() = default;
};
class RollbackDcdnStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RollbackDcdnStagingConfigResponseBody> body{};

  RollbackDcdnStagingConfigResponse() {}

  explicit RollbackDcdnStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RollbackDcdnStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RollbackDcdnStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~RollbackDcdnStagingConfigResponse() = default;
};
class SetDcdnConfigOfVersionRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> versionId{};
  shared_ptr<string> configId{};
  shared_ptr<long> functionId{};
  shared_ptr<string> functionName{};
  shared_ptr<string> functionArgs{};

  SetDcdnConfigOfVersionRequest() {}

  explicit SetDcdnConfigOfVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (functionId) {
      res["FunctionId"] = boost::any(*functionId);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (functionArgs) {
      res["FunctionArgs"] = boost::any(*functionArgs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<string>(boost::any_cast<string>(m["ConfigId"]));
    }
    if (m.find("FunctionId") != m.end() && !m["FunctionId"].empty()) {
      functionId = make_shared<long>(boost::any_cast<long>(m["FunctionId"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("FunctionArgs") != m.end() && !m["FunctionArgs"].empty()) {
      functionArgs = make_shared<string>(boost::any_cast<string>(m["FunctionArgs"]));
    }
  }


  virtual ~SetDcdnConfigOfVersionRequest() = default;
};
class SetDcdnConfigOfVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDcdnConfigOfVersionResponseBody() {}

  explicit SetDcdnConfigOfVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDcdnConfigOfVersionResponseBody() = default;
};
class SetDcdnConfigOfVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetDcdnConfigOfVersionResponseBody> body{};

  SetDcdnConfigOfVersionResponse() {}

  explicit SetDcdnConfigOfVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDcdnConfigOfVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDcdnConfigOfVersionResponseBody>(model1);
      }
    }
  }


  virtual ~SetDcdnConfigOfVersionResponse() = default;
};
class SetDcdnDomainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};
  shared_ptr<string> certName{};
  shared_ptr<string> certType{};
  shared_ptr<string> SSLProtocol{};
  shared_ptr<string> SSLPub{};
  shared_ptr<string> SSLPri{};
  shared_ptr<string> region{};
  shared_ptr<string> forceSet{};

  SetDcdnDomainCertificateRequest() {}

  explicit SetDcdnDomainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (certType) {
      res["CertType"] = boost::any(*certType);
    }
    if (SSLProtocol) {
      res["SSLProtocol"] = boost::any(*SSLProtocol);
    }
    if (SSLPub) {
      res["SSLPub"] = boost::any(*SSLPub);
    }
    if (SSLPri) {
      res["SSLPri"] = boost::any(*SSLPri);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (forceSet) {
      res["ForceSet"] = boost::any(*forceSet);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CertType") != m.end() && !m["CertType"].empty()) {
      certType = make_shared<string>(boost::any_cast<string>(m["CertType"]));
    }
    if (m.find("SSLProtocol") != m.end() && !m["SSLProtocol"].empty()) {
      SSLProtocol = make_shared<string>(boost::any_cast<string>(m["SSLProtocol"]));
    }
    if (m.find("SSLPub") != m.end() && !m["SSLPub"].empty()) {
      SSLPub = make_shared<string>(boost::any_cast<string>(m["SSLPub"]));
    }
    if (m.find("SSLPri") != m.end() && !m["SSLPri"].empty()) {
      SSLPri = make_shared<string>(boost::any_cast<string>(m["SSLPri"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ForceSet") != m.end() && !m["ForceSet"].empty()) {
      forceSet = make_shared<string>(boost::any_cast<string>(m["ForceSet"]));
    }
  }


  virtual ~SetDcdnDomainCertificateRequest() = default;
};
class SetDcdnDomainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDcdnDomainCertificateResponseBody() {}

  explicit SetDcdnDomainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDcdnDomainCertificateResponseBody() = default;
};
class SetDcdnDomainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetDcdnDomainCertificateResponseBody> body{};

  SetDcdnDomainCertificateResponse() {}

  explicit SetDcdnDomainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDcdnDomainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDcdnDomainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetDcdnDomainCertificateResponse() = default;
};
class SetDcdnDomainCSRCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> serverCertificate{};
  shared_ptr<string> domainName{};

  SetDcdnDomainCSRCertificateRequest() {}

  explicit SetDcdnDomainCSRCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (serverCertificate) {
      res["ServerCertificate"] = boost::any(*serverCertificate);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ServerCertificate") != m.end() && !m["ServerCertificate"].empty()) {
      serverCertificate = make_shared<string>(boost::any_cast<string>(m["ServerCertificate"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~SetDcdnDomainCSRCertificateRequest() = default;
};
class SetDcdnDomainCSRCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDcdnDomainCSRCertificateResponseBody() {}

  explicit SetDcdnDomainCSRCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDcdnDomainCSRCertificateResponseBody() = default;
};
class SetDcdnDomainCSRCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetDcdnDomainCSRCertificateResponseBody> body{};

  SetDcdnDomainCSRCertificateResponse() {}

  explicit SetDcdnDomainCSRCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDcdnDomainCSRCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDcdnDomainCSRCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetDcdnDomainCSRCertificateResponse() = default;
};
class SetDcdnDomainStagingConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> functions{};

  SetDcdnDomainStagingConfigRequest() {}

  explicit SetDcdnDomainStagingConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (functions) {
      res["Functions"] = boost::any(*functions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      functions = make_shared<string>(boost::any_cast<string>(m["Functions"]));
    }
  }


  virtual ~SetDcdnDomainStagingConfigRequest() = default;
};
class SetDcdnDomainStagingConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDcdnDomainStagingConfigResponseBody() {}

  explicit SetDcdnDomainStagingConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDcdnDomainStagingConfigResponseBody() = default;
};
class SetDcdnDomainStagingConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetDcdnDomainStagingConfigResponseBody> body{};

  SetDcdnDomainStagingConfigResponse() {}

  explicit SetDcdnDomainStagingConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDcdnDomainStagingConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDcdnDomainStagingConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetDcdnDomainStagingConfigResponse() = default;
};
class SetRoutineSubdomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<map<string, boost::any>> subdomains{};

  SetRoutineSubdomainRequest() {}

  explicit SetRoutineSubdomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (subdomains) {
      res["Subdomains"] = boost::any(*subdomains);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Subdomains") != m.end() && !m["Subdomains"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Subdomains"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      subdomains = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~SetRoutineSubdomainRequest() = default;
};
class SetRoutineSubdomainShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> subdomainsShrink{};

  SetRoutineSubdomainShrinkRequest() {}

  explicit SetRoutineSubdomainShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (subdomainsShrink) {
      res["Subdomains"] = boost::any(*subdomainsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Subdomains") != m.end() && !m["Subdomains"].empty()) {
      subdomainsShrink = make_shared<string>(boost::any_cast<string>(m["Subdomains"]));
    }
  }


  virtual ~SetRoutineSubdomainShrinkRequest() = default;
};
class SetRoutineSubdomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  SetRoutineSubdomainResponseBody() {}

  explicit SetRoutineSubdomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetRoutineSubdomainResponseBody() = default;
};
class SetRoutineSubdomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetRoutineSubdomainResponseBody> body{};

  SetRoutineSubdomainResponse() {}

  explicit SetRoutineSubdomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetRoutineSubdomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetRoutineSubdomainResponseBody>(model1);
      }
    }
  }


  virtual ~SetRoutineSubdomainResponse() = default;
};
class StartDcdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};

  StartDcdnDomainRequest() {}

  explicit StartDcdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~StartDcdnDomainRequest() = default;
};
class StartDcdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartDcdnDomainResponseBody() {}

  explicit StartDcdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartDcdnDomainResponseBody() = default;
};
class StartDcdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartDcdnDomainResponseBody> body{};

  StartDcdnDomainResponse() {}

  explicit StartDcdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartDcdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartDcdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~StartDcdnDomainResponse() = default;
};
class StartDcdnIpaDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};

  StartDcdnIpaDomainRequest() {}

  explicit StartDcdnIpaDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~StartDcdnIpaDomainRequest() = default;
};
class StartDcdnIpaDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartDcdnIpaDomainResponseBody() {}

  explicit StartDcdnIpaDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartDcdnIpaDomainResponseBody() = default;
};
class StartDcdnIpaDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartDcdnIpaDomainResponseBody> body{};

  StartDcdnIpaDomainResponse() {}

  explicit StartDcdnIpaDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartDcdnIpaDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartDcdnIpaDomainResponseBody>(model1);
      }
    }
  }


  virtual ~StartDcdnIpaDomainResponse() = default;
};
class StopDcdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};

  StopDcdnDomainRequest() {}

  explicit StopDcdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~StopDcdnDomainRequest() = default;
};
class StopDcdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopDcdnDomainResponseBody() {}

  explicit StopDcdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopDcdnDomainResponseBody() = default;
};
class StopDcdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StopDcdnDomainResponseBody> body{};

  StopDcdnDomainResponse() {}

  explicit StopDcdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopDcdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopDcdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~StopDcdnDomainResponse() = default;
};
class StopDcdnIpaDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};

  StopDcdnIpaDomainRequest() {}

  explicit StopDcdnIpaDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~StopDcdnIpaDomainRequest() = default;
};
class StopDcdnIpaDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopDcdnIpaDomainResponseBody() {}

  explicit StopDcdnIpaDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopDcdnIpaDomainResponseBody() = default;
};
class StopDcdnIpaDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StopDcdnIpaDomainResponseBody> body{};

  StopDcdnIpaDomainResponse() {}

  explicit StopDcdnIpaDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopDcdnIpaDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopDcdnIpaDomainResponseBody>(model1);
      }
    }
  }


  virtual ~StopDcdnIpaDomainResponse() = default;
};
class TagDcdnResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagDcdnResourcesRequestTag() {}

  explicit TagDcdnResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagDcdnResourcesRequestTag() = default;
};
class TagDcdnResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<vector<TagDcdnResourcesRequestTag>> tag{};

  TagDcdnResourcesRequest() {}

  explicit TagDcdnResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagDcdnResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagDcdnResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagDcdnResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagDcdnResourcesRequest() = default;
};
class TagDcdnResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagDcdnResourcesResponseBody() {}

  explicit TagDcdnResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagDcdnResourcesResponseBody() = default;
};
class TagDcdnResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TagDcdnResourcesResponseBody> body{};

  TagDcdnResourcesResponse() {}

  explicit TagDcdnResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagDcdnResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagDcdnResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagDcdnResourcesResponse() = default;
};
class UntagDcdnResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceType{};
  shared_ptr<bool> all{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<vector<string>> tagKey{};

  UntagDcdnResourcesRequest() {}

  explicit UntagDcdnResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagDcdnResourcesRequest() = default;
};
class UntagDcdnResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagDcdnResourcesResponseBody() {}

  explicit UntagDcdnResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagDcdnResourcesResponseBody() = default;
};
class UntagDcdnResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UntagDcdnResourcesResponseBody> body{};

  UntagDcdnResourcesResponse() {}

  explicit UntagDcdnResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagDcdnResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagDcdnResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagDcdnResourcesResponse() = default;
};
class UpdateDcdnDeliverTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> deliverId{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> reports{};
  shared_ptr<string> domainName{};
  shared_ptr<map<string, boost::any>> deliver{};
  shared_ptr<map<string, boost::any>> schedule{};

  UpdateDcdnDeliverTaskRequest() {}

  explicit UpdateDcdnDeliverTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (deliverId) {
      res["DeliverId"] = boost::any(*deliverId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (reports) {
      res["Reports"] = boost::any(*reports);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (deliver) {
      res["Deliver"] = boost::any(*deliver);
    }
    if (schedule) {
      res["Schedule"] = boost::any(*schedule);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DeliverId") != m.end() && !m["DeliverId"].empty()) {
      deliverId = make_shared<long>(boost::any_cast<long>(m["DeliverId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Reports") != m.end() && !m["Reports"].empty()) {
      reports = make_shared<string>(boost::any_cast<string>(m["Reports"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Deliver") != m.end() && !m["Deliver"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Deliver"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      deliver = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Schedule") != m.end() && !m["Schedule"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Schedule"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      schedule = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~UpdateDcdnDeliverTaskRequest() = default;
};
class UpdateDcdnDeliverTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<long> deliverId{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> reports{};
  shared_ptr<string> domainName{};
  shared_ptr<string> deliverShrink{};
  shared_ptr<string> scheduleShrink{};

  UpdateDcdnDeliverTaskShrinkRequest() {}

  explicit UpdateDcdnDeliverTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (deliverId) {
      res["DeliverId"] = boost::any(*deliverId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (reports) {
      res["Reports"] = boost::any(*reports);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (deliverShrink) {
      res["Deliver"] = boost::any(*deliverShrink);
    }
    if (scheduleShrink) {
      res["Schedule"] = boost::any(*scheduleShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DeliverId") != m.end() && !m["DeliverId"].empty()) {
      deliverId = make_shared<long>(boost::any_cast<long>(m["DeliverId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Reports") != m.end() && !m["Reports"].empty()) {
      reports = make_shared<string>(boost::any_cast<string>(m["Reports"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Deliver") != m.end() && !m["Deliver"].empty()) {
      deliverShrink = make_shared<string>(boost::any_cast<string>(m["Deliver"]));
    }
    if (m.find("Schedule") != m.end() && !m["Schedule"].empty()) {
      scheduleShrink = make_shared<string>(boost::any_cast<string>(m["Schedule"]));
    }
  }


  virtual ~UpdateDcdnDeliverTaskShrinkRequest() = default;
};
class UpdateDcdnDeliverTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDcdnDeliverTaskResponseBody() {}

  explicit UpdateDcdnDeliverTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDcdnDeliverTaskResponseBody() = default;
};
class UpdateDcdnDeliverTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateDcdnDeliverTaskResponseBody> body{};

  UpdateDcdnDeliverTaskResponse() {}

  explicit UpdateDcdnDeliverTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDcdnDeliverTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDcdnDeliverTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDcdnDeliverTaskResponse() = default;
};
class UpdateDcdnDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};
  shared_ptr<string> sources{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> topLevelDomain{};

  UpdateDcdnDomainRequest() {}

  explicit UpdateDcdnDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~UpdateDcdnDomainRequest() = default;
};
class UpdateDcdnDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDcdnDomainResponseBody() {}

  explicit UpdateDcdnDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDcdnDomainResponseBody() = default;
};
class UpdateDcdnDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateDcdnDomainResponseBody> body{};

  UpdateDcdnDomainResponse() {}

  explicit UpdateDcdnDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDcdnDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDcdnDomainResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDcdnDomainResponse() = default;
};
class UpdateDcdnIpaDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> domainName{};
  shared_ptr<string> sources{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> topLevelDomain{};

  UpdateDcdnIpaDomainRequest() {}

  explicit UpdateDcdnIpaDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (sources) {
      res["Sources"] = boost::any(*sources);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (topLevelDomain) {
      res["TopLevelDomain"] = boost::any(*topLevelDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sources = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("TopLevelDomain") != m.end() && !m["TopLevelDomain"].empty()) {
      topLevelDomain = make_shared<string>(boost::any_cast<string>(m["TopLevelDomain"]));
    }
  }


  virtual ~UpdateDcdnIpaDomainRequest() = default;
};
class UpdateDcdnIpaDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDcdnIpaDomainResponseBody() {}

  explicit UpdateDcdnIpaDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDcdnIpaDomainResponseBody() = default;
};
class UpdateDcdnIpaDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateDcdnIpaDomainResponseBody> body{};

  UpdateDcdnIpaDomainResponse() {}

  explicit UpdateDcdnIpaDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDcdnIpaDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDcdnIpaDomainResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDcdnIpaDomainResponse() = default;
};
class UpdateDcdnSubTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> status{};
  shared_ptr<string> reportIds{};
  shared_ptr<string> domainName{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  UpdateDcdnSubTaskRequest() {}

  explicit UpdateDcdnSubTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (reportIds) {
      res["ReportIds"] = boost::any(*reportIds);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ReportIds") != m.end() && !m["ReportIds"].empty()) {
      reportIds = make_shared<string>(boost::any_cast<string>(m["ReportIds"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~UpdateDcdnSubTaskRequest() = default;
};
class UpdateDcdnSubTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDcdnSubTaskResponseBody() {}

  explicit UpdateDcdnSubTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDcdnSubTaskResponseBody() = default;
};
class UpdateDcdnSubTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateDcdnSubTaskResponseBody> body{};

  UpdateDcdnSubTaskResponse() {}

  explicit UpdateDcdnSubTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDcdnSubTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDcdnSubTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDcdnSubTaskResponse() = default;
};
class UploadRoutineCodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};
  shared_ptr<string> codeDescription{};

  UploadRoutineCodeRequest() {}

  explicit UploadRoutineCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (codeDescription) {
      res["CodeDescription"] = boost::any(*codeDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("CodeDescription") != m.end() && !m["CodeDescription"].empty()) {
      codeDescription = make_shared<string>(boost::any_cast<string>(m["CodeDescription"]));
    }
  }


  virtual ~UploadRoutineCodeRequest() = default;
};
class UploadRoutineCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  UploadRoutineCodeResponseBody() {}

  explicit UploadRoutineCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UploadRoutineCodeResponseBody() = default;
};
class UploadRoutineCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UploadRoutineCodeResponseBody> body{};

  UploadRoutineCodeResponse() {}

  explicit UploadRoutineCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadRoutineCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadRoutineCodeResponseBody>(model1);
      }
    }
  }


  virtual ~UploadRoutineCodeResponse() = default;
};
class UploadStagingRoutineCodeRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> name{};
  shared_ptr<string> codeDescription{};

  UploadStagingRoutineCodeRequest() {}

  explicit UploadStagingRoutineCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (codeDescription) {
      res["CodeDescription"] = boost::any(*codeDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("CodeDescription") != m.end() && !m["CodeDescription"].empty()) {
      codeDescription = make_shared<string>(boost::any_cast<string>(m["CodeDescription"]));
    }
  }


  virtual ~UploadStagingRoutineCodeRequest() = default;
};
class UploadStagingRoutineCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> content{};
  shared_ptr<string> requestId{};

  UploadStagingRoutineCodeResponseBody() {}

  explicit UploadStagingRoutineCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Content"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      content = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UploadStagingRoutineCodeResponseBody() = default;
};
class UploadStagingRoutineCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UploadStagingRoutineCodeResponseBody> body{};

  UploadStagingRoutineCodeResponse() {}

  explicit UploadStagingRoutineCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadStagingRoutineCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadStagingRoutineCodeResponseBody>(model1);
      }
    }
  }


  virtual ~UploadStagingRoutineCodeResponse() = default;
};
class VerifyDcdnDomainOwnerRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> verifyType{};

  VerifyDcdnDomainOwnerRequest() {}

  explicit VerifyDcdnDomainOwnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (verifyType) {
      res["VerifyType"] = boost::any(*verifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("VerifyType") != m.end() && !m["VerifyType"].empty()) {
      verifyType = make_shared<string>(boost::any_cast<string>(m["VerifyType"]));
    }
  }


  virtual ~VerifyDcdnDomainOwnerRequest() = default;
};
class VerifyDcdnDomainOwnerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> requestId{};

  VerifyDcdnDomainOwnerResponseBody() {}

  explicit VerifyDcdnDomainOwnerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VerifyDcdnDomainOwnerResponseBody() = default;
};
class VerifyDcdnDomainOwnerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<VerifyDcdnDomainOwnerResponseBody> body{};

  VerifyDcdnDomainOwnerResponse() {}

  explicit VerifyDcdnDomainOwnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VerifyDcdnDomainOwnerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VerifyDcdnDomainOwnerResponseBody>(model1);
      }
    }
  }


  virtual ~VerifyDcdnDomainOwnerResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddDcdnDomainResponse addDcdnDomainWithOptions(shared_ptr<AddDcdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDcdnDomainResponse addDcdnDomain(shared_ptr<AddDcdnDomainRequest> request);
  AddDcdnIpaDomainResponse addDcdnIpaDomainWithOptions(shared_ptr<AddDcdnIpaDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDcdnIpaDomainResponse addDcdnIpaDomain(shared_ptr<AddDcdnIpaDomainRequest> request);
  BatchAddDcdnDomainResponse batchAddDcdnDomainWithOptions(shared_ptr<BatchAddDcdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchAddDcdnDomainResponse batchAddDcdnDomain(shared_ptr<BatchAddDcdnDomainRequest> request);
  BatchDeleteDcdnDomainConfigsResponse batchDeleteDcdnDomainConfigsWithOptions(shared_ptr<BatchDeleteDcdnDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteDcdnDomainConfigsResponse batchDeleteDcdnDomainConfigs(shared_ptr<BatchDeleteDcdnDomainConfigsRequest> request);
  BatchSetDcdnDomainCertificateResponse batchSetDcdnDomainCertificateWithOptions(shared_ptr<BatchSetDcdnDomainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetDcdnDomainCertificateResponse batchSetDcdnDomainCertificate(shared_ptr<BatchSetDcdnDomainCertificateRequest> request);
  BatchSetDcdnDomainConfigsResponse batchSetDcdnDomainConfigsWithOptions(shared_ptr<BatchSetDcdnDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetDcdnDomainConfigsResponse batchSetDcdnDomainConfigs(shared_ptr<BatchSetDcdnDomainConfigsRequest> request);
  BatchSetDcdnIpaDomainConfigsResponse batchSetDcdnIpaDomainConfigsWithOptions(shared_ptr<BatchSetDcdnIpaDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchSetDcdnIpaDomainConfigsResponse batchSetDcdnIpaDomainConfigs(shared_ptr<BatchSetDcdnIpaDomainConfigsRequest> request);
  BatchStartDcdnDomainResponse batchStartDcdnDomainWithOptions(shared_ptr<BatchStartDcdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchStartDcdnDomainResponse batchStartDcdnDomain(shared_ptr<BatchStartDcdnDomainRequest> request);
  BatchStopDcdnDomainResponse batchStopDcdnDomainWithOptions(shared_ptr<BatchStopDcdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchStopDcdnDomainResponse batchStopDcdnDomain(shared_ptr<BatchStopDcdnDomainRequest> request);
  CommitStagingRoutineCodeResponse commitStagingRoutineCodeWithOptions(shared_ptr<CommitStagingRoutineCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CommitStagingRoutineCodeResponse commitStagingRoutineCode(shared_ptr<CommitStagingRoutineCodeRequest> request);
  CreateDcdnCertificateSigningRequestResponse createDcdnCertificateSigningRequestWithOptions(shared_ptr<CreateDcdnCertificateSigningRequestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDcdnCertificateSigningRequestResponse createDcdnCertificateSigningRequest(shared_ptr<CreateDcdnCertificateSigningRequestRequest> request);
  CreateDcdnDeliverTaskResponse createDcdnDeliverTaskWithOptions(shared_ptr<CreateDcdnDeliverTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDcdnDeliverTaskResponse createDcdnDeliverTask(shared_ptr<CreateDcdnDeliverTaskRequest> request);
  CreateDcdnDomainOfflineLogDeliveryResponse createDcdnDomainOfflineLogDeliveryWithOptions(shared_ptr<CreateDcdnDomainOfflineLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDcdnDomainOfflineLogDeliveryResponse createDcdnDomainOfflineLogDelivery(shared_ptr<CreateDcdnDomainOfflineLogDeliveryRequest> request);
  CreateDcdnSubTaskResponse createDcdnSubTaskWithOptions(shared_ptr<CreateDcdnSubTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDcdnSubTaskResponse createDcdnSubTask(shared_ptr<CreateDcdnSubTaskRequest> request);
  CreateRoutineResponse createRoutineWithOptions(shared_ptr<CreateRoutineRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRoutineResponse createRoutine(shared_ptr<CreateRoutineRequest> request);
  DeleteDcdnDeliverTaskResponse deleteDcdnDeliverTaskWithOptions(shared_ptr<DeleteDcdnDeliverTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnDeliverTaskResponse deleteDcdnDeliverTask(shared_ptr<DeleteDcdnDeliverTaskRequest> request);
  DeleteDcdnDomainResponse deleteDcdnDomainWithOptions(shared_ptr<DeleteDcdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnDomainResponse deleteDcdnDomain(shared_ptr<DeleteDcdnDomainRequest> request);
  DeleteDcdnIpaDomainResponse deleteDcdnIpaDomainWithOptions(shared_ptr<DeleteDcdnIpaDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnIpaDomainResponse deleteDcdnIpaDomain(shared_ptr<DeleteDcdnIpaDomainRequest> request);
  DeleteDcdnIpaSpecificConfigResponse deleteDcdnIpaSpecificConfigWithOptions(shared_ptr<DeleteDcdnIpaSpecificConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnIpaSpecificConfigResponse deleteDcdnIpaSpecificConfig(shared_ptr<DeleteDcdnIpaSpecificConfigRequest> request);
  DeleteDcdnSpecificConfigResponse deleteDcdnSpecificConfigWithOptions(shared_ptr<DeleteDcdnSpecificConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnSpecificConfigResponse deleteDcdnSpecificConfig(shared_ptr<DeleteDcdnSpecificConfigRequest> request);
  DeleteDcdnSpecificStagingConfigResponse deleteDcdnSpecificStagingConfigWithOptions(shared_ptr<DeleteDcdnSpecificStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnSpecificStagingConfigResponse deleteDcdnSpecificStagingConfig(shared_ptr<DeleteDcdnSpecificStagingConfigRequest> request);
  DeleteDcdnSubTaskResponse deleteDcdnSubTaskWithOptions(shared_ptr<DeleteDcdnSubTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDcdnSubTaskResponse deleteDcdnSubTask(shared_ptr<DeleteDcdnSubTaskRequest> request);
  DeleteRoutineResponse deleteRoutineWithOptions(shared_ptr<DeleteRoutineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRoutineResponse deleteRoutine(shared_ptr<DeleteRoutineRequest> request);
  DeleteRoutineCodeRevisionResponse deleteRoutineCodeRevisionWithOptions(shared_ptr<DeleteRoutineCodeRevisionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRoutineCodeRevisionResponse deleteRoutineCodeRevision(shared_ptr<DeleteRoutineCodeRevisionRequest> request);
  DeleteRoutineConfEnvsResponse deleteRoutineConfEnvsWithOptions(shared_ptr<DeleteRoutineConfEnvsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRoutineConfEnvsResponse deleteRoutineConfEnvs(shared_ptr<DeleteRoutineConfEnvsRequest> request);
  DescribeDcdnBgpBpsDataResponse describeDcdnBgpBpsDataWithOptions(shared_ptr<DescribeDcdnBgpBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnBgpBpsDataResponse describeDcdnBgpBpsData(shared_ptr<DescribeDcdnBgpBpsDataRequest> request);
  DescribeDcdnBgpTrafficDataResponse describeDcdnBgpTrafficDataWithOptions(shared_ptr<DescribeDcdnBgpTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnBgpTrafficDataResponse describeDcdnBgpTrafficData(shared_ptr<DescribeDcdnBgpTrafficDataRequest> request);
  DescribeDcdnBlockedRegionsResponse describeDcdnBlockedRegionsWithOptions(shared_ptr<DescribeDcdnBlockedRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnBlockedRegionsResponse describeDcdnBlockedRegions(shared_ptr<DescribeDcdnBlockedRegionsRequest> request);
  DescribeDcdnCertificateDetailResponse describeDcdnCertificateDetailWithOptions(shared_ptr<DescribeDcdnCertificateDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnCertificateDetailResponse describeDcdnCertificateDetail(shared_ptr<DescribeDcdnCertificateDetailRequest> request);
  DescribeDcdnCertificateListResponse describeDcdnCertificateListWithOptions(shared_ptr<DescribeDcdnCertificateListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnCertificateListResponse describeDcdnCertificateList(shared_ptr<DescribeDcdnCertificateListRequest> request);
  DescribeDcdnConfigOfVersionResponse describeDcdnConfigOfVersionWithOptions(shared_ptr<DescribeDcdnConfigOfVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnConfigOfVersionResponse describeDcdnConfigOfVersion(shared_ptr<DescribeDcdnConfigOfVersionRequest> request);
  DescribeDcdnDeliverListResponse describeDcdnDeliverListWithOptions(shared_ptr<DescribeDcdnDeliverListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDeliverListResponse describeDcdnDeliverList(shared_ptr<DescribeDcdnDeliverListRequest> request);
  DescribeDcdnDomainBpsDataResponse describeDcdnDomainBpsDataWithOptions(shared_ptr<DescribeDcdnDomainBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainBpsDataResponse describeDcdnDomainBpsData(shared_ptr<DescribeDcdnDomainBpsDataRequest> request);
  DescribeDcdnDomainByCertificateResponse describeDcdnDomainByCertificateWithOptions(shared_ptr<DescribeDcdnDomainByCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainByCertificateResponse describeDcdnDomainByCertificate(shared_ptr<DescribeDcdnDomainByCertificateRequest> request);
  DescribeDcdnDomainCertificateInfoResponse describeDcdnDomainCertificateInfoWithOptions(shared_ptr<DescribeDcdnDomainCertificateInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainCertificateInfoResponse describeDcdnDomainCertificateInfo(shared_ptr<DescribeDcdnDomainCertificateInfoRequest> request);
  DescribeDcdnDomainCnameResponse describeDcdnDomainCnameWithOptions(shared_ptr<DescribeDcdnDomainCnameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainCnameResponse describeDcdnDomainCname(shared_ptr<DescribeDcdnDomainCnameRequest> request);
  DescribeDcdnDomainConfigsResponse describeDcdnDomainConfigsWithOptions(shared_ptr<DescribeDcdnDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainConfigsResponse describeDcdnDomainConfigs(shared_ptr<DescribeDcdnDomainConfigsRequest> request);
  DescribeDcdnDomainDetailResponse describeDcdnDomainDetailWithOptions(shared_ptr<DescribeDcdnDomainDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainDetailResponse describeDcdnDomainDetail(shared_ptr<DescribeDcdnDomainDetailRequest> request);
  DescribeDcdnDomainHitRateDataResponse describeDcdnDomainHitRateDataWithOptions(shared_ptr<DescribeDcdnDomainHitRateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainHitRateDataResponse describeDcdnDomainHitRateData(shared_ptr<DescribeDcdnDomainHitRateDataRequest> request);
  DescribeDcdnDomainHttpCodeDataResponse describeDcdnDomainHttpCodeDataWithOptions(shared_ptr<DescribeDcdnDomainHttpCodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainHttpCodeDataResponse describeDcdnDomainHttpCodeData(shared_ptr<DescribeDcdnDomainHttpCodeDataRequest> request);
  DescribeDcdnDomainIpaBpsDataResponse describeDcdnDomainIpaBpsDataWithOptions(shared_ptr<DescribeDcdnDomainIpaBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainIpaBpsDataResponse describeDcdnDomainIpaBpsData(shared_ptr<DescribeDcdnDomainIpaBpsDataRequest> request);
  DescribeDcdnDomainIpaTrafficDataResponse describeDcdnDomainIpaTrafficDataWithOptions(shared_ptr<DescribeDcdnDomainIpaTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainIpaTrafficDataResponse describeDcdnDomainIpaTrafficData(shared_ptr<DescribeDcdnDomainIpaTrafficDataRequest> request);
  DescribeDcdnDomainIspDataResponse describeDcdnDomainIspDataWithOptions(shared_ptr<DescribeDcdnDomainIspDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainIspDataResponse describeDcdnDomainIspData(shared_ptr<DescribeDcdnDomainIspDataRequest> request);
  DescribeDcdnDomainLogResponse describeDcdnDomainLogWithOptions(shared_ptr<DescribeDcdnDomainLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainLogResponse describeDcdnDomainLog(shared_ptr<DescribeDcdnDomainLogRequest> request);
  DescribeDcdnDomainMultiUsageDataResponse describeDcdnDomainMultiUsageDataWithOptions(shared_ptr<DescribeDcdnDomainMultiUsageDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainMultiUsageDataResponse describeDcdnDomainMultiUsageData(shared_ptr<DescribeDcdnDomainMultiUsageDataRequest> request);
  DescribeDcdnDomainOriginBpsDataResponse describeDcdnDomainOriginBpsDataWithOptions(shared_ptr<DescribeDcdnDomainOriginBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainOriginBpsDataResponse describeDcdnDomainOriginBpsData(shared_ptr<DescribeDcdnDomainOriginBpsDataRequest> request);
  DescribeDcdnDomainOriginTrafficDataResponse describeDcdnDomainOriginTrafficDataWithOptions(shared_ptr<DescribeDcdnDomainOriginTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainOriginTrafficDataResponse describeDcdnDomainOriginTrafficData(shared_ptr<DescribeDcdnDomainOriginTrafficDataRequest> request);
  DescribeDcdnDomainPropertyResponse describeDcdnDomainPropertyWithOptions(shared_ptr<DescribeDcdnDomainPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainPropertyResponse describeDcdnDomainProperty(shared_ptr<DescribeDcdnDomainPropertyRequest> request);
  DescribeDcdnDomainPvDataResponse describeDcdnDomainPvDataWithOptions(shared_ptr<DescribeDcdnDomainPvDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainPvDataResponse describeDcdnDomainPvData(shared_ptr<DescribeDcdnDomainPvDataRequest> request);
  DescribeDcdnDomainQpsDataResponse describeDcdnDomainQpsDataWithOptions(shared_ptr<DescribeDcdnDomainQpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainQpsDataResponse describeDcdnDomainQpsData(shared_ptr<DescribeDcdnDomainQpsDataRequest> request);
  DescribeDcdnDomainRealTimeBpsDataResponse describeDcdnDomainRealTimeBpsDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeBpsDataResponse describeDcdnDomainRealTimeBpsData(shared_ptr<DescribeDcdnDomainRealTimeBpsDataRequest> request);
  DescribeDcdnDomainRealTimeByteHitRateDataResponse describeDcdnDomainRealTimeByteHitRateDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeByteHitRateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeByteHitRateDataResponse describeDcdnDomainRealTimeByteHitRateData(shared_ptr<DescribeDcdnDomainRealTimeByteHitRateDataRequest> request);
  DescribeDcdnDomainRealTimeDetailDataResponse describeDcdnDomainRealTimeDetailDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeDetailDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeDetailDataResponse describeDcdnDomainRealTimeDetailData(shared_ptr<DescribeDcdnDomainRealTimeDetailDataRequest> request);
  DescribeDcdnDomainRealTimeHttpCodeDataResponse describeDcdnDomainRealTimeHttpCodeDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeHttpCodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeHttpCodeDataResponse describeDcdnDomainRealTimeHttpCodeData(shared_ptr<DescribeDcdnDomainRealTimeHttpCodeDataRequest> request);
  DescribeDcdnDomainRealTimeQpsDataResponse describeDcdnDomainRealTimeQpsDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeQpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeQpsDataResponse describeDcdnDomainRealTimeQpsData(shared_ptr<DescribeDcdnDomainRealTimeQpsDataRequest> request);
  DescribeDcdnDomainRealTimeReqHitRateDataResponse describeDcdnDomainRealTimeReqHitRateDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeReqHitRateDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeReqHitRateDataResponse describeDcdnDomainRealTimeReqHitRateData(shared_ptr<DescribeDcdnDomainRealTimeReqHitRateDataRequest> request);
  DescribeDcdnDomainRealTimeSrcBpsDataResponse describeDcdnDomainRealTimeSrcBpsDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeSrcBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeSrcBpsDataResponse describeDcdnDomainRealTimeSrcBpsData(shared_ptr<DescribeDcdnDomainRealTimeSrcBpsDataRequest> request);
  DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse describeDcdnDomainRealTimeSrcHttpCodeDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse describeDcdnDomainRealTimeSrcHttpCodeData(shared_ptr<DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest> request);
  DescribeDcdnDomainRealTimeSrcTrafficDataResponse describeDcdnDomainRealTimeSrcTrafficDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeSrcTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeSrcTrafficDataResponse describeDcdnDomainRealTimeSrcTrafficData(shared_ptr<DescribeDcdnDomainRealTimeSrcTrafficDataRequest> request);
  DescribeDcdnDomainRealTimeTrafficDataResponse describeDcdnDomainRealTimeTrafficDataWithOptions(shared_ptr<DescribeDcdnDomainRealTimeTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRealTimeTrafficDataResponse describeDcdnDomainRealTimeTrafficData(shared_ptr<DescribeDcdnDomainRealTimeTrafficDataRequest> request);
  DescribeDcdnDomainRegionDataResponse describeDcdnDomainRegionDataWithOptions(shared_ptr<DescribeDcdnDomainRegionDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainRegionDataResponse describeDcdnDomainRegionData(shared_ptr<DescribeDcdnDomainRegionDataRequest> request);
  DescribeDcdnDomainStagingConfigResponse describeDcdnDomainStagingConfigWithOptions(shared_ptr<DescribeDcdnDomainStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainStagingConfigResponse describeDcdnDomainStagingConfig(shared_ptr<DescribeDcdnDomainStagingConfigRequest> request);
  DescribeDcdnDomainTopReferVisitResponse describeDcdnDomainTopReferVisitWithOptions(shared_ptr<DescribeDcdnDomainTopReferVisitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainTopReferVisitResponse describeDcdnDomainTopReferVisit(shared_ptr<DescribeDcdnDomainTopReferVisitRequest> request);
  DescribeDcdnDomainTopUrlVisitResponse describeDcdnDomainTopUrlVisitWithOptions(shared_ptr<DescribeDcdnDomainTopUrlVisitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainTopUrlVisitResponse describeDcdnDomainTopUrlVisit(shared_ptr<DescribeDcdnDomainTopUrlVisitRequest> request);
  DescribeDcdnDomainTrafficDataResponse describeDcdnDomainTrafficDataWithOptions(shared_ptr<DescribeDcdnDomainTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainTrafficDataResponse describeDcdnDomainTrafficData(shared_ptr<DescribeDcdnDomainTrafficDataRequest> request);
  DescribeDcdnDomainUvDataResponse describeDcdnDomainUvDataWithOptions(shared_ptr<DescribeDcdnDomainUvDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainUvDataResponse describeDcdnDomainUvData(shared_ptr<DescribeDcdnDomainUvDataRequest> request);
  DescribeDcdnDomainWebsocketBpsDataResponse describeDcdnDomainWebsocketBpsDataWithOptions(shared_ptr<DescribeDcdnDomainWebsocketBpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainWebsocketBpsDataResponse describeDcdnDomainWebsocketBpsData(shared_ptr<DescribeDcdnDomainWebsocketBpsDataRequest> request);
  DescribeDcdnDomainWebsocketHttpCodeDataResponse describeDcdnDomainWebsocketHttpCodeDataWithOptions(shared_ptr<DescribeDcdnDomainWebsocketHttpCodeDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainWebsocketHttpCodeDataResponse describeDcdnDomainWebsocketHttpCodeData(shared_ptr<DescribeDcdnDomainWebsocketHttpCodeDataRequest> request);
  DescribeDcdnDomainWebsocketTrafficDataResponse describeDcdnDomainWebsocketTrafficDataWithOptions(shared_ptr<DescribeDcdnDomainWebsocketTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnDomainWebsocketTrafficDataResponse describeDcdnDomainWebsocketTrafficData(shared_ptr<DescribeDcdnDomainWebsocketTrafficDataRequest> request);
  DescribeDcdnHttpsDomainListResponse describeDcdnHttpsDomainListWithOptions(shared_ptr<DescribeDcdnHttpsDomainListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnHttpsDomainListResponse describeDcdnHttpsDomainList(shared_ptr<DescribeDcdnHttpsDomainListRequest> request);
  DescribeDcdnIpaDomainConfigsResponse describeDcdnIpaDomainConfigsWithOptions(shared_ptr<DescribeDcdnIpaDomainConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnIpaDomainConfigsResponse describeDcdnIpaDomainConfigs(shared_ptr<DescribeDcdnIpaDomainConfigsRequest> request);
  DescribeDcdnIpaDomainDetailResponse describeDcdnIpaDomainDetailWithOptions(shared_ptr<DescribeDcdnIpaDomainDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnIpaDomainDetailResponse describeDcdnIpaDomainDetail(shared_ptr<DescribeDcdnIpaDomainDetailRequest> request);
  DescribeDcdnIpaServiceResponse describeDcdnIpaServiceWithOptions(shared_ptr<DescribeDcdnIpaServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnIpaServiceResponse describeDcdnIpaService(shared_ptr<DescribeDcdnIpaServiceRequest> request);
  DescribeDcdnIpaUserDomainsResponse describeDcdnIpaUserDomainsWithOptions(shared_ptr<DescribeDcdnIpaUserDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnIpaUserDomainsResponse describeDcdnIpaUserDomains(shared_ptr<DescribeDcdnIpaUserDomainsRequest> request);
  DescribeDcdnIpInfoResponse describeDcdnIpInfoWithOptions(shared_ptr<DescribeDcdnIpInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnIpInfoResponse describeDcdnIpInfo(shared_ptr<DescribeDcdnIpInfoRequest> request);
  DescribeDcdnOfflineLogDeliveryResponse describeDcdnOfflineLogDeliveryWithOptions(shared_ptr<DescribeDcdnOfflineLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnOfflineLogDeliveryResponse describeDcdnOfflineLogDelivery(shared_ptr<DescribeDcdnOfflineLogDeliveryRequest> request);
  DescribeDcdnOfflineLogDeliveryFieldResponse describeDcdnOfflineLogDeliveryFieldWithOptions(shared_ptr<DescribeDcdnOfflineLogDeliveryFieldRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnOfflineLogDeliveryFieldResponse describeDcdnOfflineLogDeliveryField(shared_ptr<DescribeDcdnOfflineLogDeliveryFieldRequest> request);
  DescribeDcdnOfflineLogDeliveryRegionsResponse describeDcdnOfflineLogDeliveryRegionsWithOptions(shared_ptr<DescribeDcdnOfflineLogDeliveryRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnOfflineLogDeliveryRegionsResponse describeDcdnOfflineLogDeliveryRegions(shared_ptr<DescribeDcdnOfflineLogDeliveryRegionsRequest> request);
  DescribeDcdnOfflineLogDeliveryStatusResponse describeDcdnOfflineLogDeliveryStatusWithOptions(shared_ptr<DescribeDcdnOfflineLogDeliveryStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnOfflineLogDeliveryStatusResponse describeDcdnOfflineLogDeliveryStatus(shared_ptr<DescribeDcdnOfflineLogDeliveryStatusRequest> request);
  DescribeDcdnRefreshQuotaResponse describeDcdnRefreshQuotaWithOptions(shared_ptr<DescribeDcdnRefreshQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnRefreshQuotaResponse describeDcdnRefreshQuota(shared_ptr<DescribeDcdnRefreshQuotaRequest> request);
  DescribeDcdnRefreshTaskByIdResponse describeDcdnRefreshTaskByIdWithOptions(shared_ptr<DescribeDcdnRefreshTaskByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnRefreshTaskByIdResponse describeDcdnRefreshTaskById(shared_ptr<DescribeDcdnRefreshTaskByIdRequest> request);
  DescribeDcdnRefreshTasksResponse describeDcdnRefreshTasksWithOptions(shared_ptr<DescribeDcdnRefreshTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnRefreshTasksResponse describeDcdnRefreshTasks(shared_ptr<DescribeDcdnRefreshTasksRequest> request);
  DescribeDcdnRegionAndIspResponse describeDcdnRegionAndIspWithOptions(shared_ptr<DescribeDcdnRegionAndIspRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnRegionAndIspResponse describeDcdnRegionAndIsp(shared_ptr<DescribeDcdnRegionAndIspRequest> request);
  DescribeDcdnReportResponse describeDcdnReportWithOptions(shared_ptr<DescribeDcdnReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnReportResponse describeDcdnReport(shared_ptr<DescribeDcdnReportRequest> request);
  DescribeDcdnReportListResponse describeDcdnReportListWithOptions(shared_ptr<DescribeDcdnReportListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnReportListResponse describeDcdnReportList(shared_ptr<DescribeDcdnReportListRequest> request);
  DescribeDcdnSecFuncInfoResponse describeDcdnSecFuncInfoWithOptions(shared_ptr<DescribeDcdnSecFuncInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnSecFuncInfoResponse describeDcdnSecFuncInfo(shared_ptr<DescribeDcdnSecFuncInfoRequest> request);
  DescribeDcdnServiceResponse describeDcdnServiceWithOptions(shared_ptr<DescribeDcdnServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnServiceResponse describeDcdnService(shared_ptr<DescribeDcdnServiceRequest> request);
  DescribeDcdnStagingIpResponse describeDcdnStagingIpWithOptions(shared_ptr<DescribeDcdnStagingIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnStagingIpResponse describeDcdnStagingIp(shared_ptr<DescribeDcdnStagingIpRequest> request);
  DescribeDcdnSubListResponse describeDcdnSubListWithOptions(shared_ptr<DescribeDcdnSubListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnSubListResponse describeDcdnSubList(shared_ptr<DescribeDcdnSubListRequest> request);
  DescribeDcdnTagResourcesResponse describeDcdnTagResourcesWithOptions(shared_ptr<DescribeDcdnTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnTagResourcesResponse describeDcdnTagResources(shared_ptr<DescribeDcdnTagResourcesRequest> request);
  DescribeDcdnTopDomainsByFlowResponse describeDcdnTopDomainsByFlowWithOptions(shared_ptr<DescribeDcdnTopDomainsByFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnTopDomainsByFlowResponse describeDcdnTopDomainsByFlow(shared_ptr<DescribeDcdnTopDomainsByFlowRequest> request);
  DescribeDcdnUserBillHistoryResponse describeDcdnUserBillHistoryWithOptions(shared_ptr<DescribeDcdnUserBillHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserBillHistoryResponse describeDcdnUserBillHistory(shared_ptr<DescribeDcdnUserBillHistoryRequest> request);
  DescribeDcdnUserBillTypeResponse describeDcdnUserBillTypeWithOptions(shared_ptr<DescribeDcdnUserBillTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserBillTypeResponse describeDcdnUserBillType(shared_ptr<DescribeDcdnUserBillTypeRequest> request);
  DescribeDcdnUserDomainsResponse describeDcdnUserDomainsWithOptions(shared_ptr<DescribeDcdnUserDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserDomainsResponse describeDcdnUserDomains(shared_ptr<DescribeDcdnUserDomainsRequest> request);
  DescribeDcdnUserDomainsByFuncResponse describeDcdnUserDomainsByFuncWithOptions(shared_ptr<DescribeDcdnUserDomainsByFuncRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserDomainsByFuncResponse describeDcdnUserDomainsByFunc(shared_ptr<DescribeDcdnUserDomainsByFuncRequest> request);
  DescribeDcdnUserQuotaResponse describeDcdnUserQuotaWithOptions(shared_ptr<DescribeDcdnUserQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserQuotaResponse describeDcdnUserQuota(shared_ptr<DescribeDcdnUserQuotaRequest> request);
  DescribeDcdnUserResourcePackageResponse describeDcdnUserResourcePackageWithOptions(shared_ptr<DescribeDcdnUserResourcePackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserResourcePackageResponse describeDcdnUserResourcePackage(shared_ptr<DescribeDcdnUserResourcePackageRequest> request);
  DescribeDcdnUserSecDropResponse describeDcdnUserSecDropWithOptions(shared_ptr<DescribeDcdnUserSecDropRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserSecDropResponse describeDcdnUserSecDrop(shared_ptr<DescribeDcdnUserSecDropRequest> request);
  DescribeDcdnUserSecDropByMinuteResponse describeDcdnUserSecDropByMinuteWithOptions(shared_ptr<DescribeDcdnUserSecDropByMinuteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserSecDropByMinuteResponse describeDcdnUserSecDropByMinute(shared_ptr<DescribeDcdnUserSecDropByMinuteRequest> request);
  DescribeDcdnUserTagsResponse describeDcdnUserTagsWithOptions(shared_ptr<DescribeDcdnUserTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnUserTagsResponse describeDcdnUserTags(shared_ptr<DescribeDcdnUserTagsRequest> request);
  DescribeDcdnVerifyContentResponse describeDcdnVerifyContentWithOptions(shared_ptr<DescribeDcdnVerifyContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnVerifyContentResponse describeDcdnVerifyContent(shared_ptr<DescribeDcdnVerifyContentRequest> request);
  DescribeDcdnWafDomainResponse describeDcdnWafDomainWithOptions(shared_ptr<DescribeDcdnWafDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDcdnWafDomainResponse describeDcdnWafDomain(shared_ptr<DescribeDcdnWafDomainRequest> request);
  DescribeRoutineResponse describeRoutineWithOptions(shared_ptr<DescribeRoutineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRoutineResponse describeRoutine(shared_ptr<DescribeRoutineRequest> request);
  DescribeRoutineCanaryEnvsResponse describeRoutineCanaryEnvsWithOptions(shared_ptr<DescribeRoutineCanaryEnvsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRoutineCanaryEnvsResponse describeRoutineCanaryEnvs(shared_ptr<DescribeRoutineCanaryEnvsRequest> request);
  DescribeRoutineCodeRevisionResponse describeRoutineCodeRevisionWithOptions(shared_ptr<DescribeRoutineCodeRevisionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRoutineCodeRevisionResponse describeRoutineCodeRevision(shared_ptr<DescribeRoutineCodeRevisionRequest> request);
  DescribeRoutineSpecResponse describeRoutineSpecWithOptions(shared_ptr<DescribeRoutineSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRoutineSpecResponse describeRoutineSpec(shared_ptr<DescribeRoutineSpecRequest> request);
  DescribeRoutineUserInfoResponse describeRoutineUserInfoWithOptions(shared_ptr<DescribeRoutineUserInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRoutineUserInfoResponse describeRoutineUserInfo(shared_ptr<DescribeRoutineUserInfoRequest> request);
  DescribeUserDcdnIpaStatusResponse describeUserDcdnIpaStatusWithOptions(shared_ptr<DescribeUserDcdnIpaStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserDcdnIpaStatusResponse describeUserDcdnIpaStatus(shared_ptr<DescribeUserDcdnIpaStatusRequest> request);
  DescribeUserDcdnStatusResponse describeUserDcdnStatusWithOptions(shared_ptr<DescribeUserDcdnStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserDcdnStatusResponse describeUserDcdnStatus(shared_ptr<DescribeUserDcdnStatusRequest> request);
  DescribeUserErStatusResponse describeUserErStatusWithOptions(shared_ptr<DescribeUserErStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserErStatusResponse describeUserErStatus(shared_ptr<DescribeUserErStatusRequest> request);
  DescribeUserLogserviceStatusResponse describeUserLogserviceStatusWithOptions(shared_ptr<DescribeUserLogserviceStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserLogserviceStatusResponse describeUserLogserviceStatus(shared_ptr<DescribeUserLogserviceStatusRequest> request);
  DisableDcdnDomainOfflineLogDeliveryResponse disableDcdnDomainOfflineLogDeliveryWithOptions(shared_ptr<DisableDcdnDomainOfflineLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableDcdnDomainOfflineLogDeliveryResponse disableDcdnDomainOfflineLogDelivery(shared_ptr<DisableDcdnDomainOfflineLogDeliveryRequest> request);
  DisableDcdnOfflineLogDeliveryResponse disableDcdnOfflineLogDeliveryWithOptions(shared_ptr<DisableDcdnOfflineLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableDcdnOfflineLogDeliveryResponse disableDcdnOfflineLogDelivery(shared_ptr<DisableDcdnOfflineLogDeliveryRequest> request);
  EditRoutineConfResponse editRoutineConfWithOptions(shared_ptr<EditRoutineConfRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EditRoutineConfResponse editRoutineConf(shared_ptr<EditRoutineConfRequest> request);
  EnableDcdnDomainOfflineLogDeliveryResponse enableDcdnDomainOfflineLogDeliveryWithOptions(shared_ptr<EnableDcdnDomainOfflineLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableDcdnDomainOfflineLogDeliveryResponse enableDcdnDomainOfflineLogDelivery(shared_ptr<EnableDcdnDomainOfflineLogDeliveryRequest> request);
  ModifyDCdnDomainSchdmByPropertyResponse modifyDCdnDomainSchdmByPropertyWithOptions(shared_ptr<ModifyDCdnDomainSchdmByPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDCdnDomainSchdmByPropertyResponse modifyDCdnDomainSchdmByProperty(shared_ptr<ModifyDCdnDomainSchdmByPropertyRequest> request);
  OpenDcdnServiceResponse openDcdnServiceWithOptions(shared_ptr<OpenDcdnServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenDcdnServiceResponse openDcdnService(shared_ptr<OpenDcdnServiceRequest> request);
  PreloadDcdnObjectCachesResponse preloadDcdnObjectCachesWithOptions(shared_ptr<PreloadDcdnObjectCachesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PreloadDcdnObjectCachesResponse preloadDcdnObjectCaches(shared_ptr<PreloadDcdnObjectCachesRequest> request);
  PublishDcdnStagingConfigToProductionResponse publishDcdnStagingConfigToProductionWithOptions(shared_ptr<PublishDcdnStagingConfigToProductionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishDcdnStagingConfigToProductionResponse publishDcdnStagingConfigToProduction(shared_ptr<PublishDcdnStagingConfigToProductionRequest> request);
  PublishRoutineCodeRevisionResponse publishRoutineCodeRevisionWithOptions(shared_ptr<PublishRoutineCodeRevisionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishRoutineCodeRevisionResponse publishRoutineCodeRevision(shared_ptr<PublishRoutineCodeRevisionRequest> request);
  RefreshDcdnObjectCachesResponse refreshDcdnObjectCachesWithOptions(shared_ptr<RefreshDcdnObjectCachesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshDcdnObjectCachesResponse refreshDcdnObjectCaches(shared_ptr<RefreshDcdnObjectCachesRequest> request);
  RollbackDcdnStagingConfigResponse rollbackDcdnStagingConfigWithOptions(shared_ptr<RollbackDcdnStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RollbackDcdnStagingConfigResponse rollbackDcdnStagingConfig(shared_ptr<RollbackDcdnStagingConfigRequest> request);
  SetDcdnConfigOfVersionResponse setDcdnConfigOfVersionWithOptions(shared_ptr<SetDcdnConfigOfVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDcdnConfigOfVersionResponse setDcdnConfigOfVersion(shared_ptr<SetDcdnConfigOfVersionRequest> request);
  SetDcdnDomainCertificateResponse setDcdnDomainCertificateWithOptions(shared_ptr<SetDcdnDomainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDcdnDomainCertificateResponse setDcdnDomainCertificate(shared_ptr<SetDcdnDomainCertificateRequest> request);
  SetDcdnDomainCSRCertificateResponse setDcdnDomainCSRCertificateWithOptions(shared_ptr<SetDcdnDomainCSRCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDcdnDomainCSRCertificateResponse setDcdnDomainCSRCertificate(shared_ptr<SetDcdnDomainCSRCertificateRequest> request);
  SetDcdnDomainStagingConfigResponse setDcdnDomainStagingConfigWithOptions(shared_ptr<SetDcdnDomainStagingConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDcdnDomainStagingConfigResponse setDcdnDomainStagingConfig(shared_ptr<SetDcdnDomainStagingConfigRequest> request);
  SetRoutineSubdomainResponse setRoutineSubdomainWithOptions(shared_ptr<SetRoutineSubdomainRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetRoutineSubdomainResponse setRoutineSubdomain(shared_ptr<SetRoutineSubdomainRequest> request);
  StartDcdnDomainResponse startDcdnDomainWithOptions(shared_ptr<StartDcdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartDcdnDomainResponse startDcdnDomain(shared_ptr<StartDcdnDomainRequest> request);
  StartDcdnIpaDomainResponse startDcdnIpaDomainWithOptions(shared_ptr<StartDcdnIpaDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartDcdnIpaDomainResponse startDcdnIpaDomain(shared_ptr<StartDcdnIpaDomainRequest> request);
  StopDcdnDomainResponse stopDcdnDomainWithOptions(shared_ptr<StopDcdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopDcdnDomainResponse stopDcdnDomain(shared_ptr<StopDcdnDomainRequest> request);
  StopDcdnIpaDomainResponse stopDcdnIpaDomainWithOptions(shared_ptr<StopDcdnIpaDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopDcdnIpaDomainResponse stopDcdnIpaDomain(shared_ptr<StopDcdnIpaDomainRequest> request);
  TagDcdnResourcesResponse tagDcdnResourcesWithOptions(shared_ptr<TagDcdnResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagDcdnResourcesResponse tagDcdnResources(shared_ptr<TagDcdnResourcesRequest> request);
  UntagDcdnResourcesResponse untagDcdnResourcesWithOptions(shared_ptr<UntagDcdnResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagDcdnResourcesResponse untagDcdnResources(shared_ptr<UntagDcdnResourcesRequest> request);
  UpdateDcdnDeliverTaskResponse updateDcdnDeliverTaskWithOptions(shared_ptr<UpdateDcdnDeliverTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDcdnDeliverTaskResponse updateDcdnDeliverTask(shared_ptr<UpdateDcdnDeliverTaskRequest> request);
  UpdateDcdnDomainResponse updateDcdnDomainWithOptions(shared_ptr<UpdateDcdnDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDcdnDomainResponse updateDcdnDomain(shared_ptr<UpdateDcdnDomainRequest> request);
  UpdateDcdnIpaDomainResponse updateDcdnIpaDomainWithOptions(shared_ptr<UpdateDcdnIpaDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDcdnIpaDomainResponse updateDcdnIpaDomain(shared_ptr<UpdateDcdnIpaDomainRequest> request);
  UpdateDcdnSubTaskResponse updateDcdnSubTaskWithOptions(shared_ptr<UpdateDcdnSubTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDcdnSubTaskResponse updateDcdnSubTask(shared_ptr<UpdateDcdnSubTaskRequest> request);
  UploadRoutineCodeResponse uploadRoutineCodeWithOptions(shared_ptr<UploadRoutineCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadRoutineCodeResponse uploadRoutineCode(shared_ptr<UploadRoutineCodeRequest> request);
  UploadStagingRoutineCodeResponse uploadStagingRoutineCodeWithOptions(shared_ptr<UploadStagingRoutineCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadStagingRoutineCodeResponse uploadStagingRoutineCode(shared_ptr<UploadStagingRoutineCodeRequest> request);
  VerifyDcdnDomainOwnerResponse verifyDcdnDomainOwnerWithOptions(shared_ptr<VerifyDcdnDomainOwnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifyDcdnDomainOwnerResponse verifyDcdnDomainOwner(shared_ptr<VerifyDcdnDomainOwnerRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Dcdn20180115

#endif
