// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_CLOUDAPI20180601_H_
#define ALIBABACLOUD_CLOUDAPI20180601_H_

#include <alibabacloud/open_api.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_CloudAPI20180601 {
class AbolishApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  AbolishApiRequest() {}

  explicit AbolishApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~AbolishApiRequest() = default;
};
class AbolishApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AbolishApiResponseBody() {}

  explicit AbolishApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AbolishApiResponseBody() = default;
};
class AbolishApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AbolishApiResponseBody> body{};

  AbolishApiResponse() {}

  explicit AbolishApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AbolishApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AbolishApiResponseBody>(model1);
      }
    }
  }


  virtual ~AbolishApiResponse() = default;
};
class AddBlackListRequest : public Darabonba::Model {
public:
  shared_ptr<string> blackContent{};
  shared_ptr<string> blackType{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};

  AddBlackListRequest() {}

  explicit AddBlackListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackContent) {
      res["BlackContent"] = boost::any(*blackContent);
    }
    if (blackType) {
      res["BlackType"] = boost::any(*blackType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackContent") != m.end() && !m["BlackContent"].empty()) {
      blackContent = make_shared<string>(boost::any_cast<string>(m["BlackContent"]));
    }
    if (m.find("BlackType") != m.end() && !m["BlackType"].empty()) {
      blackType = make_shared<string>(boost::any_cast<string>(m["BlackType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~AddBlackListRequest() = default;
};
class AddBlackListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddBlackListResponseBody() {}

  explicit AddBlackListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddBlackListResponseBody() = default;
};
class AddBlackListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddBlackListResponseBody> body{};

  AddBlackListResponse() {}

  explicit AddBlackListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddBlackListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddBlackListResponseBody>(model1);
      }
    }
  }


  virtual ~AddBlackListResponse() = default;
};
class AddIpControlPolicyItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> cidrIp{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> securityToken{};

  AddIpControlPolicyItemRequest() {}

  explicit AddIpControlPolicyItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~AddIpControlPolicyItemRequest() = default;
};
class AddIpControlPolicyItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> policyItemId{};
  shared_ptr<string> requestId{};

  AddIpControlPolicyItemResponseBody() {}

  explicit AddIpControlPolicyItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyItemId) {
      res["PolicyItemId"] = boost::any(*policyItemId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyItemId") != m.end() && !m["PolicyItemId"].empty()) {
      policyItemId = make_shared<string>(boost::any_cast<string>(m["PolicyItemId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddIpControlPolicyItemResponseBody() = default;
};
class AddIpControlPolicyItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddIpControlPolicyItemResponseBody> body{};

  AddIpControlPolicyItemResponse() {}

  explicit AddIpControlPolicyItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddIpControlPolicyItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddIpControlPolicyItemResponseBody>(model1);
      }
    }
  }


  virtual ~AddIpControlPolicyItemResponse() = default;
};
class AddTrafficSpecialControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> specialKey{};
  shared_ptr<string> specialType{};
  shared_ptr<string> trafficControlId{};
  shared_ptr<long> trafficValue{};

  AddTrafficSpecialControlRequest() {}

  explicit AddTrafficSpecialControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (specialKey) {
      res["SpecialKey"] = boost::any(*specialKey);
    }
    if (specialType) {
      res["SpecialType"] = boost::any(*specialType);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    if (trafficValue) {
      res["TrafficValue"] = boost::any(*trafficValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SpecialKey") != m.end() && !m["SpecialKey"].empty()) {
      specialKey = make_shared<string>(boost::any_cast<string>(m["SpecialKey"]));
    }
    if (m.find("SpecialType") != m.end() && !m["SpecialType"].empty()) {
      specialType = make_shared<string>(boost::any_cast<string>(m["SpecialType"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
    if (m.find("TrafficValue") != m.end() && !m["TrafficValue"].empty()) {
      trafficValue = make_shared<long>(boost::any_cast<long>(m["TrafficValue"]));
    }
  }


  virtual ~AddTrafficSpecialControlRequest() = default;
};
class AddTrafficSpecialControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddTrafficSpecialControlResponseBody() {}

  explicit AddTrafficSpecialControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddTrafficSpecialControlResponseBody() = default;
};
class AddTrafficSpecialControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTrafficSpecialControlResponseBody> body{};

  AddTrafficSpecialControlResponse() {}

  explicit AddTrafficSpecialControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTrafficSpecialControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTrafficSpecialControlResponseBody>(model1);
      }
    }
  }


  virtual ~AddTrafficSpecialControlResponse() = default;
};
class CreateApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> allowSignatureMethod{};
  shared_ptr<string> apiName{};
  shared_ptr<string> authType{};
  shared_ptr<string> description{};
  shared_ptr<string> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<string> groupId{};
  shared_ptr<string> openIdConnectConfig{};
  shared_ptr<string> requestConfig{};
  shared_ptr<string> requestParamters{};
  shared_ptr<string> resultDescriptions{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> serviceConfig{};
  shared_ptr<string> serviceParameters{};
  shared_ptr<string> serviceParametersMap{};
  shared_ptr<string> visibility{};
  shared_ptr<string> webSocketApiType{};

  CreateApiRequest() {}

  explicit CreateApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowSignatureMethod) {
      res["AllowSignatureMethod"] = boost::any(*allowSignatureMethod);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = boost::any(*errorCodeSamples);
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (openIdConnectConfig) {
      res["OpenIdConnectConfig"] = boost::any(*openIdConnectConfig);
    }
    if (requestConfig) {
      res["RequestConfig"] = boost::any(*requestConfig);
    }
    if (requestParamters) {
      res["RequestParamters"] = boost::any(*requestParamters);
    }
    if (resultDescriptions) {
      res["ResultDescriptions"] = boost::any(*resultDescriptions);
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (serviceConfig) {
      res["ServiceConfig"] = boost::any(*serviceConfig);
    }
    if (serviceParameters) {
      res["ServiceParameters"] = boost::any(*serviceParameters);
    }
    if (serviceParametersMap) {
      res["ServiceParametersMap"] = boost::any(*serviceParametersMap);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (webSocketApiType) {
      res["WebSocketApiType"] = boost::any(*webSocketApiType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowSignatureMethod") != m.end() && !m["AllowSignatureMethod"].empty()) {
      allowSignatureMethod = make_shared<string>(boost::any_cast<string>(m["AllowSignatureMethod"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      errorCodeSamples = make_shared<string>(boost::any_cast<string>(m["ErrorCodeSamples"]));
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OpenIdConnectConfig") != m.end() && !m["OpenIdConnectConfig"].empty()) {
      openIdConnectConfig = make_shared<string>(boost::any_cast<string>(m["OpenIdConnectConfig"]));
    }
    if (m.find("RequestConfig") != m.end() && !m["RequestConfig"].empty()) {
      requestConfig = make_shared<string>(boost::any_cast<string>(m["RequestConfig"]));
    }
    if (m.find("RequestParamters") != m.end() && !m["RequestParamters"].empty()) {
      requestParamters = make_shared<string>(boost::any_cast<string>(m["RequestParamters"]));
    }
    if (m.find("ResultDescriptions") != m.end() && !m["ResultDescriptions"].empty()) {
      resultDescriptions = make_shared<string>(boost::any_cast<string>(m["ResultDescriptions"]));
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("ServiceConfig") != m.end() && !m["ServiceConfig"].empty()) {
      serviceConfig = make_shared<string>(boost::any_cast<string>(m["ServiceConfig"]));
    }
    if (m.find("ServiceParameters") != m.end() && !m["ServiceParameters"].empty()) {
      serviceParameters = make_shared<string>(boost::any_cast<string>(m["ServiceParameters"]));
    }
    if (m.find("ServiceParametersMap") != m.end() && !m["ServiceParametersMap"].empty()) {
      serviceParametersMap = make_shared<string>(boost::any_cast<string>(m["ServiceParametersMap"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WebSocketApiType") != m.end() && !m["WebSocketApiType"].empty()) {
      webSocketApiType = make_shared<string>(boost::any_cast<string>(m["WebSocketApiType"]));
    }
  }


  virtual ~CreateApiRequest() = default;
};
class CreateApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> requestId{};

  CreateApiResponseBody() {}

  explicit CreateApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateApiResponseBody() = default;
};
class CreateApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateApiResponseBody> body{};

  CreateApiResponse() {}

  explicit CreateApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApiResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApiResponse() = default;
};
class CreateApiGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityToken{};

  CreateApiGroupRequest() {}

  explicit CreateApiGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~CreateApiGroupRequest() = default;
};
class CreateApiGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subDomain{};

  CreateApiGroupResponseBody() {}

  explicit CreateApiGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
  }


  virtual ~CreateApiGroupResponseBody() = default;
};
class CreateApiGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateApiGroupResponseBody> body{};

  CreateApiGroupResponse() {}

  explicit CreateApiGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApiGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApiGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApiGroupResponse() = default;
};
class CreateApiStageVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageRouteModel{};
  shared_ptr<bool> supportRoute{};
  shared_ptr<string> variableName{};
  shared_ptr<string> variableValue{};

  CreateApiStageVariableRequest() {}

  explicit CreateApiStageVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageRouteModel) {
      res["StageRouteModel"] = boost::any(*stageRouteModel);
    }
    if (supportRoute) {
      res["SupportRoute"] = boost::any(*supportRoute);
    }
    if (variableName) {
      res["VariableName"] = boost::any(*variableName);
    }
    if (variableValue) {
      res["VariableValue"] = boost::any(*variableValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageRouteModel") != m.end() && !m["StageRouteModel"].empty()) {
      stageRouteModel = make_shared<string>(boost::any_cast<string>(m["StageRouteModel"]));
    }
    if (m.find("SupportRoute") != m.end() && !m["SupportRoute"].empty()) {
      supportRoute = make_shared<bool>(boost::any_cast<bool>(m["SupportRoute"]));
    }
    if (m.find("VariableName") != m.end() && !m["VariableName"].empty()) {
      variableName = make_shared<string>(boost::any_cast<string>(m["VariableName"]));
    }
    if (m.find("VariableValue") != m.end() && !m["VariableValue"].empty()) {
      variableValue = make_shared<string>(boost::any_cast<string>(m["VariableValue"]));
    }
  }


  virtual ~CreateApiStageVariableRequest() = default;
};
class CreateApiStageVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateApiStageVariableResponseBody() {}

  explicit CreateApiStageVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateApiStageVariableResponseBody() = default;
};
class CreateApiStageVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateApiStageVariableResponseBody> body{};

  CreateApiStageVariableResponse() {}

  explicit CreateApiStageVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApiStageVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApiStageVariableResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApiStageVariableResponse() = default;
};
class CreateAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};

  CreateAppRequest() {}

  explicit CreateAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~CreateAppRequest() = default;
};
class CreateAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> requestId{};

  CreateAppResponseBody() {}

  explicit CreateAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAppResponseBody() = default;
};
class CreateAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAppResponseBody> body{};

  CreateAppResponse() {}

  explicit CreateAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAppResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAppResponse() = default;
};
class CreateCustomizedInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> csharpDemo{};
  shared_ptr<string> curlDemo{};
  shared_ptr<string> groupId{};
  shared_ptr<string> javaDemo{};
  shared_ptr<string> objectcDemo{};
  shared_ptr<string> phpDemo{};
  shared_ptr<string> pythonDemo{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};

  CreateCustomizedInfoRequest() {}

  explicit CreateCustomizedInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (csharpDemo) {
      res["CsharpDemo"] = boost::any(*csharpDemo);
    }
    if (curlDemo) {
      res["CurlDemo"] = boost::any(*curlDemo);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (javaDemo) {
      res["JavaDemo"] = boost::any(*javaDemo);
    }
    if (objectcDemo) {
      res["ObjectcDemo"] = boost::any(*objectcDemo);
    }
    if (phpDemo) {
      res["PhpDemo"] = boost::any(*phpDemo);
    }
    if (pythonDemo) {
      res["PythonDemo"] = boost::any(*pythonDemo);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("CsharpDemo") != m.end() && !m["CsharpDemo"].empty()) {
      csharpDemo = make_shared<string>(boost::any_cast<string>(m["CsharpDemo"]));
    }
    if (m.find("CurlDemo") != m.end() && !m["CurlDemo"].empty()) {
      curlDemo = make_shared<string>(boost::any_cast<string>(m["CurlDemo"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("JavaDemo") != m.end() && !m["JavaDemo"].empty()) {
      javaDemo = make_shared<string>(boost::any_cast<string>(m["JavaDemo"]));
    }
    if (m.find("ObjectcDemo") != m.end() && !m["ObjectcDemo"].empty()) {
      objectcDemo = make_shared<string>(boost::any_cast<string>(m["ObjectcDemo"]));
    }
    if (m.find("PhpDemo") != m.end() && !m["PhpDemo"].empty()) {
      phpDemo = make_shared<string>(boost::any_cast<string>(m["PhpDemo"]));
    }
    if (m.find("PythonDemo") != m.end() && !m["PythonDemo"].empty()) {
      pythonDemo = make_shared<string>(boost::any_cast<string>(m["PythonDemo"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~CreateCustomizedInfoRequest() = default;
};
class CreateCustomizedInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateCustomizedInfoResponseBody() {}

  explicit CreateCustomizedInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomizedInfoResponseBody() = default;
};
class CreateCustomizedInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomizedInfoResponseBody> body{};

  CreateCustomizedInfoResponse() {}

  explicit CreateCustomizedInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomizedInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomizedInfoResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomizedInfoResponse() = default;
};
class CreateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<long> accountQuantity{};
  shared_ptr<string> expiredOn{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> skuId{};
  shared_ptr<string> token{};

  CreateInstanceRequest() {}

  explicit CreateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountQuantity) {
      res["AccountQuantity"] = boost::any(*accountQuantity);
    }
    if (expiredOn) {
      res["ExpiredOn"] = boost::any(*expiredOn);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (skuId) {
      res["SkuId"] = boost::any(*skuId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountQuantity") != m.end() && !m["AccountQuantity"].empty()) {
      accountQuantity = make_shared<long>(boost::any_cast<long>(m["AccountQuantity"]));
    }
    if (m.find("ExpiredOn") != m.end() && !m["ExpiredOn"].empty()) {
      expiredOn = make_shared<string>(boost::any_cast<string>(m["ExpiredOn"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SkuId") != m.end() && !m["SkuId"].empty()) {
      skuId = make_shared<string>(boost::any_cast<string>(m["SkuId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~CreateInstanceRequest() = default;
};
class CreateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};

  CreateInstanceResponseBody() {}

  explicit CreateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateInstanceResponseBody() = default;
};
class CreateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateInstanceResponseBody> body{};

  CreateInstanceResponse() {}

  explicit CreateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInstanceResponse() = default;
};
class CreateIpControlRequestIpControlPolicys : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> IP{};

  CreateIpControlRequestIpControlPolicys() {}

  explicit CreateIpControlRequestIpControlPolicys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
  }


  virtual ~CreateIpControlRequestIpControlPolicys() = default;
};
class CreateIpControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ipControlName{};
  shared_ptr<vector<CreateIpControlRequestIpControlPolicys>> ipControlPolicys{};
  shared_ptr<string> ipControlType{};
  shared_ptr<string> securityToken{};

  CreateIpControlRequest() {}

  explicit CreateIpControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipControlName) {
      res["IpControlName"] = boost::any(*ipControlName);
    }
    if (ipControlPolicys) {
      vector<boost::any> temp1;
      for(auto item1:*ipControlPolicys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpControlPolicys"] = boost::any(temp1);
    }
    if (ipControlType) {
      res["IpControlType"] = boost::any(*ipControlType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpControlName") != m.end() && !m["IpControlName"].empty()) {
      ipControlName = make_shared<string>(boost::any_cast<string>(m["IpControlName"]));
    }
    if (m.find("IpControlPolicys") != m.end() && !m["IpControlPolicys"].empty()) {
      if (typeid(vector<boost::any>) == m["IpControlPolicys"].type()) {
        vector<CreateIpControlRequestIpControlPolicys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpControlPolicys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateIpControlRequestIpControlPolicys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipControlPolicys = make_shared<vector<CreateIpControlRequestIpControlPolicys>>(expect1);
      }
    }
    if (m.find("IpControlType") != m.end() && !m["IpControlType"].empty()) {
      ipControlType = make_shared<string>(boost::any_cast<string>(m["IpControlType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~CreateIpControlRequest() = default;
};
class CreateIpControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<string> requestId{};

  CreateIpControlResponseBody() {}

  explicit CreateIpControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateIpControlResponseBody() = default;
};
class CreateIpControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIpControlResponseBody> body{};

  CreateIpControlResponse() {}

  explicit CreateIpControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIpControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIpControlResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIpControlResponse() = default;
};
class CreateLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> logType{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> slsLogStore{};
  shared_ptr<string> slsProject{};

  CreateLogConfigRequest() {}

  explicit CreateLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (slsLogStore) {
      res["SlsLogStore"] = boost::any(*slsLogStore);
    }
    if (slsProject) {
      res["SlsProject"] = boost::any(*slsProject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SlsLogStore") != m.end() && !m["SlsLogStore"].empty()) {
      slsLogStore = make_shared<string>(boost::any_cast<string>(m["SlsLogStore"]));
    }
    if (m.find("SlsProject") != m.end() && !m["SlsProject"].empty()) {
      slsProject = make_shared<string>(boost::any_cast<string>(m["SlsProject"]));
    }
  }


  virtual ~CreateLogConfigRequest() = default;
};
class CreateLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateLogConfigResponseBody() {}

  explicit CreateLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLogConfigResponseBody() = default;
};
class CreateLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLogConfigResponseBody> body{};

  CreateLogConfigResponse() {}

  explicit CreateLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLogConfigResponse() = default;
};
class CreateRaceWorkForInnerRequest : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> groupId{};
  shared_ptr<string> keywords{};
  shared_ptr<string> logoUrl{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> shortDescription{};
  shared_ptr<string> workName{};

  CreateRaceWorkForInnerRequest() {}

  explicit CreateRaceWorkForInnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (logoUrl) {
      res["LogoUrl"] = boost::any(*logoUrl);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (shortDescription) {
      res["ShortDescription"] = boost::any(*shortDescription);
    }
    if (workName) {
      res["WorkName"] = boost::any(*workName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywords = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
    if (m.find("LogoUrl") != m.end() && !m["LogoUrl"].empty()) {
      logoUrl = make_shared<string>(boost::any_cast<string>(m["LogoUrl"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("ShortDescription") != m.end() && !m["ShortDescription"].empty()) {
      shortDescription = make_shared<string>(boost::any_cast<string>(m["ShortDescription"]));
    }
    if (m.find("WorkName") != m.end() && !m["WorkName"].empty()) {
      workName = make_shared<string>(boost::any_cast<string>(m["WorkName"]));
    }
  }


  virtual ~CreateRaceWorkForInnerRequest() = default;
};
class CreateRaceWorkForInnerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateRaceWorkForInnerResponseBody() {}

  explicit CreateRaceWorkForInnerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateRaceWorkForInnerResponseBody() = default;
};
class CreateRaceWorkForInnerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRaceWorkForInnerResponseBody> body{};

  CreateRaceWorkForInnerResponse() {}

  explicit CreateRaceWorkForInnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRaceWorkForInnerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRaceWorkForInnerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRaceWorkForInnerResponse() = default;
};
class CreateSecretKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> secretKey{};
  shared_ptr<string> secretKeyName{};
  shared_ptr<string> secretValue{};
  shared_ptr<string> securityToken{};

  CreateSecretKeyRequest() {}

  explicit CreateSecretKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (secretKeyName) {
      res["SecretKeyName"] = boost::any(*secretKeyName);
    }
    if (secretValue) {
      res["SecretValue"] = boost::any(*secretValue);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("SecretKeyName") != m.end() && !m["SecretKeyName"].empty()) {
      secretKeyName = make_shared<string>(boost::any_cast<string>(m["SecretKeyName"]));
    }
    if (m.find("SecretValue") != m.end() && !m["SecretValue"].empty()) {
      secretValue = make_shared<string>(boost::any_cast<string>(m["SecretValue"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~CreateSecretKeyRequest() = default;
};
class CreateSecretKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> secretKeyId{};
  shared_ptr<string> secretKeyName{};

  CreateSecretKeyResponseBody() {}

  explicit CreateSecretKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (secretKeyId) {
      res["SecretKeyId"] = boost::any(*secretKeyId);
    }
    if (secretKeyName) {
      res["SecretKeyName"] = boost::any(*secretKeyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecretKeyId") != m.end() && !m["SecretKeyId"].empty()) {
      secretKeyId = make_shared<string>(boost::any_cast<string>(m["SecretKeyId"]));
    }
    if (m.find("SecretKeyName") != m.end() && !m["SecretKeyName"].empty()) {
      secretKeyName = make_shared<string>(boost::any_cast<string>(m["SecretKeyName"]));
    }
  }


  virtual ~CreateSecretKeyResponseBody() = default;
};
class CreateSecretKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSecretKeyResponseBody> body{};

  CreateSecretKeyResponse() {}

  explicit CreateSecretKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSecretKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSecretKeyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSecretKeyResponse() = default;
};
class CreateTrafficControlRequest : public Darabonba::Model {
public:
  shared_ptr<long> apiDefault{};
  shared_ptr<long> appDefault{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> trafficControlName{};
  shared_ptr<string> trafficControlUnit{};
  shared_ptr<long> userDefault{};

  CreateTrafficControlRequest() {}

  explicit CreateTrafficControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiDefault) {
      res["ApiDefault"] = boost::any(*apiDefault);
    }
    if (appDefault) {
      res["AppDefault"] = boost::any(*appDefault);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (trafficControlName) {
      res["TrafficControlName"] = boost::any(*trafficControlName);
    }
    if (trafficControlUnit) {
      res["TrafficControlUnit"] = boost::any(*trafficControlUnit);
    }
    if (userDefault) {
      res["UserDefault"] = boost::any(*userDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiDefault") != m.end() && !m["ApiDefault"].empty()) {
      apiDefault = make_shared<long>(boost::any_cast<long>(m["ApiDefault"]));
    }
    if (m.find("AppDefault") != m.end() && !m["AppDefault"].empty()) {
      appDefault = make_shared<long>(boost::any_cast<long>(m["AppDefault"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TrafficControlName") != m.end() && !m["TrafficControlName"].empty()) {
      trafficControlName = make_shared<string>(boost::any_cast<string>(m["TrafficControlName"]));
    }
    if (m.find("TrafficControlUnit") != m.end() && !m["TrafficControlUnit"].empty()) {
      trafficControlUnit = make_shared<string>(boost::any_cast<string>(m["TrafficControlUnit"]));
    }
    if (m.find("UserDefault") != m.end() && !m["UserDefault"].empty()) {
      userDefault = make_shared<long>(boost::any_cast<long>(m["UserDefault"]));
    }
  }


  virtual ~CreateTrafficControlRequest() = default;
};
class CreateTrafficControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> trafficControlId{};

  CreateTrafficControlResponseBody() {}

  explicit CreateTrafficControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~CreateTrafficControlResponseBody() = default;
};
class CreateTrafficControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTrafficControlResponseBody> body{};

  CreateTrafficControlResponse() {}

  explicit CreateTrafficControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTrafficControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTrafficControlResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTrafficControlResponse() = default;
};
class DeleteAllTrafficSpecialControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> trafficControlId{};

  DeleteAllTrafficSpecialControlRequest() {}

  explicit DeleteAllTrafficSpecialControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~DeleteAllTrafficSpecialControlRequest() = default;
};
class DeleteAllTrafficSpecialControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAllTrafficSpecialControlResponseBody() {}

  explicit DeleteAllTrafficSpecialControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAllTrafficSpecialControlResponseBody() = default;
};
class DeleteAllTrafficSpecialControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAllTrafficSpecialControlResponseBody> body{};

  DeleteAllTrafficSpecialControlResponse() {}

  explicit DeleteAllTrafficSpecialControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAllTrafficSpecialControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAllTrafficSpecialControlResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAllTrafficSpecialControlResponse() = default;
};
class DeleteApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DeleteApiRequest() {}

  explicit DeleteApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteApiRequest() = default;
};
class DeleteApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApiResponseBody() {}

  explicit DeleteApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApiResponseBody() = default;
};
class DeleteApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApiResponseBody> body{};

  DeleteApiResponse() {}

  explicit DeleteApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApiResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApiResponse() = default;
};
class DeleteApiGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DeleteApiGroupRequest() {}

  explicit DeleteApiGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteApiGroupRequest() = default;
};
class DeleteApiGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApiGroupResponseBody() {}

  explicit DeleteApiGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApiGroupResponseBody() = default;
};
class DeleteApiGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApiGroupResponseBody> body{};

  DeleteApiGroupResponse() {}

  explicit DeleteApiGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApiGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApiGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApiGroupResponse() = default;
};
class DeleteApiStageVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageId{};
  shared_ptr<string> variableName{};

  DeleteApiStageVariableRequest() {}

  explicit DeleteApiStageVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (variableName) {
      res["VariableName"] = boost::any(*variableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("VariableName") != m.end() && !m["VariableName"].empty()) {
      variableName = make_shared<string>(boost::any_cast<string>(m["VariableName"]));
    }
  }


  virtual ~DeleteApiStageVariableRequest() = default;
};
class DeleteApiStageVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApiStageVariableResponseBody() {}

  explicit DeleteApiStageVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApiStageVariableResponseBody() = default;
};
class DeleteApiStageVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApiStageVariableResponseBody> body{};

  DeleteApiStageVariableResponse() {}

  explicit DeleteApiStageVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApiStageVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApiStageVariableResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApiStageVariableResponse() = default;
};
class DeleteAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> securityToken{};

  DeleteAppRequest() {}

  explicit DeleteAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteAppRequest() = default;
};
class DeleteAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAppResponseBody() {}

  explicit DeleteAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAppResponseBody() = default;
};
class DeleteAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAppResponseBody> body{};

  DeleteAppResponse() {}

  explicit DeleteAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAppResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAppResponse() = default;
};
class DeleteDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DeleteDomainRequest() {}

  explicit DeleteDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteDomainRequest() = default;
};
class DeleteDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDomainResponseBody() {}

  explicit DeleteDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDomainResponseBody() = default;
};
class DeleteDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDomainResponseBody> body{};

  DeleteDomainResponse() {}

  explicit DeleteDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDomainResponse() = default;
};
class DeleteDomainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certificateId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DeleteDomainCertificateRequest() {}

  explicit DeleteDomainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteDomainCertificateRequest() = default;
};
class DeleteDomainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDomainCertificateResponseBody() {}

  explicit DeleteDomainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDomainCertificateResponseBody() = default;
};
class DeleteDomainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDomainCertificateResponseBody> body{};

  DeleteDomainCertificateResponse() {}

  explicit DeleteDomainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDomainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDomainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDomainCertificateResponse() = default;
};
class DeleteIpControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<string> securityToken{};

  DeleteIpControlRequest() {}

  explicit DeleteIpControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteIpControlRequest() = default;
};
class DeleteIpControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteIpControlResponseBody() {}

  explicit DeleteIpControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIpControlResponseBody() = default;
};
class DeleteIpControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIpControlResponseBody> body{};

  DeleteIpControlResponse() {}

  explicit DeleteIpControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIpControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIpControlResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIpControlResponse() = default;
};
class DeleteLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> logType{};
  shared_ptr<string> securityToken{};

  DeleteLogConfigRequest() {}

  explicit DeleteLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLogConfigRequest() = default;
};
class DeleteLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLogConfigResponseBody() {}

  explicit DeleteLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLogConfigResponseBody() = default;
};
class DeleteLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLogConfigResponseBody> body{};

  DeleteLogConfigResponse() {}

  explicit DeleteLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLogConfigResponse() = default;
};
class DeleteSecretKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> secretKeyId{};
  shared_ptr<string> securityToken{};

  DeleteSecretKeyRequest() {}

  explicit DeleteSecretKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (secretKeyId) {
      res["SecretKeyId"] = boost::any(*secretKeyId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecretKeyId") != m.end() && !m["SecretKeyId"].empty()) {
      secretKeyId = make_shared<string>(boost::any_cast<string>(m["SecretKeyId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteSecretKeyRequest() = default;
};
class DeleteSecretKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSecretKeyResponseBody() {}

  explicit DeleteSecretKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSecretKeyResponseBody() = default;
};
class DeleteSecretKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSecretKeyResponseBody> body{};

  DeleteSecretKeyResponse() {}

  explicit DeleteSecretKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSecretKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSecretKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSecretKeyResponse() = default;
};
class DeleteTrafficControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> trafficControlId{};

  DeleteTrafficControlRequest() {}

  explicit DeleteTrafficControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~DeleteTrafficControlRequest() = default;
};
class DeleteTrafficControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTrafficControlResponseBody() {}

  explicit DeleteTrafficControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTrafficControlResponseBody() = default;
};
class DeleteTrafficControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTrafficControlResponseBody> body{};

  DeleteTrafficControlResponse() {}

  explicit DeleteTrafficControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTrafficControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTrafficControlResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTrafficControlResponse() = default;
};
class DeleteTrafficSpecialControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> specialKey{};
  shared_ptr<string> specialType{};
  shared_ptr<string> trafficControlId{};

  DeleteTrafficSpecialControlRequest() {}

  explicit DeleteTrafficSpecialControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (specialKey) {
      res["SpecialKey"] = boost::any(*specialKey);
    }
    if (specialType) {
      res["SpecialType"] = boost::any(*specialType);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SpecialKey") != m.end() && !m["SpecialKey"].empty()) {
      specialKey = make_shared<string>(boost::any_cast<string>(m["SpecialKey"]));
    }
    if (m.find("SpecialType") != m.end() && !m["SpecialType"].empty()) {
      specialType = make_shared<string>(boost::any_cast<string>(m["SpecialType"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~DeleteTrafficSpecialControlRequest() = default;
};
class DeleteTrafficSpecialControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTrafficSpecialControlResponseBody() {}

  explicit DeleteTrafficSpecialControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTrafficSpecialControlResponseBody() = default;
};
class DeleteTrafficSpecialControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTrafficSpecialControlResponseBody> body{};

  DeleteTrafficSpecialControlResponse() {}

  explicit DeleteTrafficSpecialControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTrafficSpecialControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTrafficSpecialControlResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTrafficSpecialControlResponse() = default;
};
class DeployApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> supportMock{};

  DeployApiRequest() {}

  explicit DeployApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (supportMock) {
      res["SupportMock"] = boost::any(*supportMock);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("SupportMock") != m.end() && !m["SupportMock"].empty()) {
      supportMock = make_shared<string>(boost::any_cast<string>(m["SupportMock"]));
    }
  }


  virtual ~DeployApiRequest() = default;
};
class DeployApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeployApiResponseBody() {}

  explicit DeployApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeployApiResponseBody() = default;
};
class DeployApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeployApiResponseBody> body{};

  DeployApiResponse() {}

  explicit DeployApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeployApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeployApiResponseBody>(model1);
      }
    }
  }


  virtual ~DeployApiResponse() = default;
};
class DescribeApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribeApiRequest() {}

  explicit DescribeApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApiRequest() = default;
};
class DescribeApiResponseBodyConstantParametersConstantParameter : public Darabonba::Model {
public:
  shared_ptr<string> constantValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiResponseBodyConstantParametersConstantParameter() {}

  explicit DescribeApiResponseBodyConstantParametersConstantParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantValue) {
      res["ConstantValue"] = boost::any(*constantValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantValue") != m.end() && !m["ConstantValue"].empty()) {
      constantValue = make_shared<string>(boost::any_cast<string>(m["ConstantValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiResponseBodyConstantParametersConstantParameter() = default;
};
class DescribeApiResponseBodyConstantParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyConstantParametersConstantParameter>> constantParameter{};

  DescribeApiResponseBodyConstantParameters() {}

  explicit DescribeApiResponseBodyConstantParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantParameter) {
      vector<boost::any> temp1;
      for(auto item1:*constantParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConstantParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantParameter") != m.end() && !m["ConstantParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ConstantParameter"].type()) {
        vector<DescribeApiResponseBodyConstantParametersConstantParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConstantParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyConstantParametersConstantParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        constantParameter = make_shared<vector<DescribeApiResponseBodyConstantParametersConstantParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyConstantParameters() = default;
};
class DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter() {}

  explicit DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter() = default;
};
class DescribeApiResponseBodyCustomSystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter>> customSystemParameter{};

  DescribeApiResponseBodyCustomSystemParameters() {}

  explicit DescribeApiResponseBodyCustomSystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customSystemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*customSystemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomSystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomSystemParameter") != m.end() && !m["CustomSystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomSystemParameter"].type()) {
        vector<DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomSystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customSystemParameter = make_shared<vector<DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyCustomSystemParameters() = default;
};
class DescribeApiResponseBodyDeployedInfosDeployedInfo : public Darabonba::Model {
public:
  shared_ptr<string> deployedStatus{};
  shared_ptr<string> effectiveVersion{};
  shared_ptr<string> stageName{};

  DescribeApiResponseBodyDeployedInfosDeployedInfo() {}

  explicit DescribeApiResponseBodyDeployedInfosDeployedInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedStatus) {
      res["DeployedStatus"] = boost::any(*deployedStatus);
    }
    if (effectiveVersion) {
      res["EffectiveVersion"] = boost::any(*effectiveVersion);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedStatus") != m.end() && !m["DeployedStatus"].empty()) {
      deployedStatus = make_shared<string>(boost::any_cast<string>(m["DeployedStatus"]));
    }
    if (m.find("EffectiveVersion") != m.end() && !m["EffectiveVersion"].empty()) {
      effectiveVersion = make_shared<string>(boost::any_cast<string>(m["EffectiveVersion"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiResponseBodyDeployedInfosDeployedInfo() = default;
};
class DescribeApiResponseBodyDeployedInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyDeployedInfosDeployedInfo>> deployedInfo{};

  DescribeApiResponseBodyDeployedInfos() {}

  explicit DescribeApiResponseBodyDeployedInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deployedInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployedInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedInfo") != m.end() && !m["DeployedInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployedInfo"].type()) {
        vector<DescribeApiResponseBodyDeployedInfosDeployedInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployedInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyDeployedInfosDeployedInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployedInfo = make_shared<vector<DescribeApiResponseBodyDeployedInfosDeployedInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyDeployedInfos() = default;
};
class DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> message{};

  DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample() {}

  explicit DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample() = default;
};
class DescribeApiResponseBodyErrorCodeSamples : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample>> errorCodeSample{};

  DescribeApiResponseBodyErrorCodeSamples() {}

  explicit DescribeApiResponseBodyErrorCodeSamples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCodeSample) {
      vector<boost::any> temp1;
      for(auto item1:*errorCodeSample){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorCodeSample"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCodeSample") != m.end() && !m["ErrorCodeSample"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorCodeSample"].type()) {
        vector<DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorCodeSample"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorCodeSample = make_shared<vector<DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyErrorCodeSamples() = default;
};
class DescribeApiResponseBodyOpenIdConnectConfig : public Darabonba::Model {
public:
  shared_ptr<string> idTokenParamName{};
  shared_ptr<string> openIdApiType{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> publicKeyId{};

  DescribeApiResponseBodyOpenIdConnectConfig() {}

  explicit DescribeApiResponseBodyOpenIdConnectConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (idTokenParamName) {
      res["IdTokenParamName"] = boost::any(*idTokenParamName);
    }
    if (openIdApiType) {
      res["OpenIdApiType"] = boost::any(*openIdApiType);
    }
    if (publicKey) {
      res["PublicKey"] = boost::any(*publicKey);
    }
    if (publicKeyId) {
      res["PublicKeyId"] = boost::any(*publicKeyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdTokenParamName") != m.end() && !m["IdTokenParamName"].empty()) {
      idTokenParamName = make_shared<string>(boost::any_cast<string>(m["IdTokenParamName"]));
    }
    if (m.find("OpenIdApiType") != m.end() && !m["OpenIdApiType"].empty()) {
      openIdApiType = make_shared<string>(boost::any_cast<string>(m["OpenIdApiType"]));
    }
    if (m.find("PublicKey") != m.end() && !m["PublicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["PublicKey"]));
    }
    if (m.find("PublicKeyId") != m.end() && !m["PublicKeyId"].empty()) {
      publicKeyId = make_shared<string>(boost::any_cast<string>(m["PublicKeyId"]));
    }
  }


  virtual ~DescribeApiResponseBodyOpenIdConnectConfig() = default;
};
class DescribeApiResponseBodyParametersMapObjectServiceParameterMap : public Darabonba::Model {
public:
  shared_ptr<string> requestParameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiResponseBodyParametersMapObjectServiceParameterMap() {}

  explicit DescribeApiResponseBodyParametersMapObjectServiceParameterMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParameterName) {
      res["RequestParameterName"] = boost::any(*requestParameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParameterName") != m.end() && !m["RequestParameterName"].empty()) {
      requestParameterName = make_shared<string>(boost::any_cast<string>(m["RequestParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiResponseBodyParametersMapObjectServiceParameterMap() = default;
};
class DescribeApiResponseBodyParametersMapObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyParametersMapObjectServiceParameterMap>> serviceParameterMap{};

  DescribeApiResponseBodyParametersMapObject() {}

  explicit DescribeApiResponseBodyParametersMapObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceParameterMap) {
      vector<boost::any> temp1;
      for(auto item1:*serviceParameterMap){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceParameterMap"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceParameterMap") != m.end() && !m["ServiceParameterMap"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceParameterMap"].type()) {
        vector<DescribeApiResponseBodyParametersMapObjectServiceParameterMap> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceParameterMap"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyParametersMapObjectServiceParameterMap model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceParameterMap = make_shared<vector<DescribeApiResponseBodyParametersMapObjectServiceParameterMap>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyParametersMapObject() = default;
};
class DescribeApiResponseBodyRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> bodyFormat{};
  shared_ptr<string> postBodyDescription{};
  shared_ptr<string> requestHttpMethod{};
  shared_ptr<string> requestMode{};
  shared_ptr<string> requestPath{};
  shared_ptr<string> requestProtocol{};

  DescribeApiResponseBodyRequestConfig() {}

  explicit DescribeApiResponseBodyRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bodyFormat) {
      res["BodyFormat"] = boost::any(*bodyFormat);
    }
    if (postBodyDescription) {
      res["PostBodyDescription"] = boost::any(*postBodyDescription);
    }
    if (requestHttpMethod) {
      res["RequestHttpMethod"] = boost::any(*requestHttpMethod);
    }
    if (requestMode) {
      res["RequestMode"] = boost::any(*requestMode);
    }
    if (requestPath) {
      res["RequestPath"] = boost::any(*requestPath);
    }
    if (requestProtocol) {
      res["RequestProtocol"] = boost::any(*requestProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BodyFormat") != m.end() && !m["BodyFormat"].empty()) {
      bodyFormat = make_shared<string>(boost::any_cast<string>(m["BodyFormat"]));
    }
    if (m.find("PostBodyDescription") != m.end() && !m["PostBodyDescription"].empty()) {
      postBodyDescription = make_shared<string>(boost::any_cast<string>(m["PostBodyDescription"]));
    }
    if (m.find("RequestHttpMethod") != m.end() && !m["RequestHttpMethod"].empty()) {
      requestHttpMethod = make_shared<string>(boost::any_cast<string>(m["RequestHttpMethod"]));
    }
    if (m.find("RequestMode") != m.end() && !m["RequestMode"].empty()) {
      requestMode = make_shared<string>(boost::any_cast<string>(m["RequestMode"]));
    }
    if (m.find("RequestPath") != m.end() && !m["RequestPath"].empty()) {
      requestPath = make_shared<string>(boost::any_cast<string>(m["RequestPath"]));
    }
    if (m.find("RequestProtocol") != m.end() && !m["RequestProtocol"].empty()) {
      requestProtocol = make_shared<string>(boost::any_cast<string>(m["RequestProtocol"]));
    }
  }


  virtual ~DescribeApiResponseBodyRequestConfig() = default;
};
class DescribeApiResponseBodyRequestParametersObjectRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<string> location{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};

  DescribeApiResponseBodyRequestParametersObjectRequestParam() {}

  explicit DescribeApiResponseBodyRequestParametersObjectRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<string>(boost::any_cast<string>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
  }


  virtual ~DescribeApiResponseBodyRequestParametersObjectRequestParam() = default;
};
class DescribeApiResponseBodyRequestParametersObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyRequestParametersObjectRequestParam>> requestParam{};

  DescribeApiResponseBodyRequestParametersObject() {}

  explicit DescribeApiResponseBodyRequestParametersObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParam) {
      vector<boost::any> temp1;
      for(auto item1:*requestParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParam"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParam") != m.end() && !m["RequestParam"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParam"].type()) {
        vector<DescribeApiResponseBodyRequestParametersObjectRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyRequestParametersObjectRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParam = make_shared<vector<DescribeApiResponseBodyRequestParametersObjectRequestParam>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyRequestParametersObject() = default;
};
class DescribeApiResponseBodyServiceConfigFunctionComputeConfig : public Darabonba::Model {
public:
  shared_ptr<string> fcRegionId{};
  shared_ptr<string> functionName{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> serviceName{};

  DescribeApiResponseBodyServiceConfigFunctionComputeConfig() {}

  explicit DescribeApiResponseBodyServiceConfigFunctionComputeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fcRegionId) {
      res["FcRegionId"] = boost::any(*fcRegionId);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FcRegionId") != m.end() && !m["FcRegionId"].empty()) {
      fcRegionId = make_shared<string>(boost::any_cast<string>(m["FcRegionId"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeApiResponseBodyServiceConfigFunctionComputeConfig() = default;
};
class DescribeApiResponseBodyServiceConfigVpcConfig : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> vpcId{};

  DescribeApiResponseBodyServiceConfigVpcConfig() {}

  explicit DescribeApiResponseBodyServiceConfigVpcConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeApiResponseBodyServiceConfigVpcConfig() = default;
};
class DescribeApiResponseBodyServiceConfig : public Darabonba::Model {
public:
  shared_ptr<string> aoneAppName{};
  shared_ptr<string> contentTypeCatagory{};
  shared_ptr<string> contentTypeValue{};
  shared_ptr<DescribeApiResponseBodyServiceConfigFunctionComputeConfig> functionComputeConfig{};
  shared_ptr<string> mock{};
  shared_ptr<string> mockResult{};
  shared_ptr<string> serviceAddress{};
  shared_ptr<string> serviceHttpMethod{};
  shared_ptr<string> servicePath{};
  shared_ptr<string> serviceProtocol{};
  shared_ptr<string> serviceTimeout{};
  shared_ptr<string> serviceVpcEnable{};
  shared_ptr<DescribeApiResponseBodyServiceConfigVpcConfig> vpcConfig{};

  DescribeApiResponseBodyServiceConfig() {}

  explicit DescribeApiResponseBodyServiceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aoneAppName) {
      res["AoneAppName"] = boost::any(*aoneAppName);
    }
    if (contentTypeCatagory) {
      res["ContentTypeCatagory"] = boost::any(*contentTypeCatagory);
    }
    if (contentTypeValue) {
      res["ContentTypeValue"] = boost::any(*contentTypeValue);
    }
    if (functionComputeConfig) {
      res["FunctionComputeConfig"] = functionComputeConfig ? boost::any(functionComputeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mock) {
      res["Mock"] = boost::any(*mock);
    }
    if (mockResult) {
      res["MockResult"] = boost::any(*mockResult);
    }
    if (serviceAddress) {
      res["ServiceAddress"] = boost::any(*serviceAddress);
    }
    if (serviceHttpMethod) {
      res["ServiceHttpMethod"] = boost::any(*serviceHttpMethod);
    }
    if (servicePath) {
      res["ServicePath"] = boost::any(*servicePath);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    if (serviceTimeout) {
      res["ServiceTimeout"] = boost::any(*serviceTimeout);
    }
    if (serviceVpcEnable) {
      res["ServiceVpcEnable"] = boost::any(*serviceVpcEnable);
    }
    if (vpcConfig) {
      res["VpcConfig"] = vpcConfig ? boost::any(vpcConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AoneAppName") != m.end() && !m["AoneAppName"].empty()) {
      aoneAppName = make_shared<string>(boost::any_cast<string>(m["AoneAppName"]));
    }
    if (m.find("ContentTypeCatagory") != m.end() && !m["ContentTypeCatagory"].empty()) {
      contentTypeCatagory = make_shared<string>(boost::any_cast<string>(m["ContentTypeCatagory"]));
    }
    if (m.find("ContentTypeValue") != m.end() && !m["ContentTypeValue"].empty()) {
      contentTypeValue = make_shared<string>(boost::any_cast<string>(m["ContentTypeValue"]));
    }
    if (m.find("FunctionComputeConfig") != m.end() && !m["FunctionComputeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionComputeConfig"].type()) {
        DescribeApiResponseBodyServiceConfigFunctionComputeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionComputeConfig"]));
        functionComputeConfig = make_shared<DescribeApiResponseBodyServiceConfigFunctionComputeConfig>(model1);
      }
    }
    if (m.find("Mock") != m.end() && !m["Mock"].empty()) {
      mock = make_shared<string>(boost::any_cast<string>(m["Mock"]));
    }
    if (m.find("MockResult") != m.end() && !m["MockResult"].empty()) {
      mockResult = make_shared<string>(boost::any_cast<string>(m["MockResult"]));
    }
    if (m.find("ServiceAddress") != m.end() && !m["ServiceAddress"].empty()) {
      serviceAddress = make_shared<string>(boost::any_cast<string>(m["ServiceAddress"]));
    }
    if (m.find("ServiceHttpMethod") != m.end() && !m["ServiceHttpMethod"].empty()) {
      serviceHttpMethod = make_shared<string>(boost::any_cast<string>(m["ServiceHttpMethod"]));
    }
    if (m.find("ServicePath") != m.end() && !m["ServicePath"].empty()) {
      servicePath = make_shared<string>(boost::any_cast<string>(m["ServicePath"]));
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
    if (m.find("ServiceTimeout") != m.end() && !m["ServiceTimeout"].empty()) {
      serviceTimeout = make_shared<string>(boost::any_cast<string>(m["ServiceTimeout"]));
    }
    if (m.find("ServiceVpcEnable") != m.end() && !m["ServiceVpcEnable"].empty()) {
      serviceVpcEnable = make_shared<string>(boost::any_cast<string>(m["ServiceVpcEnable"]));
    }
    if (m.find("VpcConfig") != m.end() && !m["VpcConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcConfig"].type()) {
        DescribeApiResponseBodyServiceConfigVpcConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcConfig"]));
        vpcConfig = make_shared<DescribeApiResponseBodyServiceConfigVpcConfig>(model1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyServiceConfig() = default;
};
class DescribeApiResponseBodyServiceParametersObjectServiceParam : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> serviceParameterName{};
  shared_ptr<string> type{};

  DescribeApiResponseBodyServiceParametersObjectServiceParam() {}

  explicit DescribeApiResponseBodyServiceParametersObjectServiceParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeApiResponseBodyServiceParametersObjectServiceParam() = default;
};
class DescribeApiResponseBodyServiceParametersObject : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyServiceParametersObjectServiceParam>> serviceParam{};

  DescribeApiResponseBodyServiceParametersObject() {}

  explicit DescribeApiResponseBodyServiceParametersObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceParam) {
      vector<boost::any> temp1;
      for(auto item1:*serviceParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceParam"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceParam") != m.end() && !m["ServiceParam"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceParam"].type()) {
        vector<DescribeApiResponseBodyServiceParametersObjectServiceParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyServiceParametersObjectServiceParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceParam = make_shared<vector<DescribeApiResponseBodyServiceParametersObjectServiceParam>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyServiceParametersObject() = default;
};
class DescribeApiResponseBodySystemParametersSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiResponseBodySystemParametersSystemParameter() {}

  explicit DescribeApiResponseBodySystemParametersSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiResponseBodySystemParametersSystemParameter() = default;
};
class DescribeApiResponseBodySystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodySystemParametersSystemParameter>> systemParameter{};

  DescribeApiResponseBodySystemParameters() {}

  explicit DescribeApiResponseBodySystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*systemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemParameter") != m.end() && !m["SystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemParameter"].type()) {
        vector<DescribeApiResponseBodySystemParametersSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodySystemParametersSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemParameter = make_shared<vector<DescribeApiResponseBodySystemParametersSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodySystemParameters() = default;
};
class DescribeApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> allowSignatureMethod{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> authType{};
  shared_ptr<DescribeApiResponseBodyConstantParameters> constantParameters{};
  shared_ptr<string> createdTime{};
  shared_ptr<DescribeApiResponseBodyCustomSystemParameters> customSystemParameters{};
  shared_ptr<DescribeApiResponseBodyDeployedInfos> deployedInfos{};
  shared_ptr<string> description{};
  shared_ptr<DescribeApiResponseBodyErrorCodeSamples> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> mock{};
  shared_ptr<string> mockResult{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<DescribeApiResponseBodyOpenIdConnectConfig> openIdConnectConfig{};
  shared_ptr<string> originResultDescription{};
  shared_ptr<DescribeApiResponseBodyParametersMapObject> parametersMapObject{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeApiResponseBodyRequestConfig> requestConfig{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeApiResponseBodyRequestParametersObject> requestParametersObject{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<DescribeApiResponseBodyServiceConfig> serviceConfig{};
  shared_ptr<DescribeApiResponseBodyServiceParametersObject> serviceParametersObject{};
  shared_ptr<DescribeApiResponseBodySystemParameters> systemParameters{};
  shared_ptr<string> visibility{};
  shared_ptr<string> webSocketApiType{};

  DescribeApiResponseBody() {}

  explicit DescribeApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowSignatureMethod) {
      res["AllowSignatureMethod"] = boost::any(*allowSignatureMethod);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (constantParameters) {
      res["ConstantParameters"] = constantParameters ? boost::any(constantParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (customSystemParameters) {
      res["CustomSystemParameters"] = customSystemParameters ? boost::any(customSystemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployedInfos) {
      res["DeployedInfos"] = deployedInfos ? boost::any(deployedInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = errorCodeSamples ? boost::any(errorCodeSamples->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (mock) {
      res["Mock"] = boost::any(*mock);
    }
    if (mockResult) {
      res["MockResult"] = boost::any(*mockResult);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (openIdConnectConfig) {
      res["OpenIdConnectConfig"] = openIdConnectConfig ? boost::any(openIdConnectConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (originResultDescription) {
      res["OriginResultDescription"] = boost::any(*originResultDescription);
    }
    if (parametersMapObject) {
      res["ParametersMapObject"] = parametersMapObject ? boost::any(parametersMapObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestConfig) {
      res["RequestConfig"] = requestConfig ? boost::any(requestConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestParametersObject) {
      res["RequestParametersObject"] = requestParametersObject ? boost::any(requestParametersObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (serviceConfig) {
      res["ServiceConfig"] = serviceConfig ? boost::any(serviceConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceParametersObject) {
      res["ServiceParametersObject"] = serviceParametersObject ? boost::any(serviceParametersObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (systemParameters) {
      res["SystemParameters"] = systemParameters ? boost::any(systemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (webSocketApiType) {
      res["WebSocketApiType"] = boost::any(*webSocketApiType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowSignatureMethod") != m.end() && !m["AllowSignatureMethod"].empty()) {
      allowSignatureMethod = make_shared<string>(boost::any_cast<string>(m["AllowSignatureMethod"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("ConstantParameters") != m.end() && !m["ConstantParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConstantParameters"].type()) {
        DescribeApiResponseBodyConstantParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConstantParameters"]));
        constantParameters = make_shared<DescribeApiResponseBodyConstantParameters>(model1);
      }
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("CustomSystemParameters") != m.end() && !m["CustomSystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomSystemParameters"].type()) {
        DescribeApiResponseBodyCustomSystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomSystemParameters"]));
        customSystemParameters = make_shared<DescribeApiResponseBodyCustomSystemParameters>(model1);
      }
    }
    if (m.find("DeployedInfos") != m.end() && !m["DeployedInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployedInfos"].type()) {
        DescribeApiResponseBodyDeployedInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployedInfos"]));
        deployedInfos = make_shared<DescribeApiResponseBodyDeployedInfos>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorCodeSamples"].type()) {
        DescribeApiResponseBodyErrorCodeSamples model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorCodeSamples"]));
        errorCodeSamples = make_shared<DescribeApiResponseBodyErrorCodeSamples>(model1);
      }
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Mock") != m.end() && !m["Mock"].empty()) {
      mock = make_shared<string>(boost::any_cast<string>(m["Mock"]));
    }
    if (m.find("MockResult") != m.end() && !m["MockResult"].empty()) {
      mockResult = make_shared<string>(boost::any_cast<string>(m["MockResult"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OpenIdConnectConfig") != m.end() && !m["OpenIdConnectConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpenIdConnectConfig"].type()) {
        DescribeApiResponseBodyOpenIdConnectConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpenIdConnectConfig"]));
        openIdConnectConfig = make_shared<DescribeApiResponseBodyOpenIdConnectConfig>(model1);
      }
    }
    if (m.find("OriginResultDescription") != m.end() && !m["OriginResultDescription"].empty()) {
      originResultDescription = make_shared<string>(boost::any_cast<string>(m["OriginResultDescription"]));
    }
    if (m.find("ParametersMapObject") != m.end() && !m["ParametersMapObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["ParametersMapObject"].type()) {
        DescribeApiResponseBodyParametersMapObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ParametersMapObject"]));
        parametersMapObject = make_shared<DescribeApiResponseBodyParametersMapObject>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestConfig") != m.end() && !m["RequestConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestConfig"].type()) {
        DescribeApiResponseBodyRequestConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestConfig"]));
        requestConfig = make_shared<DescribeApiResponseBodyRequestConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestParametersObject") != m.end() && !m["RequestParametersObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestParametersObject"].type()) {
        DescribeApiResponseBodyRequestParametersObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestParametersObject"]));
        requestParametersObject = make_shared<DescribeApiResponseBodyRequestParametersObject>(model1);
      }
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("ServiceConfig") != m.end() && !m["ServiceConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceConfig"].type()) {
        DescribeApiResponseBodyServiceConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceConfig"]));
        serviceConfig = make_shared<DescribeApiResponseBodyServiceConfig>(model1);
      }
    }
    if (m.find("ServiceParametersObject") != m.end() && !m["ServiceParametersObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceParametersObject"].type()) {
        DescribeApiResponseBodyServiceParametersObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceParametersObject"]));
        serviceParametersObject = make_shared<DescribeApiResponseBodyServiceParametersObject>(model1);
      }
    }
    if (m.find("SystemParameters") != m.end() && !m["SystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemParameters"].type()) {
        DescribeApiResponseBodySystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemParameters"]));
        systemParameters = make_shared<DescribeApiResponseBodySystemParameters>(model1);
      }
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WebSocketApiType") != m.end() && !m["WebSocketApiType"].empty()) {
      webSocketApiType = make_shared<string>(boost::any_cast<string>(m["WebSocketApiType"]));
    }
  }


  virtual ~DescribeApiResponseBody() = default;
};
class DescribeApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiResponseBody> body{};

  DescribeApiResponse() {}

  explicit DescribeApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiResponse() = default;
};
class DescribeApiDocRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiDocRequest() {}

  explicit DescribeApiDocRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiDocRequest() = default;
};
class DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> message{};

  DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample() {}

  explicit DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample() = default;
};
class DescribeApiDocResponseBodyErrorCodeSamples : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample>> errorCodeSample{};

  DescribeApiDocResponseBodyErrorCodeSamples() {}

  explicit DescribeApiDocResponseBodyErrorCodeSamples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCodeSample) {
      vector<boost::any> temp1;
      for(auto item1:*errorCodeSample){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorCodeSample"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCodeSample") != m.end() && !m["ErrorCodeSample"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorCodeSample"].type()) {
        vector<DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorCodeSample"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorCodeSample = make_shared<vector<DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample>>(expect1);
      }
    }
  }


  virtual ~DescribeApiDocResponseBodyErrorCodeSamples() = default;
};
class DescribeApiDocResponseBodyPathParametersPathParameter : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};

  DescribeApiDocResponseBodyPathParametersPathParameter() {}

  explicit DescribeApiDocResponseBodyPathParametersPathParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~DescribeApiDocResponseBodyPathParametersPathParameter() = default;
};
class DescribeApiDocResponseBodyPathParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiDocResponseBodyPathParametersPathParameter>> pathParameter{};

  DescribeApiDocResponseBodyPathParameters() {}

  explicit DescribeApiDocResponseBodyPathParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pathParameter) {
      vector<boost::any> temp1;
      for(auto item1:*pathParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PathParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PathParameter") != m.end() && !m["PathParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["PathParameter"].type()) {
        vector<DescribeApiDocResponseBodyPathParametersPathParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PathParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiDocResponseBodyPathParametersPathParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pathParameter = make_shared<vector<DescribeApiDocResponseBodyPathParametersPathParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiDocResponseBodyPathParameters() = default;
};
class DescribeApiDocResponseBodyRequestBodyRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};

  DescribeApiDocResponseBodyRequestBodyRequestParam() {}

  explicit DescribeApiDocResponseBodyRequestBodyRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
  }


  virtual ~DescribeApiDocResponseBodyRequestBodyRequestParam() = default;
};
class DescribeApiDocResponseBodyRequestBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiDocResponseBodyRequestBodyRequestParam>> requestParam{};

  DescribeApiDocResponseBodyRequestBody() {}

  explicit DescribeApiDocResponseBodyRequestBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParam) {
      vector<boost::any> temp1;
      for(auto item1:*requestParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParam"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParam") != m.end() && !m["RequestParam"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParam"].type()) {
        vector<DescribeApiDocResponseBodyRequestBodyRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiDocResponseBodyRequestBodyRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParam = make_shared<vector<DescribeApiDocResponseBodyRequestBodyRequestParam>>(expect1);
      }
    }
  }


  virtual ~DescribeApiDocResponseBodyRequestBody() = default;
};
class DescribeApiDocResponseBodyRequestHeadersRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};

  DescribeApiDocResponseBodyRequestHeadersRequestParam() {}

  explicit DescribeApiDocResponseBodyRequestHeadersRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
  }


  virtual ~DescribeApiDocResponseBodyRequestHeadersRequestParam() = default;
};
class DescribeApiDocResponseBodyRequestHeaders : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiDocResponseBodyRequestHeadersRequestParam>> requestParam{};

  DescribeApiDocResponseBodyRequestHeaders() {}

  explicit DescribeApiDocResponseBodyRequestHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParam) {
      vector<boost::any> temp1;
      for(auto item1:*requestParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParam"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParam") != m.end() && !m["RequestParam"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParam"].type()) {
        vector<DescribeApiDocResponseBodyRequestHeadersRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiDocResponseBodyRequestHeadersRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParam = make_shared<vector<DescribeApiDocResponseBodyRequestHeadersRequestParam>>(expect1);
      }
    }
  }


  virtual ~DescribeApiDocResponseBodyRequestHeaders() = default;
};
class DescribeApiDocResponseBodyRequestQueriesRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};

  DescribeApiDocResponseBodyRequestQueriesRequestParam() {}

  explicit DescribeApiDocResponseBodyRequestQueriesRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
  }


  virtual ~DescribeApiDocResponseBodyRequestQueriesRequestParam() = default;
};
class DescribeApiDocResponseBodyRequestQueries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiDocResponseBodyRequestQueriesRequestParam>> requestParam{};

  DescribeApiDocResponseBodyRequestQueries() {}

  explicit DescribeApiDocResponseBodyRequestQueries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParam) {
      vector<boost::any> temp1;
      for(auto item1:*requestParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParam"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParam") != m.end() && !m["RequestParam"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParam"].type()) {
        vector<DescribeApiDocResponseBodyRequestQueriesRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiDocResponseBodyRequestQueriesRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParam = make_shared<vector<DescribeApiDocResponseBodyRequestQueriesRequestParam>>(expect1);
      }
    }
  }


  virtual ~DescribeApiDocResponseBodyRequestQueries() = default;
};
class DescribeApiDocResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> bodyFormat{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<DescribeApiDocResponseBodyErrorCodeSamples> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> httpProtocol{};
  shared_ptr<string> mock{};
  shared_ptr<string> mockResult{};
  shared_ptr<string> originResultDescription{};
  shared_ptr<string> path{};
  shared_ptr<DescribeApiDocResponseBodyPathParameters> pathParameters{};
  shared_ptr<string> postBodyDescription{};
  shared_ptr<string> postBodyType{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeApiDocResponseBodyRequestBody> requestBody{};
  shared_ptr<DescribeApiDocResponseBodyRequestHeaders> requestHeaders{};
  shared_ptr<string> requestId{};
  shared_ptr<string> requestMode{};
  shared_ptr<DescribeApiDocResponseBodyRequestQueries> requestQueries{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<long> serviceTimeout{};
  shared_ptr<string> serviceVpcEnable{};
  shared_ptr<string> stageName{};
  shared_ptr<string> vpcName{};

  DescribeApiDocResponseBody() {}

  explicit DescribeApiDocResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (bodyFormat) {
      res["BodyFormat"] = boost::any(*bodyFormat);
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = errorCodeSamples ? boost::any(errorCodeSamples->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (httpProtocol) {
      res["HttpProtocol"] = boost::any(*httpProtocol);
    }
    if (mock) {
      res["Mock"] = boost::any(*mock);
    }
    if (mockResult) {
      res["MockResult"] = boost::any(*mockResult);
    }
    if (originResultDescription) {
      res["OriginResultDescription"] = boost::any(*originResultDescription);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (pathParameters) {
      res["PathParameters"] = pathParameters ? boost::any(pathParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (postBodyDescription) {
      res["PostBodyDescription"] = boost::any(*postBodyDescription);
    }
    if (postBodyType) {
      res["PostBodyType"] = boost::any(*postBodyType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestBody) {
      res["RequestBody"] = requestBody ? boost::any(requestBody->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestHeaders) {
      res["RequestHeaders"] = requestHeaders ? boost::any(requestHeaders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestMode) {
      res["RequestMode"] = boost::any(*requestMode);
    }
    if (requestQueries) {
      res["RequestQueries"] = requestQueries ? boost::any(requestQueries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (serviceTimeout) {
      res["ServiceTimeout"] = boost::any(*serviceTimeout);
    }
    if (serviceVpcEnable) {
      res["ServiceVpcEnable"] = boost::any(*serviceVpcEnable);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("BodyFormat") != m.end() && !m["BodyFormat"].empty()) {
      bodyFormat = make_shared<string>(boost::any_cast<string>(m["BodyFormat"]));
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorCodeSamples"].type()) {
        DescribeApiDocResponseBodyErrorCodeSamples model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorCodeSamples"]));
        errorCodeSamples = make_shared<DescribeApiDocResponseBodyErrorCodeSamples>(model1);
      }
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("HttpProtocol") != m.end() && !m["HttpProtocol"].empty()) {
      httpProtocol = make_shared<string>(boost::any_cast<string>(m["HttpProtocol"]));
    }
    if (m.find("Mock") != m.end() && !m["Mock"].empty()) {
      mock = make_shared<string>(boost::any_cast<string>(m["Mock"]));
    }
    if (m.find("MockResult") != m.end() && !m["MockResult"].empty()) {
      mockResult = make_shared<string>(boost::any_cast<string>(m["MockResult"]));
    }
    if (m.find("OriginResultDescription") != m.end() && !m["OriginResultDescription"].empty()) {
      originResultDescription = make_shared<string>(boost::any_cast<string>(m["OriginResultDescription"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("PathParameters") != m.end() && !m["PathParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathParameters"].type()) {
        DescribeApiDocResponseBodyPathParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathParameters"]));
        pathParameters = make_shared<DescribeApiDocResponseBodyPathParameters>(model1);
      }
    }
    if (m.find("PostBodyDescription") != m.end() && !m["PostBodyDescription"].empty()) {
      postBodyDescription = make_shared<string>(boost::any_cast<string>(m["PostBodyDescription"]));
    }
    if (m.find("PostBodyType") != m.end() && !m["PostBodyType"].empty()) {
      postBodyType = make_shared<string>(boost::any_cast<string>(m["PostBodyType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestBody") != m.end() && !m["RequestBody"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestBody"].type()) {
        DescribeApiDocResponseBodyRequestBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestBody"]));
        requestBody = make_shared<DescribeApiDocResponseBodyRequestBody>(model1);
      }
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestHeaders"].type()) {
        DescribeApiDocResponseBodyRequestHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestHeaders"]));
        requestHeaders = make_shared<DescribeApiDocResponseBodyRequestHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestMode") != m.end() && !m["RequestMode"].empty()) {
      requestMode = make_shared<string>(boost::any_cast<string>(m["RequestMode"]));
    }
    if (m.find("RequestQueries") != m.end() && !m["RequestQueries"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestQueries"].type()) {
        DescribeApiDocResponseBodyRequestQueries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestQueries"]));
        requestQueries = make_shared<DescribeApiDocResponseBodyRequestQueries>(model1);
      }
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("ServiceTimeout") != m.end() && !m["ServiceTimeout"].empty()) {
      serviceTimeout = make_shared<long>(boost::any_cast<long>(m["ServiceTimeout"]));
    }
    if (m.find("ServiceVpcEnable") != m.end() && !m["ServiceVpcEnable"].empty()) {
      serviceVpcEnable = make_shared<string>(boost::any_cast<string>(m["ServiceVpcEnable"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
  }


  virtual ~DescribeApiDocResponseBody() = default;
};
class DescribeApiDocResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiDocResponseBody> body{};

  DescribeApiDocResponse() {}

  explicit DescribeApiDocResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiDocResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiDocResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiDocResponse() = default;
};
class DescribeApiDocsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiDocsRequest() {}

  explicit DescribeApiDocsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiDocsRequest() = default;
};
class DescribeApiDocsResponseBodyApiInfosApiInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupDescription{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};

  DescribeApiDocsResponseBodyApiInfosApiInfo() {}

  explicit DescribeApiDocsResponseBodyApiInfosApiInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupDescription) {
      res["GroupDescription"] = boost::any(*groupDescription);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupDescription") != m.end() && !m["GroupDescription"].empty()) {
      groupDescription = make_shared<string>(boost::any_cast<string>(m["GroupDescription"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiDocsResponseBodyApiInfosApiInfo() = default;
};
class DescribeApiDocsResponseBodyApiInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiDocsResponseBodyApiInfosApiInfo>> apiInfo{};

  DescribeApiDocsResponseBodyApiInfos() {}

  explicit DescribeApiDocsResponseBodyApiInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiInfo"].type()) {
        vector<DescribeApiDocsResponseBodyApiInfosApiInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiDocsResponseBodyApiInfosApiInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiInfo = make_shared<vector<DescribeApiDocsResponseBodyApiInfosApiInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApiDocsResponseBodyApiInfos() = default;
};
class DescribeApiDocsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiDocsResponseBodyApiInfos> apiInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApiDocsResponseBody() {}

  explicit DescribeApiDocsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfos) {
      res["ApiInfos"] = apiInfos ? boost::any(apiInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfos") != m.end() && !m["ApiInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInfos"].type()) {
        DescribeApiDocsResponseBodyApiInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInfos"]));
        apiInfos = make_shared<DescribeApiDocsResponseBodyApiInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApiDocsResponseBody() = default;
};
class DescribeApiDocsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiDocsResponseBody> body{};

  DescribeApiDocsResponse() {}

  explicit DescribeApiDocsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiDocsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiDocsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiDocsResponse() = default;
};
class DescribeApiErrorRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};

  DescribeApiErrorRequest() {}

  explicit DescribeApiErrorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeApiErrorRequest() = default;
};
class DescribeApiErrorResponseBodyClientErrorsClientError : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> value{};

  DescribeApiErrorResponseBodyClientErrorsClientError() {}

  explicit DescribeApiErrorResponseBodyClientErrorsClientError(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApiErrorResponseBodyClientErrorsClientError() = default;
};
class DescribeApiErrorResponseBodyClientErrors : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiErrorResponseBodyClientErrorsClientError>> clientError{};

  DescribeApiErrorResponseBodyClientErrors() {}

  explicit DescribeApiErrorResponseBodyClientErrors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientError) {
      vector<boost::any> temp1;
      for(auto item1:*clientError){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClientError"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientError") != m.end() && !m["ClientError"].empty()) {
      if (typeid(vector<boost::any>) == m["ClientError"].type()) {
        vector<DescribeApiErrorResponseBodyClientErrorsClientError> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClientError"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiErrorResponseBodyClientErrorsClientError model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clientError = make_shared<vector<DescribeApiErrorResponseBodyClientErrorsClientError>>(expect1);
      }
    }
  }


  virtual ~DescribeApiErrorResponseBodyClientErrors() = default;
};
class DescribeApiErrorResponseBodyServerErrorsServerError : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> value{};

  DescribeApiErrorResponseBodyServerErrorsServerError() {}

  explicit DescribeApiErrorResponseBodyServerErrorsServerError(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApiErrorResponseBodyServerErrorsServerError() = default;
};
class DescribeApiErrorResponseBodyServerErrors : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiErrorResponseBodyServerErrorsServerError>> serverError{};

  DescribeApiErrorResponseBodyServerErrors() {}

  explicit DescribeApiErrorResponseBodyServerErrors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serverError) {
      vector<boost::any> temp1;
      for(auto item1:*serverError){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServerError"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServerError") != m.end() && !m["ServerError"].empty()) {
      if (typeid(vector<boost::any>) == m["ServerError"].type()) {
        vector<DescribeApiErrorResponseBodyServerErrorsServerError> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServerError"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiErrorResponseBodyServerErrorsServerError model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serverError = make_shared<vector<DescribeApiErrorResponseBodyServerErrorsServerError>>(expect1);
      }
    }
  }


  virtual ~DescribeApiErrorResponseBodyServerErrors() = default;
};
class DescribeApiErrorResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiErrorResponseBodyClientErrors> clientErrors{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeApiErrorResponseBodyServerErrors> serverErrors{};

  DescribeApiErrorResponseBody() {}

  explicit DescribeApiErrorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientErrors) {
      res["ClientErrors"] = clientErrors ? boost::any(clientErrors->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (serverErrors) {
      res["ServerErrors"] = serverErrors ? boost::any(serverErrors->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientErrors") != m.end() && !m["ClientErrors"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClientErrors"].type()) {
        DescribeApiErrorResponseBodyClientErrors model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClientErrors"]));
        clientErrors = make_shared<DescribeApiErrorResponseBodyClientErrors>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ServerErrors") != m.end() && !m["ServerErrors"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServerErrors"].type()) {
        DescribeApiErrorResponseBodyServerErrors model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServerErrors"]));
        serverErrors = make_shared<DescribeApiErrorResponseBodyServerErrors>(model1);
      }
    }
  }


  virtual ~DescribeApiErrorResponseBody() = default;
};
class DescribeApiErrorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiErrorResponseBody> body{};

  DescribeApiErrorResponse() {}

  explicit DescribeApiErrorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiErrorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiErrorResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiErrorResponse() = default;
};
class DescribeApiGroupDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribeApiGroupDetailRequest() {}

  explicit DescribeApiGroupDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApiGroupDetailRequest() = default;
};
class DescribeApiGroupDetailResponseBodyDomainItemsDomainItem : public Darabonba::Model {
public:
  shared_ptr<string> certificateId{};
  shared_ptr<string> certificateName{};
  shared_ptr<string> domainBindingStatus{};
  shared_ptr<string> domainLegalStatus{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainNameResolution{};
  shared_ptr<string> domainRemark{};
  shared_ptr<string> domainWebSocketStatus{};

  DescribeApiGroupDetailResponseBodyDomainItemsDomainItem() {}

  explicit DescribeApiGroupDetailResponseBodyDomainItemsDomainItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (certificateName) {
      res["CertificateName"] = boost::any(*certificateName);
    }
    if (domainBindingStatus) {
      res["DomainBindingStatus"] = boost::any(*domainBindingStatus);
    }
    if (domainLegalStatus) {
      res["DomainLegalStatus"] = boost::any(*domainLegalStatus);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainNameResolution) {
      res["DomainNameResolution"] = boost::any(*domainNameResolution);
    }
    if (domainRemark) {
      res["DomainRemark"] = boost::any(*domainRemark);
    }
    if (domainWebSocketStatus) {
      res["DomainWebSocketStatus"] = boost::any(*domainWebSocketStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("CertificateName") != m.end() && !m["CertificateName"].empty()) {
      certificateName = make_shared<string>(boost::any_cast<string>(m["CertificateName"]));
    }
    if (m.find("DomainBindingStatus") != m.end() && !m["DomainBindingStatus"].empty()) {
      domainBindingStatus = make_shared<string>(boost::any_cast<string>(m["DomainBindingStatus"]));
    }
    if (m.find("DomainLegalStatus") != m.end() && !m["DomainLegalStatus"].empty()) {
      domainLegalStatus = make_shared<string>(boost::any_cast<string>(m["DomainLegalStatus"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainNameResolution") != m.end() && !m["DomainNameResolution"].empty()) {
      domainNameResolution = make_shared<string>(boost::any_cast<string>(m["DomainNameResolution"]));
    }
    if (m.find("DomainRemark") != m.end() && !m["DomainRemark"].empty()) {
      domainRemark = make_shared<string>(boost::any_cast<string>(m["DomainRemark"]));
    }
    if (m.find("DomainWebSocketStatus") != m.end() && !m["DomainWebSocketStatus"].empty()) {
      domainWebSocketStatus = make_shared<string>(boost::any_cast<string>(m["DomainWebSocketStatus"]));
    }
  }


  virtual ~DescribeApiGroupDetailResponseBodyDomainItemsDomainItem() = default;
};
class DescribeApiGroupDetailResponseBodyDomainItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiGroupDetailResponseBodyDomainItemsDomainItem>> domainItem{};

  DescribeApiGroupDetailResponseBodyDomainItems() {}

  explicit DescribeApiGroupDetailResponseBodyDomainItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainItem) {
      vector<boost::any> temp1;
      for(auto item1:*domainItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainItem") != m.end() && !m["DomainItem"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainItem"].type()) {
        vector<DescribeApiGroupDetailResponseBodyDomainItemsDomainItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiGroupDetailResponseBodyDomainItemsDomainItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainItem = make_shared<vector<DescribeApiGroupDetailResponseBodyDomainItemsDomainItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiGroupDetailResponseBodyDomainItems() = default;
};
class DescribeApiGroupDetailResponseBodyStageItemsStageInfo : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};

  DescribeApiGroupDetailResponseBodyStageItemsStageInfo() {}

  explicit DescribeApiGroupDetailResponseBodyStageItemsStageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiGroupDetailResponseBodyStageItemsStageInfo() = default;
};
class DescribeApiGroupDetailResponseBodyStageItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiGroupDetailResponseBodyStageItemsStageInfo>> stageInfo{};

  DescribeApiGroupDetailResponseBodyStageItems() {}

  explicit DescribeApiGroupDetailResponseBodyStageItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stageInfo) {
      vector<boost::any> temp1;
      for(auto item1:*stageInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StageInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StageInfo") != m.end() && !m["StageInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["StageInfo"].type()) {
        vector<DescribeApiGroupDetailResponseBodyStageItemsStageInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StageInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiGroupDetailResponseBodyStageItemsStageInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stageInfo = make_shared<vector<DescribeApiGroupDetailResponseBodyStageItemsStageInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApiGroupDetailResponseBodyStageItems() = default;
};
class DescribeApiGroupDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> billingStatus{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<DescribeApiGroupDetailResponseBodyDomainItems> domainItems{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> illegalStatus{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeApiGroupDetailResponseBodyStageItems> stageItems{};
  shared_ptr<string> status{};
  shared_ptr<string> subDomain{};
  shared_ptr<long> trafficLimit{};

  DescribeApiGroupDetailResponseBody() {}

  explicit DescribeApiGroupDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billingStatus) {
      res["BillingStatus"] = boost::any(*billingStatus);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainItems) {
      res["DomainItems"] = domainItems ? boost::any(domainItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (illegalStatus) {
      res["IllegalStatus"] = boost::any(*illegalStatus);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (stageItems) {
      res["StageItems"] = stageItems ? boost::any(stageItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (trafficLimit) {
      res["TrafficLimit"] = boost::any(*trafficLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillingStatus") != m.end() && !m["BillingStatus"].empty()) {
      billingStatus = make_shared<string>(boost::any_cast<string>(m["BillingStatus"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainItems") != m.end() && !m["DomainItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainItems"].type()) {
        DescribeApiGroupDetailResponseBodyDomainItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainItems"]));
        domainItems = make_shared<DescribeApiGroupDetailResponseBodyDomainItems>(model1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IllegalStatus") != m.end() && !m["IllegalStatus"].empty()) {
      illegalStatus = make_shared<string>(boost::any_cast<string>(m["IllegalStatus"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StageItems") != m.end() && !m["StageItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["StageItems"].type()) {
        DescribeApiGroupDetailResponseBodyStageItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StageItems"]));
        stageItems = make_shared<DescribeApiGroupDetailResponseBodyStageItems>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("TrafficLimit") != m.end() && !m["TrafficLimit"].empty()) {
      trafficLimit = make_shared<long>(boost::any_cast<long>(m["TrafficLimit"]));
    }
  }


  virtual ~DescribeApiGroupDetailResponseBody() = default;
};
class DescribeApiGroupDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiGroupDetailResponseBody> body{};

  DescribeApiGroupDetailResponse() {}

  explicit DescribeApiGroupDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiGroupDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiGroupDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiGroupDetailResponse() = default;
};
class DescribeApiGroupDetailForConsumerRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiGroupDetailForConsumerRequest() {}

  explicit DescribeApiGroupDetailForConsumerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiGroupDetailForConsumerRequest() = default;
};
class DescribeApiGroupDetailForConsumerResponseBodyDomainItemsDomainItem : public Darabonba::Model {
public:
  shared_ptr<string> certificateId{};
  shared_ptr<string> certificateName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainNameResolution{};
  shared_ptr<string> domainStatus{};

  DescribeApiGroupDetailForConsumerResponseBodyDomainItemsDomainItem() {}

  explicit DescribeApiGroupDetailForConsumerResponseBodyDomainItemsDomainItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (certificateName) {
      res["CertificateName"] = boost::any(*certificateName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainNameResolution) {
      res["DomainNameResolution"] = boost::any(*domainNameResolution);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("CertificateName") != m.end() && !m["CertificateName"].empty()) {
      certificateName = make_shared<string>(boost::any_cast<string>(m["CertificateName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainNameResolution") != m.end() && !m["DomainNameResolution"].empty()) {
      domainNameResolution = make_shared<string>(boost::any_cast<string>(m["DomainNameResolution"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
  }


  virtual ~DescribeApiGroupDetailForConsumerResponseBodyDomainItemsDomainItem() = default;
};
class DescribeApiGroupDetailForConsumerResponseBodyDomainItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiGroupDetailForConsumerResponseBodyDomainItemsDomainItem>> domainItem{};

  DescribeApiGroupDetailForConsumerResponseBodyDomainItems() {}

  explicit DescribeApiGroupDetailForConsumerResponseBodyDomainItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainItem) {
      vector<boost::any> temp1;
      for(auto item1:*domainItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainItem") != m.end() && !m["DomainItem"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainItem"].type()) {
        vector<DescribeApiGroupDetailForConsumerResponseBodyDomainItemsDomainItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiGroupDetailForConsumerResponseBodyDomainItemsDomainItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainItem = make_shared<vector<DescribeApiGroupDetailForConsumerResponseBodyDomainItemsDomainItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiGroupDetailForConsumerResponseBodyDomainItems() = default;
};
class DescribeApiGroupDetailForConsumerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> billingStatus{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<DescribeApiGroupDetailForConsumerResponseBodyDomainItems> domainItems{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> illegalStatus{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> purchased{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<string> subDomain{};
  shared_ptr<long> trafficLimit{};

  DescribeApiGroupDetailForConsumerResponseBody() {}

  explicit DescribeApiGroupDetailForConsumerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billingStatus) {
      res["BillingStatus"] = boost::any(*billingStatus);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainItems) {
      res["DomainItems"] = domainItems ? boost::any(domainItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (illegalStatus) {
      res["IllegalStatus"] = boost::any(*illegalStatus);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (purchased) {
      res["Purchased"] = boost::any(*purchased);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (trafficLimit) {
      res["TrafficLimit"] = boost::any(*trafficLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillingStatus") != m.end() && !m["BillingStatus"].empty()) {
      billingStatus = make_shared<string>(boost::any_cast<string>(m["BillingStatus"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainItems") != m.end() && !m["DomainItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainItems"].type()) {
        DescribeApiGroupDetailForConsumerResponseBodyDomainItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainItems"]));
        domainItems = make_shared<DescribeApiGroupDetailForConsumerResponseBodyDomainItems>(model1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IllegalStatus") != m.end() && !m["IllegalStatus"].empty()) {
      illegalStatus = make_shared<string>(boost::any_cast<string>(m["IllegalStatus"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Purchased") != m.end() && !m["Purchased"].empty()) {
      purchased = make_shared<string>(boost::any_cast<string>(m["Purchased"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("TrafficLimit") != m.end() && !m["TrafficLimit"].empty()) {
      trafficLimit = make_shared<long>(boost::any_cast<long>(m["TrafficLimit"]));
    }
  }


  virtual ~DescribeApiGroupDetailForConsumerResponseBody() = default;
};
class DescribeApiGroupDetailForConsumerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiGroupDetailForConsumerResponseBody> body{};

  DescribeApiGroupDetailForConsumerResponse() {}

  explicit DescribeApiGroupDetailForConsumerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiGroupDetailForConsumerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiGroupDetailForConsumerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiGroupDetailForConsumerResponse() = default;
};
class DescribeApiGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeApiGroupsRequest() {}

  explicit DescribeApiGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApiGroupsRequest() = default;
};
class DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute : public Darabonba::Model {
public:
  shared_ptr<string> billingStatus{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> illegalStatus{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subDomain{};
  shared_ptr<long> trafficLimit{};

  DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute() {}

  explicit DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billingStatus) {
      res["BillingStatus"] = boost::any(*billingStatus);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (illegalStatus) {
      res["IllegalStatus"] = boost::any(*illegalStatus);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (trafficLimit) {
      res["TrafficLimit"] = boost::any(*trafficLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillingStatus") != m.end() && !m["BillingStatus"].empty()) {
      billingStatus = make_shared<string>(boost::any_cast<string>(m["BillingStatus"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IllegalStatus") != m.end() && !m["IllegalStatus"].empty()) {
      illegalStatus = make_shared<string>(boost::any_cast<string>(m["IllegalStatus"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("TrafficLimit") != m.end() && !m["TrafficLimit"].empty()) {
      trafficLimit = make_shared<long>(boost::any_cast<long>(m["TrafficLimit"]));
    }
  }


  virtual ~DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute() = default;
};
class DescribeApiGroupsResponseBodyApiGroupAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute>> apiGroupAttribute{};

  DescribeApiGroupsResponseBodyApiGroupAttributes() {}

  explicit DescribeApiGroupsResponseBodyApiGroupAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiGroupAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*apiGroupAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiGroupAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiGroupAttribute") != m.end() && !m["ApiGroupAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiGroupAttribute"].type()) {
        vector<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiGroupAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiGroupAttribute = make_shared<vector<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeApiGroupsResponseBodyApiGroupAttributes() = default;
};
class DescribeApiGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiGroupsResponseBodyApiGroupAttributes> apiGroupAttributes{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApiGroupsResponseBody() {}

  explicit DescribeApiGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiGroupAttributes) {
      res["ApiGroupAttributes"] = apiGroupAttributes ? boost::any(apiGroupAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiGroupAttributes") != m.end() && !m["ApiGroupAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiGroupAttributes"].type()) {
        DescribeApiGroupsResponseBodyApiGroupAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiGroupAttributes"]));
        apiGroupAttributes = make_shared<DescribeApiGroupsResponseBodyApiGroupAttributes>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApiGroupsResponseBody() = default;
};
class DescribeApiGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiGroupsResponseBody> body{};

  DescribeApiGroupsResponse() {}

  explicit DescribeApiGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiGroupsResponse() = default;
};
class DescribeApiIpControlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiIpControlsRequest() {}

  explicit DescribeApiIpControlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiIpControlsRequest() = default;
};
class DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> boundTime{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> ipControlName{};

  DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem() {}

  explicit DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (ipControlName) {
      res["IpControlName"] = boost::any(*ipControlName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("IpControlName") != m.end() && !m["IpControlName"].empty()) {
      ipControlName = make_shared<string>(boost::any_cast<string>(m["IpControlName"]));
    }
  }


  virtual ~DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem() = default;
};
class DescribeApiIpControlsResponseBodyApiIpControls : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem>> apiIpControlItem{};

  DescribeApiIpControlsResponseBodyApiIpControls() {}

  explicit DescribeApiIpControlsResponseBodyApiIpControls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIpControlItem) {
      vector<boost::any> temp1;
      for(auto item1:*apiIpControlItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiIpControlItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIpControlItem") != m.end() && !m["ApiIpControlItem"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiIpControlItem"].type()) {
        vector<DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiIpControlItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiIpControlItem = make_shared<vector<DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiIpControlsResponseBodyApiIpControls() = default;
};
class DescribeApiIpControlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiIpControlsResponseBodyApiIpControls> apiIpControls{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApiIpControlsResponseBody() {}

  explicit DescribeApiIpControlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIpControls) {
      res["ApiIpControls"] = apiIpControls ? boost::any(apiIpControls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIpControls") != m.end() && !m["ApiIpControls"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiIpControls"].type()) {
        DescribeApiIpControlsResponseBodyApiIpControls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiIpControls"]));
        apiIpControls = make_shared<DescribeApiIpControlsResponseBodyApiIpControls>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApiIpControlsResponseBody() = default;
};
class DescribeApiIpControlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiIpControlsResponseBody> body{};

  DescribeApiIpControlsResponse() {}

  explicit DescribeApiIpControlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiIpControlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiIpControlsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiIpControlsResponse() = default;
};
class DescribeApiLatencyRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};

  DescribeApiLatencyRequest() {}

  explicit DescribeApiLatencyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeApiLatencyRequest() = default;
};
class DescribeApiLatencyResponseBodyLatencysLatency : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> value{};

  DescribeApiLatencyResponseBodyLatencysLatency() {}

  explicit DescribeApiLatencyResponseBodyLatencysLatency(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApiLatencyResponseBodyLatencysLatency() = default;
};
class DescribeApiLatencyResponseBodyLatencys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiLatencyResponseBodyLatencysLatency>> latency{};

  DescribeApiLatencyResponseBodyLatencys() {}

  explicit DescribeApiLatencyResponseBodyLatencys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (latency) {
      vector<boost::any> temp1;
      for(auto item1:*latency){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Latency"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Latency") != m.end() && !m["Latency"].empty()) {
      if (typeid(vector<boost::any>) == m["Latency"].type()) {
        vector<DescribeApiLatencyResponseBodyLatencysLatency> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Latency"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiLatencyResponseBodyLatencysLatency model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        latency = make_shared<vector<DescribeApiLatencyResponseBodyLatencysLatency>>(expect1);
      }
    }
  }


  virtual ~DescribeApiLatencyResponseBodyLatencys() = default;
};
class DescribeApiLatencyResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiLatencyResponseBodyLatencys> latencys{};
  shared_ptr<string> requestId{};

  DescribeApiLatencyResponseBody() {}

  explicit DescribeApiLatencyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (latencys) {
      res["Latencys"] = latencys ? boost::any(latencys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Latencys") != m.end() && !m["Latencys"].empty()) {
      if (typeid(map<string, boost::any>) == m["Latencys"].type()) {
        DescribeApiLatencyResponseBodyLatencys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Latencys"]));
        latencys = make_shared<DescribeApiLatencyResponseBodyLatencys>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApiLatencyResponseBody() = default;
};
class DescribeApiLatencyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiLatencyResponseBody> body{};

  DescribeApiLatencyResponse() {}

  explicit DescribeApiLatencyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiLatencyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiLatencyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiLatencyResponse() = default;
};
class DescribeApiQpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};

  DescribeApiQpsRequest() {}

  explicit DescribeApiQpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeApiQpsRequest() = default;
};
class DescribeApiQpsResponseBodyFailsFail : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> value{};

  DescribeApiQpsResponseBodyFailsFail() {}

  explicit DescribeApiQpsResponseBodyFailsFail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApiQpsResponseBodyFailsFail() = default;
};
class DescribeApiQpsResponseBodyFails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiQpsResponseBodyFailsFail>> fail{};

  DescribeApiQpsResponseBodyFails() {}

  explicit DescribeApiQpsResponseBodyFails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fail) {
      vector<boost::any> temp1;
      for(auto item1:*fail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Fail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fail") != m.end() && !m["Fail"].empty()) {
      if (typeid(vector<boost::any>) == m["Fail"].type()) {
        vector<DescribeApiQpsResponseBodyFailsFail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Fail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiQpsResponseBodyFailsFail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fail = make_shared<vector<DescribeApiQpsResponseBodyFailsFail>>(expect1);
      }
    }
  }


  virtual ~DescribeApiQpsResponseBodyFails() = default;
};
class DescribeApiQpsResponseBodySuccessesSuccess : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> value{};

  DescribeApiQpsResponseBodySuccessesSuccess() {}

  explicit DescribeApiQpsResponseBodySuccessesSuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApiQpsResponseBodySuccessesSuccess() = default;
};
class DescribeApiQpsResponseBodySuccesses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiQpsResponseBodySuccessesSuccess>> success{};

  DescribeApiQpsResponseBodySuccesses() {}

  explicit DescribeApiQpsResponseBodySuccesses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (success) {
      vector<boost::any> temp1;
      for(auto item1:*success){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Success"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      if (typeid(vector<boost::any>) == m["Success"].type()) {
        vector<DescribeApiQpsResponseBodySuccessesSuccess> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Success"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiQpsResponseBodySuccessesSuccess model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        success = make_shared<vector<DescribeApiQpsResponseBodySuccessesSuccess>>(expect1);
      }
    }
  }


  virtual ~DescribeApiQpsResponseBodySuccesses() = default;
};
class DescribeApiQpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiQpsResponseBodyFails> fails{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeApiQpsResponseBodySuccesses> successes{};

  DescribeApiQpsResponseBody() {}

  explicit DescribeApiQpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fails) {
      res["Fails"] = fails ? boost::any(fails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successes) {
      res["Successes"] = successes ? boost::any(successes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Fails") != m.end() && !m["Fails"].empty()) {
      if (typeid(map<string, boost::any>) == m["Fails"].type()) {
        DescribeApiQpsResponseBodyFails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Fails"]));
        fails = make_shared<DescribeApiQpsResponseBodyFails>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Successes") != m.end() && !m["Successes"].empty()) {
      if (typeid(map<string, boost::any>) == m["Successes"].type()) {
        DescribeApiQpsResponseBodySuccesses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Successes"]));
        successes = make_shared<DescribeApiQpsResponseBodySuccesses>(model1);
      }
    }
  }


  virtual ~DescribeApiQpsResponseBody() = default;
};
class DescribeApiQpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiQpsResponseBody> body{};

  DescribeApiQpsResponse() {}

  explicit DescribeApiQpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiQpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiQpsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiQpsResponse() = default;
};
class DescribeApiRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ruleType{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiRulesRequest() {}

  explicit DescribeApiRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiRulesRequest() = default;
};
class DescribeApiRulesResponseBodyApiRulesApiRule : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleType{};

  DescribeApiRulesResponseBodyApiRulesApiRule() {}

  explicit DescribeApiRulesResponseBodyApiRulesApiRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
  }


  virtual ~DescribeApiRulesResponseBodyApiRulesApiRule() = default;
};
class DescribeApiRulesResponseBodyApiRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiRulesResponseBodyApiRulesApiRule>> apiRule{};

  DescribeApiRulesResponseBodyApiRules() {}

  explicit DescribeApiRulesResponseBodyApiRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiRule) {
      vector<boost::any> temp1;
      for(auto item1:*apiRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiRule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiRule") != m.end() && !m["ApiRule"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiRule"].type()) {
        vector<DescribeApiRulesResponseBodyApiRulesApiRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiRulesResponseBodyApiRulesApiRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiRule = make_shared<vector<DescribeApiRulesResponseBodyApiRulesApiRule>>(expect1);
      }
    }
  }


  virtual ~DescribeApiRulesResponseBodyApiRules() = default;
};
class DescribeApiRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiRulesResponseBodyApiRules> apiRules{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApiRulesResponseBody() {}

  explicit DescribeApiRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiRules) {
      res["ApiRules"] = apiRules ? boost::any(apiRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiRules") != m.end() && !m["ApiRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiRules"].type()) {
        DescribeApiRulesResponseBodyApiRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiRules"]));
        apiRules = make_shared<DescribeApiRulesResponseBodyApiRules>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApiRulesResponseBody() = default;
};
class DescribeApiRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiRulesResponseBody> body{};

  DescribeApiRulesResponse() {}

  explicit DescribeApiRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiRulesResponse() = default;
};
class DescribeApiStageDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageId{};

  DescribeApiStageDetailRequest() {}

  explicit DescribeApiStageDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
  }


  virtual ~DescribeApiStageDetailRequest() = default;
};
class DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModelRouteRulesRouteRuleItem : public Darabonba::Model {
public:
  shared_ptr<string> conditionValue{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minValue{};
  shared_ptr<string> resultValue{};

  DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModelRouteRulesRouteRuleItem() {}

  explicit DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModelRouteRulesRouteRuleItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionValue) {
      res["ConditionValue"] = boost::any(*conditionValue);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (resultValue) {
      res["ResultValue"] = boost::any(*resultValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionValue") != m.end() && !m["ConditionValue"].empty()) {
      conditionValue = make_shared<string>(boost::any_cast<string>(m["ConditionValue"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ResultValue") != m.end() && !m["ResultValue"].empty()) {
      resultValue = make_shared<string>(boost::any_cast<string>(m["ResultValue"]));
    }
  }


  virtual ~DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModelRouteRulesRouteRuleItem() = default;
};
class DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModelRouteRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModelRouteRulesRouteRuleItem>> routeRuleItem{};

  DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModelRouteRules() {}

  explicit DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModelRouteRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeRuleItem) {
      vector<boost::any> temp1;
      for(auto item1:*routeRuleItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RouteRuleItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteRuleItem") != m.end() && !m["RouteRuleItem"].empty()) {
      if (typeid(vector<boost::any>) == m["RouteRuleItem"].type()) {
        vector<DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModelRouteRulesRouteRuleItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RouteRuleItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModelRouteRulesRouteRuleItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeRuleItem = make_shared<vector<DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModelRouteRulesRouteRuleItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModelRouteRules() = default;
};
class DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModel : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> parameterCatalog{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> routeMatchSymbol{};
  shared_ptr<DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModelRouteRules> routeRules{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModel() {}

  explicit DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterCatalog) {
      res["ParameterCatalog"] = boost::any(*parameterCatalog);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (routeMatchSymbol) {
      res["RouteMatchSymbol"] = boost::any(*routeMatchSymbol);
    }
    if (routeRules) {
      res["RouteRules"] = routeRules ? boost::any(routeRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterCatalog") != m.end() && !m["ParameterCatalog"].empty()) {
      parameterCatalog = make_shared<string>(boost::any_cast<string>(m["ParameterCatalog"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RouteMatchSymbol") != m.end() && !m["RouteMatchSymbol"].empty()) {
      routeMatchSymbol = make_shared<string>(boost::any_cast<string>(m["RouteMatchSymbol"]));
    }
    if (m.find("RouteRules") != m.end() && !m["RouteRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["RouteRules"].type()) {
        DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModelRouteRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RouteRules"]));
        routeRules = make_shared<DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModelRouteRules>(model1);
      }
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModel() = default;
};
class DescribeApiStageDetailResponseBodyVariablesVariableItem : public Darabonba::Model {
public:
  shared_ptr<DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModel> stageRouteModel{};
  shared_ptr<bool> supportRoute{};
  shared_ptr<string> variableName{};
  shared_ptr<string> variableValue{};

  DescribeApiStageDetailResponseBodyVariablesVariableItem() {}

  explicit DescribeApiStageDetailResponseBodyVariablesVariableItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stageRouteModel) {
      res["StageRouteModel"] = stageRouteModel ? boost::any(stageRouteModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (supportRoute) {
      res["SupportRoute"] = boost::any(*supportRoute);
    }
    if (variableName) {
      res["VariableName"] = boost::any(*variableName);
    }
    if (variableValue) {
      res["VariableValue"] = boost::any(*variableValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StageRouteModel") != m.end() && !m["StageRouteModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["StageRouteModel"].type()) {
        DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StageRouteModel"]));
        stageRouteModel = make_shared<DescribeApiStageDetailResponseBodyVariablesVariableItemStageRouteModel>(model1);
      }
    }
    if (m.find("SupportRoute") != m.end() && !m["SupportRoute"].empty()) {
      supportRoute = make_shared<bool>(boost::any_cast<bool>(m["SupportRoute"]));
    }
    if (m.find("VariableName") != m.end() && !m["VariableName"].empty()) {
      variableName = make_shared<string>(boost::any_cast<string>(m["VariableName"]));
    }
    if (m.find("VariableValue") != m.end() && !m["VariableValue"].empty()) {
      variableValue = make_shared<string>(boost::any_cast<string>(m["VariableValue"]));
    }
  }


  virtual ~DescribeApiStageDetailResponseBodyVariablesVariableItem() = default;
};
class DescribeApiStageDetailResponseBodyVariables : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiStageDetailResponseBodyVariablesVariableItem>> variableItem{};

  DescribeApiStageDetailResponseBodyVariables() {}

  explicit DescribeApiStageDetailResponseBodyVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (variableItem) {
      vector<boost::any> temp1;
      for(auto item1:*variableItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VariableItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VariableItem") != m.end() && !m["VariableItem"].empty()) {
      if (typeid(vector<boost::any>) == m["VariableItem"].type()) {
        vector<DescribeApiStageDetailResponseBodyVariablesVariableItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VariableItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiStageDetailResponseBodyVariablesVariableItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variableItem = make_shared<vector<DescribeApiStageDetailResponseBodyVariablesVariableItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiStageDetailResponseBodyVariables() = default;
};
class DescribeApiStageDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};
  shared_ptr<DescribeApiStageDetailResponseBodyVariables> variables{};

  DescribeApiStageDetailResponseBody() {}

  explicit DescribeApiStageDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (variables) {
      res["Variables"] = variables ? boost::any(variables->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(map<string, boost::any>) == m["Variables"].type()) {
        DescribeApiStageDetailResponseBodyVariables model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Variables"]));
        variables = make_shared<DescribeApiStageDetailResponseBodyVariables>(model1);
      }
    }
  }


  virtual ~DescribeApiStageDetailResponseBody() = default;
};
class DescribeApiStageDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiStageDetailResponseBody> body{};

  DescribeApiStageDetailResponse() {}

  explicit DescribeApiStageDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiStageDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiStageDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiStageDetailResponse() = default;
};
class DescribeApiTrafficRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};

  DescribeApiTrafficRequest() {}

  explicit DescribeApiTrafficRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeApiTrafficRequest() = default;
};
class DescribeApiTrafficResponseBodyDownloadsDownload : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> value{};

  DescribeApiTrafficResponseBodyDownloadsDownload() {}

  explicit DescribeApiTrafficResponseBodyDownloadsDownload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApiTrafficResponseBodyDownloadsDownload() = default;
};
class DescribeApiTrafficResponseBodyDownloads : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiTrafficResponseBodyDownloadsDownload>> download{};

  DescribeApiTrafficResponseBodyDownloads() {}

  explicit DescribeApiTrafficResponseBodyDownloads(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (download) {
      vector<boost::any> temp1;
      for(auto item1:*download){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Download"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Download") != m.end() && !m["Download"].empty()) {
      if (typeid(vector<boost::any>) == m["Download"].type()) {
        vector<DescribeApiTrafficResponseBodyDownloadsDownload> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Download"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiTrafficResponseBodyDownloadsDownload model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        download = make_shared<vector<DescribeApiTrafficResponseBodyDownloadsDownload>>(expect1);
      }
    }
  }


  virtual ~DescribeApiTrafficResponseBodyDownloads() = default;
};
class DescribeApiTrafficResponseBodyUploadsUpload : public Darabonba::Model {
public:
  shared_ptr<string> time{};
  shared_ptr<string> value{};

  DescribeApiTrafficResponseBodyUploadsUpload() {}

  explicit DescribeApiTrafficResponseBodyUploadsUpload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApiTrafficResponseBodyUploadsUpload() = default;
};
class DescribeApiTrafficResponseBodyUploads : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiTrafficResponseBodyUploadsUpload>> upload{};

  DescribeApiTrafficResponseBodyUploads() {}

  explicit DescribeApiTrafficResponseBodyUploads(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (upload) {
      vector<boost::any> temp1;
      for(auto item1:*upload){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Upload"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Upload") != m.end() && !m["Upload"].empty()) {
      if (typeid(vector<boost::any>) == m["Upload"].type()) {
        vector<DescribeApiTrafficResponseBodyUploadsUpload> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Upload"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiTrafficResponseBodyUploadsUpload model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        upload = make_shared<vector<DescribeApiTrafficResponseBodyUploadsUpload>>(expect1);
      }
    }
  }


  virtual ~DescribeApiTrafficResponseBodyUploads() = default;
};
class DescribeApiTrafficResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiTrafficResponseBodyDownloads> downloads{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeApiTrafficResponseBodyUploads> uploads{};

  DescribeApiTrafficResponseBody() {}

  explicit DescribeApiTrafficResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloads) {
      res["Downloads"] = downloads ? boost::any(downloads->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploads) {
      res["Uploads"] = uploads ? boost::any(uploads->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Downloads") != m.end() && !m["Downloads"].empty()) {
      if (typeid(map<string, boost::any>) == m["Downloads"].type()) {
        DescribeApiTrafficResponseBodyDownloads model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Downloads"]));
        downloads = make_shared<DescribeApiTrafficResponseBodyDownloads>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Uploads") != m.end() && !m["Uploads"].empty()) {
      if (typeid(map<string, boost::any>) == m["Uploads"].type()) {
        DescribeApiTrafficResponseBodyUploads model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Uploads"]));
        uploads = make_shared<DescribeApiTrafficResponseBodyUploads>(model1);
      }
    }
  }


  virtual ~DescribeApiTrafficResponseBody() = default;
};
class DescribeApiTrafficResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiTrafficResponseBody> body{};

  DescribeApiTrafficResponse() {}

  explicit DescribeApiTrafficResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiTrafficResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiTrafficResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiTrafficResponse() = default;
};
class DescribeApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> visibility{};

  DescribeApisRequest() {}

  explicit DescribeApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApisRequest() = default;
};
class DescribeApisResponseBodyApiInfosApiInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> visibility{};

  DescribeApisResponseBodyApiInfosApiInfo() {}

  explicit DescribeApisResponseBodyApiInfosApiInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApisResponseBodyApiInfosApiInfo() = default;
};
class DescribeApisResponseBodyApiInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisResponseBodyApiInfosApiInfo>> apiInfo{};

  DescribeApisResponseBodyApiInfos() {}

  explicit DescribeApisResponseBodyApiInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiInfo"].type()) {
        vector<DescribeApisResponseBodyApiInfosApiInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisResponseBodyApiInfosApiInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiInfo = make_shared<vector<DescribeApisResponseBodyApiInfosApiInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisResponseBodyApiInfos() = default;
};
class DescribeApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisResponseBodyApiInfos> apiInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisResponseBody() {}

  explicit DescribeApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfos) {
      res["ApiInfos"] = apiInfos ? boost::any(apiInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfos") != m.end() && !m["ApiInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInfos"].type()) {
        DescribeApisResponseBodyApiInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInfos"]));
        apiInfos = make_shared<DescribeApisResponseBodyApiInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisResponseBody() = default;
};
class DescribeApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisResponseBody> body{};

  DescribeApisResponse() {}

  explicit DescribeApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisResponse() = default;
};
class DescribeApisByAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeApisByAppRequest() {}

  explicit DescribeApisByAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApisByAppRequest() = default;
};
class DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> authorizationSource{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> operator_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};

  DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo() {}

  explicit DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (authorizationSource) {
      res["AuthorizationSource"] = boost::any(*authorizationSource);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AuthorizationSource") != m.end() && !m["AuthorizationSource"].empty()) {
      authorizationSource = make_shared<string>(boost::any_cast<string>(m["AuthorizationSource"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo() = default;
};
class DescribeApisByAppResponseBodyAppApiRelationInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo>> appApiRelationInfo{};

  DescribeApisByAppResponseBodyAppApiRelationInfos() {}

  explicit DescribeApisByAppResponseBodyAppApiRelationInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appApiRelationInfo) {
      vector<boost::any> temp1;
      for(auto item1:*appApiRelationInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppApiRelationInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppApiRelationInfo") != m.end() && !m["AppApiRelationInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["AppApiRelationInfo"].type()) {
        vector<DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppApiRelationInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appApiRelationInfo = make_shared<vector<DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisByAppResponseBodyAppApiRelationInfos() = default;
};
class DescribeApisByAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisByAppResponseBodyAppApiRelationInfos> appApiRelationInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisByAppResponseBody() {}

  explicit DescribeApisByAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appApiRelationInfos) {
      res["AppApiRelationInfos"] = appApiRelationInfos ? boost::any(appApiRelationInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppApiRelationInfos") != m.end() && !m["AppApiRelationInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppApiRelationInfos"].type()) {
        DescribeApisByAppResponseBodyAppApiRelationInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppApiRelationInfos"]));
        appApiRelationInfos = make_shared<DescribeApisByAppResponseBodyAppApiRelationInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisByAppResponseBody() = default;
};
class DescribeApisByAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisByAppResponseBody> body{};

  DescribeApisByAppResponse() {}

  explicit DescribeApisByAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisByAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisByAppResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisByAppResponse() = default;
};
class DescribeApisByIpControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeApisByIpControlRequest() {}

  explicit DescribeApisByIpControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApisByIpControlRequest() = default;
};
class DescribeApisByIpControlResponseBodyApiInfosApiInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> boundTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribeApisByIpControlResponseBodyApiInfosApiInfo() {}

  explicit DescribeApisByIpControlResponseBodyApiInfosApiInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApisByIpControlResponseBodyApiInfosApiInfo() = default;
};
class DescribeApisByIpControlResponseBodyApiInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisByIpControlResponseBodyApiInfosApiInfo>> apiInfo{};

  DescribeApisByIpControlResponseBodyApiInfos() {}

  explicit DescribeApisByIpControlResponseBodyApiInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiInfo"].type()) {
        vector<DescribeApisByIpControlResponseBodyApiInfosApiInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisByIpControlResponseBodyApiInfosApiInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiInfo = make_shared<vector<DescribeApisByIpControlResponseBodyApiInfosApiInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisByIpControlResponseBodyApiInfos() = default;
};
class DescribeApisByIpControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisByIpControlResponseBodyApiInfos> apiInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisByIpControlResponseBody() {}

  explicit DescribeApisByIpControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfos) {
      res["ApiInfos"] = apiInfos ? boost::any(apiInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfos") != m.end() && !m["ApiInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInfos"].type()) {
        DescribeApisByIpControlResponseBodyApiInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInfos"]));
        apiInfos = make_shared<DescribeApisByIpControlResponseBodyApiInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisByIpControlResponseBody() = default;
};
class DescribeApisByIpControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisByIpControlResponseBody> body{};

  DescribeApisByIpControlResponse() {}

  explicit DescribeApisByIpControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisByIpControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisByIpControlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisByIpControlResponse() = default;
};
class DescribeApisByRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleType{};
  shared_ptr<string> securityToken{};

  DescribeApisByRuleRequest() {}

  explicit DescribeApisByRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApisByRuleRequest() = default;
};
class DescribeApisByRuleResponseBodyApiInfosApiInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribeApisByRuleResponseBodyApiInfosApiInfo() {}

  explicit DescribeApisByRuleResponseBodyApiInfosApiInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApisByRuleResponseBodyApiInfosApiInfo() = default;
};
class DescribeApisByRuleResponseBodyApiInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisByRuleResponseBodyApiInfosApiInfo>> apiInfo{};

  DescribeApisByRuleResponseBodyApiInfos() {}

  explicit DescribeApisByRuleResponseBodyApiInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiInfo"].type()) {
        vector<DescribeApisByRuleResponseBodyApiInfosApiInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisByRuleResponseBodyApiInfosApiInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiInfo = make_shared<vector<DescribeApisByRuleResponseBodyApiInfosApiInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisByRuleResponseBodyApiInfos() = default;
};
class DescribeApisByRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisByRuleResponseBodyApiInfos> apiInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisByRuleResponseBody() {}

  explicit DescribeApisByRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfos) {
      res["ApiInfos"] = apiInfos ? boost::any(apiInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfos") != m.end() && !m["ApiInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInfos"].type()) {
        DescribeApisByRuleResponseBodyApiInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInfos"]));
        apiInfos = make_shared<DescribeApisByRuleResponseBodyApiInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisByRuleResponseBody() = default;
};
class DescribeApisByRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisByRuleResponseBody> body{};

  DescribeApisByRuleResponse() {}

  explicit DescribeApisByRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisByRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisByRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisByRuleResponse() = default;
};
class DescribeApisForConsoleRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribeApisForConsoleRequest() {}

  explicit DescribeApisForConsoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApisForConsoleRequest() = default;
};
class DescribeApisForConsoleResponseBodyApiInfosApiInfoDeployedInfosDeployedInfo : public Darabonba::Model {
public:
  shared_ptr<string> deployedStatus{};
  shared_ptr<string> effectiveVersion{};
  shared_ptr<string> stageName{};

  DescribeApisForConsoleResponseBodyApiInfosApiInfoDeployedInfosDeployedInfo() {}

  explicit DescribeApisForConsoleResponseBodyApiInfosApiInfoDeployedInfosDeployedInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedStatus) {
      res["DeployedStatus"] = boost::any(*deployedStatus);
    }
    if (effectiveVersion) {
      res["EffectiveVersion"] = boost::any(*effectiveVersion);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedStatus") != m.end() && !m["DeployedStatus"].empty()) {
      deployedStatus = make_shared<string>(boost::any_cast<string>(m["DeployedStatus"]));
    }
    if (m.find("EffectiveVersion") != m.end() && !m["EffectiveVersion"].empty()) {
      effectiveVersion = make_shared<string>(boost::any_cast<string>(m["EffectiveVersion"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApisForConsoleResponseBodyApiInfosApiInfoDeployedInfosDeployedInfo() = default;
};
class DescribeApisForConsoleResponseBodyApiInfosApiInfoDeployedInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisForConsoleResponseBodyApiInfosApiInfoDeployedInfosDeployedInfo>> deployedInfo{};

  DescribeApisForConsoleResponseBodyApiInfosApiInfoDeployedInfos() {}

  explicit DescribeApisForConsoleResponseBodyApiInfosApiInfoDeployedInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deployedInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployedInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedInfo") != m.end() && !m["DeployedInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployedInfo"].type()) {
        vector<DescribeApisForConsoleResponseBodyApiInfosApiInfoDeployedInfosDeployedInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployedInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisForConsoleResponseBodyApiInfosApiInfoDeployedInfosDeployedInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployedInfo = make_shared<vector<DescribeApisForConsoleResponseBodyApiInfosApiInfoDeployedInfosDeployedInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisForConsoleResponseBodyApiInfosApiInfoDeployedInfos() = default;
};
class DescribeApisForConsoleResponseBodyApiInfosApiInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> createdTime{};
  shared_ptr<DescribeApisForConsoleResponseBodyApiInfosApiInfoDeployedInfos> deployedInfos{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> visibility{};

  DescribeApisForConsoleResponseBodyApiInfosApiInfo() {}

  explicit DescribeApisForConsoleResponseBodyApiInfosApiInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (deployedInfos) {
      res["DeployedInfos"] = deployedInfos ? boost::any(deployedInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("DeployedInfos") != m.end() && !m["DeployedInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployedInfos"].type()) {
        DescribeApisForConsoleResponseBodyApiInfosApiInfoDeployedInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployedInfos"]));
        deployedInfos = make_shared<DescribeApisForConsoleResponseBodyApiInfosApiInfoDeployedInfos>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApisForConsoleResponseBodyApiInfosApiInfo() = default;
};
class DescribeApisForConsoleResponseBodyApiInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisForConsoleResponseBodyApiInfosApiInfo>> apiInfo{};

  DescribeApisForConsoleResponseBodyApiInfos() {}

  explicit DescribeApisForConsoleResponseBodyApiInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiInfo"].type()) {
        vector<DescribeApisForConsoleResponseBodyApiInfosApiInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisForConsoleResponseBodyApiInfosApiInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiInfo = make_shared<vector<DescribeApisForConsoleResponseBodyApiInfosApiInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisForConsoleResponseBodyApiInfos() = default;
};
class DescribeApisForConsoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisForConsoleResponseBodyApiInfos> apiInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisForConsoleResponseBody() {}

  explicit DescribeApisForConsoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfos) {
      res["ApiInfos"] = apiInfos ? boost::any(apiInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfos") != m.end() && !m["ApiInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInfos"].type()) {
        DescribeApisForConsoleResponseBodyApiInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInfos"]));
        apiInfos = make_shared<DescribeApisForConsoleResponseBodyApiInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisForConsoleResponseBody() = default;
};
class DescribeApisForConsoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisForConsoleResponseBody> body{};

  DescribeApisForConsoleResponse() {}

  explicit DescribeApisForConsoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisForConsoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisForConsoleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisForConsoleResponse() = default;
};
class DescribeAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> securityToken{};

  DescribeAppRequest() {}

  explicit DescribeAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAppRequest() = default;
};
class DescribeAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> requestId{};

  DescribeAppResponseBody() {}

  explicit DescribeAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAppResponseBody() = default;
};
class DescribeAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppResponseBody> body{};

  DescribeAppResponse() {}

  explicit DescribeAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppResponse() = default;
};
class DescribeAppSecuritiesRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> securityToken{};

  DescribeAppSecuritiesRequest() {}

  explicit DescribeAppSecuritiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAppSecuritiesRequest() = default;
};
class DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> appSecret{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> modifiedTime{};

  DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity() {}

  explicit DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
  }


  virtual ~DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity() = default;
};
class DescribeAppSecuritiesResponseBodyAppSecuritys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity>> appSecurity{};

  DescribeAppSecuritiesResponseBodyAppSecuritys() {}

  explicit DescribeAppSecuritiesResponseBodyAppSecuritys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appSecurity) {
      vector<boost::any> temp1;
      for(auto item1:*appSecurity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppSecurity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppSecurity") != m.end() && !m["AppSecurity"].empty()) {
      if (typeid(vector<boost::any>) == m["AppSecurity"].type()) {
        vector<DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppSecurity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appSecurity = make_shared<vector<DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity>>(expect1);
      }
    }
  }


  virtual ~DescribeAppSecuritiesResponseBodyAppSecuritys() = default;
};
class DescribeAppSecuritiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAppSecuritiesResponseBodyAppSecuritys> appSecuritys{};
  shared_ptr<string> requestId{};

  DescribeAppSecuritiesResponseBody() {}

  explicit DescribeAppSecuritiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appSecuritys) {
      res["AppSecuritys"] = appSecuritys ? boost::any(appSecuritys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppSecuritys") != m.end() && !m["AppSecuritys"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppSecuritys"].type()) {
        DescribeAppSecuritiesResponseBodyAppSecuritys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppSecuritys"]));
        appSecuritys = make_shared<DescribeAppSecuritiesResponseBodyAppSecuritys>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAppSecuritiesResponseBody() = default;
};
class DescribeAppSecuritiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppSecuritiesResponseBody> body{};

  DescribeAppSecuritiesResponse() {}

  explicit DescribeAppSecuritiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppSecuritiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppSecuritiesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppSecuritiesResponse() = default;
};
class DescribeAppSecurityRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> securityToken{};

  DescribeAppSecurityRequest() {}

  explicit DescribeAppSecurityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAppSecurityRequest() = default;
};
class DescribeAppSecurityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> appKey{};
  shared_ptr<string> appSecret{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> requestId{};

  DescribeAppSecurityResponseBody() {}

  explicit DescribeAppSecurityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAppSecurityResponseBody() = default;
};
class DescribeAppSecurityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppSecurityResponseBody> body{};

  DescribeAppSecurityResponse() {}

  explicit DescribeAppSecurityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppSecurityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppSecurityResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppSecurityResponse() = default;
};
class DescribeAppsRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeAppsRequest() {}

  explicit DescribeAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAppsRequest() = default;
};
class DescribeAppsResponseBodyAppsApp : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modifiedTime{};

  DescribeAppsResponseBodyAppsApp() {}

  explicit DescribeAppsResponseBodyAppsApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
  }


  virtual ~DescribeAppsResponseBodyAppsApp() = default;
};
class DescribeAppsResponseBodyApps : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAppsResponseBodyAppsApp>> app{};

  DescribeAppsResponseBodyApps() {}

  explicit DescribeAppsResponseBodyApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      vector<boost::any> temp1;
      for(auto item1:*app){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["App"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      if (typeid(vector<boost::any>) == m["App"].type()) {
        vector<DescribeAppsResponseBodyAppsApp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["App"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppsResponseBodyAppsApp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        app = make_shared<vector<DescribeAppsResponseBodyAppsApp>>(expect1);
      }
    }
  }


  virtual ~DescribeAppsResponseBodyApps() = default;
};
class DescribeAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAppsResponseBodyApps> apps{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAppsResponseBody() {}

  explicit DescribeAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apps) {
      res["Apps"] = apps ? boost::any(apps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Apps") != m.end() && !m["Apps"].empty()) {
      if (typeid(map<string, boost::any>) == m["Apps"].type()) {
        DescribeAppsResponseBodyApps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Apps"]));
        apps = make_shared<DescribeAppsResponseBodyApps>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAppsResponseBody() = default;
};
class DescribeAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppsResponseBody> body{};

  DescribeAppsResponse() {}

  explicit DescribeAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppsResponse() = default;
};
class DescribeAppsByApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeAppsByApiRequest() {}

  explicit DescribeAppsByApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeAppsByApiRequest() = default;
};
class DescribeAppsByApiResponseBodyAppApiRelationInfosAppApiRelationInfo : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> authorizationSource{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> operator_{};
  shared_ptr<string> stageName{};

  DescribeAppsByApiResponseBodyAppApiRelationInfosAppApiRelationInfo() {}

  explicit DescribeAppsByApiResponseBodyAppApiRelationInfosAppApiRelationInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (authorizationSource) {
      res["AuthorizationSource"] = boost::any(*authorizationSource);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AuthorizationSource") != m.end() && !m["AuthorizationSource"].empty()) {
      authorizationSource = make_shared<string>(boost::any_cast<string>(m["AuthorizationSource"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeAppsByApiResponseBodyAppApiRelationInfosAppApiRelationInfo() = default;
};
class DescribeAppsByApiResponseBodyAppApiRelationInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAppsByApiResponseBodyAppApiRelationInfosAppApiRelationInfo>> appApiRelationInfo{};

  DescribeAppsByApiResponseBodyAppApiRelationInfos() {}

  explicit DescribeAppsByApiResponseBodyAppApiRelationInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appApiRelationInfo) {
      vector<boost::any> temp1;
      for(auto item1:*appApiRelationInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppApiRelationInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppApiRelationInfo") != m.end() && !m["AppApiRelationInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["AppApiRelationInfo"].type()) {
        vector<DescribeAppsByApiResponseBodyAppApiRelationInfosAppApiRelationInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppApiRelationInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppsByApiResponseBodyAppApiRelationInfosAppApiRelationInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appApiRelationInfo = make_shared<vector<DescribeAppsByApiResponseBodyAppApiRelationInfosAppApiRelationInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeAppsByApiResponseBodyAppApiRelationInfos() = default;
};
class DescribeAppsByApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAppsByApiResponseBodyAppApiRelationInfos> appApiRelationInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAppsByApiResponseBody() {}

  explicit DescribeAppsByApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appApiRelationInfos) {
      res["AppApiRelationInfos"] = appApiRelationInfos ? boost::any(appApiRelationInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppApiRelationInfos") != m.end() && !m["AppApiRelationInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppApiRelationInfos"].type()) {
        DescribeAppsByApiResponseBodyAppApiRelationInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppApiRelationInfos"]));
        appApiRelationInfos = make_shared<DescribeAppsByApiResponseBodyAppApiRelationInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAppsByApiResponseBody() = default;
};
class DescribeAppsByApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppsByApiResponseBody> body{};

  DescribeAppsByApiResponse() {}

  explicit DescribeAppsByApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppsByApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppsByApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppsByApiResponse() = default;
};
class DescribeAppsForProviderRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<long> appOwnerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeAppsForProviderRequest() {}

  explicit DescribeAppsForProviderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appOwnerId) {
      res["AppOwnerId"] = boost::any(*appOwnerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppOwnerId") != m.end() && !m["AppOwnerId"].empty()) {
      appOwnerId = make_shared<long>(boost::any_cast<long>(m["AppOwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAppsForProviderRequest() = default;
};
class DescribeAppsForProviderResponseBodyAppsApp : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modifiedTime{};

  DescribeAppsForProviderResponseBodyAppsApp() {}

  explicit DescribeAppsForProviderResponseBodyAppsApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
  }


  virtual ~DescribeAppsForProviderResponseBodyAppsApp() = default;
};
class DescribeAppsForProviderResponseBodyApps : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAppsForProviderResponseBodyAppsApp>> app{};

  DescribeAppsForProviderResponseBodyApps() {}

  explicit DescribeAppsForProviderResponseBodyApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (app) {
      vector<boost::any> temp1;
      for(auto item1:*app){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["App"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("App") != m.end() && !m["App"].empty()) {
      if (typeid(vector<boost::any>) == m["App"].type()) {
        vector<DescribeAppsForProviderResponseBodyAppsApp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["App"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppsForProviderResponseBodyAppsApp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        app = make_shared<vector<DescribeAppsForProviderResponseBodyAppsApp>>(expect1);
      }
    }
  }


  virtual ~DescribeAppsForProviderResponseBodyApps() = default;
};
class DescribeAppsForProviderResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAppsForProviderResponseBodyApps> apps{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAppsForProviderResponseBody() {}

  explicit DescribeAppsForProviderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apps) {
      res["Apps"] = apps ? boost::any(apps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Apps") != m.end() && !m["Apps"].empty()) {
      if (typeid(map<string, boost::any>) == m["Apps"].type()) {
        DescribeAppsForProviderResponseBodyApps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Apps"]));
        apps = make_shared<DescribeAppsForProviderResponseBodyApps>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAppsForProviderResponseBody() = default;
};
class DescribeAppsForProviderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppsForProviderResponseBody> body{};

  DescribeAppsForProviderResponse() {}

  explicit DescribeAppsForProviderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppsForProviderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppsForProviderResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppsForProviderResponse() = default;
};
class DescribeBlackListsRequest : public Darabonba::Model {
public:
  shared_ptr<string> blackType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeBlackListsRequest() {}

  explicit DescribeBlackListsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackType) {
      res["BlackType"] = boost::any(*blackType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackType") != m.end() && !m["BlackType"].empty()) {
      blackType = make_shared<string>(boost::any_cast<string>(m["BlackType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeBlackListsRequest() = default;
};
class DescribeBlackListsResponseBodyBlackListsBlackList : public Darabonba::Model {
public:
  shared_ptr<string> blackContent{};
  shared_ptr<string> blackType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modifiedTime{};

  DescribeBlackListsResponseBodyBlackListsBlackList() {}

  explicit DescribeBlackListsResponseBodyBlackListsBlackList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackContent) {
      res["BlackContent"] = boost::any(*blackContent);
    }
    if (blackType) {
      res["BlackType"] = boost::any(*blackType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackContent") != m.end() && !m["BlackContent"].empty()) {
      blackContent = make_shared<string>(boost::any_cast<string>(m["BlackContent"]));
    }
    if (m.find("BlackType") != m.end() && !m["BlackType"].empty()) {
      blackType = make_shared<string>(boost::any_cast<string>(m["BlackType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
  }


  virtual ~DescribeBlackListsResponseBodyBlackListsBlackList() = default;
};
class DescribeBlackListsResponseBodyBlackLists : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBlackListsResponseBodyBlackListsBlackList>> blackList{};

  DescribeBlackListsResponseBodyBlackLists() {}

  explicit DescribeBlackListsResponseBodyBlackLists(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackList) {
      vector<boost::any> temp1;
      for(auto item1:*blackList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BlackList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackList") != m.end() && !m["BlackList"].empty()) {
      if (typeid(vector<boost::any>) == m["BlackList"].type()) {
        vector<DescribeBlackListsResponseBodyBlackListsBlackList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BlackList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBlackListsResponseBodyBlackListsBlackList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        blackList = make_shared<vector<DescribeBlackListsResponseBodyBlackListsBlackList>>(expect1);
      }
    }
  }


  virtual ~DescribeBlackListsResponseBodyBlackLists() = default;
};
class DescribeBlackListsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeBlackListsResponseBodyBlackLists> blackLists{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeBlackListsResponseBody() {}

  explicit DescribeBlackListsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackLists) {
      res["BlackLists"] = blackLists ? boost::any(blackLists->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackLists") != m.end() && !m["BlackLists"].empty()) {
      if (typeid(map<string, boost::any>) == m["BlackLists"].type()) {
        DescribeBlackListsResponseBodyBlackLists model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BlackLists"]));
        blackLists = make_shared<DescribeBlackListsResponseBodyBlackLists>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeBlackListsResponseBody() = default;
};
class DescribeBlackListsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBlackListsResponseBody> body{};

  DescribeBlackListsResponse() {}

  explicit DescribeBlackListsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBlackListsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBlackListsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBlackListsResponse() = default;
};
class DescribeDeployedApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeDeployedApiRequest() {}

  explicit DescribeDeployedApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeDeployedApiRequest() = default;
};
class DescribeDeployedApiResponseBodyConstantParametersConstantParameter : public Darabonba::Model {
public:
  shared_ptr<string> constantValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> serviceParameterName{};

  DescribeDeployedApiResponseBodyConstantParametersConstantParameter() {}

  explicit DescribeDeployedApiResponseBodyConstantParametersConstantParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantValue) {
      res["ConstantValue"] = boost::any(*constantValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantValue") != m.end() && !m["ConstantValue"].empty()) {
      constantValue = make_shared<string>(boost::any_cast<string>(m["ConstantValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyConstantParametersConstantParameter() = default;
};
class DescribeDeployedApiResponseBodyConstantParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyConstantParametersConstantParameter>> constantParameter{};

  DescribeDeployedApiResponseBodyConstantParameters() {}

  explicit DescribeDeployedApiResponseBodyConstantParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantParameter) {
      vector<boost::any> temp1;
      for(auto item1:*constantParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConstantParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantParameter") != m.end() && !m["ConstantParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ConstantParameter"].type()) {
        vector<DescribeDeployedApiResponseBodyConstantParametersConstantParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConstantParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyConstantParametersConstantParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        constantParameter = make_shared<vector<DescribeDeployedApiResponseBodyConstantParametersConstantParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyConstantParameters() = default;
};
class DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> message{};

  DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample() {}

  explicit DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample() = default;
};
class DescribeDeployedApiResponseBodyErrorCodeSamples : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample>> errorCodeSample{};

  DescribeDeployedApiResponseBodyErrorCodeSamples() {}

  explicit DescribeDeployedApiResponseBodyErrorCodeSamples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCodeSample) {
      vector<boost::any> temp1;
      for(auto item1:*errorCodeSample){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorCodeSample"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCodeSample") != m.end() && !m["ErrorCodeSample"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorCodeSample"].type()) {
        vector<DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorCodeSample"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorCodeSample = make_shared<vector<DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyErrorCodeSamples() = default;
};
class DescribeDeployedApiResponseBodyFunctionComputeConfig : public Darabonba::Model {
public:
  shared_ptr<string> fcRegionId{};
  shared_ptr<string> functionName{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> serviceName{};

  DescribeDeployedApiResponseBodyFunctionComputeConfig() {}

  explicit DescribeDeployedApiResponseBodyFunctionComputeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fcRegionId) {
      res["FcRegionId"] = boost::any(*fcRegionId);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FcRegionId") != m.end() && !m["FcRegionId"].empty()) {
      fcRegionId = make_shared<string>(boost::any_cast<string>(m["FcRegionId"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyFunctionComputeConfig() = default;
};
class DescribeDeployedApiResponseBodyPathParametersPathParameter : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> serviceParameterName{};

  DescribeDeployedApiResponseBodyPathParametersPathParameter() {}

  explicit DescribeDeployedApiResponseBodyPathParametersPathParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyPathParametersPathParameter() = default;
};
class DescribeDeployedApiResponseBodyPathParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyPathParametersPathParameter>> pathParameter{};

  DescribeDeployedApiResponseBodyPathParameters() {}

  explicit DescribeDeployedApiResponseBodyPathParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pathParameter) {
      vector<boost::any> temp1;
      for(auto item1:*pathParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PathParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PathParameter") != m.end() && !m["PathParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["PathParameter"].type()) {
        vector<DescribeDeployedApiResponseBodyPathParametersPathParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PathParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyPathParametersPathParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pathParameter = make_shared<vector<DescribeDeployedApiResponseBodyPathParametersPathParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyPathParameters() = default;
};
class DescribeDeployedApiResponseBodyRequestBodyRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};
  shared_ptr<string> serviceParameterName{};

  DescribeDeployedApiResponseBodyRequestBodyRequestParam() {}

  explicit DescribeDeployedApiResponseBodyRequestBodyRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<string>(boost::any_cast<string>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyRequestBodyRequestParam() = default;
};
class DescribeDeployedApiResponseBodyRequestBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyRequestBodyRequestParam>> requestParam{};

  DescribeDeployedApiResponseBodyRequestBody() {}

  explicit DescribeDeployedApiResponseBodyRequestBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParam) {
      vector<boost::any> temp1;
      for(auto item1:*requestParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParam"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParam") != m.end() && !m["RequestParam"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParam"].type()) {
        vector<DescribeDeployedApiResponseBodyRequestBodyRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyRequestBodyRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParam = make_shared<vector<DescribeDeployedApiResponseBodyRequestBodyRequestParam>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyRequestBody() = default;
};
class DescribeDeployedApiResponseBodyRequestHeadersRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};
  shared_ptr<string> serviceParameterName{};

  DescribeDeployedApiResponseBodyRequestHeadersRequestParam() {}

  explicit DescribeDeployedApiResponseBodyRequestHeadersRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<string>(boost::any_cast<string>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyRequestHeadersRequestParam() = default;
};
class DescribeDeployedApiResponseBodyRequestHeaders : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyRequestHeadersRequestParam>> requestParam{};

  DescribeDeployedApiResponseBodyRequestHeaders() {}

  explicit DescribeDeployedApiResponseBodyRequestHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParam) {
      vector<boost::any> temp1;
      for(auto item1:*requestParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParam"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParam") != m.end() && !m["RequestParam"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParam"].type()) {
        vector<DescribeDeployedApiResponseBodyRequestHeadersRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyRequestHeadersRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParam = make_shared<vector<DescribeDeployedApiResponseBodyRequestHeadersRequestParam>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyRequestHeaders() = default;
};
class DescribeDeployedApiResponseBodyRequestQueriesRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};
  shared_ptr<string> serviceParameterName{};

  DescribeDeployedApiResponseBodyRequestQueriesRequestParam() {}

  explicit DescribeDeployedApiResponseBodyRequestQueriesRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<string>(boost::any_cast<string>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyRequestQueriesRequestParam() = default;
};
class DescribeDeployedApiResponseBodyRequestQueries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyRequestQueriesRequestParam>> requestParam{};

  DescribeDeployedApiResponseBodyRequestQueries() {}

  explicit DescribeDeployedApiResponseBodyRequestQueries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParam) {
      vector<boost::any> temp1;
      for(auto item1:*requestParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParam"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParam") != m.end() && !m["RequestParam"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParam"].type()) {
        vector<DescribeDeployedApiResponseBodyRequestQueriesRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyRequestQueriesRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParam = make_shared<vector<DescribeDeployedApiResponseBodyRequestQueriesRequestParam>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyRequestQueries() = default;
};
class DescribeDeployedApiResponseBodySystemParametersSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeDeployedApiResponseBodySystemParametersSystemParameter() {}

  explicit DescribeDeployedApiResponseBodySystemParametersSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodySystemParametersSystemParameter() = default;
};
class DescribeDeployedApiResponseBodySystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodySystemParametersSystemParameter>> systemParameter{};

  DescribeDeployedApiResponseBodySystemParameters() {}

  explicit DescribeDeployedApiResponseBodySystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*systemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemParameter") != m.end() && !m["SystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemParameter"].type()) {
        vector<DescribeDeployedApiResponseBodySystemParametersSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodySystemParametersSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemParameter = make_shared<vector<DescribeDeployedApiResponseBodySystemParametersSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodySystemParameters() = default;
};
class DescribeDeployedApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> authType{};
  shared_ptr<string> bodyFormat{};
  shared_ptr<DescribeDeployedApiResponseBodyConstantParameters> constantParameters{};
  shared_ptr<string> deployedTime{};
  shared_ptr<DescribeDeployedApiResponseBodyErrorCodeSamples> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<DescribeDeployedApiResponseBodyFunctionComputeConfig> functionComputeConfig{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> httpProtocol{};
  shared_ptr<string> path{};
  shared_ptr<DescribeDeployedApiResponseBodyPathParameters> pathParameters{};
  shared_ptr<string> postBodyDescription{};
  shared_ptr<string> postBodyType{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeDeployedApiResponseBodyRequestBody> requestBody{};
  shared_ptr<DescribeDeployedApiResponseBodyRequestHeaders> requestHeaders{};
  shared_ptr<string> requestId{};
  shared_ptr<string> requestMode{};
  shared_ptr<DescribeDeployedApiResponseBodyRequestQueries> requestQueries{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<string> serviceAddress{};
  shared_ptr<string> serviceFCEnable{};
  shared_ptr<string> serviceProtocol{};
  shared_ptr<long> serviceTimeout{};
  shared_ptr<string> serviceVpcEnable{};
  shared_ptr<string> stageName{};
  shared_ptr<DescribeDeployedApiResponseBodySystemParameters> systemParameters{};
  shared_ptr<string> visibility{};
  shared_ptr<string> vpcName{};

  DescribeDeployedApiResponseBody() {}

  explicit DescribeDeployedApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (bodyFormat) {
      res["BodyFormat"] = boost::any(*bodyFormat);
    }
    if (constantParameters) {
      res["ConstantParameters"] = constantParameters ? boost::any(constantParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = errorCodeSamples ? boost::any(errorCodeSamples->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (functionComputeConfig) {
      res["FunctionComputeConfig"] = functionComputeConfig ? boost::any(functionComputeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (httpProtocol) {
      res["HttpProtocol"] = boost::any(*httpProtocol);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (pathParameters) {
      res["PathParameters"] = pathParameters ? boost::any(pathParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (postBodyDescription) {
      res["PostBodyDescription"] = boost::any(*postBodyDescription);
    }
    if (postBodyType) {
      res["PostBodyType"] = boost::any(*postBodyType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestBody) {
      res["RequestBody"] = requestBody ? boost::any(requestBody->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestHeaders) {
      res["RequestHeaders"] = requestHeaders ? boost::any(requestHeaders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestMode) {
      res["RequestMode"] = boost::any(*requestMode);
    }
    if (requestQueries) {
      res["RequestQueries"] = requestQueries ? boost::any(requestQueries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (serviceAddress) {
      res["ServiceAddress"] = boost::any(*serviceAddress);
    }
    if (serviceFCEnable) {
      res["ServiceFCEnable"] = boost::any(*serviceFCEnable);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    if (serviceTimeout) {
      res["ServiceTimeout"] = boost::any(*serviceTimeout);
    }
    if (serviceVpcEnable) {
      res["ServiceVpcEnable"] = boost::any(*serviceVpcEnable);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (systemParameters) {
      res["SystemParameters"] = systemParameters ? boost::any(systemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("BodyFormat") != m.end() && !m["BodyFormat"].empty()) {
      bodyFormat = make_shared<string>(boost::any_cast<string>(m["BodyFormat"]));
    }
    if (m.find("ConstantParameters") != m.end() && !m["ConstantParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConstantParameters"].type()) {
        DescribeDeployedApiResponseBodyConstantParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConstantParameters"]));
        constantParameters = make_shared<DescribeDeployedApiResponseBodyConstantParameters>(model1);
      }
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorCodeSamples"].type()) {
        DescribeDeployedApiResponseBodyErrorCodeSamples model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorCodeSamples"]));
        errorCodeSamples = make_shared<DescribeDeployedApiResponseBodyErrorCodeSamples>(model1);
      }
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("FunctionComputeConfig") != m.end() && !m["FunctionComputeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionComputeConfig"].type()) {
        DescribeDeployedApiResponseBodyFunctionComputeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionComputeConfig"]));
        functionComputeConfig = make_shared<DescribeDeployedApiResponseBodyFunctionComputeConfig>(model1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("HttpProtocol") != m.end() && !m["HttpProtocol"].empty()) {
      httpProtocol = make_shared<string>(boost::any_cast<string>(m["HttpProtocol"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("PathParameters") != m.end() && !m["PathParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathParameters"].type()) {
        DescribeDeployedApiResponseBodyPathParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathParameters"]));
        pathParameters = make_shared<DescribeDeployedApiResponseBodyPathParameters>(model1);
      }
    }
    if (m.find("PostBodyDescription") != m.end() && !m["PostBodyDescription"].empty()) {
      postBodyDescription = make_shared<string>(boost::any_cast<string>(m["PostBodyDescription"]));
    }
    if (m.find("PostBodyType") != m.end() && !m["PostBodyType"].empty()) {
      postBodyType = make_shared<string>(boost::any_cast<string>(m["PostBodyType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestBody") != m.end() && !m["RequestBody"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestBody"].type()) {
        DescribeDeployedApiResponseBodyRequestBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestBody"]));
        requestBody = make_shared<DescribeDeployedApiResponseBodyRequestBody>(model1);
      }
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestHeaders"].type()) {
        DescribeDeployedApiResponseBodyRequestHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestHeaders"]));
        requestHeaders = make_shared<DescribeDeployedApiResponseBodyRequestHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestMode") != m.end() && !m["RequestMode"].empty()) {
      requestMode = make_shared<string>(boost::any_cast<string>(m["RequestMode"]));
    }
    if (m.find("RequestQueries") != m.end() && !m["RequestQueries"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestQueries"].type()) {
        DescribeDeployedApiResponseBodyRequestQueries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestQueries"]));
        requestQueries = make_shared<DescribeDeployedApiResponseBodyRequestQueries>(model1);
      }
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("ServiceAddress") != m.end() && !m["ServiceAddress"].empty()) {
      serviceAddress = make_shared<string>(boost::any_cast<string>(m["ServiceAddress"]));
    }
    if (m.find("ServiceFCEnable") != m.end() && !m["ServiceFCEnable"].empty()) {
      serviceFCEnable = make_shared<string>(boost::any_cast<string>(m["ServiceFCEnable"]));
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
    if (m.find("ServiceTimeout") != m.end() && !m["ServiceTimeout"].empty()) {
      serviceTimeout = make_shared<long>(boost::any_cast<long>(m["ServiceTimeout"]));
    }
    if (m.find("ServiceVpcEnable") != m.end() && !m["ServiceVpcEnable"].empty()) {
      serviceVpcEnable = make_shared<string>(boost::any_cast<string>(m["ServiceVpcEnable"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("SystemParameters") != m.end() && !m["SystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemParameters"].type()) {
        DescribeDeployedApiResponseBodySystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemParameters"]));
        systemParameters = make_shared<DescribeDeployedApiResponseBodySystemParameters>(model1);
      }
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBody() = default;
};
class DescribeDeployedApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDeployedApiResponseBody> body{};

  DescribeDeployedApiResponse() {}

  explicit DescribeDeployedApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeployedApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeployedApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponse() = default;
};
class DescribeDeployedApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeDeployedApisRequest() {}

  explicit DescribeDeployedApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeDeployedApisRequest() = default;
};
class DescribeDeployedApisResponseBodyApiInfosApiInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribeDeployedApisResponseBodyApiInfosApiInfo() {}

  explicit DescribeDeployedApisResponseBodyApiInfosApiInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeDeployedApisResponseBodyApiInfosApiInfo() = default;
};
class DescribeDeployedApisResponseBodyApiInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApisResponseBodyApiInfosApiInfo>> apiInfo{};

  DescribeDeployedApisResponseBodyApiInfos() {}

  explicit DescribeDeployedApisResponseBodyApiInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiInfo"].type()) {
        vector<DescribeDeployedApisResponseBodyApiInfosApiInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApisResponseBodyApiInfosApiInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiInfo = make_shared<vector<DescribeDeployedApisResponseBodyApiInfosApiInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApisResponseBodyApiInfos() = default;
};
class DescribeDeployedApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDeployedApisResponseBodyApiInfos> apiInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDeployedApisResponseBody() {}

  explicit DescribeDeployedApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfos) {
      res["ApiInfos"] = apiInfos ? boost::any(apiInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfos") != m.end() && !m["ApiInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInfos"].type()) {
        DescribeDeployedApisResponseBodyApiInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInfos"]));
        apiInfos = make_shared<DescribeDeployedApisResponseBodyApiInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDeployedApisResponseBody() = default;
};
class DescribeDeployedApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDeployedApisResponseBody> body{};

  DescribeDeployedApisResponse() {}

  explicit DescribeDeployedApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeployedApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeployedApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeployedApisResponse() = default;
};
class DescribeDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribeDomainRequest() {}

  explicit DescribeDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDomainRequest() = default;
};
class DescribeDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> certificateBody{};
  shared_ptr<string> certificateId{};
  shared_ptr<string> certificateName{};
  shared_ptr<string> domainBindingStatus{};
  shared_ptr<string> domainLegalStatus{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainNameResolution{};
  shared_ptr<string> domainRemark{};
  shared_ptr<string> domainWebSocketStatus{};
  shared_ptr<string> groupId{};
  shared_ptr<string> privateKey{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subDomain{};

  DescribeDomainResponseBody() {}

  explicit DescribeDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateBody) {
      res["CertificateBody"] = boost::any(*certificateBody);
    }
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (certificateName) {
      res["CertificateName"] = boost::any(*certificateName);
    }
    if (domainBindingStatus) {
      res["DomainBindingStatus"] = boost::any(*domainBindingStatus);
    }
    if (domainLegalStatus) {
      res["DomainLegalStatus"] = boost::any(*domainLegalStatus);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainNameResolution) {
      res["DomainNameResolution"] = boost::any(*domainNameResolution);
    }
    if (domainRemark) {
      res["DomainRemark"] = boost::any(*domainRemark);
    }
    if (domainWebSocketStatus) {
      res["DomainWebSocketStatus"] = boost::any(*domainWebSocketStatus);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateBody") != m.end() && !m["CertificateBody"].empty()) {
      certificateBody = make_shared<string>(boost::any_cast<string>(m["CertificateBody"]));
    }
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("CertificateName") != m.end() && !m["CertificateName"].empty()) {
      certificateName = make_shared<string>(boost::any_cast<string>(m["CertificateName"]));
    }
    if (m.find("DomainBindingStatus") != m.end() && !m["DomainBindingStatus"].empty()) {
      domainBindingStatus = make_shared<string>(boost::any_cast<string>(m["DomainBindingStatus"]));
    }
    if (m.find("DomainLegalStatus") != m.end() && !m["DomainLegalStatus"].empty()) {
      domainLegalStatus = make_shared<string>(boost::any_cast<string>(m["DomainLegalStatus"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainNameResolution") != m.end() && !m["DomainNameResolution"].empty()) {
      domainNameResolution = make_shared<string>(boost::any_cast<string>(m["DomainNameResolution"]));
    }
    if (m.find("DomainRemark") != m.end() && !m["DomainRemark"].empty()) {
      domainRemark = make_shared<string>(boost::any_cast<string>(m["DomainRemark"]));
    }
    if (m.find("DomainWebSocketStatus") != m.end() && !m["DomainWebSocketStatus"].empty()) {
      domainWebSocketStatus = make_shared<string>(boost::any_cast<string>(m["DomainWebSocketStatus"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
  }


  virtual ~DescribeDomainResponseBody() = default;
};
class DescribeDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainResponseBody> body{};

  DescribeDomainResponse() {}

  explicit DescribeDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainResponse() = default;
};
class DescribeDomainResolutionRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainNames{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribeDomainResolutionRequest() {}

  explicit DescribeDomainResolutionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainNames) {
      res["DomainNames"] = boost::any(*domainNames);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainNames") != m.end() && !m["DomainNames"].empty()) {
      domainNames = make_shared<string>(boost::any_cast<string>(m["DomainNames"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDomainResolutionRequest() = default;
};
class DescribeDomainResolutionResponseBodyDomainResolutionsDomainResolution : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> domainNameResolution{};

  DescribeDomainResolutionResponseBodyDomainResolutionsDomainResolution() {}

  explicit DescribeDomainResolutionResponseBodyDomainResolutionsDomainResolution(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainNameResolution) {
      res["DomainNameResolution"] = boost::any(*domainNameResolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainNameResolution") != m.end() && !m["DomainNameResolution"].empty()) {
      domainNameResolution = make_shared<string>(boost::any_cast<string>(m["DomainNameResolution"]));
    }
  }


  virtual ~DescribeDomainResolutionResponseBodyDomainResolutionsDomainResolution() = default;
};
class DescribeDomainResolutionResponseBodyDomainResolutions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainResolutionResponseBodyDomainResolutionsDomainResolution>> domainResolution{};

  DescribeDomainResolutionResponseBodyDomainResolutions() {}

  explicit DescribeDomainResolutionResponseBodyDomainResolutions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainResolution) {
      vector<boost::any> temp1;
      for(auto item1:*domainResolution){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainResolution"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainResolution") != m.end() && !m["DomainResolution"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainResolution"].type()) {
        vector<DescribeDomainResolutionResponseBodyDomainResolutionsDomainResolution> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainResolution"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainResolutionResponseBodyDomainResolutionsDomainResolution model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainResolution = make_shared<vector<DescribeDomainResolutionResponseBodyDomainResolutionsDomainResolution>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainResolutionResponseBodyDomainResolutions() = default;
};
class DescribeDomainResolutionResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainResolutionResponseBodyDomainResolutions> domainResolutions{};
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};

  DescribeDomainResolutionResponseBody() {}

  explicit DescribeDomainResolutionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainResolutions) {
      res["DomainResolutions"] = domainResolutions ? boost::any(domainResolutions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainResolutions") != m.end() && !m["DomainResolutions"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainResolutions"].type()) {
        DescribeDomainResolutionResponseBodyDomainResolutions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainResolutions"]));
        domainResolutions = make_shared<DescribeDomainResolutionResponseBodyDomainResolutions>(model1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainResolutionResponseBody() = default;
};
class DescribeDomainResolutionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainResolutionResponseBody> body{};

  DescribeDomainResolutionResponse() {}

  explicit DescribeDomainResolutionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainResolutionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainResolutionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainResolutionResponse() = default;
};
class DescribeHistoryApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> historyVersion{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeHistoryApiRequest() {}

  explicit DescribeHistoryApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeHistoryApiRequest() = default;
};
class DescribeHistoryApiResponseBodyConstantParametersConstantParameter : public Darabonba::Model {
public:
  shared_ptr<string> constantValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> serviceParameterName{};

  DescribeHistoryApiResponseBodyConstantParametersConstantParameter() {}

  explicit DescribeHistoryApiResponseBodyConstantParametersConstantParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantValue) {
      res["ConstantValue"] = boost::any(*constantValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantValue") != m.end() && !m["ConstantValue"].empty()) {
      constantValue = make_shared<string>(boost::any_cast<string>(m["ConstantValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeHistoryApiResponseBodyConstantParametersConstantParameter() = default;
};
class DescribeHistoryApiResponseBodyConstantParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHistoryApiResponseBodyConstantParametersConstantParameter>> constantParameter{};

  DescribeHistoryApiResponseBodyConstantParameters() {}

  explicit DescribeHistoryApiResponseBodyConstantParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantParameter) {
      vector<boost::any> temp1;
      for(auto item1:*constantParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConstantParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantParameter") != m.end() && !m["ConstantParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ConstantParameter"].type()) {
        vector<DescribeHistoryApiResponseBodyConstantParametersConstantParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConstantParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHistoryApiResponseBodyConstantParametersConstantParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        constantParameter = make_shared<vector<DescribeHistoryApiResponseBodyConstantParametersConstantParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeHistoryApiResponseBodyConstantParameters() = default;
};
class DescribeHistoryApiResponseBodyCustomSystemParametersCustomSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeHistoryApiResponseBodyCustomSystemParametersCustomSystemParameter() {}

  explicit DescribeHistoryApiResponseBodyCustomSystemParametersCustomSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeHistoryApiResponseBodyCustomSystemParametersCustomSystemParameter() = default;
};
class DescribeHistoryApiResponseBodyCustomSystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHistoryApiResponseBodyCustomSystemParametersCustomSystemParameter>> customSystemParameter{};

  DescribeHistoryApiResponseBodyCustomSystemParameters() {}

  explicit DescribeHistoryApiResponseBodyCustomSystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customSystemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*customSystemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomSystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomSystemParameter") != m.end() && !m["CustomSystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomSystemParameter"].type()) {
        vector<DescribeHistoryApiResponseBodyCustomSystemParametersCustomSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomSystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHistoryApiResponseBodyCustomSystemParametersCustomSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customSystemParameter = make_shared<vector<DescribeHistoryApiResponseBodyCustomSystemParametersCustomSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeHistoryApiResponseBodyCustomSystemParameters() = default;
};
class DescribeHistoryApiResponseBodyErrorCodeSamplesErrorCodeSample : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> message{};

  DescribeHistoryApiResponseBodyErrorCodeSamplesErrorCodeSample() {}

  explicit DescribeHistoryApiResponseBodyErrorCodeSamplesErrorCodeSample(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DescribeHistoryApiResponseBodyErrorCodeSamplesErrorCodeSample() = default;
};
class DescribeHistoryApiResponseBodyErrorCodeSamples : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHistoryApiResponseBodyErrorCodeSamplesErrorCodeSample>> errorCodeSample{};

  DescribeHistoryApiResponseBodyErrorCodeSamples() {}

  explicit DescribeHistoryApiResponseBodyErrorCodeSamples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCodeSample) {
      vector<boost::any> temp1;
      for(auto item1:*errorCodeSample){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorCodeSample"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCodeSample") != m.end() && !m["ErrorCodeSample"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorCodeSample"].type()) {
        vector<DescribeHistoryApiResponseBodyErrorCodeSamplesErrorCodeSample> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorCodeSample"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHistoryApiResponseBodyErrorCodeSamplesErrorCodeSample model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorCodeSample = make_shared<vector<DescribeHistoryApiResponseBodyErrorCodeSamplesErrorCodeSample>>(expect1);
      }
    }
  }


  virtual ~DescribeHistoryApiResponseBodyErrorCodeSamples() = default;
};
class DescribeHistoryApiResponseBodyFunctionComputeConfig : public Darabonba::Model {
public:
  shared_ptr<string> fcRegionId{};
  shared_ptr<string> functionName{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> serviceName{};

  DescribeHistoryApiResponseBodyFunctionComputeConfig() {}

  explicit DescribeHistoryApiResponseBodyFunctionComputeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fcRegionId) {
      res["FcRegionId"] = boost::any(*fcRegionId);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FcRegionId") != m.end() && !m["FcRegionId"].empty()) {
      fcRegionId = make_shared<string>(boost::any_cast<string>(m["FcRegionId"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeHistoryApiResponseBodyFunctionComputeConfig() = default;
};
class DescribeHistoryApiResponseBodyOpenIdConnectConfig : public Darabonba::Model {
public:
  shared_ptr<string> idTokenParamName{};
  shared_ptr<string> openIdApiType{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> publicKeyId{};

  DescribeHistoryApiResponseBodyOpenIdConnectConfig() {}

  explicit DescribeHistoryApiResponseBodyOpenIdConnectConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (idTokenParamName) {
      res["IdTokenParamName"] = boost::any(*idTokenParamName);
    }
    if (openIdApiType) {
      res["OpenIdApiType"] = boost::any(*openIdApiType);
    }
    if (publicKey) {
      res["PublicKey"] = boost::any(*publicKey);
    }
    if (publicKeyId) {
      res["PublicKeyId"] = boost::any(*publicKeyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdTokenParamName") != m.end() && !m["IdTokenParamName"].empty()) {
      idTokenParamName = make_shared<string>(boost::any_cast<string>(m["IdTokenParamName"]));
    }
    if (m.find("OpenIdApiType") != m.end() && !m["OpenIdApiType"].empty()) {
      openIdApiType = make_shared<string>(boost::any_cast<string>(m["OpenIdApiType"]));
    }
    if (m.find("PublicKey") != m.end() && !m["PublicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["PublicKey"]));
    }
    if (m.find("PublicKeyId") != m.end() && !m["PublicKeyId"].empty()) {
      publicKeyId = make_shared<string>(boost::any_cast<string>(m["PublicKeyId"]));
    }
  }


  virtual ~DescribeHistoryApiResponseBodyOpenIdConnectConfig() = default;
};
class DescribeHistoryApiResponseBodyPathParametersPathParameter : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> serviceParameterName{};

  DescribeHistoryApiResponseBodyPathParametersPathParameter() {}

  explicit DescribeHistoryApiResponseBodyPathParametersPathParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeHistoryApiResponseBodyPathParametersPathParameter() = default;
};
class DescribeHistoryApiResponseBodyPathParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHistoryApiResponseBodyPathParametersPathParameter>> pathParameter{};

  DescribeHistoryApiResponseBodyPathParameters() {}

  explicit DescribeHistoryApiResponseBodyPathParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pathParameter) {
      vector<boost::any> temp1;
      for(auto item1:*pathParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PathParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PathParameter") != m.end() && !m["PathParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["PathParameter"].type()) {
        vector<DescribeHistoryApiResponseBodyPathParametersPathParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PathParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHistoryApiResponseBodyPathParametersPathParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pathParameter = make_shared<vector<DescribeHistoryApiResponseBodyPathParametersPathParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeHistoryApiResponseBodyPathParameters() = default;
};
class DescribeHistoryApiResponseBodyRequestBodyRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};
  shared_ptr<string> serviceParameterName{};

  DescribeHistoryApiResponseBodyRequestBodyRequestParam() {}

  explicit DescribeHistoryApiResponseBodyRequestBodyRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<string>(boost::any_cast<string>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeHistoryApiResponseBodyRequestBodyRequestParam() = default;
};
class DescribeHistoryApiResponseBodyRequestBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHistoryApiResponseBodyRequestBodyRequestParam>> requestParam{};

  DescribeHistoryApiResponseBodyRequestBody() {}

  explicit DescribeHistoryApiResponseBodyRequestBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParam) {
      vector<boost::any> temp1;
      for(auto item1:*requestParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParam"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParam") != m.end() && !m["RequestParam"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParam"].type()) {
        vector<DescribeHistoryApiResponseBodyRequestBodyRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHistoryApiResponseBodyRequestBodyRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParam = make_shared<vector<DescribeHistoryApiResponseBodyRequestBodyRequestParam>>(expect1);
      }
    }
  }


  virtual ~DescribeHistoryApiResponseBodyRequestBody() = default;
};
class DescribeHistoryApiResponseBodyRequestHeadersRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};
  shared_ptr<string> serviceParameterName{};

  DescribeHistoryApiResponseBodyRequestHeadersRequestParam() {}

  explicit DescribeHistoryApiResponseBodyRequestHeadersRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<string>(boost::any_cast<string>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeHistoryApiResponseBodyRequestHeadersRequestParam() = default;
};
class DescribeHistoryApiResponseBodyRequestHeaders : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHistoryApiResponseBodyRequestHeadersRequestParam>> requestParam{};

  DescribeHistoryApiResponseBodyRequestHeaders() {}

  explicit DescribeHistoryApiResponseBodyRequestHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParam) {
      vector<boost::any> temp1;
      for(auto item1:*requestParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParam"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParam") != m.end() && !m["RequestParam"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParam"].type()) {
        vector<DescribeHistoryApiResponseBodyRequestHeadersRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHistoryApiResponseBodyRequestHeadersRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParam = make_shared<vector<DescribeHistoryApiResponseBodyRequestHeadersRequestParam>>(expect1);
      }
    }
  }


  virtual ~DescribeHistoryApiResponseBodyRequestHeaders() = default;
};
class DescribeHistoryApiResponseBodyRequestQueriesRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};
  shared_ptr<string> serviceParameterName{};

  DescribeHistoryApiResponseBodyRequestQueriesRequestParam() {}

  explicit DescribeHistoryApiResponseBodyRequestQueriesRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<string>(boost::any_cast<string>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeHistoryApiResponseBodyRequestQueriesRequestParam() = default;
};
class DescribeHistoryApiResponseBodyRequestQueries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHistoryApiResponseBodyRequestQueriesRequestParam>> requestParam{};

  DescribeHistoryApiResponseBodyRequestQueries() {}

  explicit DescribeHistoryApiResponseBodyRequestQueries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParam) {
      vector<boost::any> temp1;
      for(auto item1:*requestParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParam"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParam") != m.end() && !m["RequestParam"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParam"].type()) {
        vector<DescribeHistoryApiResponseBodyRequestQueriesRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHistoryApiResponseBodyRequestQueriesRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParam = make_shared<vector<DescribeHistoryApiResponseBodyRequestQueriesRequestParam>>(expect1);
      }
    }
  }


  virtual ~DescribeHistoryApiResponseBodyRequestQueries() = default;
};
class DescribeHistoryApiResponseBodySystemParametersSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeHistoryApiResponseBodySystemParametersSystemParameter() {}

  explicit DescribeHistoryApiResponseBodySystemParametersSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeHistoryApiResponseBodySystemParametersSystemParameter() = default;
};
class DescribeHistoryApiResponseBodySystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHistoryApiResponseBodySystemParametersSystemParameter>> systemParameter{};

  DescribeHistoryApiResponseBodySystemParameters() {}

  explicit DescribeHistoryApiResponseBodySystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*systemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemParameter") != m.end() && !m["SystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemParameter"].type()) {
        vector<DescribeHistoryApiResponseBodySystemParametersSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHistoryApiResponseBodySystemParametersSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemParameter = make_shared<vector<DescribeHistoryApiResponseBodySystemParametersSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeHistoryApiResponseBodySystemParameters() = default;
};
class DescribeHistoryApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> allowSignatureMethod{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> authType{};
  shared_ptr<string> bodyFormat{};
  shared_ptr<DescribeHistoryApiResponseBodyConstantParameters> constantParameters{};
  shared_ptr<DescribeHistoryApiResponseBodyCustomSystemParameters> customSystemParameters{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<DescribeHistoryApiResponseBodyErrorCodeSamples> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<DescribeHistoryApiResponseBodyFunctionComputeConfig> functionComputeConfig{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> historyVersion{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> httpProtocol{};
  shared_ptr<string> mock{};
  shared_ptr<string> mockResult{};
  shared_ptr<DescribeHistoryApiResponseBodyOpenIdConnectConfig> openIdConnectConfig{};
  shared_ptr<string> originResultDescription{};
  shared_ptr<string> path{};
  shared_ptr<DescribeHistoryApiResponseBodyPathParameters> pathParameters{};
  shared_ptr<string> postBodyDescription{};
  shared_ptr<string> postBodyType{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeHistoryApiResponseBodyRequestBody> requestBody{};
  shared_ptr<DescribeHistoryApiResponseBodyRequestHeaders> requestHeaders{};
  shared_ptr<string> requestId{};
  shared_ptr<string> requestMode{};
  shared_ptr<DescribeHistoryApiResponseBodyRequestQueries> requestQueries{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<string> serviceAddress{};
  shared_ptr<string> serviceFCEnable{};
  shared_ptr<string> serviceProtocol{};
  shared_ptr<long> serviceTimeout{};
  shared_ptr<string> serviceVpcEnable{};
  shared_ptr<string> status{};
  shared_ptr<DescribeHistoryApiResponseBodySystemParameters> systemParameters{};
  shared_ptr<string> visibility{};
  shared_ptr<string> vpcName{};

  DescribeHistoryApiResponseBody() {}

  explicit DescribeHistoryApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowSignatureMethod) {
      res["AllowSignatureMethod"] = boost::any(*allowSignatureMethod);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (bodyFormat) {
      res["BodyFormat"] = boost::any(*bodyFormat);
    }
    if (constantParameters) {
      res["ConstantParameters"] = constantParameters ? boost::any(constantParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customSystemParameters) {
      res["CustomSystemParameters"] = customSystemParameters ? boost::any(customSystemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = errorCodeSamples ? boost::any(errorCodeSamples->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (functionComputeConfig) {
      res["FunctionComputeConfig"] = functionComputeConfig ? boost::any(functionComputeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (httpProtocol) {
      res["HttpProtocol"] = boost::any(*httpProtocol);
    }
    if (mock) {
      res["Mock"] = boost::any(*mock);
    }
    if (mockResult) {
      res["MockResult"] = boost::any(*mockResult);
    }
    if (openIdConnectConfig) {
      res["OpenIdConnectConfig"] = openIdConnectConfig ? boost::any(openIdConnectConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (originResultDescription) {
      res["OriginResultDescription"] = boost::any(*originResultDescription);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (pathParameters) {
      res["PathParameters"] = pathParameters ? boost::any(pathParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (postBodyDescription) {
      res["PostBodyDescription"] = boost::any(*postBodyDescription);
    }
    if (postBodyType) {
      res["PostBodyType"] = boost::any(*postBodyType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestBody) {
      res["RequestBody"] = requestBody ? boost::any(requestBody->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestHeaders) {
      res["RequestHeaders"] = requestHeaders ? boost::any(requestHeaders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestMode) {
      res["RequestMode"] = boost::any(*requestMode);
    }
    if (requestQueries) {
      res["RequestQueries"] = requestQueries ? boost::any(requestQueries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (serviceAddress) {
      res["ServiceAddress"] = boost::any(*serviceAddress);
    }
    if (serviceFCEnable) {
      res["ServiceFCEnable"] = boost::any(*serviceFCEnable);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    if (serviceTimeout) {
      res["ServiceTimeout"] = boost::any(*serviceTimeout);
    }
    if (serviceVpcEnable) {
      res["ServiceVpcEnable"] = boost::any(*serviceVpcEnable);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (systemParameters) {
      res["SystemParameters"] = systemParameters ? boost::any(systemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowSignatureMethod") != m.end() && !m["AllowSignatureMethod"].empty()) {
      allowSignatureMethod = make_shared<string>(boost::any_cast<string>(m["AllowSignatureMethod"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("BodyFormat") != m.end() && !m["BodyFormat"].empty()) {
      bodyFormat = make_shared<string>(boost::any_cast<string>(m["BodyFormat"]));
    }
    if (m.find("ConstantParameters") != m.end() && !m["ConstantParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConstantParameters"].type()) {
        DescribeHistoryApiResponseBodyConstantParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConstantParameters"]));
        constantParameters = make_shared<DescribeHistoryApiResponseBodyConstantParameters>(model1);
      }
    }
    if (m.find("CustomSystemParameters") != m.end() && !m["CustomSystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomSystemParameters"].type()) {
        DescribeHistoryApiResponseBodyCustomSystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomSystemParameters"]));
        customSystemParameters = make_shared<DescribeHistoryApiResponseBodyCustomSystemParameters>(model1);
      }
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorCodeSamples"].type()) {
        DescribeHistoryApiResponseBodyErrorCodeSamples model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorCodeSamples"]));
        errorCodeSamples = make_shared<DescribeHistoryApiResponseBodyErrorCodeSamples>(model1);
      }
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("FunctionComputeConfig") != m.end() && !m["FunctionComputeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionComputeConfig"].type()) {
        DescribeHistoryApiResponseBodyFunctionComputeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionComputeConfig"]));
        functionComputeConfig = make_shared<DescribeHistoryApiResponseBodyFunctionComputeConfig>(model1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("HttpProtocol") != m.end() && !m["HttpProtocol"].empty()) {
      httpProtocol = make_shared<string>(boost::any_cast<string>(m["HttpProtocol"]));
    }
    if (m.find("Mock") != m.end() && !m["Mock"].empty()) {
      mock = make_shared<string>(boost::any_cast<string>(m["Mock"]));
    }
    if (m.find("MockResult") != m.end() && !m["MockResult"].empty()) {
      mockResult = make_shared<string>(boost::any_cast<string>(m["MockResult"]));
    }
    if (m.find("OpenIdConnectConfig") != m.end() && !m["OpenIdConnectConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpenIdConnectConfig"].type()) {
        DescribeHistoryApiResponseBodyOpenIdConnectConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpenIdConnectConfig"]));
        openIdConnectConfig = make_shared<DescribeHistoryApiResponseBodyOpenIdConnectConfig>(model1);
      }
    }
    if (m.find("OriginResultDescription") != m.end() && !m["OriginResultDescription"].empty()) {
      originResultDescription = make_shared<string>(boost::any_cast<string>(m["OriginResultDescription"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("PathParameters") != m.end() && !m["PathParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathParameters"].type()) {
        DescribeHistoryApiResponseBodyPathParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathParameters"]));
        pathParameters = make_shared<DescribeHistoryApiResponseBodyPathParameters>(model1);
      }
    }
    if (m.find("PostBodyDescription") != m.end() && !m["PostBodyDescription"].empty()) {
      postBodyDescription = make_shared<string>(boost::any_cast<string>(m["PostBodyDescription"]));
    }
    if (m.find("PostBodyType") != m.end() && !m["PostBodyType"].empty()) {
      postBodyType = make_shared<string>(boost::any_cast<string>(m["PostBodyType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestBody") != m.end() && !m["RequestBody"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestBody"].type()) {
        DescribeHistoryApiResponseBodyRequestBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestBody"]));
        requestBody = make_shared<DescribeHistoryApiResponseBodyRequestBody>(model1);
      }
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestHeaders"].type()) {
        DescribeHistoryApiResponseBodyRequestHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestHeaders"]));
        requestHeaders = make_shared<DescribeHistoryApiResponseBodyRequestHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestMode") != m.end() && !m["RequestMode"].empty()) {
      requestMode = make_shared<string>(boost::any_cast<string>(m["RequestMode"]));
    }
    if (m.find("RequestQueries") != m.end() && !m["RequestQueries"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestQueries"].type()) {
        DescribeHistoryApiResponseBodyRequestQueries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestQueries"]));
        requestQueries = make_shared<DescribeHistoryApiResponseBodyRequestQueries>(model1);
      }
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("ServiceAddress") != m.end() && !m["ServiceAddress"].empty()) {
      serviceAddress = make_shared<string>(boost::any_cast<string>(m["ServiceAddress"]));
    }
    if (m.find("ServiceFCEnable") != m.end() && !m["ServiceFCEnable"].empty()) {
      serviceFCEnable = make_shared<string>(boost::any_cast<string>(m["ServiceFCEnable"]));
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
    if (m.find("ServiceTimeout") != m.end() && !m["ServiceTimeout"].empty()) {
      serviceTimeout = make_shared<long>(boost::any_cast<long>(m["ServiceTimeout"]));
    }
    if (m.find("ServiceVpcEnable") != m.end() && !m["ServiceVpcEnable"].empty()) {
      serviceVpcEnable = make_shared<string>(boost::any_cast<string>(m["ServiceVpcEnable"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SystemParameters") != m.end() && !m["SystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemParameters"].type()) {
        DescribeHistoryApiResponseBodySystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemParameters"]));
        systemParameters = make_shared<DescribeHistoryApiResponseBodySystemParameters>(model1);
      }
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
  }


  virtual ~DescribeHistoryApiResponseBody() = default;
};
class DescribeHistoryApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHistoryApiResponseBody> body{};

  DescribeHistoryApiResponse() {}

  explicit DescribeHistoryApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHistoryApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHistoryApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHistoryApiResponse() = default;
};
class DescribeHistoryApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeHistoryApisRequest() {}

  explicit DescribeHistoryApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeHistoryApisRequest() = default;
};
class DescribeHistoryApisResponseBodyApiInfosApiInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> historyVersion{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> status{};

  DescribeHistoryApisResponseBodyApiInfosApiInfo() {}

  explicit DescribeHistoryApisResponseBodyApiInfosApiInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeHistoryApisResponseBodyApiInfosApiInfo() = default;
};
class DescribeHistoryApisResponseBodyApiInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHistoryApisResponseBodyApiInfosApiInfo>> apiInfo{};

  DescribeHistoryApisResponseBodyApiInfos() {}

  explicit DescribeHistoryApisResponseBodyApiInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiInfo"].type()) {
        vector<DescribeHistoryApisResponseBodyApiInfosApiInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHistoryApisResponseBodyApiInfosApiInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiInfo = make_shared<vector<DescribeHistoryApisResponseBodyApiInfosApiInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeHistoryApisResponseBodyApiInfos() = default;
};
class DescribeHistoryApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeHistoryApisResponseBodyApiInfos> apiInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeHistoryApisResponseBody() {}

  explicit DescribeHistoryApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfos) {
      res["ApiInfos"] = apiInfos ? boost::any(apiInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfos") != m.end() && !m["ApiInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInfos"].type()) {
        DescribeHistoryApisResponseBodyApiInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInfos"]));
        apiInfos = make_shared<DescribeHistoryApisResponseBodyApiInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeHistoryApisResponseBody() = default;
};
class DescribeHistoryApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHistoryApisResponseBody> body{};

  DescribeHistoryApisResponse() {}

  explicit DescribeHistoryApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHistoryApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHistoryApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHistoryApisResponse() = default;
};
class DescribeIpControlPolicyItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> policyItemId{};
  shared_ptr<string> securityToken{};

  DescribeIpControlPolicyItemsRequest() {}

  explicit DescribeIpControlPolicyItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (policyItemId) {
      res["PolicyItemId"] = boost::any(*policyItemId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PolicyItemId") != m.end() && !m["PolicyItemId"].empty()) {
      policyItemId = make_shared<string>(boost::any_cast<string>(m["PolicyItemId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeIpControlPolicyItemsRequest() = default;
};
class DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> cidrIp{};
  shared_ptr<string> createTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> policyItemId{};

  DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem() {}

  explicit DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (policyItemId) {
      res["PolicyItemId"] = boost::any(*policyItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("PolicyItemId") != m.end() && !m["PolicyItemId"].empty()) {
      policyItemId = make_shared<string>(boost::any_cast<string>(m["PolicyItemId"]));
    }
  }


  virtual ~DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem() = default;
};
class DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem>> ipControlPolicyItem{};

  DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems() {}

  explicit DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlPolicyItem) {
      vector<boost::any> temp1;
      for(auto item1:*ipControlPolicyItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpControlPolicyItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlPolicyItem") != m.end() && !m["IpControlPolicyItem"].empty()) {
      if (typeid(vector<boost::any>) == m["IpControlPolicyItem"].type()) {
        vector<DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpControlPolicyItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipControlPolicyItem = make_shared<vector<DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem>>(expect1);
      }
    }
  }


  virtual ~DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems() = default;
};
class DescribeIpControlPolicyItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems> ipControlPolicyItems{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeIpControlPolicyItemsResponseBody() {}

  explicit DescribeIpControlPolicyItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlPolicyItems) {
      res["IpControlPolicyItems"] = ipControlPolicyItems ? boost::any(ipControlPolicyItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlPolicyItems") != m.end() && !m["IpControlPolicyItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpControlPolicyItems"].type()) {
        DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpControlPolicyItems"]));
        ipControlPolicyItems = make_shared<DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeIpControlPolicyItemsResponseBody() = default;
};
class DescribeIpControlPolicyItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIpControlPolicyItemsResponseBody> body{};

  DescribeIpControlPolicyItemsResponse() {}

  explicit DescribeIpControlPolicyItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIpControlPolicyItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIpControlPolicyItemsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIpControlPolicyItemsResponse() = default;
};
class DescribeIpControlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<string> ipControlName{};
  shared_ptr<string> ipControlType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeIpControlsRequest() {}

  explicit DescribeIpControlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (ipControlName) {
      res["IpControlName"] = boost::any(*ipControlName);
    }
    if (ipControlType) {
      res["IpControlType"] = boost::any(*ipControlType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("IpControlName") != m.end() && !m["IpControlName"].empty()) {
      ipControlName = make_shared<string>(boost::any_cast<string>(m["IpControlName"]));
    }
    if (m.find("IpControlType") != m.end() && !m["IpControlType"].empty()) {
      ipControlType = make_shared<string>(boost::any_cast<string>(m["IpControlType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeIpControlsRequest() = default;
};
class DescribeIpControlsResponseBodyIpControlInfosIpControlInfo : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> ipControlName{};
  shared_ptr<string> ipControlType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};

  DescribeIpControlsResponseBodyIpControlInfosIpControlInfo() {}

  explicit DescribeIpControlsResponseBodyIpControlInfosIpControlInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (ipControlName) {
      res["IpControlName"] = boost::any(*ipControlName);
    }
    if (ipControlType) {
      res["IpControlType"] = boost::any(*ipControlType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("IpControlName") != m.end() && !m["IpControlName"].empty()) {
      ipControlName = make_shared<string>(boost::any_cast<string>(m["IpControlName"]));
    }
    if (m.find("IpControlType") != m.end() && !m["IpControlType"].empty()) {
      ipControlType = make_shared<string>(boost::any_cast<string>(m["IpControlType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeIpControlsResponseBodyIpControlInfosIpControlInfo() = default;
};
class DescribeIpControlsResponseBodyIpControlInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIpControlsResponseBodyIpControlInfosIpControlInfo>> ipControlInfo{};

  DescribeIpControlsResponseBodyIpControlInfos() {}

  explicit DescribeIpControlsResponseBodyIpControlInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ipControlInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpControlInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlInfo") != m.end() && !m["IpControlInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["IpControlInfo"].type()) {
        vector<DescribeIpControlsResponseBodyIpControlInfosIpControlInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpControlInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpControlsResponseBodyIpControlInfosIpControlInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipControlInfo = make_shared<vector<DescribeIpControlsResponseBodyIpControlInfosIpControlInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeIpControlsResponseBodyIpControlInfos() = default;
};
class DescribeIpControlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeIpControlsResponseBodyIpControlInfos> ipControlInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeIpControlsResponseBody() {}

  explicit DescribeIpControlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlInfos) {
      res["IpControlInfos"] = ipControlInfos ? boost::any(ipControlInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlInfos") != m.end() && !m["IpControlInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpControlInfos"].type()) {
        DescribeIpControlsResponseBodyIpControlInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpControlInfos"]));
        ipControlInfos = make_shared<DescribeIpControlsResponseBodyIpControlInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeIpControlsResponseBody() = default;
};
class DescribeIpControlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIpControlsResponseBody> body{};

  DescribeIpControlsResponse() {}

  explicit DescribeIpControlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIpControlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIpControlsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIpControlsResponse() = default;
};
class DescribeLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> logType{};
  shared_ptr<string> securityToken{};

  DescribeLogConfigRequest() {}

  explicit DescribeLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLogConfigRequest() = default;
};
class DescribeLogConfigResponseBodyLogInfosLogInfo : public Darabonba::Model {
public:
  shared_ptr<string> logType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> slsLogStore{};
  shared_ptr<string> slsProject{};

  DescribeLogConfigResponseBodyLogInfosLogInfo() {}

  explicit DescribeLogConfigResponseBodyLogInfosLogInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (slsLogStore) {
      res["SlsLogStore"] = boost::any(*slsLogStore);
    }
    if (slsProject) {
      res["SlsProject"] = boost::any(*slsProject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SlsLogStore") != m.end() && !m["SlsLogStore"].empty()) {
      slsLogStore = make_shared<string>(boost::any_cast<string>(m["SlsLogStore"]));
    }
    if (m.find("SlsProject") != m.end() && !m["SlsProject"].empty()) {
      slsProject = make_shared<string>(boost::any_cast<string>(m["SlsProject"]));
    }
  }


  virtual ~DescribeLogConfigResponseBodyLogInfosLogInfo() = default;
};
class DescribeLogConfigResponseBodyLogInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLogConfigResponseBodyLogInfosLogInfo>> logInfo{};

  DescribeLogConfigResponseBodyLogInfos() {}

  explicit DescribeLogConfigResponseBodyLogInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfo) {
      vector<boost::any> temp1;
      for(auto item1:*logInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfo") != m.end() && !m["LogInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfo"].type()) {
        vector<DescribeLogConfigResponseBodyLogInfosLogInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLogConfigResponseBodyLogInfosLogInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfo = make_shared<vector<DescribeLogConfigResponseBodyLogInfosLogInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLogConfigResponseBodyLogInfos() = default;
};
class DescribeLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLogConfigResponseBodyLogInfos> logInfos{};
  shared_ptr<string> requestId{};

  DescribeLogConfigResponseBody() {}

  explicit DescribeLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfos) {
      res["LogInfos"] = logInfos ? boost::any(logInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfos") != m.end() && !m["LogInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogInfos"].type()) {
        DescribeLogConfigResponseBodyLogInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogInfos"]));
        logInfos = make_shared<DescribeLogConfigResponseBodyLogInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLogConfigResponseBody() = default;
};
class DescribeLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLogConfigResponseBody> body{};

  DescribeLogConfigResponse() {}

  explicit DescribeLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLogConfigResponse() = default;
};
class DescribePurchasedApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribePurchasedApiRequest() {}

  explicit DescribePurchasedApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribePurchasedApiRequest() = default;
};
class DescribePurchasedApiResponseBodyPathParametersPathParameter : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};

  DescribePurchasedApiResponseBodyPathParametersPathParameter() {}

  explicit DescribePurchasedApiResponseBodyPathParametersPathParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~DescribePurchasedApiResponseBodyPathParametersPathParameter() = default;
};
class DescribePurchasedApiResponseBodyPathParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePurchasedApiResponseBodyPathParametersPathParameter>> pathParameter{};

  DescribePurchasedApiResponseBodyPathParameters() {}

  explicit DescribePurchasedApiResponseBodyPathParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pathParameter) {
      vector<boost::any> temp1;
      for(auto item1:*pathParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PathParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PathParameter") != m.end() && !m["PathParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["PathParameter"].type()) {
        vector<DescribePurchasedApiResponseBodyPathParametersPathParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PathParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePurchasedApiResponseBodyPathParametersPathParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pathParameter = make_shared<vector<DescribePurchasedApiResponseBodyPathParametersPathParameter>>(expect1);
      }
    }
  }


  virtual ~DescribePurchasedApiResponseBodyPathParameters() = default;
};
class DescribePurchasedApiResponseBodyRequestBodyRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<long> maxLength{};
  shared_ptr<string> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<string> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};

  DescribePurchasedApiResponseBodyRequestBodyRequestParam() {}

  explicit DescribePurchasedApiResponseBodyRequestBodyRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<string>(boost::any_cast<string>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<string>(boost::any_cast<string>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<string>(boost::any_cast<string>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
  }


  virtual ~DescribePurchasedApiResponseBodyRequestBodyRequestParam() = default;
};
class DescribePurchasedApiResponseBodyRequestBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePurchasedApiResponseBodyRequestBodyRequestParam>> requestParam{};

  DescribePurchasedApiResponseBodyRequestBody() {}

  explicit DescribePurchasedApiResponseBodyRequestBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParam) {
      vector<boost::any> temp1;
      for(auto item1:*requestParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParam"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParam") != m.end() && !m["RequestParam"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParam"].type()) {
        vector<DescribePurchasedApiResponseBodyRequestBodyRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePurchasedApiResponseBodyRequestBodyRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParam = make_shared<vector<DescribePurchasedApiResponseBodyRequestBodyRequestParam>>(expect1);
      }
    }
  }


  virtual ~DescribePurchasedApiResponseBodyRequestBody() = default;
};
class DescribePurchasedApiResponseBodyRequestHeadersRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};

  DescribePurchasedApiResponseBodyRequestHeadersRequestParam() {}

  explicit DescribePurchasedApiResponseBodyRequestHeadersRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<string>(boost::any_cast<string>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
  }


  virtual ~DescribePurchasedApiResponseBodyRequestHeadersRequestParam() = default;
};
class DescribePurchasedApiResponseBodyRequestHeaders : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePurchasedApiResponseBodyRequestHeadersRequestParam>> requestParam{};

  DescribePurchasedApiResponseBodyRequestHeaders() {}

  explicit DescribePurchasedApiResponseBodyRequestHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParam) {
      vector<boost::any> temp1;
      for(auto item1:*requestParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParam"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParam") != m.end() && !m["RequestParam"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParam"].type()) {
        vector<DescribePurchasedApiResponseBodyRequestHeadersRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePurchasedApiResponseBodyRequestHeadersRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParam = make_shared<vector<DescribePurchasedApiResponseBodyRequestHeadersRequestParam>>(expect1);
      }
    }
  }


  virtual ~DescribePurchasedApiResponseBodyRequestHeaders() = default;
};
class DescribePurchasedApiResponseBodyRequestQueriesRequestParam : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<long> maxLength{};
  shared_ptr<string> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<string> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};

  DescribePurchasedApiResponseBodyRequestQueriesRequestParam() {}

  explicit DescribePurchasedApiResponseBodyRequestQueriesRequestParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<string>(boost::any_cast<string>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<string>(boost::any_cast<string>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<string>(boost::any_cast<string>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
  }


  virtual ~DescribePurchasedApiResponseBodyRequestQueriesRequestParam() = default;
};
class DescribePurchasedApiResponseBodyRequestQueries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePurchasedApiResponseBodyRequestQueriesRequestParam>> requestParam{};

  DescribePurchasedApiResponseBodyRequestQueries() {}

  explicit DescribePurchasedApiResponseBodyRequestQueries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParam) {
      vector<boost::any> temp1;
      for(auto item1:*requestParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParam"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParam") != m.end() && !m["RequestParam"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParam"].type()) {
        vector<DescribePurchasedApiResponseBodyRequestQueriesRequestParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePurchasedApiResponseBodyRequestQueriesRequestParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParam = make_shared<vector<DescribePurchasedApiResponseBodyRequestQueriesRequestParam>>(expect1);
      }
    }
  }


  virtual ~DescribePurchasedApiResponseBodyRequestQueries() = default;
};
class DescribePurchasedApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> bodyFormat{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> httpProtocol{};
  shared_ptr<string> mock{};
  shared_ptr<string> mockResult{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> path{};
  shared_ptr<DescribePurchasedApiResponseBodyPathParameters> pathParameters{};
  shared_ptr<string> postBodyDescription{};
  shared_ptr<string> postBodyType{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribePurchasedApiResponseBodyRequestBody> requestBody{};
  shared_ptr<DescribePurchasedApiResponseBodyRequestHeaders> requestHeaders{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribePurchasedApiResponseBodyRequestQueries> requestQueries{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<string> visibility{};

  DescribePurchasedApiResponseBody() {}

  explicit DescribePurchasedApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (bodyFormat) {
      res["BodyFormat"] = boost::any(*bodyFormat);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (httpProtocol) {
      res["HttpProtocol"] = boost::any(*httpProtocol);
    }
    if (mock) {
      res["Mock"] = boost::any(*mock);
    }
    if (mockResult) {
      res["MockResult"] = boost::any(*mockResult);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (pathParameters) {
      res["PathParameters"] = pathParameters ? boost::any(pathParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (postBodyDescription) {
      res["PostBodyDescription"] = boost::any(*postBodyDescription);
    }
    if (postBodyType) {
      res["PostBodyType"] = boost::any(*postBodyType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestBody) {
      res["RequestBody"] = requestBody ? boost::any(requestBody->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestHeaders) {
      res["RequestHeaders"] = requestHeaders ? boost::any(requestHeaders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestQueries) {
      res["RequestQueries"] = requestQueries ? boost::any(requestQueries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("BodyFormat") != m.end() && !m["BodyFormat"].empty()) {
      bodyFormat = make_shared<string>(boost::any_cast<string>(m["BodyFormat"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("HttpProtocol") != m.end() && !m["HttpProtocol"].empty()) {
      httpProtocol = make_shared<string>(boost::any_cast<string>(m["HttpProtocol"]));
    }
    if (m.find("Mock") != m.end() && !m["Mock"].empty()) {
      mock = make_shared<string>(boost::any_cast<string>(m["Mock"]));
    }
    if (m.find("MockResult") != m.end() && !m["MockResult"].empty()) {
      mockResult = make_shared<string>(boost::any_cast<string>(m["MockResult"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("PathParameters") != m.end() && !m["PathParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathParameters"].type()) {
        DescribePurchasedApiResponseBodyPathParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathParameters"]));
        pathParameters = make_shared<DescribePurchasedApiResponseBodyPathParameters>(model1);
      }
    }
    if (m.find("PostBodyDescription") != m.end() && !m["PostBodyDescription"].empty()) {
      postBodyDescription = make_shared<string>(boost::any_cast<string>(m["PostBodyDescription"]));
    }
    if (m.find("PostBodyType") != m.end() && !m["PostBodyType"].empty()) {
      postBodyType = make_shared<string>(boost::any_cast<string>(m["PostBodyType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestBody") != m.end() && !m["RequestBody"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestBody"].type()) {
        DescribePurchasedApiResponseBodyRequestBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestBody"]));
        requestBody = make_shared<DescribePurchasedApiResponseBodyRequestBody>(model1);
      }
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestHeaders"].type()) {
        DescribePurchasedApiResponseBodyRequestHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestHeaders"]));
        requestHeaders = make_shared<DescribePurchasedApiResponseBodyRequestHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestQueries") != m.end() && !m["RequestQueries"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestQueries"].type()) {
        DescribePurchasedApiResponseBodyRequestQueries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestQueries"]));
        requestQueries = make_shared<DescribePurchasedApiResponseBodyRequestQueries>(model1);
      }
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribePurchasedApiResponseBody() = default;
};
class DescribePurchasedApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePurchasedApiResponseBody> body{};

  DescribePurchasedApiResponse() {}

  explicit DescribePurchasedApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePurchasedApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePurchasedApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePurchasedApiResponse() = default;
};
class DescribePurchasedApiGroupDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribePurchasedApiGroupDetailRequest() {}

  explicit DescribePurchasedApiGroupDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribePurchasedApiGroupDetailRequest() = default;
};
class DescribePurchasedApiGroupDetailResponseBodyDomainItemsDomainItem : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  DescribePurchasedApiGroupDetailResponseBodyDomainItemsDomainItem() {}

  explicit DescribePurchasedApiGroupDetailResponseBodyDomainItemsDomainItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribePurchasedApiGroupDetailResponseBodyDomainItemsDomainItem() = default;
};
class DescribePurchasedApiGroupDetailResponseBodyDomainItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePurchasedApiGroupDetailResponseBodyDomainItemsDomainItem>> domainItem{};

  DescribePurchasedApiGroupDetailResponseBodyDomainItems() {}

  explicit DescribePurchasedApiGroupDetailResponseBodyDomainItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainItem) {
      vector<boost::any> temp1;
      for(auto item1:*domainItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainItem") != m.end() && !m["DomainItem"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainItem"].type()) {
        vector<DescribePurchasedApiGroupDetailResponseBodyDomainItemsDomainItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePurchasedApiGroupDetailResponseBodyDomainItemsDomainItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainItem = make_shared<vector<DescribePurchasedApiGroupDetailResponseBodyDomainItemsDomainItem>>(expect1);
      }
    }
  }


  virtual ~DescribePurchasedApiGroupDetailResponseBodyDomainItems() = default;
};
class DescribePurchasedApiGroupDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<DescribePurchasedApiGroupDetailResponseBodyDomainItems> domainItems{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribePurchasedApiGroupDetailResponseBody() {}

  explicit DescribePurchasedApiGroupDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainItems) {
      res["DomainItems"] = domainItems ? boost::any(domainItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainItems") != m.end() && !m["DomainItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainItems"].type()) {
        DescribePurchasedApiGroupDetailResponseBodyDomainItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainItems"]));
        domainItems = make_shared<DescribePurchasedApiGroupDetailResponseBodyDomainItems>(model1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribePurchasedApiGroupDetailResponseBody() = default;
};
class DescribePurchasedApiGroupDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePurchasedApiGroupDetailResponseBody> body{};

  DescribePurchasedApiGroupDetailResponse() {}

  explicit DescribePurchasedApiGroupDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePurchasedApiGroupDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePurchasedApiGroupDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePurchasedApiGroupDetailResponse() = default;
};
class DescribePurchasedApiGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribePurchasedApiGroupsRequest() {}

  explicit DescribePurchasedApiGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribePurchasedApiGroupsRequest() = default;
};
class DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute : public Darabonba::Model {
public:
  shared_ptr<string> billingType{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> groupDescription{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> invokeTimesMax{};
  shared_ptr<long> invokeTimesNow{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};

  DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute() {}

  explicit DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billingType) {
      res["BillingType"] = boost::any(*billingType);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (groupDescription) {
      res["GroupDescription"] = boost::any(*groupDescription);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (invokeTimesMax) {
      res["InvokeTimesMax"] = boost::any(*invokeTimesMax);
    }
    if (invokeTimesNow) {
      res["InvokeTimesNow"] = boost::any(*invokeTimesNow);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillingType") != m.end() && !m["BillingType"].empty()) {
      billingType = make_shared<string>(boost::any_cast<string>(m["BillingType"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("GroupDescription") != m.end() && !m["GroupDescription"].empty()) {
      groupDescription = make_shared<string>(boost::any_cast<string>(m["GroupDescription"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InvokeTimesMax") != m.end() && !m["InvokeTimesMax"].empty()) {
      invokeTimesMax = make_shared<long>(boost::any_cast<long>(m["InvokeTimesMax"]));
    }
    if (m.find("InvokeTimesNow") != m.end() && !m["InvokeTimesNow"].empty()) {
      invokeTimesNow = make_shared<long>(boost::any_cast<long>(m["InvokeTimesNow"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute() = default;
};
class DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute>> purchasedApiGroupAttribute{};

  DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes() {}

  explicit DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (purchasedApiGroupAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*purchasedApiGroupAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PurchasedApiGroupAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PurchasedApiGroupAttribute") != m.end() && !m["PurchasedApiGroupAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["PurchasedApiGroupAttribute"].type()) {
        vector<DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PurchasedApiGroupAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        purchasedApiGroupAttribute = make_shared<vector<DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes() = default;
};
class DescribePurchasedApiGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes> purchasedApiGroupAttributes{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePurchasedApiGroupsResponseBody() {}

  explicit DescribePurchasedApiGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (purchasedApiGroupAttributes) {
      res["PurchasedApiGroupAttributes"] = purchasedApiGroupAttributes ? boost::any(purchasedApiGroupAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PurchasedApiGroupAttributes") != m.end() && !m["PurchasedApiGroupAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["PurchasedApiGroupAttributes"].type()) {
        DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PurchasedApiGroupAttributes"]));
        purchasedApiGroupAttributes = make_shared<DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePurchasedApiGroupsResponseBody() = default;
};
class DescribePurchasedApiGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePurchasedApiGroupsResponseBody> body{};

  DescribePurchasedApiGroupsResponse() {}

  explicit DescribePurchasedApiGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePurchasedApiGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePurchasedApiGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePurchasedApiGroupsResponse() = default;
};
class DescribePurchasedApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribePurchasedApisRequest() {}

  explicit DescribePurchasedApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribePurchasedApisRequest() = default;
};
class DescribePurchasedApisResponseBodyApiInfosApiInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribePurchasedApisResponseBodyApiInfosApiInfo() {}

  explicit DescribePurchasedApisResponseBodyApiInfosApiInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribePurchasedApisResponseBodyApiInfosApiInfo() = default;
};
class DescribePurchasedApisResponseBodyApiInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePurchasedApisResponseBodyApiInfosApiInfo>> apiInfo{};

  DescribePurchasedApisResponseBodyApiInfos() {}

  explicit DescribePurchasedApisResponseBodyApiInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiInfo"].type()) {
        vector<DescribePurchasedApisResponseBodyApiInfosApiInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePurchasedApisResponseBodyApiInfosApiInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiInfo = make_shared<vector<DescribePurchasedApisResponseBodyApiInfosApiInfo>>(expect1);
      }
    }
  }


  virtual ~DescribePurchasedApisResponseBodyApiInfos() = default;
};
class DescribePurchasedApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePurchasedApisResponseBodyApiInfos> apiInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePurchasedApisResponseBody() {}

  explicit DescribePurchasedApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfos) {
      res["ApiInfos"] = apiInfos ? boost::any(apiInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfos") != m.end() && !m["ApiInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInfos"].type()) {
        DescribePurchasedApisResponseBodyApiInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInfos"]));
        apiInfos = make_shared<DescribePurchasedApisResponseBodyApiInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePurchasedApisResponseBody() = default;
};
class DescribePurchasedApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePurchasedApisResponseBody> body{};

  DescribePurchasedApisResponse() {}

  explicit DescribePurchasedApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePurchasedApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePurchasedApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePurchasedApisResponse() = default;
};
class DescribeRaceWorkForInnerRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribeRaceWorkForInnerRequest() {}

  explicit DescribeRaceWorkForInnerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeRaceWorkForInnerRequest() = default;
};
class DescribeRaceWorkForInnerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> createTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> keywords{};
  shared_ptr<string> logoUrl{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> shortDescription{};
  shared_ptr<string> workName{};

  DescribeRaceWorkForInnerResponseBody() {}

  explicit DescribeRaceWorkForInnerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (logoUrl) {
      res["LogoUrl"] = boost::any(*logoUrl);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (shortDescription) {
      res["ShortDescription"] = boost::any(*shortDescription);
    }
    if (workName) {
      res["WorkName"] = boost::any(*workName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywords = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
    if (m.find("LogoUrl") != m.end() && !m["LogoUrl"].empty()) {
      logoUrl = make_shared<string>(boost::any_cast<string>(m["LogoUrl"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ShortDescription") != m.end() && !m["ShortDescription"].empty()) {
      shortDescription = make_shared<string>(boost::any_cast<string>(m["ShortDescription"]));
    }
    if (m.find("WorkName") != m.end() && !m["WorkName"].empty()) {
      workName = make_shared<string>(boost::any_cast<string>(m["WorkName"]));
    }
  }


  virtual ~DescribeRaceWorkForInnerResponseBody() = default;
};
class DescribeRaceWorkForInnerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRaceWorkForInnerResponseBody> body{};

  DescribeRaceWorkForInnerResponse() {}

  explicit DescribeRaceWorkForInnerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRaceWorkForInnerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRaceWorkForInnerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRaceWorkForInnerResponse() = default;
};
class DescribeRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> language{};
  shared_ptr<string> securityToken{};

  DescribeRegionsRequest() {}

  explicit DescribeRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeRegionsRequest() = default;
};
class DescribeRegionsResponseBodyRegionsRegion : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionEndpoint{};
  shared_ptr<string> regionId{};

  DescribeRegionsResponseBodyRegionsRegion() {}

  explicit DescribeRegionsResponseBodyRegionsRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionEndpoint) {
      res["RegionEndpoint"] = boost::any(*regionEndpoint);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionEndpoint") != m.end() && !m["RegionEndpoint"].empty()) {
      regionEndpoint = make_shared<string>(boost::any_cast<string>(m["RegionEndpoint"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsResponseBodyRegionsRegion() = default;
};
class DescribeRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRegionsResponseBodyRegionsRegion>> region{};

  DescribeRegionsResponseBodyRegions() {}

  explicit DescribeRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      vector<boost::any> temp1;
      for(auto item1:*region){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Region"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      if (typeid(vector<boost::any>) == m["Region"].type()) {
        vector<DescribeRegionsResponseBodyRegionsRegion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Region"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionsResponseBodyRegionsRegion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        region = make_shared<vector<DescribeRegionsResponseBodyRegionsRegion>>(expect1);
      }
    }
  }


  virtual ~DescribeRegionsResponseBodyRegions() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeRegionsResponseBodyRegions> regions{};
  shared_ptr<string> requestId{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      res["Regions"] = regions ? boost::any(regions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Regions"].type()) {
        DescribeRegionsResponseBodyRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Regions"]));
        regions = make_shared<DescribeRegionsResponseBodyRegions>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class DescribeRulesByApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeRulesByApiRequest() {}

  explicit DescribeRulesByApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeRulesByApiRequest() = default;
};
class DescribeRulesByApiResponseBodyRulesRule : public Darabonba::Model {
public:
  shared_ptr<long> createdTime{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleType{};

  DescribeRulesByApiResponseBodyRulesRule() {}

  explicit DescribeRulesByApiResponseBodyRulesRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
  }


  virtual ~DescribeRulesByApiResponseBodyRulesRule() = default;
};
class DescribeRulesByApiResponseBodyRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRulesByApiResponseBodyRulesRule>> rule{};

  DescribeRulesByApiResponseBodyRules() {}

  explicit DescribeRulesByApiResponseBodyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rule) {
      vector<boost::any> temp1;
      for(auto item1:*rule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(vector<boost::any>) == m["Rule"].type()) {
        vector<DescribeRulesByApiResponseBodyRulesRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRulesByApiResponseBodyRulesRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rule = make_shared<vector<DescribeRulesByApiResponseBodyRulesRule>>(expect1);
      }
    }
  }


  virtual ~DescribeRulesByApiResponseBodyRules() = default;
};
class DescribeRulesByApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRulesByApiResponseBodyRules> rules{};

  DescribeRulesByApiResponseBody() {}

  explicit DescribeRulesByApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rules) {
      res["Rules"] = rules ? boost::any(rules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rules"].type()) {
        DescribeRulesByApiResponseBodyRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rules"]));
        rules = make_shared<DescribeRulesByApiResponseBodyRules>(model1);
      }
    }
  }


  virtual ~DescribeRulesByApiResponseBody() = default;
};
class DescribeRulesByApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRulesByApiResponseBody> body{};

  DescribeRulesByApiResponse() {}

  explicit DescribeRulesByApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRulesByApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRulesByApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRulesByApiResponse() = default;
};
class DescribeSecretKeysRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> secretKeyId{};
  shared_ptr<string> secretKeyName{};
  shared_ptr<string> securityToken{};

  DescribeSecretKeysRequest() {}

  explicit DescribeSecretKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (secretKeyId) {
      res["SecretKeyId"] = boost::any(*secretKeyId);
    }
    if (secretKeyName) {
      res["SecretKeyName"] = boost::any(*secretKeyName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecretKeyId") != m.end() && !m["SecretKeyId"].empty()) {
      secretKeyId = make_shared<string>(boost::any_cast<string>(m["SecretKeyId"]));
    }
    if (m.find("SecretKeyName") != m.end() && !m["SecretKeyName"].empty()) {
      secretKeyName = make_shared<string>(boost::any_cast<string>(m["SecretKeyName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeSecretKeysRequest() = default;
};
class DescribeSecretKeysResponseBodySecretKeysSecretKey : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> secretKey{};
  shared_ptr<string> secretKeyId{};
  shared_ptr<string> secretKeyName{};
  shared_ptr<string> secretKeyValue{};

  DescribeSecretKeysResponseBodySecretKeysSecretKey() {}

  explicit DescribeSecretKeysResponseBodySecretKeysSecretKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (secretKeyId) {
      res["SecretKeyId"] = boost::any(*secretKeyId);
    }
    if (secretKeyName) {
      res["SecretKeyName"] = boost::any(*secretKeyName);
    }
    if (secretKeyValue) {
      res["SecretKeyValue"] = boost::any(*secretKeyValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("SecretKeyId") != m.end() && !m["SecretKeyId"].empty()) {
      secretKeyId = make_shared<string>(boost::any_cast<string>(m["SecretKeyId"]));
    }
    if (m.find("SecretKeyName") != m.end() && !m["SecretKeyName"].empty()) {
      secretKeyName = make_shared<string>(boost::any_cast<string>(m["SecretKeyName"]));
    }
    if (m.find("SecretKeyValue") != m.end() && !m["SecretKeyValue"].empty()) {
      secretKeyValue = make_shared<string>(boost::any_cast<string>(m["SecretKeyValue"]));
    }
  }


  virtual ~DescribeSecretKeysResponseBodySecretKeysSecretKey() = default;
};
class DescribeSecretKeysResponseBodySecretKeys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecretKeysResponseBodySecretKeysSecretKey>> secretKey{};

  DescribeSecretKeysResponseBodySecretKeys() {}

  explicit DescribeSecretKeysResponseBodySecretKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (secretKey) {
      vector<boost::any> temp1;
      for(auto item1:*secretKey){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecretKey"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      if (typeid(vector<boost::any>) == m["SecretKey"].type()) {
        vector<DescribeSecretKeysResponseBodySecretKeysSecretKey> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecretKey"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecretKeysResponseBodySecretKeysSecretKey model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        secretKey = make_shared<vector<DescribeSecretKeysResponseBodySecretKeysSecretKey>>(expect1);
      }
    }
  }


  virtual ~DescribeSecretKeysResponseBodySecretKeys() = default;
};
class DescribeSecretKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSecretKeysResponseBodySecretKeys> secretKeys{};
  shared_ptr<long> totalCount{};

  DescribeSecretKeysResponseBody() {}

  explicit DescribeSecretKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (secretKeys) {
      res["SecretKeys"] = secretKeys ? boost::any(secretKeys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecretKeys") != m.end() && !m["SecretKeys"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecretKeys"].type()) {
        DescribeSecretKeysResponseBodySecretKeys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecretKeys"]));
        secretKeys = make_shared<DescribeSecretKeysResponseBodySecretKeys>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSecretKeysResponseBody() = default;
};
class DescribeSecretKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSecretKeysResponseBody> body{};

  DescribeSecretKeysResponse() {}

  explicit DescribeSecretKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecretKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecretKeysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecretKeysResponse() = default;
};
class DescribeSystemParametersRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};

  DescribeSystemParametersRequest() {}

  explicit DescribeSystemParametersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeSystemParametersRequest() = default;
};
class DescribeSystemParametersResponseBodySystemParametersSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> paramName{};
  shared_ptr<string> paramType{};

  DescribeSystemParametersResponseBodySystemParametersSystemParameter() {}

  explicit DescribeSystemParametersResponseBodySystemParametersSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (paramName) {
      res["ParamName"] = boost::any(*paramName);
    }
    if (paramType) {
      res["ParamType"] = boost::any(*paramType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ParamName") != m.end() && !m["ParamName"].empty()) {
      paramName = make_shared<string>(boost::any_cast<string>(m["ParamName"]));
    }
    if (m.find("ParamType") != m.end() && !m["ParamType"].empty()) {
      paramType = make_shared<string>(boost::any_cast<string>(m["ParamType"]));
    }
  }


  virtual ~DescribeSystemParametersResponseBodySystemParametersSystemParameter() = default;
};
class DescribeSystemParametersResponseBodySystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSystemParametersResponseBodySystemParametersSystemParameter>> systemParameter{};

  DescribeSystemParametersResponseBodySystemParameters() {}

  explicit DescribeSystemParametersResponseBodySystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*systemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemParameter") != m.end() && !m["SystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemParameter"].type()) {
        vector<DescribeSystemParametersResponseBodySystemParametersSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSystemParametersResponseBodySystemParametersSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemParameter = make_shared<vector<DescribeSystemParametersResponseBodySystemParametersSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeSystemParametersResponseBodySystemParameters() = default;
};
class DescribeSystemParametersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSystemParametersResponseBodySystemParameters> systemParameters{};

  DescribeSystemParametersResponseBody() {}

  explicit DescribeSystemParametersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (systemParameters) {
      res["SystemParameters"] = systemParameters ? boost::any(systemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SystemParameters") != m.end() && !m["SystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemParameters"].type()) {
        DescribeSystemParametersResponseBodySystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemParameters"]));
        systemParameters = make_shared<DescribeSystemParametersResponseBodySystemParameters>(model1);
      }
    }
  }


  virtual ~DescribeSystemParametersResponseBody() = default;
};
class DescribeSystemParametersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSystemParametersResponseBody> body{};

  DescribeSystemParametersResponse() {}

  explicit DescribeSystemParametersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSystemParametersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSystemParametersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSystemParametersResponse() = default;
};
class DescribeSystemParamsRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};

  DescribeSystemParamsRequest() {}

  explicit DescribeSystemParamsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeSystemParamsRequest() = default;
};
class DescribeSystemParamsResponseBodySystemParamsSystemParam : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> paramName{};
  shared_ptr<string> paramType{};

  DescribeSystemParamsResponseBodySystemParamsSystemParam() {}

  explicit DescribeSystemParamsResponseBodySystemParamsSystemParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (paramName) {
      res["ParamName"] = boost::any(*paramName);
    }
    if (paramType) {
      res["ParamType"] = boost::any(*paramType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ParamName") != m.end() && !m["ParamName"].empty()) {
      paramName = make_shared<string>(boost::any_cast<string>(m["ParamName"]));
    }
    if (m.find("ParamType") != m.end() && !m["ParamType"].empty()) {
      paramType = make_shared<string>(boost::any_cast<string>(m["ParamType"]));
    }
  }


  virtual ~DescribeSystemParamsResponseBodySystemParamsSystemParam() = default;
};
class DescribeSystemParamsResponseBodySystemParams : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSystemParamsResponseBodySystemParamsSystemParam>> systemParam{};

  DescribeSystemParamsResponseBodySystemParams() {}

  explicit DescribeSystemParamsResponseBodySystemParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemParam) {
      vector<boost::any> temp1;
      for(auto item1:*systemParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemParam"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemParam") != m.end() && !m["SystemParam"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemParam"].type()) {
        vector<DescribeSystemParamsResponseBodySystemParamsSystemParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSystemParamsResponseBodySystemParamsSystemParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemParam = make_shared<vector<DescribeSystemParamsResponseBodySystemParamsSystemParam>>(expect1);
      }
    }
  }


  virtual ~DescribeSystemParamsResponseBodySystemParams() = default;
};
class DescribeSystemParamsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSystemParamsResponseBodySystemParams> systemParams{};

  DescribeSystemParamsResponseBody() {}

  explicit DescribeSystemParamsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (systemParams) {
      res["SystemParams"] = systemParams ? boost::any(systemParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SystemParams") != m.end() && !m["SystemParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemParams"].type()) {
        DescribeSystemParamsResponseBodySystemParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemParams"]));
        systemParams = make_shared<DescribeSystemParamsResponseBodySystemParams>(model1);
      }
    }
  }


  virtual ~DescribeSystemParamsResponseBody() = default;
};
class DescribeSystemParamsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSystemParamsResponseBody> body{};

  DescribeSystemParamsResponse() {}

  explicit DescribeSystemParamsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSystemParamsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSystemParamsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSystemParamsResponse() = default;
};
class DescribeTrafficControlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiUid{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> trafficControlId{};
  shared_ptr<string> trafficControlName{};

  DescribeTrafficControlsRequest() {}

  explicit DescribeTrafficControlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    if (trafficControlName) {
      res["TrafficControlName"] = boost::any(*trafficControlName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
    if (m.find("TrafficControlName") != m.end() && !m["TrafficControlName"].empty()) {
      trafficControlName = make_shared<string>(boost::any_cast<string>(m["TrafficControlName"]));
    }
  }


  virtual ~DescribeTrafficControlsRequest() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial : public Darabonba::Model {
public:
  shared_ptr<string> specialKey{};
  shared_ptr<long> trafficValue{};

  DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (specialKey) {
      res["SpecialKey"] = boost::any(*specialKey);
    }
    if (trafficValue) {
      res["TrafficValue"] = boost::any(*trafficValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpecialKey") != m.end() && !m["SpecialKey"].empty()) {
      specialKey = make_shared<string>(boost::any_cast<string>(m["SpecialKey"]));
    }
    if (m.find("TrafficValue") != m.end() && !m["TrafficValue"].empty()) {
      trafficValue = make_shared<long>(boost::any_cast<long>(m["TrafficValue"]));
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial>> special{};

  DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (special) {
      vector<boost::any> temp1;
      for(auto item1:*special){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Special"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Special") != m.end() && !m["Special"].empty()) {
      if (typeid(vector<boost::any>) == m["Special"].type()) {
        vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Special"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        special = make_shared<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial>>(expect1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy : public Darabonba::Model {
public:
  shared_ptr<string> specialType{};
  shared_ptr<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials> specials{};

  DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (specialType) {
      res["SpecialType"] = boost::any(*specialType);
    }
    if (specials) {
      res["Specials"] = specials ? boost::any(specials->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpecialType") != m.end() && !m["SpecialType"].empty()) {
      specialType = make_shared<string>(boost::any_cast<string>(m["SpecialType"]));
    }
    if (m.find("Specials") != m.end() && !m["Specials"].empty()) {
      if (typeid(map<string, boost::any>) == m["Specials"].type()) {
        DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Specials"]));
        specials = make_shared<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials>(model1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy>> specialPolicy{};

  DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (specialPolicy) {
      vector<boost::any> temp1;
      for(auto item1:*specialPolicy){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecialPolicy"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpecialPolicy") != m.end() && !m["SpecialPolicy"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecialPolicy"].type()) {
        vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecialPolicy"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specialPolicy = make_shared<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy>>(expect1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl : public Darabonba::Model {
public:
  shared_ptr<long> apiDefault{};
  shared_ptr<long> appDefault{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies> specialPolicies{};
  shared_ptr<string> trafficControlId{};
  shared_ptr<string> trafficControlName{};
  shared_ptr<string> trafficControlUnit{};
  shared_ptr<long> userDefault{};

  DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiDefault) {
      res["ApiDefault"] = boost::any(*apiDefault);
    }
    if (appDefault) {
      res["AppDefault"] = boost::any(*appDefault);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (specialPolicies) {
      res["SpecialPolicies"] = specialPolicies ? boost::any(specialPolicies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    if (trafficControlName) {
      res["TrafficControlName"] = boost::any(*trafficControlName);
    }
    if (trafficControlUnit) {
      res["TrafficControlUnit"] = boost::any(*trafficControlUnit);
    }
    if (userDefault) {
      res["UserDefault"] = boost::any(*userDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiDefault") != m.end() && !m["ApiDefault"].empty()) {
      apiDefault = make_shared<long>(boost::any_cast<long>(m["ApiDefault"]));
    }
    if (m.find("AppDefault") != m.end() && !m["AppDefault"].empty()) {
      appDefault = make_shared<long>(boost::any_cast<long>(m["AppDefault"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("SpecialPolicies") != m.end() && !m["SpecialPolicies"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpecialPolicies"].type()) {
        DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpecialPolicies"]));
        specialPolicies = make_shared<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies>(model1);
      }
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
    if (m.find("TrafficControlName") != m.end() && !m["TrafficControlName"].empty()) {
      trafficControlName = make_shared<string>(boost::any_cast<string>(m["TrafficControlName"]));
    }
    if (m.find("TrafficControlUnit") != m.end() && !m["TrafficControlUnit"].empty()) {
      trafficControlUnit = make_shared<string>(boost::any_cast<string>(m["TrafficControlUnit"]));
    }
    if (m.find("UserDefault") != m.end() && !m["UserDefault"].empty()) {
      userDefault = make_shared<long>(boost::any_cast<long>(m["UserDefault"]));
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControls : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl>> trafficControl{};

  DescribeTrafficControlsResponseBodyTrafficControls() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trafficControl) {
      vector<boost::any> temp1;
      for(auto item1:*trafficControl){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TrafficControl"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrafficControl") != m.end() && !m["TrafficControl"].empty()) {
      if (typeid(vector<boost::any>) == m["TrafficControl"].type()) {
        vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TrafficControl"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trafficControl = make_shared<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl>>(expect1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControls() = default;
};
class DescribeTrafficControlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeTrafficControlsResponseBodyTrafficControls> trafficControls{};

  DescribeTrafficControlsResponseBody() {}

  explicit DescribeTrafficControlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (trafficControls) {
      res["TrafficControls"] = trafficControls ? boost::any(trafficControls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TrafficControls") != m.end() && !m["TrafficControls"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficControls"].type()) {
        DescribeTrafficControlsResponseBodyTrafficControls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficControls"]));
        trafficControls = make_shared<DescribeTrafficControlsResponseBodyTrafficControls>(model1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponseBody() = default;
};
class DescribeTrafficControlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTrafficControlsResponseBody> body{};

  DescribeTrafficControlsResponse() {}

  explicit DescribeTrafficControlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTrafficControlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTrafficControlsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponse() = default;
};
class GetApiMethodsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiPath{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  GetApiMethodsRequest() {}

  explicit GetApiMethodsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~GetApiMethodsRequest() = default;
};
class GetApiMethodsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> methods{};
  shared_ptr<string> requestId{};

  GetApiMethodsResponseBody() {}

  explicit GetApiMethodsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (methods) {
      res["Methods"] = boost::any(*methods);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Methods") != m.end() && !m["Methods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Methods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Methods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      methods = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetApiMethodsResponseBody() = default;
};
class GetApiMethodsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetApiMethodsResponseBody> body{};

  GetApiMethodsResponse() {}

  explicit GetApiMethodsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetApiMethodsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetApiMethodsResponseBody>(model1);
      }
    }
  }


  virtual ~GetApiMethodsResponse() = default;
};
class GetCustomizedInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};

  GetCustomizedInfoRequest() {}

  explicit GetCustomizedInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~GetCustomizedInfoRequest() = default;
};
class GetCustomizedInfoResponseBodySdkDemosSdkDemo : public Darabonba::Model {
public:
  shared_ptr<string> callDemo{};
  shared_ptr<string> ideKey{};

  GetCustomizedInfoResponseBodySdkDemosSdkDemo() {}

  explicit GetCustomizedInfoResponseBodySdkDemosSdkDemo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callDemo) {
      res["CallDemo"] = boost::any(*callDemo);
    }
    if (ideKey) {
      res["IdeKey"] = boost::any(*ideKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallDemo") != m.end() && !m["CallDemo"].empty()) {
      callDemo = make_shared<string>(boost::any_cast<string>(m["CallDemo"]));
    }
    if (m.find("IdeKey") != m.end() && !m["IdeKey"].empty()) {
      ideKey = make_shared<string>(boost::any_cast<string>(m["IdeKey"]));
    }
  }


  virtual ~GetCustomizedInfoResponseBodySdkDemosSdkDemo() = default;
};
class GetCustomizedInfoResponseBodySdkDemos : public Darabonba::Model {
public:
  shared_ptr<vector<GetCustomizedInfoResponseBodySdkDemosSdkDemo>> sdkDemo{};

  GetCustomizedInfoResponseBodySdkDemos() {}

  explicit GetCustomizedInfoResponseBodySdkDemos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sdkDemo) {
      vector<boost::any> temp1;
      for(auto item1:*sdkDemo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SdkDemo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SdkDemo") != m.end() && !m["SdkDemo"].empty()) {
      if (typeid(vector<boost::any>) == m["SdkDemo"].type()) {
        vector<GetCustomizedInfoResponseBodySdkDemosSdkDemo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SdkDemo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCustomizedInfoResponseBodySdkDemosSdkDemo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sdkDemo = make_shared<vector<GetCustomizedInfoResponseBodySdkDemosSdkDemo>>(expect1);
      }
    }
  }


  virtual ~GetCustomizedInfoResponseBodySdkDemos() = default;
};
class GetCustomizedInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetCustomizedInfoResponseBodySdkDemos> sdkDemos{};

  GetCustomizedInfoResponseBody() {}

  explicit GetCustomizedInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sdkDemos) {
      res["SdkDemos"] = sdkDemos ? boost::any(sdkDemos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SdkDemos") != m.end() && !m["SdkDemos"].empty()) {
      if (typeid(map<string, boost::any>) == m["SdkDemos"].type()) {
        GetCustomizedInfoResponseBodySdkDemos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SdkDemos"]));
        sdkDemos = make_shared<GetCustomizedInfoResponseBodySdkDemos>(model1);
      }
    }
  }


  virtual ~GetCustomizedInfoResponseBody() = default;
};
class GetCustomizedInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCustomizedInfoResponseBody> body{};

  GetCustomizedInfoResponse() {}

  explicit GetCustomizedInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCustomizedInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCustomizedInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetCustomizedInfoResponse() = default;
};
class ModifyApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> allowSignatureMethod{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> authType{};
  shared_ptr<string> description{};
  shared_ptr<string> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<string> groupId{};
  shared_ptr<string> openIdConnectConfig{};
  shared_ptr<string> requestConfig{};
  shared_ptr<string> requestParamters{};
  shared_ptr<string> resultDescriptions{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> serviceConfig{};
  shared_ptr<string> serviceParameters{};
  shared_ptr<string> serviceParametersMap{};
  shared_ptr<string> visibility{};
  shared_ptr<string> webSocketApiType{};

  ModifyApiRequest() {}

  explicit ModifyApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowSignatureMethod) {
      res["AllowSignatureMethod"] = boost::any(*allowSignatureMethod);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = boost::any(*errorCodeSamples);
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (openIdConnectConfig) {
      res["OpenIdConnectConfig"] = boost::any(*openIdConnectConfig);
    }
    if (requestConfig) {
      res["RequestConfig"] = boost::any(*requestConfig);
    }
    if (requestParamters) {
      res["RequestParamters"] = boost::any(*requestParamters);
    }
    if (resultDescriptions) {
      res["ResultDescriptions"] = boost::any(*resultDescriptions);
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (serviceConfig) {
      res["ServiceConfig"] = boost::any(*serviceConfig);
    }
    if (serviceParameters) {
      res["ServiceParameters"] = boost::any(*serviceParameters);
    }
    if (serviceParametersMap) {
      res["ServiceParametersMap"] = boost::any(*serviceParametersMap);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (webSocketApiType) {
      res["WebSocketApiType"] = boost::any(*webSocketApiType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowSignatureMethod") != m.end() && !m["AllowSignatureMethod"].empty()) {
      allowSignatureMethod = make_shared<string>(boost::any_cast<string>(m["AllowSignatureMethod"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      errorCodeSamples = make_shared<string>(boost::any_cast<string>(m["ErrorCodeSamples"]));
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OpenIdConnectConfig") != m.end() && !m["OpenIdConnectConfig"].empty()) {
      openIdConnectConfig = make_shared<string>(boost::any_cast<string>(m["OpenIdConnectConfig"]));
    }
    if (m.find("RequestConfig") != m.end() && !m["RequestConfig"].empty()) {
      requestConfig = make_shared<string>(boost::any_cast<string>(m["RequestConfig"]));
    }
    if (m.find("RequestParamters") != m.end() && !m["RequestParamters"].empty()) {
      requestParamters = make_shared<string>(boost::any_cast<string>(m["RequestParamters"]));
    }
    if (m.find("ResultDescriptions") != m.end() && !m["ResultDescriptions"].empty()) {
      resultDescriptions = make_shared<string>(boost::any_cast<string>(m["ResultDescriptions"]));
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("ServiceConfig") != m.end() && !m["ServiceConfig"].empty()) {
      serviceConfig = make_shared<string>(boost::any_cast<string>(m["ServiceConfig"]));
    }
    if (m.find("ServiceParameters") != m.end() && !m["ServiceParameters"].empty()) {
      serviceParameters = make_shared<string>(boost::any_cast<string>(m["ServiceParameters"]));
    }
    if (m.find("ServiceParametersMap") != m.end() && !m["ServiceParametersMap"].empty()) {
      serviceParametersMap = make_shared<string>(boost::any_cast<string>(m["ServiceParametersMap"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WebSocketApiType") != m.end() && !m["WebSocketApiType"].empty()) {
      webSocketApiType = make_shared<string>(boost::any_cast<string>(m["WebSocketApiType"]));
    }
  }


  virtual ~ModifyApiRequest() = default;
};
class ModifyApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyApiResponseBody() {}

  explicit ModifyApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyApiResponseBody() = default;
};
class ModifyApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyApiResponseBody> body{};

  ModifyApiResponse() {}

  explicit ModifyApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApiResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApiResponse() = default;
};
class ModifyApiGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> securityToken{};

  ModifyApiGroupRequest() {}

  explicit ModifyApiGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ModifyApiGroupRequest() = default;
};
class ModifyApiGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subDomain{};

  ModifyApiGroupResponseBody() {}

  explicit ModifyApiGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
  }


  virtual ~ModifyApiGroupResponseBody() = default;
};
class ModifyApiGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyApiGroupResponseBody> body{};

  ModifyApiGroupResponse() {}

  explicit ModifyApiGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApiGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApiGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApiGroupResponse() = default;
};
class ModifyAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};

  ModifyAppRequest() {}

  explicit ModifyAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ModifyAppRequest() = default;
};
class ModifyAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAppResponseBody() {}

  explicit ModifyAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAppResponseBody() = default;
};
class ModifyAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAppResponseBody> body{};

  ModifyAppResponse() {}

  explicit ModifyAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAppResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAppResponse() = default;
};
class ModifyIpControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> ipControlName{};
  shared_ptr<string> securityToken{};

  ModifyIpControlRequest() {}

  explicit ModifyIpControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (ipControlName) {
      res["IpControlName"] = boost::any(*ipControlName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("IpControlName") != m.end() && !m["IpControlName"].empty()) {
      ipControlName = make_shared<string>(boost::any_cast<string>(m["IpControlName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ModifyIpControlRequest() = default;
};
class ModifyIpControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyIpControlResponseBody() {}

  explicit ModifyIpControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyIpControlResponseBody() = default;
};
class ModifyIpControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyIpControlResponseBody> body{};

  ModifyIpControlResponse() {}

  explicit ModifyIpControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyIpControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyIpControlResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyIpControlResponse() = default;
};
class ModifyIpControlPolicyItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> cidrIp{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> policyItemId{};
  shared_ptr<string> securityToken{};

  ModifyIpControlPolicyItemRequest() {}

  explicit ModifyIpControlPolicyItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (policyItemId) {
      res["PolicyItemId"] = boost::any(*policyItemId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("PolicyItemId") != m.end() && !m["PolicyItemId"].empty()) {
      policyItemId = make_shared<string>(boost::any_cast<string>(m["PolicyItemId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ModifyIpControlPolicyItemRequest() = default;
};
class ModifyIpControlPolicyItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyIpControlPolicyItemResponseBody() {}

  explicit ModifyIpControlPolicyItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyIpControlPolicyItemResponseBody() = default;
};
class ModifyIpControlPolicyItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyIpControlPolicyItemResponseBody> body{};

  ModifyIpControlPolicyItemResponse() {}

  explicit ModifyIpControlPolicyItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyIpControlPolicyItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyIpControlPolicyItemResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyIpControlPolicyItemResponse() = default;
};
class ModifyLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> logType{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> slsLogStore{};
  shared_ptr<string> slsProject{};

  ModifyLogConfigRequest() {}

  explicit ModifyLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (slsLogStore) {
      res["SlsLogStore"] = boost::any(*slsLogStore);
    }
    if (slsProject) {
      res["SlsProject"] = boost::any(*slsProject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SlsLogStore") != m.end() && !m["SlsLogStore"].empty()) {
      slsLogStore = make_shared<string>(boost::any_cast<string>(m["SlsLogStore"]));
    }
    if (m.find("SlsProject") != m.end() && !m["SlsProject"].empty()) {
      slsProject = make_shared<string>(boost::any_cast<string>(m["SlsProject"]));
    }
  }


  virtual ~ModifyLogConfigRequest() = default;
};
class ModifyLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLogConfigResponseBody() {}

  explicit ModifyLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLogConfigResponseBody() = default;
};
class ModifyLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLogConfigResponseBody> body{};

  ModifyLogConfigResponse() {}

  explicit ModifyLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLogConfigResponse() = default;
};
class ModifySecretKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> secretKey{};
  shared_ptr<string> secretKeyId{};
  shared_ptr<string> secretKeyName{};
  shared_ptr<string> secretValue{};
  shared_ptr<string> securityToken{};

  ModifySecretKeyRequest() {}

  explicit ModifySecretKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (secretKeyId) {
      res["SecretKeyId"] = boost::any(*secretKeyId);
    }
    if (secretKeyName) {
      res["SecretKeyName"] = boost::any(*secretKeyName);
    }
    if (secretValue) {
      res["SecretValue"] = boost::any(*secretValue);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("SecretKeyId") != m.end() && !m["SecretKeyId"].empty()) {
      secretKeyId = make_shared<string>(boost::any_cast<string>(m["SecretKeyId"]));
    }
    if (m.find("SecretKeyName") != m.end() && !m["SecretKeyName"].empty()) {
      secretKeyName = make_shared<string>(boost::any_cast<string>(m["SecretKeyName"]));
    }
    if (m.find("SecretValue") != m.end() && !m["SecretValue"].empty()) {
      secretValue = make_shared<string>(boost::any_cast<string>(m["SecretValue"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ModifySecretKeyRequest() = default;
};
class ModifySecretKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> secretKeyId{};
  shared_ptr<string> secretKeyName{};

  ModifySecretKeyResponseBody() {}

  explicit ModifySecretKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (secretKeyId) {
      res["SecretKeyId"] = boost::any(*secretKeyId);
    }
    if (secretKeyName) {
      res["SecretKeyName"] = boost::any(*secretKeyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecretKeyId") != m.end() && !m["SecretKeyId"].empty()) {
      secretKeyId = make_shared<string>(boost::any_cast<string>(m["SecretKeyId"]));
    }
    if (m.find("SecretKeyName") != m.end() && !m["SecretKeyName"].empty()) {
      secretKeyName = make_shared<string>(boost::any_cast<string>(m["SecretKeyName"]));
    }
  }


  virtual ~ModifySecretKeyResponseBody() = default;
};
class ModifySecretKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySecretKeyResponseBody> body{};

  ModifySecretKeyResponse() {}

  explicit ModifySecretKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySecretKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySecretKeyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySecretKeyResponse() = default;
};
class ModifyTrafficControlRequest : public Darabonba::Model {
public:
  shared_ptr<long> apiDefault{};
  shared_ptr<long> appDefault{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> trafficControlId{};
  shared_ptr<string> trafficControlName{};
  shared_ptr<string> trafficControlUnit{};
  shared_ptr<long> userDefault{};

  ModifyTrafficControlRequest() {}

  explicit ModifyTrafficControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiDefault) {
      res["ApiDefault"] = boost::any(*apiDefault);
    }
    if (appDefault) {
      res["AppDefault"] = boost::any(*appDefault);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    if (trafficControlName) {
      res["TrafficControlName"] = boost::any(*trafficControlName);
    }
    if (trafficControlUnit) {
      res["TrafficControlUnit"] = boost::any(*trafficControlUnit);
    }
    if (userDefault) {
      res["UserDefault"] = boost::any(*userDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiDefault") != m.end() && !m["ApiDefault"].empty()) {
      apiDefault = make_shared<long>(boost::any_cast<long>(m["ApiDefault"]));
    }
    if (m.find("AppDefault") != m.end() && !m["AppDefault"].empty()) {
      appDefault = make_shared<long>(boost::any_cast<long>(m["AppDefault"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
    if (m.find("TrafficControlName") != m.end() && !m["TrafficControlName"].empty()) {
      trafficControlName = make_shared<string>(boost::any_cast<string>(m["TrafficControlName"]));
    }
    if (m.find("TrafficControlUnit") != m.end() && !m["TrafficControlUnit"].empty()) {
      trafficControlUnit = make_shared<string>(boost::any_cast<string>(m["TrafficControlUnit"]));
    }
    if (m.find("UserDefault") != m.end() && !m["UserDefault"].empty()) {
      userDefault = make_shared<long>(boost::any_cast<long>(m["UserDefault"]));
    }
  }


  virtual ~ModifyTrafficControlRequest() = default;
};
class ModifyTrafficControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyTrafficControlResponseBody() {}

  explicit ModifyTrafficControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyTrafficControlResponseBody() = default;
};
class ModifyTrafficControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTrafficControlResponseBody> body{};

  ModifyTrafficControlResponse() {}

  explicit ModifyTrafficControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTrafficControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTrafficControlResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTrafficControlResponse() = default;
};
class ReactivateDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  ReactivateDomainRequest() {}

  explicit ReactivateDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ReactivateDomainRequest() = default;
};
class ReactivateDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReactivateDomainResponseBody() {}

  explicit ReactivateDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReactivateDomainResponseBody() = default;
};
class ReactivateDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReactivateDomainResponseBody> body{};

  ReactivateDomainResponse() {}

  explicit ReactivateDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReactivateDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReactivateDomainResponseBody>(model1);
      }
    }
  }


  virtual ~ReactivateDomainResponse() = default;
};
class RecoverApiFromHistoricalRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> historyVersion{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  RecoverApiFromHistoricalRequest() {}

  explicit RecoverApiFromHistoricalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~RecoverApiFromHistoricalRequest() = default;
};
class RecoverApiFromHistoricalResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RecoverApiFromHistoricalResponseBody() {}

  explicit RecoverApiFromHistoricalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RecoverApiFromHistoricalResponseBody() = default;
};
class RecoverApiFromHistoricalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecoverApiFromHistoricalResponseBody> body{};

  RecoverApiFromHistoricalResponse() {}

  explicit RecoverApiFromHistoricalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecoverApiFromHistoricalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecoverApiFromHistoricalResponseBody>(model1);
      }
    }
  }


  virtual ~RecoverApiFromHistoricalResponse() = default;
};
class RecoveryApiDefineFromHistoricalRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> historyVersion{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  RecoveryApiDefineFromHistoricalRequest() {}

  explicit RecoveryApiDefineFromHistoricalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~RecoveryApiDefineFromHistoricalRequest() = default;
};
class RecoveryApiDefineFromHistoricalResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RecoveryApiDefineFromHistoricalResponseBody() {}

  explicit RecoveryApiDefineFromHistoricalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RecoveryApiDefineFromHistoricalResponseBody() = default;
};
class RecoveryApiDefineFromHistoricalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecoveryApiDefineFromHistoricalResponseBody> body{};

  RecoveryApiDefineFromHistoricalResponse() {}

  explicit RecoveryApiDefineFromHistoricalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecoveryApiDefineFromHistoricalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecoveryApiDefineFromHistoricalResponseBody>(model1);
      }
    }
  }


  virtual ~RecoveryApiDefineFromHistoricalResponse() = default;
};
class RecoveryApiFromHistoricalRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> historyVersion{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  RecoveryApiFromHistoricalRequest() {}

  explicit RecoveryApiFromHistoricalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~RecoveryApiFromHistoricalRequest() = default;
};
class RecoveryApiFromHistoricalResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RecoveryApiFromHistoricalResponseBody() {}

  explicit RecoveryApiFromHistoricalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RecoveryApiFromHistoricalResponseBody() = default;
};
class RecoveryApiFromHistoricalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecoveryApiFromHistoricalResponseBody> body{};

  RecoveryApiFromHistoricalResponse() {}

  explicit RecoveryApiFromHistoricalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecoveryApiFromHistoricalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecoveryApiFromHistoricalResponseBody>(model1);
      }
    }
  }


  virtual ~RecoveryApiFromHistoricalResponse() = default;
};
class RefreshDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  RefreshDomainRequest() {}

  explicit RefreshDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~RefreshDomainRequest() = default;
};
class RefreshDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> certificateId{};
  shared_ptr<string> certificateName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainNameResolution{};
  shared_ptr<string> domainStatus{};
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subDomain{};

  RefreshDomainResponseBody() {}

  explicit RefreshDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (certificateName) {
      res["CertificateName"] = boost::any(*certificateName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainNameResolution) {
      res["DomainNameResolution"] = boost::any(*domainNameResolution);
    }
    if (domainStatus) {
      res["DomainStatus"] = boost::any(*domainStatus);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("CertificateName") != m.end() && !m["CertificateName"].empty()) {
      certificateName = make_shared<string>(boost::any_cast<string>(m["CertificateName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainNameResolution") != m.end() && !m["DomainNameResolution"].empty()) {
      domainNameResolution = make_shared<string>(boost::any_cast<string>(m["DomainNameResolution"]));
    }
    if (m.find("DomainStatus") != m.end() && !m["DomainStatus"].empty()) {
      domainStatus = make_shared<string>(boost::any_cast<string>(m["DomainStatus"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
  }


  virtual ~RefreshDomainResponseBody() = default;
};
class RefreshDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshDomainResponseBody> body{};

  RefreshDomainResponse() {}

  explicit RefreshDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshDomainResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshDomainResponse() = default;
};
class RemoveAccessPermissionByApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<long> appId{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  RemoveAccessPermissionByApisRequest() {}

  explicit RemoveAccessPermissionByApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~RemoveAccessPermissionByApisRequest() = default;
};
class RemoveAccessPermissionByApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveAccessPermissionByApisResponseBody() {}

  explicit RemoveAccessPermissionByApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveAccessPermissionByApisResponseBody() = default;
};
class RemoveAccessPermissionByApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveAccessPermissionByApisResponseBody> body{};

  RemoveAccessPermissionByApisResponse() {}

  explicit RemoveAccessPermissionByApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveAccessPermissionByApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveAccessPermissionByApisResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveAccessPermissionByApisResponse() = default;
};
class RemoveAccessPermissionByAppsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> appIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  RemoveAccessPermissionByAppsRequest() {}

  explicit RemoveAccessPermissionByAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~RemoveAccessPermissionByAppsRequest() = default;
};
class RemoveAccessPermissionByAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveAccessPermissionByAppsResponseBody() {}

  explicit RemoveAccessPermissionByAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveAccessPermissionByAppsResponseBody() = default;
};
class RemoveAccessPermissionByAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveAccessPermissionByAppsResponseBody> body{};

  RemoveAccessPermissionByAppsResponse() {}

  explicit RemoveAccessPermissionByAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveAccessPermissionByAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveAccessPermissionByAppsResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveAccessPermissionByAppsResponse() = default;
};
class RemoveAllBlackListRequest : public Darabonba::Model {
public:
  shared_ptr<string> blackType{};
  shared_ptr<string> securityToken{};

  RemoveAllBlackListRequest() {}

  explicit RemoveAllBlackListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackType) {
      res["BlackType"] = boost::any(*blackType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackType") != m.end() && !m["BlackType"].empty()) {
      blackType = make_shared<string>(boost::any_cast<string>(m["BlackType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~RemoveAllBlackListRequest() = default;
};
class RemoveAllBlackListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveAllBlackListResponseBody() {}

  explicit RemoveAllBlackListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveAllBlackListResponseBody() = default;
};
class RemoveAllBlackListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveAllBlackListResponseBody> body{};

  RemoveAllBlackListResponse() {}

  explicit RemoveAllBlackListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveAllBlackListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveAllBlackListResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveAllBlackListResponse() = default;
};
class RemoveApiRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleType{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  RemoveApiRuleRequest() {}

  explicit RemoveApiRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~RemoveApiRuleRequest() = default;
};
class RemoveApiRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveApiRuleResponseBody() {}

  explicit RemoveApiRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveApiRuleResponseBody() = default;
};
class RemoveApiRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveApiRuleResponseBody> body{};

  RemoveApiRuleResponse() {}

  explicit RemoveApiRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveApiRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveApiRuleResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveApiRuleResponse() = default;
};
class RemoveAppsFromApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> appIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  RemoveAppsFromApiRequest() {}

  explicit RemoveAppsFromApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~RemoveAppsFromApiRequest() = default;
};
class RemoveAppsFromApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveAppsFromApiResponseBody() {}

  explicit RemoveAppsFromApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveAppsFromApiResponseBody() = default;
};
class RemoveAppsFromApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveAppsFromApiResponseBody> body{};

  RemoveAppsFromApiResponse() {}

  explicit RemoveAppsFromApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveAppsFromApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveAppsFromApiResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveAppsFromApiResponse() = default;
};
class RemoveBlackListRequest : public Darabonba::Model {
public:
  shared_ptr<string> blackContent{};
  shared_ptr<string> blackType{};
  shared_ptr<string> securityToken{};

  RemoveBlackListRequest() {}

  explicit RemoveBlackListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackContent) {
      res["BlackContent"] = boost::any(*blackContent);
    }
    if (blackType) {
      res["BlackType"] = boost::any(*blackType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackContent") != m.end() && !m["BlackContent"].empty()) {
      blackContent = make_shared<string>(boost::any_cast<string>(m["BlackContent"]));
    }
    if (m.find("BlackType") != m.end() && !m["BlackType"].empty()) {
      blackType = make_shared<string>(boost::any_cast<string>(m["BlackType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~RemoveBlackListRequest() = default;
};
class RemoveBlackListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveBlackListResponseBody() {}

  explicit RemoveBlackListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveBlackListResponseBody() = default;
};
class RemoveBlackListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveBlackListResponseBody> body{};

  RemoveBlackListResponse() {}

  explicit RemoveBlackListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveBlackListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveBlackListResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveBlackListResponse() = default;
};
class RemoveIpControlApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  RemoveIpControlApisRequest() {}

  explicit RemoveIpControlApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~RemoveIpControlApisRequest() = default;
};
class RemoveIpControlApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveIpControlApisResponseBody() {}

  explicit RemoveIpControlApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveIpControlApisResponseBody() = default;
};
class RemoveIpControlApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveIpControlApisResponseBody> body{};

  RemoveIpControlApisResponse() {}

  explicit RemoveIpControlApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveIpControlApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveIpControlApisResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveIpControlApisResponse() = default;
};
class RemoveIpControlPolicyItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<string> policyItemIds{};
  shared_ptr<string> securityToken{};

  RemoveIpControlPolicyItemRequest() {}

  explicit RemoveIpControlPolicyItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (policyItemIds) {
      res["PolicyItemIds"] = boost::any(*policyItemIds);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("PolicyItemIds") != m.end() && !m["PolicyItemIds"].empty()) {
      policyItemIds = make_shared<string>(boost::any_cast<string>(m["PolicyItemIds"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~RemoveIpControlPolicyItemRequest() = default;
};
class RemoveIpControlPolicyItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveIpControlPolicyItemResponseBody() {}

  explicit RemoveIpControlPolicyItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveIpControlPolicyItemResponseBody() = default;
};
class RemoveIpControlPolicyItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveIpControlPolicyItemResponseBody> body{};

  RemoveIpControlPolicyItemResponse() {}

  explicit RemoveIpControlPolicyItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveIpControlPolicyItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveIpControlPolicyItemResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveIpControlPolicyItemResponse() = default;
};
class ResetAppKeySecretRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> securityToken{};

  ResetAppKeySecretRequest() {}

  explicit ResetAppKeySecretRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ResetAppKeySecretRequest() = default;
};
class ResetAppKeySecretResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetAppKeySecretResponseBody() {}

  explicit ResetAppKeySecretResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetAppKeySecretResponseBody() = default;
};
class ResetAppKeySecretResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetAppKeySecretResponseBody> body{};

  ResetAppKeySecretResponse() {}

  explicit ResetAppKeySecretResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetAppKeySecretResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetAppKeySecretResponseBody>(model1);
      }
    }
  }


  virtual ~ResetAppKeySecretResponse() = default;
};
class ResetCustomizedRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};

  ResetCustomizedRequest() {}

  explicit ResetCustomizedRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~ResetCustomizedRequest() = default;
};
class ResetCustomizedResponseBodySdkDemosSdkDemo : public Darabonba::Model {
public:
  shared_ptr<string> callDemo{};
  shared_ptr<string> ideKey{};

  ResetCustomizedResponseBodySdkDemosSdkDemo() {}

  explicit ResetCustomizedResponseBodySdkDemosSdkDemo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callDemo) {
      res["CallDemo"] = boost::any(*callDemo);
    }
    if (ideKey) {
      res["IdeKey"] = boost::any(*ideKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallDemo") != m.end() && !m["CallDemo"].empty()) {
      callDemo = make_shared<string>(boost::any_cast<string>(m["CallDemo"]));
    }
    if (m.find("IdeKey") != m.end() && !m["IdeKey"].empty()) {
      ideKey = make_shared<string>(boost::any_cast<string>(m["IdeKey"]));
    }
  }


  virtual ~ResetCustomizedResponseBodySdkDemosSdkDemo() = default;
};
class ResetCustomizedResponseBodySdkDemos : public Darabonba::Model {
public:
  shared_ptr<vector<ResetCustomizedResponseBodySdkDemosSdkDemo>> sdkDemo{};

  ResetCustomizedResponseBodySdkDemos() {}

  explicit ResetCustomizedResponseBodySdkDemos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sdkDemo) {
      vector<boost::any> temp1;
      for(auto item1:*sdkDemo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SdkDemo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SdkDemo") != m.end() && !m["SdkDemo"].empty()) {
      if (typeid(vector<boost::any>) == m["SdkDemo"].type()) {
        vector<ResetCustomizedResponseBodySdkDemosSdkDemo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SdkDemo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ResetCustomizedResponseBodySdkDemosSdkDemo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sdkDemo = make_shared<vector<ResetCustomizedResponseBodySdkDemosSdkDemo>>(expect1);
      }
    }
  }


  virtual ~ResetCustomizedResponseBodySdkDemos() = default;
};
class ResetCustomizedResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ResetCustomizedResponseBodySdkDemos> sdkDemos{};

  ResetCustomizedResponseBody() {}

  explicit ResetCustomizedResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sdkDemos) {
      res["SdkDemos"] = sdkDemos ? boost::any(sdkDemos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SdkDemos") != m.end() && !m["SdkDemos"].empty()) {
      if (typeid(map<string, boost::any>) == m["SdkDemos"].type()) {
        ResetCustomizedResponseBodySdkDemos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SdkDemos"]));
        sdkDemos = make_shared<ResetCustomizedResponseBodySdkDemos>(model1);
      }
    }
  }


  virtual ~ResetCustomizedResponseBody() = default;
};
class ResetCustomizedResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetCustomizedResponseBody> body{};

  ResetCustomizedResponse() {}

  explicit ResetCustomizedResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetCustomizedResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetCustomizedResponseBody>(model1);
      }
    }
  }


  virtual ~ResetCustomizedResponse() = default;
};
class SdkGenerateRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> language{};
  shared_ptr<string> securityToken{};

  SdkGenerateRequest() {}

  explicit SdkGenerateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SdkGenerateRequest() = default;
};
class SdkGenerateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> downloadLink{};
  shared_ptr<string> requestId{};

  SdkGenerateResponseBody() {}

  explicit SdkGenerateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadLink) {
      res["DownloadLink"] = boost::any(*downloadLink);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadLink") != m.end() && !m["DownloadLink"].empty()) {
      downloadLink = make_shared<string>(boost::any_cast<string>(m["DownloadLink"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SdkGenerateResponseBody() = default;
};
class SdkGenerateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SdkGenerateResponseBody> body{};

  SdkGenerateResponse() {}

  explicit SdkGenerateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SdkGenerateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SdkGenerateResponseBody>(model1);
      }
    }
  }


  virtual ~SdkGenerateResponse() = default;
};
class SdkGenerateByAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> language{};
  shared_ptr<string> securityToken{};

  SdkGenerateByAppRequest() {}

  explicit SdkGenerateByAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SdkGenerateByAppRequest() = default;
};
class SdkGenerateByAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> downloadLink{};
  shared_ptr<string> requestId{};

  SdkGenerateByAppResponseBody() {}

  explicit SdkGenerateByAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadLink) {
      res["DownloadLink"] = boost::any(*downloadLink);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadLink") != m.end() && !m["DownloadLink"].empty()) {
      downloadLink = make_shared<string>(boost::any_cast<string>(m["DownloadLink"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SdkGenerateByAppResponseBody() = default;
};
class SdkGenerateByAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SdkGenerateByAppResponseBody> body{};

  SdkGenerateByAppResponse() {}

  explicit SdkGenerateByAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SdkGenerateByAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SdkGenerateByAppResponseBody>(model1);
      }
    }
  }


  virtual ~SdkGenerateByAppResponse() = default;
};
class SdkGenerateByGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> language{};
  shared_ptr<string> securityToken{};

  SdkGenerateByGroupRequest() {}

  explicit SdkGenerateByGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SdkGenerateByGroupRequest() = default;
};
class SdkGenerateByGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> downloadLink{};
  shared_ptr<string> requestId{};

  SdkGenerateByGroupResponseBody() {}

  explicit SdkGenerateByGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadLink) {
      res["DownloadLink"] = boost::any(*downloadLink);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadLink") != m.end() && !m["DownloadLink"].empty()) {
      downloadLink = make_shared<string>(boost::any_cast<string>(m["DownloadLink"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SdkGenerateByGroupResponseBody() = default;
};
class SdkGenerateByGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SdkGenerateByGroupResponseBody> body{};

  SdkGenerateByGroupResponse() {}

  explicit SdkGenerateByGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SdkGenerateByGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SdkGenerateByGroupResponseBody>(model1);
      }
    }
  }


  virtual ~SdkGenerateByGroupResponse() = default;
};
class SetAccessPermissionByApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<long> appId{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  SetAccessPermissionByApisRequest() {}

  explicit SetAccessPermissionByApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~SetAccessPermissionByApisRequest() = default;
};
class SetAccessPermissionByApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetAccessPermissionByApisResponseBody() {}

  explicit SetAccessPermissionByApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetAccessPermissionByApisResponseBody() = default;
};
class SetAccessPermissionByApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetAccessPermissionByApisResponseBody> body{};

  SetAccessPermissionByApisResponse() {}

  explicit SetAccessPermissionByApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetAccessPermissionByApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetAccessPermissionByApisResponseBody>(model1);
      }
    }
  }


  virtual ~SetAccessPermissionByApisResponse() = default;
};
class SetAccessPermissionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> appIds{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  SetAccessPermissionsRequest() {}

  explicit SetAccessPermissionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~SetAccessPermissionsRequest() = default;
};
class SetAccessPermissionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetAccessPermissionsResponseBody() {}

  explicit SetAccessPermissionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetAccessPermissionsResponseBody() = default;
};
class SetAccessPermissionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetAccessPermissionsResponseBody> body{};

  SetAccessPermissionsResponse() {}

  explicit SetAccessPermissionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetAccessPermissionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetAccessPermissionsResponseBody>(model1);
      }
    }
  }


  virtual ~SetAccessPermissionsResponse() = default;
};
class SetApiRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleType{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  SetApiRuleRequest() {}

  explicit SetApiRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~SetApiRuleRequest() = default;
};
class SetApiRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetApiRuleResponseBody() {}

  explicit SetApiRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetApiRuleResponseBody() = default;
};
class SetApiRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetApiRuleResponseBody> body{};

  SetApiRuleResponse() {}

  explicit SetApiRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetApiRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetApiRuleResponseBody>(model1);
      }
    }
  }


  virtual ~SetApiRuleResponse() = default;
};
class SetDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> certificateBody{};
  shared_ptr<string> certificateName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> privateKey{};
  shared_ptr<string> securityToken{};

  SetDomainRequest() {}

  explicit SetDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateBody) {
      res["CertificateBody"] = boost::any(*certificateBody);
    }
    if (certificateName) {
      res["CertificateName"] = boost::any(*certificateName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateBody") != m.end() && !m["CertificateBody"].empty()) {
      certificateBody = make_shared<string>(boost::any_cast<string>(m["CertificateBody"]));
    }
    if (m.find("CertificateName") != m.end() && !m["CertificateName"].empty()) {
      certificateName = make_shared<string>(boost::any_cast<string>(m["CertificateName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetDomainRequest() = default;
};
class SetDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainBindingStatus{};
  shared_ptr<string> domainLegalStatus{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainRemark{};
  shared_ptr<string> domainWebSocketStatus{};
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subDomain{};

  SetDomainResponseBody() {}

  explicit SetDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainBindingStatus) {
      res["DomainBindingStatus"] = boost::any(*domainBindingStatus);
    }
    if (domainLegalStatus) {
      res["DomainLegalStatus"] = boost::any(*domainLegalStatus);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainRemark) {
      res["DomainRemark"] = boost::any(*domainRemark);
    }
    if (domainWebSocketStatus) {
      res["DomainWebSocketStatus"] = boost::any(*domainWebSocketStatus);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainBindingStatus") != m.end() && !m["DomainBindingStatus"].empty()) {
      domainBindingStatus = make_shared<string>(boost::any_cast<string>(m["DomainBindingStatus"]));
    }
    if (m.find("DomainLegalStatus") != m.end() && !m["DomainLegalStatus"].empty()) {
      domainLegalStatus = make_shared<string>(boost::any_cast<string>(m["DomainLegalStatus"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainRemark") != m.end() && !m["DomainRemark"].empty()) {
      domainRemark = make_shared<string>(boost::any_cast<string>(m["DomainRemark"]));
    }
    if (m.find("DomainWebSocketStatus") != m.end() && !m["DomainWebSocketStatus"].empty()) {
      domainWebSocketStatus = make_shared<string>(boost::any_cast<string>(m["DomainWebSocketStatus"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
  }


  virtual ~SetDomainResponseBody() = default;
};
class SetDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDomainResponseBody> body{};

  SetDomainResponse() {}

  explicit SetDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDomainResponseBody>(model1);
      }
    }
  }


  virtual ~SetDomainResponse() = default;
};
class SetDomainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certificateBody{};
  shared_ptr<string> certificateName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> privateKey{};
  shared_ptr<string> securityToken{};

  SetDomainCertificateRequest() {}

  explicit SetDomainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateBody) {
      res["CertificateBody"] = boost::any(*certificateBody);
    }
    if (certificateName) {
      res["CertificateName"] = boost::any(*certificateName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateBody") != m.end() && !m["CertificateBody"].empty()) {
      certificateBody = make_shared<string>(boost::any_cast<string>(m["CertificateBody"]));
    }
    if (m.find("CertificateName") != m.end() && !m["CertificateName"].empty()) {
      certificateName = make_shared<string>(boost::any_cast<string>(m["CertificateName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetDomainCertificateRequest() = default;
};
class SetDomainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDomainCertificateResponseBody() {}

  explicit SetDomainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDomainCertificateResponseBody() = default;
};
class SetDomainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDomainCertificateResponseBody> body{};

  SetDomainCertificateResponse() {}

  explicit SetDomainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDomainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDomainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetDomainCertificateResponse() = default;
};
class SetDomainWebSocketStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionValue{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  SetDomainWebSocketStatusRequest() {}

  explicit SetDomainWebSocketStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionValue) {
      res["ActionValue"] = boost::any(*actionValue);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionValue") != m.end() && !m["ActionValue"].empty()) {
      actionValue = make_shared<string>(boost::any_cast<string>(m["ActionValue"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetDomainWebSocketStatusRequest() = default;
};
class SetDomainWebSocketStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDomainWebSocketStatusResponseBody() {}

  explicit SetDomainWebSocketStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDomainWebSocketStatusResponseBody() = default;
};
class SetDomainWebSocketStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDomainWebSocketStatusResponseBody> body{};

  SetDomainWebSocketStatusResponse() {}

  explicit SetDomainWebSocketStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDomainWebSocketStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDomainWebSocketStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SetDomainWebSocketStatusResponse() = default;
};
class SetIpControlApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  SetIpControlApisRequest() {}

  explicit SetIpControlApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~SetIpControlApisRequest() = default;
};
class SetIpControlApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetIpControlApisResponseBody() {}

  explicit SetIpControlApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetIpControlApisResponseBody() = default;
};
class SetIpControlApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetIpControlApisResponseBody> body{};

  SetIpControlApisResponse() {}

  explicit SetIpControlApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetIpControlApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetIpControlApisResponseBody>(model1);
      }
    }
  }


  virtual ~SetIpControlApisResponse() = default;
};
class SetMockIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> mock{};
  shared_ptr<string> mockResult{};
  shared_ptr<string> securityToken{};

  SetMockIntegrationRequest() {}

  explicit SetMockIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (mock) {
      res["Mock"] = boost::any(*mock);
    }
    if (mockResult) {
      res["MockResult"] = boost::any(*mockResult);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Mock") != m.end() && !m["Mock"].empty()) {
      mock = make_shared<string>(boost::any_cast<string>(m["Mock"]));
    }
    if (m.find("MockResult") != m.end() && !m["MockResult"].empty()) {
      mockResult = make_shared<string>(boost::any_cast<string>(m["MockResult"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetMockIntegrationRequest() = default;
};
class SetMockIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetMockIntegrationResponseBody() {}

  explicit SetMockIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetMockIntegrationResponseBody() = default;
};
class SetMockIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetMockIntegrationResponseBody> body{};

  SetMockIntegrationResponse() {}

  explicit SetMockIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetMockIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetMockIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~SetMockIntegrationResponse() = default;
};
class SwitchApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> historyVersion{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  SwitchApiRequest() {}

  explicit SwitchApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~SwitchApiRequest() = default;
};
class SwitchApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SwitchApiResponseBody() {}

  explicit SwitchApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SwitchApiResponseBody() = default;
};
class SwitchApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchApiResponseBody> body{};

  SwitchApiResponse() {}

  explicit SwitchApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchApiResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchApiResponse() = default;
};
class VpcDescribeAccessesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instancePort{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> vpcId{};

  VpcDescribeAccessesRequest() {}

  explicit VpcDescribeAccessesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instancePort) {
      res["InstancePort"] = boost::any(*instancePort);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstancePort") != m.end() && !m["InstancePort"].empty()) {
      instancePort = make_shared<string>(boost::any_cast<string>(m["InstancePort"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~VpcDescribeAccessesRequest() = default;
};
class VpcDescribeAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<string> port{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<string> userId{};
  shared_ptr<string> vpcId{};

  VpcDescribeAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute() {}

  explicit VpcDescribeAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~VpcDescribeAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute() = default;
};
class VpcDescribeAccessesResponseBodyVpcAccessAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<VpcDescribeAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute>> vpcAccessAttribute{};

  VpcDescribeAccessesResponseBodyVpcAccessAttributes() {}

  explicit VpcDescribeAccessesResponseBodyVpcAccessAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcAccessAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*vpcAccessAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpcAccessAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcAccessAttribute") != m.end() && !m["VpcAccessAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["VpcAccessAttribute"].type()) {
        vector<VpcDescribeAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpcAccessAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            VpcDescribeAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpcAccessAttribute = make_shared<vector<VpcDescribeAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute>>(expect1);
      }
    }
  }


  virtual ~VpcDescribeAccessesResponseBodyVpcAccessAttributes() = default;
};
class VpcDescribeAccessesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<VpcDescribeAccessesResponseBodyVpcAccessAttributes> vpcAccessAttributes{};

  VpcDescribeAccessesResponseBody() {}

  explicit VpcDescribeAccessesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vpcAccessAttributes) {
      res["VpcAccessAttributes"] = vpcAccessAttributes ? boost::any(vpcAccessAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VpcAccessAttributes") != m.end() && !m["VpcAccessAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcAccessAttributes"].type()) {
        VpcDescribeAccessesResponseBodyVpcAccessAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcAccessAttributes"]));
        vpcAccessAttributes = make_shared<VpcDescribeAccessesResponseBodyVpcAccessAttributes>(model1);
      }
    }
  }


  virtual ~VpcDescribeAccessesResponseBody() = default;
};
class VpcDescribeAccessesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VpcDescribeAccessesResponseBody> body{};

  VpcDescribeAccessesResponse() {}

  explicit VpcDescribeAccessesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VpcDescribeAccessesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VpcDescribeAccessesResponseBody>(model1);
      }
    }
  }


  virtual ~VpcDescribeAccessesResponse() = default;
};
class VpcGrantAccessRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instancePort{};
  shared_ptr<string> name{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> token{};
  shared_ptr<string> vpcId{};

  VpcGrantAccessRequest() {}

  explicit VpcGrantAccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instancePort) {
      res["InstancePort"] = boost::any(*instancePort);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstancePort") != m.end() && !m["InstancePort"].empty()) {
      instancePort = make_shared<string>(boost::any_cast<string>(m["InstancePort"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~VpcGrantAccessRequest() = default;
};
class VpcGrantAccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  VpcGrantAccessResponseBody() {}

  explicit VpcGrantAccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VpcGrantAccessResponseBody() = default;
};
class VpcGrantAccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VpcGrantAccessResponseBody> body{};

  VpcGrantAccessResponse() {}

  explicit VpcGrantAccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VpcGrantAccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VpcGrantAccessResponseBody>(model1);
      }
    }
  }


  virtual ~VpcGrantAccessResponse() = default;
};
class VpcModifyAccessRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instancePort{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> token{};
  shared_ptr<string> vpcId{};

  VpcModifyAccessRequest() {}

  explicit VpcModifyAccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instancePort) {
      res["InstancePort"] = boost::any(*instancePort);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstancePort") != m.end() && !m["InstancePort"].empty()) {
      instancePort = make_shared<string>(boost::any_cast<string>(m["InstancePort"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~VpcModifyAccessRequest() = default;
};
class VpcModifyAccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  VpcModifyAccessResponseBody() {}

  explicit VpcModifyAccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VpcModifyAccessResponseBody() = default;
};
class VpcModifyAccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VpcModifyAccessResponseBody> body{};

  VpcModifyAccessResponse() {}

  explicit VpcModifyAccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VpcModifyAccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VpcModifyAccessResponseBody>(model1);
      }
    }
  }


  virtual ~VpcModifyAccessResponse() = default;
};
class VpcRevokeAccessRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instancePort{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> token{};
  shared_ptr<string> vpcId{};

  VpcRevokeAccessRequest() {}

  explicit VpcRevokeAccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instancePort) {
      res["InstancePort"] = boost::any(*instancePort);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstancePort") != m.end() && !m["InstancePort"].empty()) {
      instancePort = make_shared<string>(boost::any_cast<string>(m["InstancePort"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~VpcRevokeAccessRequest() = default;
};
class VpcRevokeAccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  VpcRevokeAccessResponseBody() {}

  explicit VpcRevokeAccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~VpcRevokeAccessResponseBody() = default;
};
class VpcRevokeAccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VpcRevokeAccessResponseBody> body{};

  VpcRevokeAccessResponse() {}

  explicit VpcRevokeAccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VpcRevokeAccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VpcRevokeAccessResponseBody>(model1);
      }
    }
  }


  virtual ~VpcRevokeAccessResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AbolishApiResponse abolishApiWithOptions(shared_ptr<AbolishApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AbolishApiResponse abolishApi(shared_ptr<AbolishApiRequest> request);
  AddBlackListResponse addBlackListWithOptions(shared_ptr<AddBlackListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddBlackListResponse addBlackList(shared_ptr<AddBlackListRequest> request);
  AddIpControlPolicyItemResponse addIpControlPolicyItemWithOptions(shared_ptr<AddIpControlPolicyItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddIpControlPolicyItemResponse addIpControlPolicyItem(shared_ptr<AddIpControlPolicyItemRequest> request);
  AddTrafficSpecialControlResponse addTrafficSpecialControlWithOptions(shared_ptr<AddTrafficSpecialControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTrafficSpecialControlResponse addTrafficSpecialControl(shared_ptr<AddTrafficSpecialControlRequest> request);
  CreateApiResponse createApiWithOptions(shared_ptr<CreateApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApiResponse createApi(shared_ptr<CreateApiRequest> request);
  CreateApiGroupResponse createApiGroupWithOptions(shared_ptr<CreateApiGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApiGroupResponse createApiGroup(shared_ptr<CreateApiGroupRequest> request);
  CreateApiStageVariableResponse createApiStageVariableWithOptions(shared_ptr<CreateApiStageVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApiStageVariableResponse createApiStageVariable(shared_ptr<CreateApiStageVariableRequest> request);
  CreateAppResponse createAppWithOptions(shared_ptr<CreateAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAppResponse createApp(shared_ptr<CreateAppRequest> request);
  CreateCustomizedInfoResponse createCustomizedInfoWithOptions(shared_ptr<CreateCustomizedInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomizedInfoResponse createCustomizedInfo(shared_ptr<CreateCustomizedInfoRequest> request);
  CreateInstanceResponse createInstanceWithOptions(shared_ptr<CreateInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInstanceResponse createInstance(shared_ptr<CreateInstanceRequest> request);
  CreateIpControlResponse createIpControlWithOptions(shared_ptr<CreateIpControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIpControlResponse createIpControl(shared_ptr<CreateIpControlRequest> request);
  CreateLogConfigResponse createLogConfigWithOptions(shared_ptr<CreateLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLogConfigResponse createLogConfig(shared_ptr<CreateLogConfigRequest> request);
  CreateRaceWorkForInnerResponse createRaceWorkForInnerWithOptions(shared_ptr<CreateRaceWorkForInnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRaceWorkForInnerResponse createRaceWorkForInner(shared_ptr<CreateRaceWorkForInnerRequest> request);
  CreateSecretKeyResponse createSecretKeyWithOptions(shared_ptr<CreateSecretKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSecretKeyResponse createSecretKey(shared_ptr<CreateSecretKeyRequest> request);
  CreateTrafficControlResponse createTrafficControlWithOptions(shared_ptr<CreateTrafficControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTrafficControlResponse createTrafficControl(shared_ptr<CreateTrafficControlRequest> request);
  DeleteAllTrafficSpecialControlResponse deleteAllTrafficSpecialControlWithOptions(shared_ptr<DeleteAllTrafficSpecialControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAllTrafficSpecialControlResponse deleteAllTrafficSpecialControl(shared_ptr<DeleteAllTrafficSpecialControlRequest> request);
  DeleteApiResponse deleteApiWithOptions(shared_ptr<DeleteApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApiResponse deleteApi(shared_ptr<DeleteApiRequest> request);
  DeleteApiGroupResponse deleteApiGroupWithOptions(shared_ptr<DeleteApiGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApiGroupResponse deleteApiGroup(shared_ptr<DeleteApiGroupRequest> request);
  DeleteApiStageVariableResponse deleteApiStageVariableWithOptions(shared_ptr<DeleteApiStageVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApiStageVariableResponse deleteApiStageVariable(shared_ptr<DeleteApiStageVariableRequest> request);
  DeleteAppResponse deleteAppWithOptions(shared_ptr<DeleteAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAppResponse deleteApp(shared_ptr<DeleteAppRequest> request);
  DeleteDomainResponse deleteDomainWithOptions(shared_ptr<DeleteDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDomainResponse deleteDomain(shared_ptr<DeleteDomainRequest> request);
  DeleteDomainCertificateResponse deleteDomainCertificateWithOptions(shared_ptr<DeleteDomainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDomainCertificateResponse deleteDomainCertificate(shared_ptr<DeleteDomainCertificateRequest> request);
  DeleteIpControlResponse deleteIpControlWithOptions(shared_ptr<DeleteIpControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIpControlResponse deleteIpControl(shared_ptr<DeleteIpControlRequest> request);
  DeleteLogConfigResponse deleteLogConfigWithOptions(shared_ptr<DeleteLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLogConfigResponse deleteLogConfig(shared_ptr<DeleteLogConfigRequest> request);
  DeleteSecretKeyResponse deleteSecretKeyWithOptions(shared_ptr<DeleteSecretKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSecretKeyResponse deleteSecretKey(shared_ptr<DeleteSecretKeyRequest> request);
  DeleteTrafficControlResponse deleteTrafficControlWithOptions(shared_ptr<DeleteTrafficControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTrafficControlResponse deleteTrafficControl(shared_ptr<DeleteTrafficControlRequest> request);
  DeleteTrafficSpecialControlResponse deleteTrafficSpecialControlWithOptions(shared_ptr<DeleteTrafficSpecialControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTrafficSpecialControlResponse deleteTrafficSpecialControl(shared_ptr<DeleteTrafficSpecialControlRequest> request);
  DeployApiResponse deployApiWithOptions(shared_ptr<DeployApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeployApiResponse deployApi(shared_ptr<DeployApiRequest> request);
  DescribeApiResponse describeApiWithOptions(shared_ptr<DescribeApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiResponse describeApi(shared_ptr<DescribeApiRequest> request);
  DescribeApiDocResponse describeApiDocWithOptions(shared_ptr<DescribeApiDocRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiDocResponse describeApiDoc(shared_ptr<DescribeApiDocRequest> request);
  DescribeApiDocsResponse describeApiDocsWithOptions(shared_ptr<DescribeApiDocsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiDocsResponse describeApiDocs(shared_ptr<DescribeApiDocsRequest> request);
  DescribeApiErrorResponse describeApiErrorWithOptions(shared_ptr<DescribeApiErrorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiErrorResponse describeApiError(shared_ptr<DescribeApiErrorRequest> request);
  DescribeApiGroupDetailResponse describeApiGroupDetailWithOptions(shared_ptr<DescribeApiGroupDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiGroupDetailResponse describeApiGroupDetail(shared_ptr<DescribeApiGroupDetailRequest> request);
  DescribeApiGroupDetailForConsumerResponse describeApiGroupDetailForConsumerWithOptions(shared_ptr<DescribeApiGroupDetailForConsumerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiGroupDetailForConsumerResponse describeApiGroupDetailForConsumer(shared_ptr<DescribeApiGroupDetailForConsumerRequest> request);
  DescribeApiGroupsResponse describeApiGroupsWithOptions(shared_ptr<DescribeApiGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiGroupsResponse describeApiGroups(shared_ptr<DescribeApiGroupsRequest> request);
  DescribeApiIpControlsResponse describeApiIpControlsWithOptions(shared_ptr<DescribeApiIpControlsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiIpControlsResponse describeApiIpControls(shared_ptr<DescribeApiIpControlsRequest> request);
  DescribeApiLatencyResponse describeApiLatencyWithOptions(shared_ptr<DescribeApiLatencyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiLatencyResponse describeApiLatency(shared_ptr<DescribeApiLatencyRequest> request);
  DescribeApiQpsResponse describeApiQpsWithOptions(shared_ptr<DescribeApiQpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiQpsResponse describeApiQps(shared_ptr<DescribeApiQpsRequest> request);
  DescribeApiRulesResponse describeApiRulesWithOptions(shared_ptr<DescribeApiRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiRulesResponse describeApiRules(shared_ptr<DescribeApiRulesRequest> request);
  DescribeApiStageDetailResponse describeApiStageDetailWithOptions(shared_ptr<DescribeApiStageDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiStageDetailResponse describeApiStageDetail(shared_ptr<DescribeApiStageDetailRequest> request);
  DescribeApiTrafficResponse describeApiTrafficWithOptions(shared_ptr<DescribeApiTrafficRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiTrafficResponse describeApiTraffic(shared_ptr<DescribeApiTrafficRequest> request);
  DescribeApisResponse describeApisWithOptions(shared_ptr<DescribeApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisResponse describeApis(shared_ptr<DescribeApisRequest> request);
  DescribeApisByAppResponse describeApisByAppWithOptions(shared_ptr<DescribeApisByAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisByAppResponse describeApisByApp(shared_ptr<DescribeApisByAppRequest> request);
  DescribeApisByIpControlResponse describeApisByIpControlWithOptions(shared_ptr<DescribeApisByIpControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisByIpControlResponse describeApisByIpControl(shared_ptr<DescribeApisByIpControlRequest> request);
  DescribeApisByRuleResponse describeApisByRuleWithOptions(shared_ptr<DescribeApisByRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisByRuleResponse describeApisByRule(shared_ptr<DescribeApisByRuleRequest> request);
  DescribeApisForConsoleResponse describeApisForConsoleWithOptions(shared_ptr<DescribeApisForConsoleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisForConsoleResponse describeApisForConsole(shared_ptr<DescribeApisForConsoleRequest> request);
  DescribeAppResponse describeAppWithOptions(shared_ptr<DescribeAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppResponse describeApp(shared_ptr<DescribeAppRequest> request);
  DescribeAppSecuritiesResponse describeAppSecuritiesWithOptions(shared_ptr<DescribeAppSecuritiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppSecuritiesResponse describeAppSecurities(shared_ptr<DescribeAppSecuritiesRequest> request);
  DescribeAppSecurityResponse describeAppSecurityWithOptions(shared_ptr<DescribeAppSecurityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppSecurityResponse describeAppSecurity(shared_ptr<DescribeAppSecurityRequest> request);
  DescribeAppsResponse describeAppsWithOptions(shared_ptr<DescribeAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppsResponse describeApps(shared_ptr<DescribeAppsRequest> request);
  DescribeAppsByApiResponse describeAppsByApiWithOptions(shared_ptr<DescribeAppsByApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppsByApiResponse describeAppsByApi(shared_ptr<DescribeAppsByApiRequest> request);
  DescribeAppsForProviderResponse describeAppsForProviderWithOptions(shared_ptr<DescribeAppsForProviderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppsForProviderResponse describeAppsForProvider(shared_ptr<DescribeAppsForProviderRequest> request);
  DescribeBlackListsResponse describeBlackListsWithOptions(shared_ptr<DescribeBlackListsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBlackListsResponse describeBlackLists(shared_ptr<DescribeBlackListsRequest> request);
  DescribeDeployedApiResponse describeDeployedApiWithOptions(shared_ptr<DescribeDeployedApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeployedApiResponse describeDeployedApi(shared_ptr<DescribeDeployedApiRequest> request);
  DescribeDeployedApisResponse describeDeployedApisWithOptions(shared_ptr<DescribeDeployedApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeployedApisResponse describeDeployedApis(shared_ptr<DescribeDeployedApisRequest> request);
  DescribeDomainResponse describeDomainWithOptions(shared_ptr<DescribeDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainResponse describeDomain(shared_ptr<DescribeDomainRequest> request);
  DescribeDomainResolutionResponse describeDomainResolutionWithOptions(shared_ptr<DescribeDomainResolutionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainResolutionResponse describeDomainResolution(shared_ptr<DescribeDomainResolutionRequest> request);
  DescribeHistoryApiResponse describeHistoryApiWithOptions(shared_ptr<DescribeHistoryApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHistoryApiResponse describeHistoryApi(shared_ptr<DescribeHistoryApiRequest> request);
  DescribeHistoryApisResponse describeHistoryApisWithOptions(shared_ptr<DescribeHistoryApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHistoryApisResponse describeHistoryApis(shared_ptr<DescribeHistoryApisRequest> request);
  DescribeIpControlPolicyItemsResponse describeIpControlPolicyItemsWithOptions(shared_ptr<DescribeIpControlPolicyItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIpControlPolicyItemsResponse describeIpControlPolicyItems(shared_ptr<DescribeIpControlPolicyItemsRequest> request);
  DescribeIpControlsResponse describeIpControlsWithOptions(shared_ptr<DescribeIpControlsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIpControlsResponse describeIpControls(shared_ptr<DescribeIpControlsRequest> request);
  DescribeLogConfigResponse describeLogConfigWithOptions(shared_ptr<DescribeLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLogConfigResponse describeLogConfig(shared_ptr<DescribeLogConfigRequest> request);
  DescribePurchasedApiResponse describePurchasedApiWithOptions(shared_ptr<DescribePurchasedApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePurchasedApiResponse describePurchasedApi(shared_ptr<DescribePurchasedApiRequest> request);
  DescribePurchasedApiGroupDetailResponse describePurchasedApiGroupDetailWithOptions(shared_ptr<DescribePurchasedApiGroupDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePurchasedApiGroupDetailResponse describePurchasedApiGroupDetail(shared_ptr<DescribePurchasedApiGroupDetailRequest> request);
  DescribePurchasedApiGroupsResponse describePurchasedApiGroupsWithOptions(shared_ptr<DescribePurchasedApiGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePurchasedApiGroupsResponse describePurchasedApiGroups(shared_ptr<DescribePurchasedApiGroupsRequest> request);
  DescribePurchasedApisResponse describePurchasedApisWithOptions(shared_ptr<DescribePurchasedApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePurchasedApisResponse describePurchasedApis(shared_ptr<DescribePurchasedApisRequest> request);
  DescribeRaceWorkForInnerResponse describeRaceWorkForInnerWithOptions(shared_ptr<DescribeRaceWorkForInnerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRaceWorkForInnerResponse describeRaceWorkForInner(shared_ptr<DescribeRaceWorkForInnerRequest> request);
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<DescribeRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions(shared_ptr<DescribeRegionsRequest> request);
  DescribeRulesByApiResponse describeRulesByApiWithOptions(shared_ptr<DescribeRulesByApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRulesByApiResponse describeRulesByApi(shared_ptr<DescribeRulesByApiRequest> request);
  DescribeSecretKeysResponse describeSecretKeysWithOptions(shared_ptr<DescribeSecretKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecretKeysResponse describeSecretKeys(shared_ptr<DescribeSecretKeysRequest> request);
  DescribeSystemParametersResponse describeSystemParametersWithOptions(shared_ptr<DescribeSystemParametersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSystemParametersResponse describeSystemParameters(shared_ptr<DescribeSystemParametersRequest> request);
  DescribeSystemParamsResponse describeSystemParamsWithOptions(shared_ptr<DescribeSystemParamsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSystemParamsResponse describeSystemParams(shared_ptr<DescribeSystemParamsRequest> request);
  DescribeTrafficControlsResponse describeTrafficControlsWithOptions(shared_ptr<DescribeTrafficControlsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTrafficControlsResponse describeTrafficControls(shared_ptr<DescribeTrafficControlsRequest> request);
  GetApiMethodsResponse getApiMethodsWithOptions(shared_ptr<GetApiMethodsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetApiMethodsResponse getApiMethods(shared_ptr<GetApiMethodsRequest> request);
  GetCustomizedInfoResponse getCustomizedInfoWithOptions(shared_ptr<GetCustomizedInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCustomizedInfoResponse getCustomizedInfo(shared_ptr<GetCustomizedInfoRequest> request);
  ModifyApiResponse modifyApiWithOptions(shared_ptr<ModifyApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApiResponse modifyApi(shared_ptr<ModifyApiRequest> request);
  ModifyApiGroupResponse modifyApiGroupWithOptions(shared_ptr<ModifyApiGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApiGroupResponse modifyApiGroup(shared_ptr<ModifyApiGroupRequest> request);
  ModifyAppResponse modifyAppWithOptions(shared_ptr<ModifyAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAppResponse modifyApp(shared_ptr<ModifyAppRequest> request);
  ModifyIpControlResponse modifyIpControlWithOptions(shared_ptr<ModifyIpControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyIpControlResponse modifyIpControl(shared_ptr<ModifyIpControlRequest> request);
  ModifyIpControlPolicyItemResponse modifyIpControlPolicyItemWithOptions(shared_ptr<ModifyIpControlPolicyItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyIpControlPolicyItemResponse modifyIpControlPolicyItem(shared_ptr<ModifyIpControlPolicyItemRequest> request);
  ModifyLogConfigResponse modifyLogConfigWithOptions(shared_ptr<ModifyLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLogConfigResponse modifyLogConfig(shared_ptr<ModifyLogConfigRequest> request);
  ModifySecretKeyResponse modifySecretKeyWithOptions(shared_ptr<ModifySecretKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySecretKeyResponse modifySecretKey(shared_ptr<ModifySecretKeyRequest> request);
  ModifyTrafficControlResponse modifyTrafficControlWithOptions(shared_ptr<ModifyTrafficControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTrafficControlResponse modifyTrafficControl(shared_ptr<ModifyTrafficControlRequest> request);
  ReactivateDomainResponse reactivateDomainWithOptions(shared_ptr<ReactivateDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReactivateDomainResponse reactivateDomain(shared_ptr<ReactivateDomainRequest> request);
  RecoverApiFromHistoricalResponse recoverApiFromHistoricalWithOptions(shared_ptr<RecoverApiFromHistoricalRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecoverApiFromHistoricalResponse recoverApiFromHistorical(shared_ptr<RecoverApiFromHistoricalRequest> request);
  RecoveryApiDefineFromHistoricalResponse recoveryApiDefineFromHistoricalWithOptions(shared_ptr<RecoveryApiDefineFromHistoricalRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecoveryApiDefineFromHistoricalResponse recoveryApiDefineFromHistorical(shared_ptr<RecoveryApiDefineFromHistoricalRequest> request);
  RecoveryApiFromHistoricalResponse recoveryApiFromHistoricalWithOptions(shared_ptr<RecoveryApiFromHistoricalRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecoveryApiFromHistoricalResponse recoveryApiFromHistorical(shared_ptr<RecoveryApiFromHistoricalRequest> request);
  RefreshDomainResponse refreshDomainWithOptions(shared_ptr<RefreshDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshDomainResponse refreshDomain(shared_ptr<RefreshDomainRequest> request);
  RemoveAccessPermissionByApisResponse removeAccessPermissionByApisWithOptions(shared_ptr<RemoveAccessPermissionByApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveAccessPermissionByApisResponse removeAccessPermissionByApis(shared_ptr<RemoveAccessPermissionByApisRequest> request);
  RemoveAccessPermissionByAppsResponse removeAccessPermissionByAppsWithOptions(shared_ptr<RemoveAccessPermissionByAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveAccessPermissionByAppsResponse removeAccessPermissionByApps(shared_ptr<RemoveAccessPermissionByAppsRequest> request);
  RemoveAllBlackListResponse removeAllBlackListWithOptions(shared_ptr<RemoveAllBlackListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveAllBlackListResponse removeAllBlackList(shared_ptr<RemoveAllBlackListRequest> request);
  RemoveApiRuleResponse removeApiRuleWithOptions(shared_ptr<RemoveApiRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveApiRuleResponse removeApiRule(shared_ptr<RemoveApiRuleRequest> request);
  RemoveAppsFromApiResponse removeAppsFromApiWithOptions(shared_ptr<RemoveAppsFromApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveAppsFromApiResponse removeAppsFromApi(shared_ptr<RemoveAppsFromApiRequest> request);
  RemoveBlackListResponse removeBlackListWithOptions(shared_ptr<RemoveBlackListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveBlackListResponse removeBlackList(shared_ptr<RemoveBlackListRequest> request);
  RemoveIpControlApisResponse removeIpControlApisWithOptions(shared_ptr<RemoveIpControlApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveIpControlApisResponse removeIpControlApis(shared_ptr<RemoveIpControlApisRequest> request);
  RemoveIpControlPolicyItemResponse removeIpControlPolicyItemWithOptions(shared_ptr<RemoveIpControlPolicyItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveIpControlPolicyItemResponse removeIpControlPolicyItem(shared_ptr<RemoveIpControlPolicyItemRequest> request);
  ResetAppKeySecretResponse resetAppKeySecretWithOptions(shared_ptr<ResetAppKeySecretRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetAppKeySecretResponse resetAppKeySecret(shared_ptr<ResetAppKeySecretRequest> request);
  ResetCustomizedResponse resetCustomizedWithOptions(shared_ptr<ResetCustomizedRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetCustomizedResponse resetCustomized(shared_ptr<ResetCustomizedRequest> request);
  SdkGenerateResponse sdkGenerateWithOptions(shared_ptr<SdkGenerateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SdkGenerateResponse sdkGenerate(shared_ptr<SdkGenerateRequest> request);
  SdkGenerateByAppResponse sdkGenerateByAppWithOptions(shared_ptr<SdkGenerateByAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SdkGenerateByAppResponse sdkGenerateByApp(shared_ptr<SdkGenerateByAppRequest> request);
  SdkGenerateByGroupResponse sdkGenerateByGroupWithOptions(shared_ptr<SdkGenerateByGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SdkGenerateByGroupResponse sdkGenerateByGroup(shared_ptr<SdkGenerateByGroupRequest> request);
  SetAccessPermissionByApisResponse setAccessPermissionByApisWithOptions(shared_ptr<SetAccessPermissionByApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetAccessPermissionByApisResponse setAccessPermissionByApis(shared_ptr<SetAccessPermissionByApisRequest> request);
  SetAccessPermissionsResponse setAccessPermissionsWithOptions(shared_ptr<SetAccessPermissionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetAccessPermissionsResponse setAccessPermissions(shared_ptr<SetAccessPermissionsRequest> request);
  SetApiRuleResponse setApiRuleWithOptions(shared_ptr<SetApiRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetApiRuleResponse setApiRule(shared_ptr<SetApiRuleRequest> request);
  SetDomainResponse setDomainWithOptions(shared_ptr<SetDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDomainResponse setDomain(shared_ptr<SetDomainRequest> request);
  SetDomainCertificateResponse setDomainCertificateWithOptions(shared_ptr<SetDomainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDomainCertificateResponse setDomainCertificate(shared_ptr<SetDomainCertificateRequest> request);
  SetDomainWebSocketStatusResponse setDomainWebSocketStatusWithOptions(shared_ptr<SetDomainWebSocketStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDomainWebSocketStatusResponse setDomainWebSocketStatus(shared_ptr<SetDomainWebSocketStatusRequest> request);
  SetIpControlApisResponse setIpControlApisWithOptions(shared_ptr<SetIpControlApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetIpControlApisResponse setIpControlApis(shared_ptr<SetIpControlApisRequest> request);
  SetMockIntegrationResponse setMockIntegrationWithOptions(shared_ptr<SetMockIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetMockIntegrationResponse setMockIntegration(shared_ptr<SetMockIntegrationRequest> request);
  SwitchApiResponse switchApiWithOptions(shared_ptr<SwitchApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchApiResponse switchApi(shared_ptr<SwitchApiRequest> request);
  VpcDescribeAccessesResponse vpcDescribeAccessesWithOptions(shared_ptr<VpcDescribeAccessesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VpcDescribeAccessesResponse vpcDescribeAccesses(shared_ptr<VpcDescribeAccessesRequest> request);
  VpcGrantAccessResponse vpcGrantAccessWithOptions(shared_ptr<VpcGrantAccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VpcGrantAccessResponse vpcGrantAccess(shared_ptr<VpcGrantAccessRequest> request);
  VpcModifyAccessResponse vpcModifyAccessWithOptions(shared_ptr<VpcModifyAccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VpcModifyAccessResponse vpcModifyAccess(shared_ptr<VpcModifyAccessRequest> request);
  VpcRevokeAccessResponse vpcRevokeAccessWithOptions(shared_ptr<VpcRevokeAccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VpcRevokeAccessResponse vpcRevokeAccess(shared_ptr<VpcRevokeAccessRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_CloudAPI20180601

#endif
