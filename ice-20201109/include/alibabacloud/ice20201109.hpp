// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_ICE20201109_H_
#define ALIBABACLOUD_ICE20201109_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_ICE20201109 {
class AddCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> cateName{};
  shared_ptr<long> parentId{};
  shared_ptr<string> type{};

  AddCategoryRequest() {}

  explicit AddCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddCategoryRequest() = default;
};
class AddCategoryResponseBodyCategory : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<long> level{};
  shared_ptr<long> parentId{};
  shared_ptr<string> type{};

  AddCategoryResponseBodyCategory() {}

  explicit AddCategoryResponseBodyCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddCategoryResponseBodyCategory() = default;
};
class AddCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddCategoryResponseBodyCategory> category{};
  shared_ptr<string> requestId{};

  AddCategoryResponseBody() {}

  explicit AddCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = category ? boost::any(category->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(map<string, boost::any>) == m["Category"].type()) {
        AddCategoryResponseBodyCategory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Category"]));
        category = make_shared<AddCategoryResponseBodyCategory>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCategoryResponseBody() = default;
};
class AddCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCategoryResponseBody> body{};

  AddCategoryResponse() {}

  explicit AddCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~AddCategoryResponse() = default;
};
class AddEditingProjectMaterialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> materialMaps{};
  shared_ptr<string> projectId{};

  AddEditingProjectMaterialsRequest() {}

  explicit AddEditingProjectMaterialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (materialMaps) {
      res["MaterialMaps"] = boost::any(*materialMaps);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaterialMaps") != m.end() && !m["MaterialMaps"].empty()) {
      materialMaps = make_shared<string>(boost::any_cast<string>(m["MaterialMaps"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~AddEditingProjectMaterialsRequest() = default;
};
class AddEditingProjectMaterialsResponseBodyLiveMaterials : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> liveUrl{};
  shared_ptr<string> streamName{};

  AddEditingProjectMaterialsResponseBodyLiveMaterials() {}

  explicit AddEditingProjectMaterialsResponseBodyLiveMaterials(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (liveUrl) {
      res["LiveUrl"] = boost::any(*liveUrl);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LiveUrl") != m.end() && !m["LiveUrl"].empty()) {
      liveUrl = make_shared<string>(boost::any_cast<string>(m["LiveUrl"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~AddEditingProjectMaterialsResponseBodyLiveMaterials() = default;
};
class AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo() {}

  explicit AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo() = default;
};
class AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList : public Darabonba::Model {
public:
  shared_ptr<AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo> fileBasicInfo{};

  AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList() {}

  explicit AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo>(model1);
      }
    }
  }


  virtual ~AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList() = default;
};
class AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> snapshots{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteImages{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> transcodeStatus{};
  shared_ptr<string> userData{};

  AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo() {}

  explicit AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteImages) {
      res["SpriteImages"] = boost::any(*spriteImages);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (transcodeStatus) {
      res["TranscodeStatus"] = boost::any(*transcodeStatus);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      snapshots = make_shared<string>(boost::any_cast<string>(m["Snapshots"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteImages") != m.end() && !m["SpriteImages"].empty()) {
      spriteImages = make_shared<string>(boost::any_cast<string>(m["SpriteImages"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TranscodeStatus") != m.end() && !m["TranscodeStatus"].empty()) {
      transcodeStatus = make_shared<string>(boost::any_cast<string>(m["TranscodeStatus"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo() = default;
};
class AddEditingProjectMaterialsResponseBodyMediaInfos : public Darabonba::Model {
public:
  shared_ptr<vector<AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList>> fileInfoList{};
  shared_ptr<AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  AddEditingProjectMaterialsResponseBodyMediaInfos() {}

  explicit AddEditingProjectMaterialsResponseBodyMediaInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList>>(expect1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~AddEditingProjectMaterialsResponseBodyMediaInfos() = default;
};
class AddEditingProjectMaterialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<AddEditingProjectMaterialsResponseBodyLiveMaterials>> liveMaterials{};
  shared_ptr<vector<AddEditingProjectMaterialsResponseBodyMediaInfos>> mediaInfos{};
  shared_ptr<string> projectId{};
  shared_ptr<vector<string>> projectMaterials{};
  shared_ptr<string> requestId{};

  AddEditingProjectMaterialsResponseBody() {}

  explicit AddEditingProjectMaterialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveMaterials) {
      vector<boost::any> temp1;
      for(auto item1:*liveMaterials){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveMaterials"] = boost::any(temp1);
    }
    if (mediaInfos) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInfos"] = boost::any(temp1);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectMaterials) {
      res["ProjectMaterials"] = boost::any(*projectMaterials);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveMaterials") != m.end() && !m["LiveMaterials"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveMaterials"].type()) {
        vector<AddEditingProjectMaterialsResponseBodyLiveMaterials> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveMaterials"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddEditingProjectMaterialsResponseBodyLiveMaterials model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveMaterials = make_shared<vector<AddEditingProjectMaterialsResponseBodyLiveMaterials>>(expect1);
      }
    }
    if (m.find("MediaInfos") != m.end() && !m["MediaInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInfos"].type()) {
        vector<AddEditingProjectMaterialsResponseBodyMediaInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddEditingProjectMaterialsResponseBodyMediaInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInfos = make_shared<vector<AddEditingProjectMaterialsResponseBodyMediaInfos>>(expect1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectMaterials") != m.end() && !m["ProjectMaterials"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProjectMaterials"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProjectMaterials"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      projectMaterials = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddEditingProjectMaterialsResponseBody() = default;
};
class AddEditingProjectMaterialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddEditingProjectMaterialsResponseBody> body{};

  AddEditingProjectMaterialsResponse() {}

  explicit AddEditingProjectMaterialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddEditingProjectMaterialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddEditingProjectMaterialsResponseBody>(model1);
      }
    }
  }


  virtual ~AddEditingProjectMaterialsResponse() = default;
};
class AddFavoritePublicMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaIds{};

  AddFavoritePublicMediaRequest() {}

  explicit AddFavoritePublicMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
  }


  virtual ~AddFavoritePublicMediaRequest() = default;
};
class AddFavoritePublicMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ignoredList{};
  shared_ptr<string> requestId{};

  AddFavoritePublicMediaResponseBody() {}

  explicit AddFavoritePublicMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoredList) {
      res["IgnoredList"] = boost::any(*ignoredList);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoredList") != m.end() && !m["IgnoredList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IgnoredList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IgnoredList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ignoredList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddFavoritePublicMediaResponseBody() = default;
};
class AddFavoritePublicMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddFavoritePublicMediaResponseBody> body{};

  AddFavoritePublicMediaResponse() {}

  explicit AddFavoritePublicMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddFavoritePublicMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddFavoritePublicMediaResponseBody>(model1);
      }
    }
  }


  virtual ~AddFavoritePublicMediaResponse() = default;
};
class AddTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> coverUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> previewMedia{};
  shared_ptr<string> relatedMediaids{};
  shared_ptr<string> source{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  AddTemplateRequest() {}

  explicit AddTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (previewMedia) {
      res["PreviewMedia"] = boost::any(*previewMedia);
    }
    if (relatedMediaids) {
      res["RelatedMediaids"] = boost::any(*relatedMediaids);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PreviewMedia") != m.end() && !m["PreviewMedia"].empty()) {
      previewMedia = make_shared<string>(boost::any_cast<string>(m["PreviewMedia"]));
    }
    if (m.find("RelatedMediaids") != m.end() && !m["RelatedMediaids"].empty()) {
      relatedMediaids = make_shared<string>(boost::any_cast<string>(m["RelatedMediaids"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddTemplateRequest() = default;
};
class AddTemplateResponseBodyTemplate : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> coverUrl{};
  shared_ptr<string> createSource{};
  shared_ptr<string> modifiedSource{};
  shared_ptr<string> name{};
  shared_ptr<string> previewMedia{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  AddTemplateResponseBodyTemplate() {}

  explicit AddTemplateResponseBodyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (modifiedSource) {
      res["ModifiedSource"] = boost::any(*modifiedSource);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (previewMedia) {
      res["PreviewMedia"] = boost::any(*previewMedia);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("ModifiedSource") != m.end() && !m["ModifiedSource"].empty()) {
      modifiedSource = make_shared<string>(boost::any_cast<string>(m["ModifiedSource"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PreviewMedia") != m.end() && !m["PreviewMedia"].empty()) {
      previewMedia = make_shared<string>(boost::any_cast<string>(m["PreviewMedia"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplate() = default;
};
class AddTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddTemplateResponseBodyTemplate> template_{};

  AddTemplateResponseBody() {}

  explicit AddTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (template_) {
      res["Template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(map<string, boost::any>) == m["Template"].type()) {
        AddTemplateResponseBodyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Template"]));
        template_ = make_shared<AddTemplateResponseBodyTemplate>(model1);
      }
    }
  }


  virtual ~AddTemplateResponseBody() = default;
};
class AddTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTemplateResponseBody> body{};

  AddTemplateResponse() {}

  explicit AddTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~AddTemplateResponse() = default;
};
class BatchGetMediaInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> additionType{};
  shared_ptr<string> mediaIds{};

  BatchGetMediaInfosRequest() {}

  explicit BatchGetMediaInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionType) {
      res["AdditionType"] = boost::any(*additionType);
    }
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionType") != m.end() && !m["AdditionType"].empty()) {
      additionType = make_shared<string>(boost::any_cast<string>(m["AdditionType"]));
    }
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
  }


  virtual ~BatchGetMediaInfosRequest() = default;
};
class BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo() {}

  explicit BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo() = default;
};
class BatchGetMediaInfosResponseBodyMediaInfosFileInfoList : public Darabonba::Model {
public:
  shared_ptr<BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo> fileBasicInfo{};

  BatchGetMediaInfosResponseBodyMediaInfosFileInfoList() {}

  explicit BatchGetMediaInfosResponseBodyMediaInfosFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo>(model1);
      }
    }
  }


  virtual ~BatchGetMediaInfosResponseBodyMediaInfosFileInfoList() = default;
};
class BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> snapshots{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteImages{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> transcodeStatus{};
  shared_ptr<string> userData{};

  BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo() {}

  explicit BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteImages) {
      res["SpriteImages"] = boost::any(*spriteImages);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (transcodeStatus) {
      res["TranscodeStatus"] = boost::any(*transcodeStatus);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      snapshots = make_shared<string>(boost::any_cast<string>(m["Snapshots"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteImages") != m.end() && !m["SpriteImages"].empty()) {
      spriteImages = make_shared<string>(boost::any_cast<string>(m["SpriteImages"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TranscodeStatus") != m.end() && !m["TranscodeStatus"].empty()) {
      transcodeStatus = make_shared<string>(boost::any_cast<string>(m["TranscodeStatus"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo() = default;
};
class BatchGetMediaInfosResponseBodyMediaInfos : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetMediaInfosResponseBodyMediaInfosFileInfoList>> fileInfoList{};
  shared_ptr<BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  BatchGetMediaInfosResponseBodyMediaInfos() {}

  explicit BatchGetMediaInfosResponseBodyMediaInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<BatchGetMediaInfosResponseBodyMediaInfosFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetMediaInfosResponseBodyMediaInfosFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<BatchGetMediaInfosResponseBodyMediaInfosFileInfoList>>(expect1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~BatchGetMediaInfosResponseBodyMediaInfos() = default;
};
class BatchGetMediaInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetMediaInfosResponseBodyMediaInfos>> mediaInfos{};
  shared_ptr<string> requestId{};

  BatchGetMediaInfosResponseBody() {}

  explicit BatchGetMediaInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfos) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfos") != m.end() && !m["MediaInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInfos"].type()) {
        vector<BatchGetMediaInfosResponseBodyMediaInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetMediaInfosResponseBodyMediaInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInfos = make_shared<vector<BatchGetMediaInfosResponseBodyMediaInfos>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchGetMediaInfosResponseBody() = default;
};
class BatchGetMediaInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchGetMediaInfosResponseBody> body{};

  BatchGetMediaInfosResponse() {}

  explicit BatchGetMediaInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetMediaInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetMediaInfosResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetMediaInfosResponse() = default;
};
class CancelFavoritePublicMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaIds{};

  CancelFavoritePublicMediaRequest() {}

  explicit CancelFavoritePublicMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
  }


  virtual ~CancelFavoritePublicMediaRequest() = default;
};
class CancelFavoritePublicMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ignoredList{};
  shared_ptr<string> requestId{};

  CancelFavoritePublicMediaResponseBody() {}

  explicit CancelFavoritePublicMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoredList) {
      res["IgnoredList"] = boost::any(*ignoredList);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoredList") != m.end() && !m["IgnoredList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IgnoredList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IgnoredList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ignoredList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelFavoritePublicMediaResponseBody() = default;
};
class CancelFavoritePublicMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelFavoritePublicMediaResponseBody> body{};

  CancelFavoritePublicMediaResponse() {}

  explicit CancelFavoritePublicMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelFavoritePublicMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelFavoritePublicMediaResponseBody>(model1);
      }
    }
  }


  virtual ~CancelFavoritePublicMediaResponse() = default;
};
class CreateCustomTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> subtype{};
  shared_ptr<string> templateConfig{};
  shared_ptr<long> type{};

  CreateCustomTemplateRequest() {}

  explicit CreateCustomTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<long>(boost::any_cast<long>(m["Subtype"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~CreateCustomTemplateRequest() = default;
};
class CreateCustomTemplateResponseBodyCustomTemplate : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> status{};
  shared_ptr<string> subtype{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> type{};
  shared_ptr<string> typeName_{};

  CreateCustomTemplateResponseBodyCustomTemplate() {}

  explicit CreateCustomTemplateResponseBodyCustomTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<string>(boost::any_cast<string>(m["Subtype"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~CreateCustomTemplateResponseBodyCustomTemplate() = default;
};
class CreateCustomTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateCustomTemplateResponseBodyCustomTemplate> customTemplate{};
  shared_ptr<string> requestId{};

  CreateCustomTemplateResponseBody() {}

  explicit CreateCustomTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTemplate) {
      res["CustomTemplate"] = customTemplate ? boost::any(customTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTemplate") != m.end() && !m["CustomTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomTemplate"].type()) {
        CreateCustomTemplateResponseBodyCustomTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomTemplate"]));
        customTemplate = make_shared<CreateCustomTemplateResponseBodyCustomTemplate>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomTemplateResponseBody() = default;
};
class CreateCustomTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomTemplateResponseBody> body{};

  CreateCustomTemplateResponse() {}

  explicit CreateCustomTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomTemplateResponse() = default;
};
class CreateEditingProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessConfig{};
  shared_ptr<string> clipsParam{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> materialMaps{};
  shared_ptr<string> projectType{};
  shared_ptr<string> templateId{};
  shared_ptr<string> timeline{};
  shared_ptr<string> title{};

  CreateEditingProjectRequest() {}

  explicit CreateEditingProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessConfig) {
      res["BusinessConfig"] = boost::any(*businessConfig);
    }
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (materialMaps) {
      res["MaterialMaps"] = boost::any(*materialMaps);
    }
    if (projectType) {
      res["ProjectType"] = boost::any(*projectType);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessConfig") != m.end() && !m["BusinessConfig"].empty()) {
      businessConfig = make_shared<string>(boost::any_cast<string>(m["BusinessConfig"]));
    }
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MaterialMaps") != m.end() && !m["MaterialMaps"].empty()) {
      materialMaps = make_shared<string>(boost::any_cast<string>(m["MaterialMaps"]));
    }
    if (m.find("ProjectType") != m.end() && !m["ProjectType"].empty()) {
      projectType = make_shared<string>(boost::any_cast<string>(m["ProjectType"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateEditingProjectRequest() = default;
};
class CreateEditingProjectResponseBodyProject : public Darabonba::Model {
public:
  shared_ptr<string> businessConfig{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> clipsParam{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createSource{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<double> duration{};
  shared_ptr<string> modifiedSource{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectType{};
  shared_ptr<long> status{};
  shared_ptr<string> statusName{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};
  shared_ptr<string> timeline{};
  shared_ptr<string> title{};

  CreateEditingProjectResponseBodyProject() {}

  explicit CreateEditingProjectResponseBodyProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessConfig) {
      res["BusinessConfig"] = boost::any(*businessConfig);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (modifiedSource) {
      res["ModifiedSource"] = boost::any(*modifiedSource);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectType) {
      res["ProjectType"] = boost::any(*projectType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusName) {
      res["StatusName"] = boost::any(*statusName);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessConfig") != m.end() && !m["BusinessConfig"].empty()) {
      businessConfig = make_shared<string>(boost::any_cast<string>(m["BusinessConfig"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("ModifiedSource") != m.end() && !m["ModifiedSource"].empty()) {
      modifiedSource = make_shared<string>(boost::any_cast<string>(m["ModifiedSource"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectType") != m.end() && !m["ProjectType"].empty()) {
      projectType = make_shared<string>(boost::any_cast<string>(m["ProjectType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StatusName") != m.end() && !m["StatusName"].empty()) {
      statusName = make_shared<string>(boost::any_cast<string>(m["StatusName"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateEditingProjectResponseBodyProject() = default;
};
class CreateEditingProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateEditingProjectResponseBodyProject> project{};
  shared_ptr<string> requestId{};

  CreateEditingProjectResponseBody() {}

  explicit CreateEditingProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (project) {
      res["Project"] = project ? boost::any(project->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      if (typeid(map<string, boost::any>) == m["Project"].type()) {
        CreateEditingProjectResponseBodyProject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Project"]));
        project = make_shared<CreateEditingProjectResponseBodyProject>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEditingProjectResponseBody() = default;
};
class CreateEditingProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEditingProjectResponseBody> body{};

  CreateEditingProjectResponse() {}

  explicit CreateEditingProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEditingProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEditingProjectResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEditingProjectResponse() = default;
};
class CreateLiveRecordTemplateRequestRecordFormat : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<long> sliceDuration{};
  shared_ptr<string> sliceOssObjectPrefix{};

  CreateLiveRecordTemplateRequestRecordFormat() {}

  explicit CreateLiveRecordTemplateRequestRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~CreateLiveRecordTemplateRequestRecordFormat() = default;
};
class CreateLiveRecordTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<vector<CreateLiveRecordTemplateRequestRecordFormat>> recordFormat{};

  CreateLiveRecordTemplateRequest() {}

  explicit CreateLiveRecordTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordFormat) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormat"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormat"].type()) {
        vector<CreateLiveRecordTemplateRequestRecordFormat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateLiveRecordTemplateRequestRecordFormat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormat = make_shared<vector<CreateLiveRecordTemplateRequestRecordFormat>>(expect1);
      }
    }
  }


  virtual ~CreateLiveRecordTemplateRequest() = default;
};
class CreateLiveRecordTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> recordFormatShrink{};

  CreateLiveRecordTemplateShrinkRequest() {}

  explicit CreateLiveRecordTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordFormatShrink) {
      res["RecordFormat"] = boost::any(*recordFormatShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      recordFormatShrink = make_shared<string>(boost::any_cast<string>(m["RecordFormat"]));
    }
  }


  virtual ~CreateLiveRecordTemplateShrinkRequest() = default;
};
class CreateLiveRecordTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  CreateLiveRecordTemplateResponseBody() {}

  explicit CreateLiveRecordTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateLiveRecordTemplateResponseBody() = default;
};
class CreateLiveRecordTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveRecordTemplateResponseBody> body{};

  CreateLiveRecordTemplateResponse() {}

  explicit CreateLiveRecordTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveRecordTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveRecordTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveRecordTemplateResponse() = default;
};
class CreateLiveSnapshotTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> overwriteFormat{};
  shared_ptr<string> sequenceFormat{};
  shared_ptr<string> templateName{};
  shared_ptr<long> timeInterval{};

  CreateLiveSnapshotTemplateRequest() {}

  explicit CreateLiveSnapshotTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteFormat) {
      res["OverwriteFormat"] = boost::any(*overwriteFormat);
    }
    if (sequenceFormat) {
      res["SequenceFormat"] = boost::any(*sequenceFormat);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteFormat") != m.end() && !m["OverwriteFormat"].empty()) {
      overwriteFormat = make_shared<string>(boost::any_cast<string>(m["OverwriteFormat"]));
    }
    if (m.find("SequenceFormat") != m.end() && !m["SequenceFormat"].empty()) {
      sequenceFormat = make_shared<string>(boost::any_cast<string>(m["SequenceFormat"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
  }


  virtual ~CreateLiveSnapshotTemplateRequest() = default;
};
class CreateLiveSnapshotTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  CreateLiveSnapshotTemplateResponseBody() {}

  explicit CreateLiveSnapshotTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateLiveSnapshotTemplateResponseBody() = default;
};
class CreateLiveSnapshotTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveSnapshotTemplateResponseBody> body{};

  CreateLiveSnapshotTemplateResponse() {}

  explicit CreateLiveSnapshotTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveSnapshotTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveSnapshotTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveSnapshotTemplateResponse() = default;
};
class CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> samplerate{};

  CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams() {}

  explicit CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams() = default;
};
class CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> codec{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> profile{};
  shared_ptr<string> width{};

  CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams() {}

  explicit CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams() = default;
};
class CreateLiveTranscodeTemplateRequestTemplateConfig : public Darabonba::Model {
public:
  shared_ptr<CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams> audioParams{};
  shared_ptr<CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams> videoParams{};

  CreateLiveTranscodeTemplateRequestTemplateConfig() {}

  explicit CreateLiveTranscodeTemplateRequestTemplateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioParams) {
      res["AudioParams"] = audioParams ? boost::any(audioParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoParams) {
      res["VideoParams"] = videoParams ? boost::any(videoParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioParams") != m.end() && !m["AudioParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioParams"].type()) {
        CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioParams"]));
        audioParams = make_shared<CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams>(model1);
      }
    }
    if (m.find("VideoParams") != m.end() && !m["VideoParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoParams"].type()) {
        CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoParams"]));
        videoParams = make_shared<CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams>(model1);
      }
    }
  }


  virtual ~CreateLiveTranscodeTemplateRequestTemplateConfig() = default;
};
class CreateLiveTranscodeTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<CreateLiveTranscodeTemplateRequestTemplateConfig> templateConfig{};
  shared_ptr<string> type{};

  CreateLiveTranscodeTemplateRequest() {}

  explicit CreateLiveTranscodeTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        CreateLiveTranscodeTemplateRequestTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<CreateLiveTranscodeTemplateRequestTemplateConfig>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateLiveTranscodeTemplateRequest() = default;
};
class CreateLiveTranscodeTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> templateConfigShrink{};
  shared_ptr<string> type{};

  CreateLiveTranscodeTemplateShrinkRequest() {}

  explicit CreateLiveTranscodeTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfigShrink) {
      res["TemplateConfig"] = boost::any(*templateConfigShrink);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfigShrink = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateLiveTranscodeTemplateShrinkRequest() = default;
};
class CreateLiveTranscodeTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  CreateLiveTranscodeTemplateResponseBody() {}

  explicit CreateLiveTranscodeTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateLiveTranscodeTemplateResponseBody() = default;
};
class CreateLiveTranscodeTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveTranscodeTemplateResponseBody> body{};

  CreateLiveTranscodeTemplateResponse() {}

  explicit CreateLiveTranscodeTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveTranscodeTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveTranscodeTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveTranscodeTemplateResponse() = default;
};
class CreatePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> priority{};
  shared_ptr<string> speed{};

  CreatePipelineRequest() {}

  explicit CreatePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
  }


  virtual ~CreatePipelineRequest() = default;
};
class CreatePipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};
  shared_ptr<string> speed{};
  shared_ptr<string> status{};

  CreatePipelineResponseBodyPipeline() {}

  explicit CreatePipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreatePipelineResponseBodyPipeline() = default;
};
class CreatePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreatePipelineResponseBodyPipeline> pipeline{};
  shared_ptr<string> requestId{};

  CreatePipelineResponseBody() {}

  explicit CreatePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        CreatePipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<CreatePipelineResponseBodyPipeline>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePipelineResponseBody() = default;
};
class CreatePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePipelineResponseBody> body{};

  CreatePipelineResponse() {}

  explicit CreatePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePipelineResponse() = default;
};
class CreateUploadMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> entityId{};
  shared_ptr<string> fileInfo{};
  shared_ptr<string> mediaMetaData{};
  shared_ptr<string> postProcessConfig{};
  shared_ptr<string> uploadTargetConfig{};
  shared_ptr<string> userData{};

  CreateUploadMediaRequest() {}

  explicit CreateUploadMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (fileInfo) {
      res["FileInfo"] = boost::any(*fileInfo);
    }
    if (mediaMetaData) {
      res["MediaMetaData"] = boost::any(*mediaMetaData);
    }
    if (postProcessConfig) {
      res["PostProcessConfig"] = boost::any(*postProcessConfig);
    }
    if (uploadTargetConfig) {
      res["UploadTargetConfig"] = boost::any(*uploadTargetConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("FileInfo") != m.end() && !m["FileInfo"].empty()) {
      fileInfo = make_shared<string>(boost::any_cast<string>(m["FileInfo"]));
    }
    if (m.find("MediaMetaData") != m.end() && !m["MediaMetaData"].empty()) {
      mediaMetaData = make_shared<string>(boost::any_cast<string>(m["MediaMetaData"]));
    }
    if (m.find("PostProcessConfig") != m.end() && !m["PostProcessConfig"].empty()) {
      postProcessConfig = make_shared<string>(boost::any_cast<string>(m["PostProcessConfig"]));
    }
    if (m.find("UploadTargetConfig") != m.end() && !m["UploadTargetConfig"].empty()) {
      uploadTargetConfig = make_shared<string>(boost::any_cast<string>(m["UploadTargetConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateUploadMediaRequest() = default;
};
class CreateUploadMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fileURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaURL{};
  shared_ptr<string> requestId{};
  shared_ptr<string> uploadAddress{};
  shared_ptr<string> uploadAuth{};

  CreateUploadMediaResponseBody() {}

  explicit CreateUploadMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaURL) {
      res["MediaURL"] = boost::any(*mediaURL);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadAddress) {
      res["UploadAddress"] = boost::any(*uploadAddress);
    }
    if (uploadAuth) {
      res["UploadAuth"] = boost::any(*uploadAuth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaURL") != m.end() && !m["MediaURL"].empty()) {
      mediaURL = make_shared<string>(boost::any_cast<string>(m["MediaURL"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadAddress") != m.end() && !m["UploadAddress"].empty()) {
      uploadAddress = make_shared<string>(boost::any_cast<string>(m["UploadAddress"]));
    }
    if (m.find("UploadAuth") != m.end() && !m["UploadAuth"].empty()) {
      uploadAuth = make_shared<string>(boost::any_cast<string>(m["UploadAuth"]));
    }
  }


  virtual ~CreateUploadMediaResponseBody() = default;
};
class CreateUploadMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUploadMediaResponseBody> body{};

  CreateUploadMediaResponse() {}

  explicit CreateUploadMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUploadMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUploadMediaResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUploadMediaResponse() = default;
};
class CreateUploadStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> definition{};
  shared_ptr<string> fileExtension{};
  shared_ptr<string> HDRType{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> userData{};

  CreateUploadStreamRequest() {}

  explicit CreateUploadStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (fileExtension) {
      res["FileExtension"] = boost::any(*fileExtension);
    }
    if (HDRType) {
      res["HDRType"] = boost::any(*HDRType);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("FileExtension") != m.end() && !m["FileExtension"].empty()) {
      fileExtension = make_shared<string>(boost::any_cast<string>(m["FileExtension"]));
    }
    if (m.find("HDRType") != m.end() && !m["HDRType"].empty()) {
      HDRType = make_shared<string>(boost::any_cast<string>(m["HDRType"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateUploadStreamRequest() = default;
};
class CreateUploadStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fileURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> uploadAddress{};
  shared_ptr<string> uploadAuth{};

  CreateUploadStreamResponseBody() {}

  explicit CreateUploadStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadAddress) {
      res["UploadAddress"] = boost::any(*uploadAddress);
    }
    if (uploadAuth) {
      res["UploadAuth"] = boost::any(*uploadAuth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadAddress") != m.end() && !m["UploadAddress"].empty()) {
      uploadAddress = make_shared<string>(boost::any_cast<string>(m["UploadAddress"]));
    }
    if (m.find("UploadAuth") != m.end() && !m["UploadAuth"].empty()) {
      uploadAuth = make_shared<string>(boost::any_cast<string>(m["UploadAuth"]));
    }
  }


  virtual ~CreateUploadStreamResponseBody() = default;
};
class CreateUploadStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUploadStreamResponseBody> body{};

  CreateUploadStreamResponse() {}

  explicit CreateUploadStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUploadStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUploadStreamResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUploadStreamResponse() = default;
};
class DeleteCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};

  DeleteCategoryRequest() {}

  explicit DeleteCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
  }


  virtual ~DeleteCategoryRequest() = default;
};
class DeleteCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCategoryResponseBody() {}

  explicit DeleteCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCategoryResponseBody() = default;
};
class DeleteCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCategoryResponseBody> body{};

  DeleteCategoryResponse() {}

  explicit DeleteCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCategoryResponse() = default;
};
class DeleteCustomTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  DeleteCustomTemplateRequest() {}

  explicit DeleteCustomTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteCustomTemplateRequest() = default;
};
class DeleteCustomTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteCustomTemplateResponseBody() {}

  explicit DeleteCustomTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteCustomTemplateResponseBody() = default;
};
class DeleteCustomTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomTemplateResponseBody> body{};

  DeleteCustomTemplateResponse() {}

  explicit DeleteCustomTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomTemplateResponse() = default;
};
class DeleteEditingProjectMaterialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> materialIds{};
  shared_ptr<string> materialType{};
  shared_ptr<string> projectId{};

  DeleteEditingProjectMaterialsRequest() {}

  explicit DeleteEditingProjectMaterialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (materialIds) {
      res["MaterialIds"] = boost::any(*materialIds);
    }
    if (materialType) {
      res["MaterialType"] = boost::any(*materialType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaterialIds") != m.end() && !m["MaterialIds"].empty()) {
      materialIds = make_shared<string>(boost::any_cast<string>(m["MaterialIds"]));
    }
    if (m.find("MaterialType") != m.end() && !m["MaterialType"].empty()) {
      materialType = make_shared<string>(boost::any_cast<string>(m["MaterialType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DeleteEditingProjectMaterialsRequest() = default;
};
class DeleteEditingProjectMaterialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEditingProjectMaterialsResponseBody() {}

  explicit DeleteEditingProjectMaterialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEditingProjectMaterialsResponseBody() = default;
};
class DeleteEditingProjectMaterialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEditingProjectMaterialsResponseBody> body{};

  DeleteEditingProjectMaterialsResponse() {}

  explicit DeleteEditingProjectMaterialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEditingProjectMaterialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEditingProjectMaterialsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEditingProjectMaterialsResponse() = default;
};
class DeleteEditingProjectsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectIds{};

  DeleteEditingProjectsRequest() {}

  explicit DeleteEditingProjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectIds) {
      res["ProjectIds"] = boost::any(*projectIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectIds") != m.end() && !m["ProjectIds"].empty()) {
      projectIds = make_shared<string>(boost::any_cast<string>(m["ProjectIds"]));
    }
  }


  virtual ~DeleteEditingProjectsRequest() = default;
};
class DeleteEditingProjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEditingProjectsResponseBody() {}

  explicit DeleteEditingProjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEditingProjectsResponseBody() = default;
};
class DeleteEditingProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEditingProjectsResponseBody> body{};

  DeleteEditingProjectsResponse() {}

  explicit DeleteEditingProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEditingProjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEditingProjectsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEditingProjectsResponse() = default;
};
class DeleteLiveRecordFilesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> recordIds{};
  shared_ptr<bool> removeFile{};

  DeleteLiveRecordFilesRequest() {}

  explicit DeleteLiveRecordFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordIds) {
      res["RecordIds"] = boost::any(*recordIds);
    }
    if (removeFile) {
      res["RemoveFile"] = boost::any(*removeFile);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordIds") != m.end() && !m["RecordIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RemoveFile") != m.end() && !m["RemoveFile"].empty()) {
      removeFile = make_shared<bool>(boost::any_cast<bool>(m["RemoveFile"]));
    }
  }


  virtual ~DeleteLiveRecordFilesRequest() = default;
};
class DeleteLiveRecordFilesResponseBodyDeleteFileInfoList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> recordId{};

  DeleteLiveRecordFilesResponseBodyDeleteFileInfoList() {}

  explicit DeleteLiveRecordFilesResponseBodyDeleteFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
  }


  virtual ~DeleteLiveRecordFilesResponseBodyDeleteFileInfoList() = default;
};
class DeleteLiveRecordFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteLiveRecordFilesResponseBodyDeleteFileInfoList>> deleteFileInfoList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteLiveRecordFilesResponseBody() {}

  explicit DeleteLiveRecordFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteFileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*deleteFileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeleteFileInfoList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteFileInfoList") != m.end() && !m["DeleteFileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeleteFileInfoList"].type()) {
        vector<DeleteLiveRecordFilesResponseBodyDeleteFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeleteFileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteLiveRecordFilesResponseBodyDeleteFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deleteFileInfoList = make_shared<vector<DeleteLiveRecordFilesResponseBodyDeleteFileInfoList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveRecordFilesResponseBody() = default;
};
class DeleteLiveRecordFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveRecordFilesResponseBody> body{};

  DeleteLiveRecordFilesResponse() {}

  explicit DeleteLiveRecordFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveRecordFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveRecordFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveRecordFilesResponse() = default;
};
class DeleteLiveRecordTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  DeleteLiveRecordTemplateRequest() {}

  explicit DeleteLiveRecordTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteLiveRecordTemplateRequest() = default;
};
class DeleteLiveRecordTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveRecordTemplateResponseBody() {}

  explicit DeleteLiveRecordTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveRecordTemplateResponseBody() = default;
};
class DeleteLiveRecordTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveRecordTemplateResponseBody> body{};

  DeleteLiveRecordTemplateResponse() {}

  explicit DeleteLiveRecordTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveRecordTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveRecordTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveRecordTemplateResponse() = default;
};
class DeleteLiveSnapshotFilesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> createTimestampList{};
  shared_ptr<bool> deleteOriginalFile{};
  shared_ptr<string> jobId{};

  DeleteLiveSnapshotFilesRequest() {}

  explicit DeleteLiveSnapshotFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimestampList) {
      res["CreateTimestampList"] = boost::any(*createTimestampList);
    }
    if (deleteOriginalFile) {
      res["DeleteOriginalFile"] = boost::any(*deleteOriginalFile);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimestampList") != m.end() && !m["CreateTimestampList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CreateTimestampList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreateTimestampList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      createTimestampList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("DeleteOriginalFile") != m.end() && !m["DeleteOriginalFile"].empty()) {
      deleteOriginalFile = make_shared<bool>(boost::any_cast<bool>(m["DeleteOriginalFile"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteLiveSnapshotFilesRequest() = default;
};
class DeleteLiveSnapshotFilesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> createTimestampListShrink{};
  shared_ptr<bool> deleteOriginalFile{};
  shared_ptr<string> jobId{};

  DeleteLiveSnapshotFilesShrinkRequest() {}

  explicit DeleteLiveSnapshotFilesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimestampListShrink) {
      res["CreateTimestampList"] = boost::any(*createTimestampListShrink);
    }
    if (deleteOriginalFile) {
      res["DeleteOriginalFile"] = boost::any(*deleteOriginalFile);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimestampList") != m.end() && !m["CreateTimestampList"].empty()) {
      createTimestampListShrink = make_shared<string>(boost::any_cast<string>(m["CreateTimestampList"]));
    }
    if (m.find("DeleteOriginalFile") != m.end() && !m["DeleteOriginalFile"].empty()) {
      deleteOriginalFile = make_shared<bool>(boost::any_cast<bool>(m["DeleteOriginalFile"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteLiveSnapshotFilesShrinkRequest() = default;
};
class DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList : public Darabonba::Model {
public:
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> result{};

  DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList() {}

  explicit DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList() = default;
};
class DeleteLiveSnapshotFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList>> deleteFileResultList{};
  shared_ptr<string> requestId{};

  DeleteLiveSnapshotFilesResponseBody() {}

  explicit DeleteLiveSnapshotFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteFileResultList) {
      vector<boost::any> temp1;
      for(auto item1:*deleteFileResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeleteFileResultList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteFileResultList") != m.end() && !m["DeleteFileResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeleteFileResultList"].type()) {
        vector<DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeleteFileResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deleteFileResultList = make_shared<vector<DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveSnapshotFilesResponseBody() = default;
};
class DeleteLiveSnapshotFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveSnapshotFilesResponseBody> body{};

  DeleteLiveSnapshotFilesResponse() {}

  explicit DeleteLiveSnapshotFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveSnapshotFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveSnapshotFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveSnapshotFilesResponse() = default;
};
class DeleteLiveSnapshotTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  DeleteLiveSnapshotTemplateRequest() {}

  explicit DeleteLiveSnapshotTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteLiveSnapshotTemplateRequest() = default;
};
class DeleteLiveSnapshotTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveSnapshotTemplateResponseBody() {}

  explicit DeleteLiveSnapshotTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveSnapshotTemplateResponseBody() = default;
};
class DeleteLiveSnapshotTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveSnapshotTemplateResponseBody> body{};

  DeleteLiveSnapshotTemplateResponse() {}

  explicit DeleteLiveSnapshotTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveSnapshotTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveSnapshotTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveSnapshotTemplateResponse() = default;
};
class DeleteLiveTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  DeleteLiveTranscodeJobRequest() {}

  explicit DeleteLiveTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteLiveTranscodeJobRequest() = default;
};
class DeleteLiveTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveTranscodeJobResponseBody() {}

  explicit DeleteLiveTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveTranscodeJobResponseBody() = default;
};
class DeleteLiveTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveTranscodeJobResponseBody> body{};

  DeleteLiveTranscodeJobResponse() {}

  explicit DeleteLiveTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveTranscodeJobResponse() = default;
};
class DeleteLiveTranscodeTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  DeleteLiveTranscodeTemplateRequest() {}

  explicit DeleteLiveTranscodeTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteLiveTranscodeTemplateRequest() = default;
};
class DeleteLiveTranscodeTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveTranscodeTemplateResponseBody() {}

  explicit DeleteLiveTranscodeTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveTranscodeTemplateResponseBody() = default;
};
class DeleteLiveTranscodeTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveTranscodeTemplateResponseBody> body{};

  DeleteLiveTranscodeTemplateResponse() {}

  explicit DeleteLiveTranscodeTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveTranscodeTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveTranscodeTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveTranscodeTemplateResponse() = default;
};
class DeleteMediaInfosRequest : public Darabonba::Model {
public:
  shared_ptr<bool> deletePhysicalFiles{};
  shared_ptr<string> inputURLs{};
  shared_ptr<string> mediaIds{};

  DeleteMediaInfosRequest() {}

  explicit DeleteMediaInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deletePhysicalFiles) {
      res["DeletePhysicalFiles"] = boost::any(*deletePhysicalFiles);
    }
    if (inputURLs) {
      res["InputURLs"] = boost::any(*inputURLs);
    }
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeletePhysicalFiles") != m.end() && !m["DeletePhysicalFiles"].empty()) {
      deletePhysicalFiles = make_shared<bool>(boost::any_cast<bool>(m["DeletePhysicalFiles"]));
    }
    if (m.find("InputURLs") != m.end() && !m["InputURLs"].empty()) {
      inputURLs = make_shared<string>(boost::any_cast<string>(m["InputURLs"]));
    }
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
  }


  virtual ~DeleteMediaInfosRequest() = default;
};
class DeleteMediaInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> forbiddenList{};
  shared_ptr<vector<string>> ignoredList{};
  shared_ptr<string> requestId{};

  DeleteMediaInfosResponseBody() {}

  explicit DeleteMediaInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forbiddenList) {
      res["ForbiddenList"] = boost::any(*forbiddenList);
    }
    if (ignoredList) {
      res["IgnoredList"] = boost::any(*ignoredList);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForbiddenList") != m.end() && !m["ForbiddenList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ForbiddenList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ForbiddenList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      forbiddenList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IgnoredList") != m.end() && !m["IgnoredList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IgnoredList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IgnoredList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ignoredList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMediaInfosResponseBody() = default;
};
class DeleteMediaInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMediaInfosResponseBody> body{};

  DeleteMediaInfosResponse() {}

  explicit DeleteMediaInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaInfosResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaInfosResponse() = default;
};
class DeletePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};

  DeletePipelineRequest() {}

  explicit DeletePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~DeletePipelineRequest() = default;
};
class DeletePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeletePipelineResponseBody() {}

  explicit DeletePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeletePipelineResponseBody() = default;
};
class DeletePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePipelineResponseBody> body{};

  DeletePipelineResponse() {}

  explicit DeletePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePipelineResponse() = default;
};
class DeletePlayInfoRequest : public Darabonba::Model {
public:
  shared_ptr<bool> deletePhysicalFiles{};
  shared_ptr<string> fileURLs{};
  shared_ptr<string> mediaId{};

  DeletePlayInfoRequest() {}

  explicit DeletePlayInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deletePhysicalFiles) {
      res["DeletePhysicalFiles"] = boost::any(*deletePhysicalFiles);
    }
    if (fileURLs) {
      res["FileURLs"] = boost::any(*fileURLs);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeletePhysicalFiles") != m.end() && !m["DeletePhysicalFiles"].empty()) {
      deletePhysicalFiles = make_shared<bool>(boost::any_cast<bool>(m["DeletePhysicalFiles"]));
    }
    if (m.find("FileURLs") != m.end() && !m["FileURLs"].empty()) {
      fileURLs = make_shared<string>(boost::any_cast<string>(m["FileURLs"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~DeletePlayInfoRequest() = default;
};
class DeletePlayInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> forbiddenList{};
  shared_ptr<vector<string>> ignoredList{};
  shared_ptr<string> requestId{};

  DeletePlayInfoResponseBody() {}

  explicit DeletePlayInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forbiddenList) {
      res["ForbiddenList"] = boost::any(*forbiddenList);
    }
    if (ignoredList) {
      res["IgnoredList"] = boost::any(*ignoredList);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForbiddenList") != m.end() && !m["ForbiddenList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ForbiddenList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ForbiddenList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      forbiddenList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IgnoredList") != m.end() && !m["IgnoredList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IgnoredList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IgnoredList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ignoredList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePlayInfoResponseBody() = default;
};
class DeletePlayInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePlayInfoResponseBody> body{};

  DeletePlayInfoResponse() {}

  explicit DeletePlayInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePlayInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePlayInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePlayInfoResponse() = default;
};
class DeleteSmartJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  DeleteSmartJobRequest() {}

  explicit DeleteSmartJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteSmartJobRequest() = default;
};
class DeleteSmartJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSmartJobResponseBody() {}

  explicit DeleteSmartJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSmartJobResponseBody() = default;
};
class DeleteSmartJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSmartJobResponseBody> body{};

  DeleteSmartJobResponse() {}

  explicit DeleteSmartJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSmartJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSmartJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSmartJobResponse() = default;
};
class DeleteTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateIds{};

  DeleteTemplateRequest() {}

  explicit DeleteTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateIds) {
      res["TemplateIds"] = boost::any(*templateIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateIds") != m.end() && !m["TemplateIds"].empty()) {
      templateIds = make_shared<string>(boost::any_cast<string>(m["TemplateIds"]));
    }
  }


  virtual ~DeleteTemplateRequest() = default;
};
class DeleteTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTemplateResponseBody() {}

  explicit DeleteTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTemplateResponseBody() = default;
};
class DeleteTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTemplateResponseBody> body{};

  DeleteTemplateResponse() {}

  explicit DeleteTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTemplateResponse() = default;
};
class DescribeFilterConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};

  DescribeFilterConfigsRequest() {}

  explicit DescribeFilterConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeFilterConfigsRequest() = default;
};
class DescribeFilterConfigsResponseBodyFilterConfigs : public Darabonba::Model {
public:
  shared_ptr<string> filterName{};
  shared_ptr<string> itemConfigs{};
  shared_ptr<string> type{};
  shared_ptr<string> uuId{};

  DescribeFilterConfigsResponseBodyFilterConfigs() {}

  explicit DescribeFilterConfigsResponseBodyFilterConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterName) {
      res["FilterName"] = boost::any(*filterName);
    }
    if (itemConfigs) {
      res["ItemConfigs"] = boost::any(*itemConfigs);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uuId) {
      res["UuId"] = boost::any(*uuId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilterName") != m.end() && !m["FilterName"].empty()) {
      filterName = make_shared<string>(boost::any_cast<string>(m["FilterName"]));
    }
    if (m.find("ItemConfigs") != m.end() && !m["ItemConfigs"].empty()) {
      itemConfigs = make_shared<string>(boost::any_cast<string>(m["ItemConfigs"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UuId") != m.end() && !m["UuId"].empty()) {
      uuId = make_shared<string>(boost::any_cast<string>(m["UuId"]));
    }
  }


  virtual ~DescribeFilterConfigsResponseBodyFilterConfigs() = default;
};
class DescribeFilterConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFilterConfigsResponseBodyFilterConfigs>> filterConfigs{};
  shared_ptr<string> requestId{};

  DescribeFilterConfigsResponseBody() {}

  explicit DescribeFilterConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*filterConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FilterConfigs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilterConfigs") != m.end() && !m["FilterConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["FilterConfigs"].type()) {
        vector<DescribeFilterConfigsResponseBodyFilterConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FilterConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFilterConfigsResponseBodyFilterConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filterConfigs = make_shared<vector<DescribeFilterConfigsResponseBodyFilterConfigs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFilterConfigsResponseBody() = default;
};
class DescribeFilterConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFilterConfigsResponseBody> body{};

  DescribeFilterConfigsResponse() {}

  explicit DescribeFilterConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFilterConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFilterConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFilterConfigsResponse() = default;
};
class DescribeMeterIceEditUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<long> interval{};
  shared_ptr<string> region{};
  shared_ptr<long> startTs{};

  DescribeMeterIceEditUsageRequest() {}

  explicit DescribeMeterIceEditUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterIceEditUsageRequest() = default;
};
class DescribeMeterIceEditUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> profile{};
  shared_ptr<long> time{};

  DescribeMeterIceEditUsageResponseBodyData() {}

  explicit DescribeMeterIceEditUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeMeterIceEditUsageResponseBodyData() = default;
};
class DescribeMeterIceEditUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterIceEditUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterIceEditUsageResponseBody() {}

  explicit DescribeMeterIceEditUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterIceEditUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterIceEditUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterIceEditUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterIceEditUsageResponseBody() = default;
};
class DescribeMeterIceEditUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterIceEditUsageResponseBody> body{};

  DescribeMeterIceEditUsageResponse() {}

  explicit DescribeMeterIceEditUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterIceEditUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterIceEditUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterIceEditUsageResponse() = default;
};
class DescribeMeterIceLiveMediaConvertUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<long> interval{};
  shared_ptr<string> region{};
  shared_ptr<long> startTs{};

  DescribeMeterIceLiveMediaConvertUsageRequest() {}

  explicit DescribeMeterIceLiveMediaConvertUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterIceLiveMediaConvertUsageRequest() = default;
};
class DescribeMeterIceLiveMediaConvertUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> specification{};
  shared_ptr<long> time{};

  DescribeMeterIceLiveMediaConvertUsageResponseBodyData() {}

  explicit DescribeMeterIceLiveMediaConvertUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeMeterIceLiveMediaConvertUsageResponseBodyData() = default;
};
class DescribeMeterIceLiveMediaConvertUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterIceLiveMediaConvertUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterIceLiveMediaConvertUsageResponseBody() {}

  explicit DescribeMeterIceLiveMediaConvertUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterIceLiveMediaConvertUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterIceLiveMediaConvertUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterIceLiveMediaConvertUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterIceLiveMediaConvertUsageResponseBody() = default;
};
class DescribeMeterIceLiveMediaConvertUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterIceLiveMediaConvertUsageResponseBody> body{};

  DescribeMeterIceLiveMediaConvertUsageResponse() {}

  explicit DescribeMeterIceLiveMediaConvertUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterIceLiveMediaConvertUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterIceLiveMediaConvertUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterIceLiveMediaConvertUsageResponse() = default;
};
class DescribeMeterIceMediaConvertUHDUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<string> interval{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTs{};

  DescribeMeterIceMediaConvertUHDUsageRequest() {}

  explicit DescribeMeterIceMediaConvertUHDUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterIceMediaConvertUHDUsageRequest() = default;
};
class DescribeMeterIceMediaConvertUHDUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> specification{};
  shared_ptr<long> time{};

  DescribeMeterIceMediaConvertUHDUsageResponseBodyData() {}

  explicit DescribeMeterIceMediaConvertUHDUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeMeterIceMediaConvertUHDUsageResponseBodyData() = default;
};
class DescribeMeterIceMediaConvertUHDUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterIceMediaConvertUHDUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterIceMediaConvertUHDUsageResponseBody() {}

  explicit DescribeMeterIceMediaConvertUHDUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterIceMediaConvertUHDUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterIceMediaConvertUHDUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterIceMediaConvertUHDUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterIceMediaConvertUHDUsageResponseBody() = default;
};
class DescribeMeterIceMediaConvertUHDUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterIceMediaConvertUHDUsageResponseBody> body{};

  DescribeMeterIceMediaConvertUHDUsageResponse() {}

  explicit DescribeMeterIceMediaConvertUHDUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterIceMediaConvertUHDUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterIceMediaConvertUHDUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterIceMediaConvertUHDUsageResponse() = default;
};
class DescribeMeterIceMediaConvertUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<long> interval{};
  shared_ptr<string> region{};
  shared_ptr<long> startTs{};

  DescribeMeterIceMediaConvertUsageRequest() {}

  explicit DescribeMeterIceMediaConvertUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterIceMediaConvertUsageRequest() = default;
};
class DescribeMeterIceMediaConvertUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> specification{};
  shared_ptr<long> time{};

  DescribeMeterIceMediaConvertUsageResponseBodyData() {}

  explicit DescribeMeterIceMediaConvertUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeMeterIceMediaConvertUsageResponseBodyData() = default;
};
class DescribeMeterIceMediaConvertUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterIceMediaConvertUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterIceMediaConvertUsageResponseBody() {}

  explicit DescribeMeterIceMediaConvertUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterIceMediaConvertUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterIceMediaConvertUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterIceMediaConvertUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterIceMediaConvertUsageResponseBody() = default;
};
class DescribeMeterIceMediaConvertUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterIceMediaConvertUsageResponseBody> body{};

  DescribeMeterIceMediaConvertUsageResponse() {}

  explicit DescribeMeterIceMediaConvertUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterIceMediaConvertUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterIceMediaConvertUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterIceMediaConvertUsageResponse() = default;
};
class DescribeMeterIceMpsAiUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<long> interval{};
  shared_ptr<string> region{};
  shared_ptr<long> startTs{};

  DescribeMeterIceMpsAiUsageRequest() {}

  explicit DescribeMeterIceMpsAiUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterIceMpsAiUsageRequest() = default;
};
class DescribeMeterIceMpsAiUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<long> time{};
  shared_ptr<string> type{};

  DescribeMeterIceMpsAiUsageResponseBodyData() {}

  explicit DescribeMeterIceMpsAiUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeMeterIceMpsAiUsageResponseBodyData() = default;
};
class DescribeMeterIceMpsAiUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterIceMpsAiUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterIceMpsAiUsageResponseBody() {}

  explicit DescribeMeterIceMpsAiUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterIceMpsAiUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterIceMpsAiUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterIceMpsAiUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterIceMpsAiUsageResponseBody() = default;
};
class DescribeMeterIceMpsAiUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterIceMpsAiUsageResponseBody> body{};

  DescribeMeterIceMpsAiUsageResponse() {}

  explicit DescribeMeterIceMpsAiUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterIceMpsAiUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterIceMpsAiUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterIceMpsAiUsageResponse() = default;
};
class DescribeMeterImsEditUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<long> interval{};
  shared_ptr<string> region{};
  shared_ptr<long> startTs{};

  DescribeMeterImsEditUsageRequest() {}

  explicit DescribeMeterImsEditUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterImsEditUsageRequest() = default;
};
class DescribeMeterImsEditUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> profile{};
  shared_ptr<long> time{};

  DescribeMeterImsEditUsageResponseBodyData() {}

  explicit DescribeMeterImsEditUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeMeterImsEditUsageResponseBodyData() = default;
};
class DescribeMeterImsEditUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterImsEditUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterImsEditUsageResponseBody() {}

  explicit DescribeMeterImsEditUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterImsEditUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterImsEditUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterImsEditUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterImsEditUsageResponseBody() = default;
};
class DescribeMeterImsEditUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterImsEditUsageResponseBody> body{};

  DescribeMeterImsEditUsageResponse() {}

  explicit DescribeMeterImsEditUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterImsEditUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterImsEditUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterImsEditUsageResponse() = default;
};
class DescribeMeterImsLiveEditUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<long> interval{};
  shared_ptr<string> region{};
  shared_ptr<long> startTs{};

  DescribeMeterImsLiveEditUsageRequest() {}

  explicit DescribeMeterImsLiveEditUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterImsLiveEditUsageRequest() = default;
};
class DescribeMeterImsLiveEditUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> profile{};
  shared_ptr<long> time{};

  DescribeMeterImsLiveEditUsageResponseBodyData() {}

  explicit DescribeMeterImsLiveEditUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeMeterImsLiveEditUsageResponseBodyData() = default;
};
class DescribeMeterImsLiveEditUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterImsLiveEditUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterImsLiveEditUsageResponseBody() {}

  explicit DescribeMeterImsLiveEditUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterImsLiveEditUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterImsLiveEditUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterImsLiveEditUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterImsLiveEditUsageResponseBody() = default;
};
class DescribeMeterImsLiveEditUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterImsLiveEditUsageResponseBody> body{};

  DescribeMeterImsLiveEditUsageResponse() {}

  explicit DescribeMeterImsLiveEditUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterImsLiveEditUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterImsLiveEditUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterImsLiveEditUsageResponse() = default;
};
class DescribeMeterImsLiveMediaConvertUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<long> interval{};
  shared_ptr<string> region{};
  shared_ptr<long> startTs{};

  DescribeMeterImsLiveMediaConvertUsageRequest() {}

  explicit DescribeMeterImsLiveMediaConvertUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterImsLiveMediaConvertUsageRequest() = default;
};
class DescribeMeterImsLiveMediaConvertUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> specification{};
  shared_ptr<long> time{};

  DescribeMeterImsLiveMediaConvertUsageResponseBodyData() {}

  explicit DescribeMeterImsLiveMediaConvertUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeMeterImsLiveMediaConvertUsageResponseBodyData() = default;
};
class DescribeMeterImsLiveMediaConvertUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterImsLiveMediaConvertUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterImsLiveMediaConvertUsageResponseBody() {}

  explicit DescribeMeterImsLiveMediaConvertUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterImsLiveMediaConvertUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterImsLiveMediaConvertUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterImsLiveMediaConvertUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterImsLiveMediaConvertUsageResponseBody() = default;
};
class DescribeMeterImsLiveMediaConvertUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterImsLiveMediaConvertUsageResponseBody> body{};

  DescribeMeterImsLiveMediaConvertUsageResponse() {}

  explicit DescribeMeterImsLiveMediaConvertUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterImsLiveMediaConvertUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterImsLiveMediaConvertUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterImsLiveMediaConvertUsageResponse() = default;
};
class DescribeMeterImsLiveRecordUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<long> interval{};
  shared_ptr<string> region{};
  shared_ptr<long> startTs{};

  DescribeMeterImsLiveRecordUsageRequest() {}

  explicit DescribeMeterImsLiveRecordUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterImsLiveRecordUsageRequest() = default;
};
class DescribeMeterImsLiveRecordUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<double> channels{};
  shared_ptr<long> duration{};
  shared_ptr<long> time{};
  shared_ptr<string> type{};

  DescribeMeterImsLiveRecordUsageResponseBodyData() {}

  explicit DescribeMeterImsLiveRecordUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<double>(boost::any_cast<double>(m["Channels"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeMeterImsLiveRecordUsageResponseBodyData() = default;
};
class DescribeMeterImsLiveRecordUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterImsLiveRecordUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterImsLiveRecordUsageResponseBody() {}

  explicit DescribeMeterImsLiveRecordUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterImsLiveRecordUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterImsLiveRecordUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterImsLiveRecordUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterImsLiveRecordUsageResponseBody() = default;
};
class DescribeMeterImsLiveRecordUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterImsLiveRecordUsageResponseBody> body{};

  DescribeMeterImsLiveRecordUsageResponse() {}

  explicit DescribeMeterImsLiveRecordUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterImsLiveRecordUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterImsLiveRecordUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterImsLiveRecordUsageResponse() = default;
};
class DescribeMeterImsLiveSnapshotUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<long> interval{};
  shared_ptr<string> region{};
  shared_ptr<long> startTs{};

  DescribeMeterImsLiveSnapshotUsageRequest() {}

  explicit DescribeMeterImsLiveSnapshotUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterImsLiveSnapshotUsageRequest() = default;
};
class DescribeMeterImsLiveSnapshotUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<long> time{};

  DescribeMeterImsLiveSnapshotUsageResponseBodyData() {}

  explicit DescribeMeterImsLiveSnapshotUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeMeterImsLiveSnapshotUsageResponseBodyData() = default;
};
class DescribeMeterImsLiveSnapshotUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterImsLiveSnapshotUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterImsLiveSnapshotUsageResponseBody() {}

  explicit DescribeMeterImsLiveSnapshotUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterImsLiveSnapshotUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterImsLiveSnapshotUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterImsLiveSnapshotUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterImsLiveSnapshotUsageResponseBody() = default;
};
class DescribeMeterImsLiveSnapshotUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterImsLiveSnapshotUsageResponseBody> body{};

  DescribeMeterImsLiveSnapshotUsageResponse() {}

  explicit DescribeMeterImsLiveSnapshotUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterImsLiveSnapshotUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterImsLiveSnapshotUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterImsLiveSnapshotUsageResponse() = default;
};
class DescribeMeterImsMediaConvertUHDUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<string> interval{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTs{};

  DescribeMeterImsMediaConvertUHDUsageRequest() {}

  explicit DescribeMeterImsMediaConvertUHDUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterImsMediaConvertUHDUsageRequest() = default;
};
class DescribeMeterImsMediaConvertUHDUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> specification{};
  shared_ptr<long> time{};

  DescribeMeterImsMediaConvertUHDUsageResponseBodyData() {}

  explicit DescribeMeterImsMediaConvertUHDUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeMeterImsMediaConvertUHDUsageResponseBodyData() = default;
};
class DescribeMeterImsMediaConvertUHDUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterImsMediaConvertUHDUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterImsMediaConvertUHDUsageResponseBody() {}

  explicit DescribeMeterImsMediaConvertUHDUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterImsMediaConvertUHDUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterImsMediaConvertUHDUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterImsMediaConvertUHDUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterImsMediaConvertUHDUsageResponseBody() = default;
};
class DescribeMeterImsMediaConvertUHDUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterImsMediaConvertUHDUsageResponseBody> body{};

  DescribeMeterImsMediaConvertUHDUsageResponse() {}

  explicit DescribeMeterImsMediaConvertUHDUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterImsMediaConvertUHDUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterImsMediaConvertUHDUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterImsMediaConvertUHDUsageResponse() = default;
};
class DescribeMeterImsMediaConvertUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<long> interval{};
  shared_ptr<string> region{};
  shared_ptr<long> startTs{};

  DescribeMeterImsMediaConvertUsageRequest() {}

  explicit DescribeMeterImsMediaConvertUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterImsMediaConvertUsageRequest() = default;
};
class DescribeMeterImsMediaConvertUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> specification{};
  shared_ptr<long> time{};

  DescribeMeterImsMediaConvertUsageResponseBodyData() {}

  explicit DescribeMeterImsMediaConvertUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeMeterImsMediaConvertUsageResponseBodyData() = default;
};
class DescribeMeterImsMediaConvertUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterImsMediaConvertUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterImsMediaConvertUsageResponseBody() {}

  explicit DescribeMeterImsMediaConvertUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterImsMediaConvertUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterImsMediaConvertUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterImsMediaConvertUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterImsMediaConvertUsageResponseBody() = default;
};
class DescribeMeterImsMediaConvertUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterImsMediaConvertUsageResponseBody> body{};

  DescribeMeterImsMediaConvertUsageResponse() {}

  explicit DescribeMeterImsMediaConvertUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterImsMediaConvertUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterImsMediaConvertUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterImsMediaConvertUsageResponse() = default;
};
class DescribeMeterImsMpsAiUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<long> interval{};
  shared_ptr<string> region{};
  shared_ptr<long> startTs{};

  DescribeMeterImsMpsAiUsageRequest() {}

  explicit DescribeMeterImsMpsAiUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterImsMpsAiUsageRequest() = default;
};
class DescribeMeterImsMpsAiUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<long> time{};
  shared_ptr<string> type{};

  DescribeMeterImsMpsAiUsageResponseBodyData() {}

  explicit DescribeMeterImsMpsAiUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeMeterImsMpsAiUsageResponseBodyData() = default;
};
class DescribeMeterImsMpsAiUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterImsMpsAiUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterImsMpsAiUsageResponseBody() {}

  explicit DescribeMeterImsMpsAiUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterImsMpsAiUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterImsMpsAiUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterImsMpsAiUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterImsMpsAiUsageResponseBody() = default;
};
class DescribeMeterImsMpsAiUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterImsMpsAiUsageResponseBody> body{};

  DescribeMeterImsMpsAiUsageResponse() {}

  explicit DescribeMeterImsMpsAiUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterImsMpsAiUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterImsMpsAiUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterImsMpsAiUsageResponse() = default;
};
class DescribeMeterImsSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<string> region{};
  shared_ptr<long> startTs{};

  DescribeMeterImsSummaryRequest() {}

  explicit DescribeMeterImsSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterImsSummaryRequest() = default;
};
class DescribeMeterImsSummaryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> editingDuration{};
  shared_ptr<string> liveEditDuration{};
  shared_ptr<string> liveRecordDuration{};
  shared_ptr<string> liveSnapshotCount{};
  shared_ptr<long> liveTranscodeDuration{};
  shared_ptr<long> mpsAiDuration{};
  shared_ptr<long> mpsTranscodeDuration{};
  shared_ptr<long> mpsTranscodeUHDDuration{};

  DescribeMeterImsSummaryResponseBodyData() {}

  explicit DescribeMeterImsSummaryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editingDuration) {
      res["EditingDuration"] = boost::any(*editingDuration);
    }
    if (liveEditDuration) {
      res["LiveEditDuration"] = boost::any(*liveEditDuration);
    }
    if (liveRecordDuration) {
      res["LiveRecordDuration"] = boost::any(*liveRecordDuration);
    }
    if (liveSnapshotCount) {
      res["LiveSnapshotCount"] = boost::any(*liveSnapshotCount);
    }
    if (liveTranscodeDuration) {
      res["LiveTranscodeDuration"] = boost::any(*liveTranscodeDuration);
    }
    if (mpsAiDuration) {
      res["MpsAiDuration"] = boost::any(*mpsAiDuration);
    }
    if (mpsTranscodeDuration) {
      res["MpsTranscodeDuration"] = boost::any(*mpsTranscodeDuration);
    }
    if (mpsTranscodeUHDDuration) {
      res["MpsTranscodeUHDDuration"] = boost::any(*mpsTranscodeUHDDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditingDuration") != m.end() && !m["EditingDuration"].empty()) {
      editingDuration = make_shared<string>(boost::any_cast<string>(m["EditingDuration"]));
    }
    if (m.find("LiveEditDuration") != m.end() && !m["LiveEditDuration"].empty()) {
      liveEditDuration = make_shared<string>(boost::any_cast<string>(m["LiveEditDuration"]));
    }
    if (m.find("LiveRecordDuration") != m.end() && !m["LiveRecordDuration"].empty()) {
      liveRecordDuration = make_shared<string>(boost::any_cast<string>(m["LiveRecordDuration"]));
    }
    if (m.find("LiveSnapshotCount") != m.end() && !m["LiveSnapshotCount"].empty()) {
      liveSnapshotCount = make_shared<string>(boost::any_cast<string>(m["LiveSnapshotCount"]));
    }
    if (m.find("LiveTranscodeDuration") != m.end() && !m["LiveTranscodeDuration"].empty()) {
      liveTranscodeDuration = make_shared<long>(boost::any_cast<long>(m["LiveTranscodeDuration"]));
    }
    if (m.find("MpsAiDuration") != m.end() && !m["MpsAiDuration"].empty()) {
      mpsAiDuration = make_shared<long>(boost::any_cast<long>(m["MpsAiDuration"]));
    }
    if (m.find("MpsTranscodeDuration") != m.end() && !m["MpsTranscodeDuration"].empty()) {
      mpsTranscodeDuration = make_shared<long>(boost::any_cast<long>(m["MpsTranscodeDuration"]));
    }
    if (m.find("MpsTranscodeUHDDuration") != m.end() && !m["MpsTranscodeUHDDuration"].empty()) {
      mpsTranscodeUHDDuration = make_shared<long>(boost::any_cast<long>(m["MpsTranscodeUHDDuration"]));
    }
  }


  virtual ~DescribeMeterImsSummaryResponseBodyData() = default;
};
class DescribeMeterImsSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterImsSummaryResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterImsSummaryResponseBody() {}

  explicit DescribeMeterImsSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterImsSummaryResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterImsSummaryResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterImsSummaryResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterImsSummaryResponseBody() = default;
};
class DescribeMeterImsSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterImsSummaryResponseBody> body{};

  DescribeMeterImsSummaryResponse() {}

  explicit DescribeMeterImsSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterImsSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterImsSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterImsSummaryResponse() = default;
};
class DescribePlayDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> sessionId{};

  DescribePlayDetailRequest() {}

  explicit DescribePlayDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
  }


  virtual ~DescribePlayDetailRequest() = default;
};
class DescribePlayDetailResponseBodyBaseInfos : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> bps{};
  shared_ptr<string> broadcastPace{};
  shared_ptr<string> clientIP{};
  shared_ptr<string> codec{};
  shared_ptr<string> decodeStuckTime{};
  shared_ptr<string> definition{};
  shared_ptr<string> firstFrameDuration{};
  shared_ptr<string> fps{};
  shared_ptr<string> isHardDecode{};
  shared_ptr<string> mdat{};
  shared_ptr<string> moov{};
  shared_ptr<string> network{};
  shared_ptr<string> networkDuration{};
  shared_ptr<string> networkStuckTime{};
  shared_ptr<string> os{};
  shared_ptr<string> playTs{};
  shared_ptr<string> playerLoadDuration{};
  shared_ptr<string> playerPreDealDuration{};
  shared_ptr<string> playerReadyDuration{};
  shared_ptr<string> sdkVersion{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> status{};
  shared_ptr<string> terminalType{};

  DescribePlayDetailResponseBodyBaseInfos() {}

  explicit DescribePlayDetailResponseBodyBaseInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (bps) {
      res["Bps"] = boost::any(*bps);
    }
    if (broadcastPace) {
      res["BroadcastPace"] = boost::any(*broadcastPace);
    }
    if (clientIP) {
      res["ClientIP"] = boost::any(*clientIP);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (decodeStuckTime) {
      res["DecodeStuckTime"] = boost::any(*decodeStuckTime);
    }
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (firstFrameDuration) {
      res["FirstFrameDuration"] = boost::any(*firstFrameDuration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (isHardDecode) {
      res["IsHardDecode"] = boost::any(*isHardDecode);
    }
    if (mdat) {
      res["Mdat"] = boost::any(*mdat);
    }
    if (moov) {
      res["Moov"] = boost::any(*moov);
    }
    if (network) {
      res["Network"] = boost::any(*network);
    }
    if (networkDuration) {
      res["NetworkDuration"] = boost::any(*networkDuration);
    }
    if (networkStuckTime) {
      res["NetworkStuckTime"] = boost::any(*networkStuckTime);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (playTs) {
      res["PlayTs"] = boost::any(*playTs);
    }
    if (playerLoadDuration) {
      res["PlayerLoadDuration"] = boost::any(*playerLoadDuration);
    }
    if (playerPreDealDuration) {
      res["PlayerPreDealDuration"] = boost::any(*playerPreDealDuration);
    }
    if (playerReadyDuration) {
      res["PlayerReadyDuration"] = boost::any(*playerReadyDuration);
    }
    if (sdkVersion) {
      res["SdkVersion"] = boost::any(*sdkVersion);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (terminalType) {
      res["TerminalType"] = boost::any(*terminalType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Bps") != m.end() && !m["Bps"].empty()) {
      bps = make_shared<string>(boost::any_cast<string>(m["Bps"]));
    }
    if (m.find("BroadcastPace") != m.end() && !m["BroadcastPace"].empty()) {
      broadcastPace = make_shared<string>(boost::any_cast<string>(m["BroadcastPace"]));
    }
    if (m.find("ClientIP") != m.end() && !m["ClientIP"].empty()) {
      clientIP = make_shared<string>(boost::any_cast<string>(m["ClientIP"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("DecodeStuckTime") != m.end() && !m["DecodeStuckTime"].empty()) {
      decodeStuckTime = make_shared<string>(boost::any_cast<string>(m["DecodeStuckTime"]));
    }
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("FirstFrameDuration") != m.end() && !m["FirstFrameDuration"].empty()) {
      firstFrameDuration = make_shared<string>(boost::any_cast<string>(m["FirstFrameDuration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("IsHardDecode") != m.end() && !m["IsHardDecode"].empty()) {
      isHardDecode = make_shared<string>(boost::any_cast<string>(m["IsHardDecode"]));
    }
    if (m.find("Mdat") != m.end() && !m["Mdat"].empty()) {
      mdat = make_shared<string>(boost::any_cast<string>(m["Mdat"]));
    }
    if (m.find("Moov") != m.end() && !m["Moov"].empty()) {
      moov = make_shared<string>(boost::any_cast<string>(m["Moov"]));
    }
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      network = make_shared<string>(boost::any_cast<string>(m["Network"]));
    }
    if (m.find("NetworkDuration") != m.end() && !m["NetworkDuration"].empty()) {
      networkDuration = make_shared<string>(boost::any_cast<string>(m["NetworkDuration"]));
    }
    if (m.find("NetworkStuckTime") != m.end() && !m["NetworkStuckTime"].empty()) {
      networkStuckTime = make_shared<string>(boost::any_cast<string>(m["NetworkStuckTime"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("PlayTs") != m.end() && !m["PlayTs"].empty()) {
      playTs = make_shared<string>(boost::any_cast<string>(m["PlayTs"]));
    }
    if (m.find("PlayerLoadDuration") != m.end() && !m["PlayerLoadDuration"].empty()) {
      playerLoadDuration = make_shared<string>(boost::any_cast<string>(m["PlayerLoadDuration"]));
    }
    if (m.find("PlayerPreDealDuration") != m.end() && !m["PlayerPreDealDuration"].empty()) {
      playerPreDealDuration = make_shared<string>(boost::any_cast<string>(m["PlayerPreDealDuration"]));
    }
    if (m.find("PlayerReadyDuration") != m.end() && !m["PlayerReadyDuration"].empty()) {
      playerReadyDuration = make_shared<string>(boost::any_cast<string>(m["PlayerReadyDuration"]));
    }
    if (m.find("SdkVersion") != m.end() && !m["SdkVersion"].empty()) {
      sdkVersion = make_shared<string>(boost::any_cast<string>(m["SdkVersion"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TerminalType") != m.end() && !m["TerminalType"].empty()) {
      terminalType = make_shared<string>(boost::any_cast<string>(m["TerminalType"]));
    }
  }


  virtual ~DescribePlayDetailResponseBodyBaseInfos() = default;
};
class DescribePlayDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePlayDetailResponseBodyBaseInfos>> baseInfos{};
  shared_ptr<string> requestId{};

  DescribePlayDetailResponseBody() {}

  explicit DescribePlayDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseInfos) {
      vector<boost::any> temp1;
      for(auto item1:*baseInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BaseInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseInfos") != m.end() && !m["BaseInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["BaseInfos"].type()) {
        vector<DescribePlayDetailResponseBodyBaseInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BaseInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePlayDetailResponseBodyBaseInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        baseInfos = make_shared<vector<DescribePlayDetailResponseBodyBaseInfos>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePlayDetailResponseBody() = default;
};
class DescribePlayDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePlayDetailResponseBody> body{};

  DescribePlayDetailResponse() {}

  explicit DescribePlayDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePlayDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePlayDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePlayDetailResponse() = default;
};
class DescribePlayEventListRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sessionId{};

  DescribePlayEventListRequest() {}

  explicit DescribePlayEventListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
  }


  virtual ~DescribePlayEventListRequest() = default;
};
class DescribePlayEventListResponseBodyEventList : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<double> duration{};
  shared_ptr<string> eventName{};
  shared_ptr<long> time{};
  shared_ptr<string> topic{};

  DescribePlayEventListResponseBodyEventList() {}

  explicit DescribePlayEventListResponseBodyEventList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (eventName) {
      res["EventName"] = boost::any(*eventName);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("EventName") != m.end() && !m["EventName"].empty()) {
      eventName = make_shared<string>(boost::any_cast<string>(m["EventName"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~DescribePlayEventListResponseBodyEventList() = default;
};
class DescribePlayEventListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePlayEventListResponseBodyEventList>> eventList{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePlayEventListResponseBody() {}

  explicit DescribePlayEventListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventList) {
      vector<boost::any> temp1;
      for(auto item1:*eventList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventList"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventList") != m.end() && !m["EventList"].empty()) {
      if (typeid(vector<boost::any>) == m["EventList"].type()) {
        vector<DescribePlayEventListResponseBodyEventList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePlayEventListResponseBodyEventList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventList = make_shared<vector<DescribePlayEventListResponseBodyEventList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePlayEventListResponseBody() = default;
};
class DescribePlayEventListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePlayEventListResponseBody> body{};

  DescribePlayEventListResponse() {}

  explicit DescribePlayEventListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePlayEventListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePlayEventListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePlayEventListResponse() = default;
};
class DescribePlayFirstFrameDurationMetricDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> beginTs{};
  shared_ptr<string> endTs{};
  shared_ptr<string> traceId{};

  DescribePlayFirstFrameDurationMetricDataRequest() {}

  explicit DescribePlayFirstFrameDurationMetricDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTs) {
      res["BeginTs"] = boost::any(*beginTs);
    }
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTs") != m.end() && !m["BeginTs"].empty()) {
      beginTs = make_shared<string>(boost::any_cast<string>(m["BeginTs"]));
    }
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<string>(boost::any_cast<string>(m["EndTs"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribePlayFirstFrameDurationMetricDataRequest() = default;
};
class DescribePlayFirstFrameDurationMetricDataResponseBodyNodes : public Darabonba::Model {
public:
  shared_ptr<long> x{};
  shared_ptr<long> y{};

  DescribePlayFirstFrameDurationMetricDataResponseBodyNodes() {}

  explicit DescribePlayFirstFrameDurationMetricDataResponseBodyNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<long>(boost::any_cast<long>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<long>(boost::any_cast<long>(m["Y"]));
    }
  }


  virtual ~DescribePlayFirstFrameDurationMetricDataResponseBodyNodes() = default;
};
class DescribePlayFirstFrameDurationMetricDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePlayFirstFrameDurationMetricDataResponseBodyNodes>> nodes{};
  shared_ptr<string> requestId{};

  DescribePlayFirstFrameDurationMetricDataResponseBody() {}

  explicit DescribePlayFirstFrameDurationMetricDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<DescribePlayFirstFrameDurationMetricDataResponseBodyNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePlayFirstFrameDurationMetricDataResponseBodyNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<DescribePlayFirstFrameDurationMetricDataResponseBodyNodes>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePlayFirstFrameDurationMetricDataResponseBody() = default;
};
class DescribePlayFirstFrameDurationMetricDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePlayFirstFrameDurationMetricDataResponseBody> body{};

  DescribePlayFirstFrameDurationMetricDataResponse() {}

  explicit DescribePlayFirstFrameDurationMetricDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePlayFirstFrameDurationMetricDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePlayFirstFrameDurationMetricDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePlayFirstFrameDurationMetricDataResponse() = default;
};
class DescribePlayListRequest : public Darabonba::Model {
public:
  shared_ptr<string> beginTs{};
  shared_ptr<string> endTs{};
  shared_ptr<string> orderName{};
  shared_ptr<string> orderType{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> playType{};
  shared_ptr<string> status{};
  shared_ptr<string> traceId{};

  DescribePlayListRequest() {}

  explicit DescribePlayListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTs) {
      res["BeginTs"] = boost::any(*beginTs);
    }
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (orderName) {
      res["OrderName"] = boost::any(*orderName);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (playType) {
      res["PlayType"] = boost::any(*playType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTs") != m.end() && !m["BeginTs"].empty()) {
      beginTs = make_shared<string>(boost::any_cast<string>(m["BeginTs"]));
    }
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<string>(boost::any_cast<string>(m["EndTs"]));
    }
    if (m.find("OrderName") != m.end() && !m["OrderName"].empty()) {
      orderName = make_shared<string>(boost::any_cast<string>(m["OrderName"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PlayType") != m.end() && !m["PlayType"].empty()) {
      playType = make_shared<string>(boost::any_cast<string>(m["PlayType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribePlayListRequest() = default;
};
class DescribePlayListResponseBodyPlayList : public Darabonba::Model {
public:
  shared_ptr<string> firstFrameDuration{};
  shared_ptr<string> playDuration{};
  shared_ptr<string> playType{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> status{};
  shared_ptr<string> stuckDuration{};
  shared_ptr<string> traceId{};
  shared_ptr<string> videoDuration{};
  shared_ptr<string> videoId{};

  DescribePlayListResponseBodyPlayList() {}

  explicit DescribePlayListResponseBodyPlayList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firstFrameDuration) {
      res["FirstFrameDuration"] = boost::any(*firstFrameDuration);
    }
    if (playDuration) {
      res["PlayDuration"] = boost::any(*playDuration);
    }
    if (playType) {
      res["PlayType"] = boost::any(*playType);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stuckDuration) {
      res["StuckDuration"] = boost::any(*stuckDuration);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    if (videoDuration) {
      res["VideoDuration"] = boost::any(*videoDuration);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirstFrameDuration") != m.end() && !m["FirstFrameDuration"].empty()) {
      firstFrameDuration = make_shared<string>(boost::any_cast<string>(m["FirstFrameDuration"]));
    }
    if (m.find("PlayDuration") != m.end() && !m["PlayDuration"].empty()) {
      playDuration = make_shared<string>(boost::any_cast<string>(m["PlayDuration"]));
    }
    if (m.find("PlayType") != m.end() && !m["PlayType"].empty()) {
      playType = make_shared<string>(boost::any_cast<string>(m["PlayType"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StuckDuration") != m.end() && !m["StuckDuration"].empty()) {
      stuckDuration = make_shared<string>(boost::any_cast<string>(m["StuckDuration"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
    if (m.find("VideoDuration") != m.end() && !m["VideoDuration"].empty()) {
      videoDuration = make_shared<string>(boost::any_cast<string>(m["VideoDuration"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~DescribePlayListResponseBodyPlayList() = default;
};
class DescribePlayListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribePlayListResponseBodyPlayList>> playList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};

  DescribePlayListResponseBody() {}

  explicit DescribePlayListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (playList) {
      vector<boost::any> temp1;
      for(auto item1:*playList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PlayList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PlayList") != m.end() && !m["PlayList"].empty()) {
      if (typeid(vector<boost::any>) == m["PlayList"].type()) {
        vector<DescribePlayListResponseBodyPlayList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PlayList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePlayListResponseBodyPlayList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        playList = make_shared<vector<DescribePlayListResponseBodyPlayList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
  }


  virtual ~DescribePlayListResponseBody() = default;
};
class DescribePlayListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePlayListResponseBody> body{};

  DescribePlayListResponse() {}

  explicit DescribePlayListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePlayListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePlayListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePlayListResponse() = default;
};
class DescribePlayMetricDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<long> beginTs{};
  shared_ptr<string> definition{};
  shared_ptr<long> endTs{};
  shared_ptr<string> experienceLevel{};
  shared_ptr<string> itemConfigs{};
  shared_ptr<string> metricType{};
  shared_ptr<string> network{};
  shared_ptr<string> os{};
  shared_ptr<string> sdkVersion{};
  shared_ptr<string> terminalType{};

  DescribePlayMetricDataRequest() {}

  explicit DescribePlayMetricDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (beginTs) {
      res["BeginTs"] = boost::any(*beginTs);
    }
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (experienceLevel) {
      res["ExperienceLevel"] = boost::any(*experienceLevel);
    }
    if (itemConfigs) {
      res["ItemConfigs"] = boost::any(*itemConfigs);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (network) {
      res["Network"] = boost::any(*network);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (sdkVersion) {
      res["SdkVersion"] = boost::any(*sdkVersion);
    }
    if (terminalType) {
      res["TerminalType"] = boost::any(*terminalType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BeginTs") != m.end() && !m["BeginTs"].empty()) {
      beginTs = make_shared<long>(boost::any_cast<long>(m["BeginTs"]));
    }
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("ExperienceLevel") != m.end() && !m["ExperienceLevel"].empty()) {
      experienceLevel = make_shared<string>(boost::any_cast<string>(m["ExperienceLevel"]));
    }
    if (m.find("ItemConfigs") != m.end() && !m["ItemConfigs"].empty()) {
      itemConfigs = make_shared<string>(boost::any_cast<string>(m["ItemConfigs"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      network = make_shared<string>(boost::any_cast<string>(m["Network"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("SdkVersion") != m.end() && !m["SdkVersion"].empty()) {
      sdkVersion = make_shared<string>(boost::any_cast<string>(m["SdkVersion"]));
    }
    if (m.find("TerminalType") != m.end() && !m["TerminalType"].empty()) {
      terminalType = make_shared<string>(boost::any_cast<string>(m["TerminalType"]));
    }
  }


  virtual ~DescribePlayMetricDataRequest() = default;
};
class DescribePlayMetricDataResponseBodyNodes : public Darabonba::Model {
public:
  shared_ptr<string> x{};
  shared_ptr<string> y{};

  DescribePlayMetricDataResponseBodyNodes() {}

  explicit DescribePlayMetricDataResponseBodyNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<string>(boost::any_cast<string>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<string>(boost::any_cast<string>(m["Y"]));
    }
  }


  virtual ~DescribePlayMetricDataResponseBodyNodes() = default;
};
class DescribePlayMetricDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePlayMetricDataResponseBodyNodes>> nodes{};
  shared_ptr<string> requestId{};
  shared_ptr<string> summaryData{};

  DescribePlayMetricDataResponseBody() {}

  explicit DescribePlayMetricDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (summaryData) {
      res["SummaryData"] = boost::any(*summaryData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<DescribePlayMetricDataResponseBodyNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePlayMetricDataResponseBodyNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<DescribePlayMetricDataResponseBodyNodes>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SummaryData") != m.end() && !m["SummaryData"].empty()) {
      summaryData = make_shared<string>(boost::any_cast<string>(m["SummaryData"]));
    }
  }


  virtual ~DescribePlayMetricDataResponseBody() = default;
};
class DescribePlayMetricDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePlayMetricDataResponseBody> body{};

  DescribePlayMetricDataResponse() {}

  explicit DescribePlayMetricDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePlayMetricDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePlayMetricDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePlayMetricDataResponse() = default;
};
class DescribePlayQoeListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<long> beginTs{};
  shared_ptr<string> definition{};
  shared_ptr<long> endTs{};
  shared_ptr<string> itemConfigs{};
  shared_ptr<vector<string>> metricTypes{};
  shared_ptr<string> network{};
  shared_ptr<string> orderName{};
  shared_ptr<string> orderType{};
  shared_ptr<string> os{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> terminalType{};

  DescribePlayQoeListRequest() {}

  explicit DescribePlayQoeListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (beginTs) {
      res["BeginTs"] = boost::any(*beginTs);
    }
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (itemConfigs) {
      res["ItemConfigs"] = boost::any(*itemConfigs);
    }
    if (metricTypes) {
      res["MetricTypes"] = boost::any(*metricTypes);
    }
    if (network) {
      res["Network"] = boost::any(*network);
    }
    if (orderName) {
      res["OrderName"] = boost::any(*orderName);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (terminalType) {
      res["TerminalType"] = boost::any(*terminalType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BeginTs") != m.end() && !m["BeginTs"].empty()) {
      beginTs = make_shared<long>(boost::any_cast<long>(m["BeginTs"]));
    }
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("ItemConfigs") != m.end() && !m["ItemConfigs"].empty()) {
      itemConfigs = make_shared<string>(boost::any_cast<string>(m["ItemConfigs"]));
    }
    if (m.find("MetricTypes") != m.end() && !m["MetricTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MetricTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MetricTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      metricTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      network = make_shared<string>(boost::any_cast<string>(m["Network"]));
    }
    if (m.find("OrderName") != m.end() && !m["OrderName"].empty()) {
      orderName = make_shared<string>(boost::any_cast<string>(m["OrderName"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TerminalType") != m.end() && !m["TerminalType"].empty()) {
      terminalType = make_shared<string>(boost::any_cast<string>(m["TerminalType"]));
    }
  }


  virtual ~DescribePlayQoeListRequest() = default;
};
class DescribePlayQoeListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<long> beginTs{};
  shared_ptr<string> definition{};
  shared_ptr<long> endTs{};
  shared_ptr<string> itemConfigs{};
  shared_ptr<string> metricTypesShrink{};
  shared_ptr<string> network{};
  shared_ptr<string> orderName{};
  shared_ptr<string> orderType{};
  shared_ptr<string> os{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> terminalType{};

  DescribePlayQoeListShrinkRequest() {}

  explicit DescribePlayQoeListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (beginTs) {
      res["BeginTs"] = boost::any(*beginTs);
    }
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (itemConfigs) {
      res["ItemConfigs"] = boost::any(*itemConfigs);
    }
    if (metricTypesShrink) {
      res["MetricTypes"] = boost::any(*metricTypesShrink);
    }
    if (network) {
      res["Network"] = boost::any(*network);
    }
    if (orderName) {
      res["OrderName"] = boost::any(*orderName);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (terminalType) {
      res["TerminalType"] = boost::any(*terminalType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BeginTs") != m.end() && !m["BeginTs"].empty()) {
      beginTs = make_shared<long>(boost::any_cast<long>(m["BeginTs"]));
    }
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("ItemConfigs") != m.end() && !m["ItemConfigs"].empty()) {
      itemConfigs = make_shared<string>(boost::any_cast<string>(m["ItemConfigs"]));
    }
    if (m.find("MetricTypes") != m.end() && !m["MetricTypes"].empty()) {
      metricTypesShrink = make_shared<string>(boost::any_cast<string>(m["MetricTypes"]));
    }
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      network = make_shared<string>(boost::any_cast<string>(m["Network"]));
    }
    if (m.find("OrderName") != m.end() && !m["OrderName"].empty()) {
      orderName = make_shared<string>(boost::any_cast<string>(m["OrderName"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TerminalType") != m.end() && !m["TerminalType"].empty()) {
      terminalType = make_shared<string>(boost::any_cast<string>(m["TerminalType"]));
    }
  }


  virtual ~DescribePlayQoeListShrinkRequest() = default;
};
class DescribePlayQoeListResponseBodyQoeInfoList : public Darabonba::Model {
public:
  shared_ptr<double> qoeFinishedVV{};
  shared_ptr<double> qoeFinishedVVRate{};
  shared_ptr<double> qoeUFinishedVVTime{};
  shared_ptr<double> qoeUV{};
  shared_ptr<double> qoeUVVDuration{};
  shared_ptr<double> qoeUVVTime{};
  shared_ptr<double> qoeVDuration{};
  shared_ptr<double> qoeVVDuration{};
  shared_ptr<string> traceId{};

  DescribePlayQoeListResponseBodyQoeInfoList() {}

  explicit DescribePlayQoeListResponseBodyQoeInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qoeFinishedVV) {
      res["QoeFinishedVV"] = boost::any(*qoeFinishedVV);
    }
    if (qoeFinishedVVRate) {
      res["QoeFinishedVVRate"] = boost::any(*qoeFinishedVVRate);
    }
    if (qoeUFinishedVVTime) {
      res["QoeUFinishedVVTime"] = boost::any(*qoeUFinishedVVTime);
    }
    if (qoeUV) {
      res["QoeUV"] = boost::any(*qoeUV);
    }
    if (qoeUVVDuration) {
      res["QoeUVVDuration"] = boost::any(*qoeUVVDuration);
    }
    if (qoeUVVTime) {
      res["QoeUVVTime"] = boost::any(*qoeUVVTime);
    }
    if (qoeVDuration) {
      res["QoeVDuration"] = boost::any(*qoeVDuration);
    }
    if (qoeVVDuration) {
      res["QoeVVDuration"] = boost::any(*qoeVVDuration);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QoeFinishedVV") != m.end() && !m["QoeFinishedVV"].empty()) {
      qoeFinishedVV = make_shared<double>(boost::any_cast<double>(m["QoeFinishedVV"]));
    }
    if (m.find("QoeFinishedVVRate") != m.end() && !m["QoeFinishedVVRate"].empty()) {
      qoeFinishedVVRate = make_shared<double>(boost::any_cast<double>(m["QoeFinishedVVRate"]));
    }
    if (m.find("QoeUFinishedVVTime") != m.end() && !m["QoeUFinishedVVTime"].empty()) {
      qoeUFinishedVVTime = make_shared<double>(boost::any_cast<double>(m["QoeUFinishedVVTime"]));
    }
    if (m.find("QoeUV") != m.end() && !m["QoeUV"].empty()) {
      qoeUV = make_shared<double>(boost::any_cast<double>(m["QoeUV"]));
    }
    if (m.find("QoeUVVDuration") != m.end() && !m["QoeUVVDuration"].empty()) {
      qoeUVVDuration = make_shared<double>(boost::any_cast<double>(m["QoeUVVDuration"]));
    }
    if (m.find("QoeUVVTime") != m.end() && !m["QoeUVVTime"].empty()) {
      qoeUVVTime = make_shared<double>(boost::any_cast<double>(m["QoeUVVTime"]));
    }
    if (m.find("QoeVDuration") != m.end() && !m["QoeVDuration"].empty()) {
      qoeVDuration = make_shared<double>(boost::any_cast<double>(m["QoeVDuration"]));
    }
    if (m.find("QoeVVDuration") != m.end() && !m["QoeVVDuration"].empty()) {
      qoeVVDuration = make_shared<double>(boost::any_cast<double>(m["QoeVVDuration"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribePlayQoeListResponseBodyQoeInfoList() = default;
};
class DescribePlayQoeListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribePlayQoeListResponseBodyQoeInfoList>> qoeInfoList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePlayQoeListResponseBody() {}

  explicit DescribePlayQoeListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (qoeInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*qoeInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QoeInfoList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QoeInfoList") != m.end() && !m["QoeInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["QoeInfoList"].type()) {
        vector<DescribePlayQoeListResponseBodyQoeInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QoeInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePlayQoeListResponseBodyQoeInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        qoeInfoList = make_shared<vector<DescribePlayQoeListResponseBodyQoeInfoList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePlayQoeListResponseBody() = default;
};
class DescribePlayQoeListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePlayQoeListResponseBody> body{};

  DescribePlayQoeListResponse() {}

  explicit DescribePlayQoeListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePlayQoeListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePlayQoeListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePlayQoeListResponse() = default;
};
class DescribePlayQosListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> beginTs{};
  shared_ptr<string> definition{};
  shared_ptr<string> endTs{};
  shared_ptr<string> itemConfigs{};
  shared_ptr<vector<string>> metricTypes{};
  shared_ptr<string> network{};
  shared_ptr<string> orderName{};
  shared_ptr<string> orderType{};
  shared_ptr<string> os{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> terminalType{};

  DescribePlayQosListRequest() {}

  explicit DescribePlayQosListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (beginTs) {
      res["BeginTs"] = boost::any(*beginTs);
    }
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (itemConfigs) {
      res["ItemConfigs"] = boost::any(*itemConfigs);
    }
    if (metricTypes) {
      res["MetricTypes"] = boost::any(*metricTypes);
    }
    if (network) {
      res["Network"] = boost::any(*network);
    }
    if (orderName) {
      res["OrderName"] = boost::any(*orderName);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (terminalType) {
      res["TerminalType"] = boost::any(*terminalType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BeginTs") != m.end() && !m["BeginTs"].empty()) {
      beginTs = make_shared<string>(boost::any_cast<string>(m["BeginTs"]));
    }
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<string>(boost::any_cast<string>(m["EndTs"]));
    }
    if (m.find("ItemConfigs") != m.end() && !m["ItemConfigs"].empty()) {
      itemConfigs = make_shared<string>(boost::any_cast<string>(m["ItemConfigs"]));
    }
    if (m.find("MetricTypes") != m.end() && !m["MetricTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MetricTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MetricTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      metricTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      network = make_shared<string>(boost::any_cast<string>(m["Network"]));
    }
    if (m.find("OrderName") != m.end() && !m["OrderName"].empty()) {
      orderName = make_shared<string>(boost::any_cast<string>(m["OrderName"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TerminalType") != m.end() && !m["TerminalType"].empty()) {
      terminalType = make_shared<string>(boost::any_cast<string>(m["TerminalType"]));
    }
  }


  virtual ~DescribePlayQosListRequest() = default;
};
class DescribePlayQosListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> beginTs{};
  shared_ptr<string> definition{};
  shared_ptr<string> endTs{};
  shared_ptr<string> itemConfigs{};
  shared_ptr<string> metricTypesShrink{};
  shared_ptr<string> network{};
  shared_ptr<string> orderName{};
  shared_ptr<string> orderType{};
  shared_ptr<string> os{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> terminalType{};

  DescribePlayQosListShrinkRequest() {}

  explicit DescribePlayQosListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (beginTs) {
      res["BeginTs"] = boost::any(*beginTs);
    }
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (itemConfigs) {
      res["ItemConfigs"] = boost::any(*itemConfigs);
    }
    if (metricTypesShrink) {
      res["MetricTypes"] = boost::any(*metricTypesShrink);
    }
    if (network) {
      res["Network"] = boost::any(*network);
    }
    if (orderName) {
      res["OrderName"] = boost::any(*orderName);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (os) {
      res["Os"] = boost::any(*os);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (terminalType) {
      res["TerminalType"] = boost::any(*terminalType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BeginTs") != m.end() && !m["BeginTs"].empty()) {
      beginTs = make_shared<string>(boost::any_cast<string>(m["BeginTs"]));
    }
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<string>(boost::any_cast<string>(m["EndTs"]));
    }
    if (m.find("ItemConfigs") != m.end() && !m["ItemConfigs"].empty()) {
      itemConfigs = make_shared<string>(boost::any_cast<string>(m["ItemConfigs"]));
    }
    if (m.find("MetricTypes") != m.end() && !m["MetricTypes"].empty()) {
      metricTypesShrink = make_shared<string>(boost::any_cast<string>(m["MetricTypes"]));
    }
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      network = make_shared<string>(boost::any_cast<string>(m["Network"]));
    }
    if (m.find("OrderName") != m.end() && !m["OrderName"].empty()) {
      orderName = make_shared<string>(boost::any_cast<string>(m["OrderName"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("Os") != m.end() && !m["Os"].empty()) {
      os = make_shared<string>(boost::any_cast<string>(m["Os"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TerminalType") != m.end() && !m["TerminalType"].empty()) {
      terminalType = make_shared<string>(boost::any_cast<string>(m["TerminalType"]));
    }
  }


  virtual ~DescribePlayQosListShrinkRequest() = default;
};
class DescribePlayQosListResponseBodyQosInfoList : public Darabonba::Model {
public:
  shared_ptr<string> qosFirstFrame{};
  shared_ptr<string> qosKbps{};
  shared_ptr<string> qosPlay{};
  shared_ptr<string> qosPlayFail{};
  shared_ptr<string> qosRealPlay{};
  shared_ptr<string> qosSeedFailRate{};
  shared_ptr<string> qosStuckRate{};
  shared_ptr<string> traceId{};

  DescribePlayQosListResponseBodyQosInfoList() {}

  explicit DescribePlayQosListResponseBodyQosInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qosFirstFrame) {
      res["QosFirstFrame"] = boost::any(*qosFirstFrame);
    }
    if (qosKbps) {
      res["QosKbps"] = boost::any(*qosKbps);
    }
    if (qosPlay) {
      res["QosPlay"] = boost::any(*qosPlay);
    }
    if (qosPlayFail) {
      res["QosPlayFail"] = boost::any(*qosPlayFail);
    }
    if (qosRealPlay) {
      res["QosRealPlay"] = boost::any(*qosRealPlay);
    }
    if (qosSeedFailRate) {
      res["QosSeedFailRate"] = boost::any(*qosSeedFailRate);
    }
    if (qosStuckRate) {
      res["QosStuckRate"] = boost::any(*qosStuckRate);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QosFirstFrame") != m.end() && !m["QosFirstFrame"].empty()) {
      qosFirstFrame = make_shared<string>(boost::any_cast<string>(m["QosFirstFrame"]));
    }
    if (m.find("QosKbps") != m.end() && !m["QosKbps"].empty()) {
      qosKbps = make_shared<string>(boost::any_cast<string>(m["QosKbps"]));
    }
    if (m.find("QosPlay") != m.end() && !m["QosPlay"].empty()) {
      qosPlay = make_shared<string>(boost::any_cast<string>(m["QosPlay"]));
    }
    if (m.find("QosPlayFail") != m.end() && !m["QosPlayFail"].empty()) {
      qosPlayFail = make_shared<string>(boost::any_cast<string>(m["QosPlayFail"]));
    }
    if (m.find("QosRealPlay") != m.end() && !m["QosRealPlay"].empty()) {
      qosRealPlay = make_shared<string>(boost::any_cast<string>(m["QosRealPlay"]));
    }
    if (m.find("QosSeedFailRate") != m.end() && !m["QosSeedFailRate"].empty()) {
      qosSeedFailRate = make_shared<string>(boost::any_cast<string>(m["QosSeedFailRate"]));
    }
    if (m.find("QosStuckRate") != m.end() && !m["QosStuckRate"].empty()) {
      qosStuckRate = make_shared<string>(boost::any_cast<string>(m["QosStuckRate"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribePlayQosListResponseBodyQosInfoList() = default;
};
class DescribePlayQosListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribePlayQosListResponseBodyQosInfoList>> qosInfoList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePlayQosListResponseBody() {}

  explicit DescribePlayQosListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (qosInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*qosInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QosInfoList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QosInfoList") != m.end() && !m["QosInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["QosInfoList"].type()) {
        vector<DescribePlayQosListResponseBodyQosInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QosInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePlayQosListResponseBodyQosInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        qosInfoList = make_shared<vector<DescribePlayQosListResponseBodyQosInfoList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePlayQosListResponseBody() = default;
};
class DescribePlayQosListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePlayQosListResponseBody> body{};

  DescribePlayQosListResponse() {}

  explicit DescribePlayQosListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePlayQosListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePlayQosListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePlayQosListResponse() = default;
};
class DescribeQueryConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};

  DescribeQueryConfigsRequest() {}

  explicit DescribeQueryConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeQueryConfigsRequest() = default;
};
class DescribeQueryConfigsResponseBodyConfigs : public Darabonba::Model {
public:
  shared_ptr<string> value{};

  DescribeQueryConfigsResponseBodyConfigs() {}

  explicit DescribeQueryConfigsResponseBodyConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeQueryConfigsResponseBodyConfigs() = default;
};
class DescribeQueryConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeQueryConfigsResponseBodyConfigs>> configs{};
  shared_ptr<string> requestId{};

  DescribeQueryConfigsResponseBody() {}

  explicit DescribeQueryConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<DescribeQueryConfigsResponseBodyConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeQueryConfigsResponseBodyConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<DescribeQueryConfigsResponseBodyConfigs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeQueryConfigsResponseBody() = default;
};
class DescribeQueryConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeQueryConfigsResponseBody> body{};

  DescribeQueryConfigsResponse() {}

  explicit DescribeQueryConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeQueryConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeQueryConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeQueryConfigsResponse() = default;
};
class GetCategoriesRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> type{};

  GetCategoriesRequest() {}

  explicit GetCategoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetCategoriesRequest() = default;
};
class GetCategoriesResponseBodyCategory : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<long> level{};
  shared_ptr<long> parentId{};
  shared_ptr<string> type{};

  GetCategoriesResponseBodyCategory() {}

  explicit GetCategoriesResponseBodyCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetCategoriesResponseBodyCategory() = default;
};
class GetCategoriesResponseBodySubCategoriesCategory : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<long> level{};
  shared_ptr<long> parentId{};
  shared_ptr<long> subTotal{};
  shared_ptr<string> type{};

  GetCategoriesResponseBodySubCategoriesCategory() {}

  explicit GetCategoriesResponseBodySubCategoriesCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (subTotal) {
      res["SubTotal"] = boost::any(*subTotal);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("SubTotal") != m.end() && !m["SubTotal"].empty()) {
      subTotal = make_shared<long>(boost::any_cast<long>(m["SubTotal"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetCategoriesResponseBodySubCategoriesCategory() = default;
};
class GetCategoriesResponseBodySubCategories : public Darabonba::Model {
public:
  shared_ptr<vector<GetCategoriesResponseBodySubCategoriesCategory>> category{};

  GetCategoriesResponseBodySubCategories() {}

  explicit GetCategoriesResponseBodySubCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      vector<boost::any> temp1;
      for(auto item1:*category){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Category"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(vector<boost::any>) == m["Category"].type()) {
        vector<GetCategoriesResponseBodySubCategoriesCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Category"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCategoriesResponseBodySubCategoriesCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        category = make_shared<vector<GetCategoriesResponseBodySubCategoriesCategory>>(expect1);
      }
    }
  }


  virtual ~GetCategoriesResponseBodySubCategories() = default;
};
class GetCategoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetCategoriesResponseBodyCategory> category{};
  shared_ptr<string> requestId{};
  shared_ptr<GetCategoriesResponseBodySubCategories> subCategories{};
  shared_ptr<long> subTotal{};

  GetCategoriesResponseBody() {}

  explicit GetCategoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = category ? boost::any(category->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCategories) {
      res["SubCategories"] = subCategories ? boost::any(subCategories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subTotal) {
      res["SubTotal"] = boost::any(*subTotal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(map<string, boost::any>) == m["Category"].type()) {
        GetCategoriesResponseBodyCategory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Category"]));
        category = make_shared<GetCategoriesResponseBodyCategory>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCategories") != m.end() && !m["SubCategories"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubCategories"].type()) {
        GetCategoriesResponseBodySubCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubCategories"]));
        subCategories = make_shared<GetCategoriesResponseBodySubCategories>(model1);
      }
    }
    if (m.find("SubTotal") != m.end() && !m["SubTotal"].empty()) {
      subTotal = make_shared<long>(boost::any_cast<long>(m["SubTotal"]));
    }
  }


  virtual ~GetCategoriesResponseBody() = default;
};
class GetCategoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCategoriesResponseBody> body{};

  GetCategoriesResponse() {}

  explicit GetCategoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCategoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCategoriesResponseBody>(model1);
      }
    }
  }


  virtual ~GetCategoriesResponse() = default;
};
class GetCustomTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> subtype{};
  shared_ptr<string> templateId{};
  shared_ptr<long> type{};

  GetCustomTemplateRequest() {}

  explicit GetCustomTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<long>(boost::any_cast<long>(m["Subtype"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~GetCustomTemplateRequest() = default;
};
class GetCustomTemplateResponseBodyCustomTemplate : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> status{};
  shared_ptr<long> subtype{};
  shared_ptr<string> subtypeName{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> type{};
  shared_ptr<string> typeName_{};

  GetCustomTemplateResponseBodyCustomTemplate() {}

  explicit GetCustomTemplateResponseBodyCustomTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (subtypeName) {
      res["SubtypeName"] = boost::any(*subtypeName);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<long>(boost::any_cast<long>(m["Subtype"]));
    }
    if (m.find("SubtypeName") != m.end() && !m["SubtypeName"].empty()) {
      subtypeName = make_shared<string>(boost::any_cast<string>(m["SubtypeName"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~GetCustomTemplateResponseBodyCustomTemplate() = default;
};
class GetCustomTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetCustomTemplateResponseBodyCustomTemplate> customTemplate{};
  shared_ptr<string> requestId{};

  GetCustomTemplateResponseBody() {}

  explicit GetCustomTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTemplate) {
      res["CustomTemplate"] = customTemplate ? boost::any(customTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTemplate") != m.end() && !m["CustomTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomTemplate"].type()) {
        GetCustomTemplateResponseBodyCustomTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomTemplate"]));
        customTemplate = make_shared<GetCustomTemplateResponseBodyCustomTemplate>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCustomTemplateResponseBody() = default;
};
class GetCustomTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCustomTemplateResponseBody> body{};

  GetCustomTemplateResponse() {}

  explicit GetCustomTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCustomTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCustomTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetCustomTemplateResponse() = default;
};
class GetDefaultStorageLocationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> path{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<string> storageType{};

  GetDefaultStorageLocationResponseBody() {}

  explicit GetDefaultStorageLocationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~GetDefaultStorageLocationResponseBody() = default;
};
class GetDefaultStorageLocationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDefaultStorageLocationResponseBody> body{};

  GetDefaultStorageLocationResponse() {}

  explicit GetDefaultStorageLocationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDefaultStorageLocationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDefaultStorageLocationResponseBody>(model1);
      }
    }
  }


  virtual ~GetDefaultStorageLocationResponse() = default;
};
class GetDynamicImageJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetDynamicImageJobRequest() {}

  explicit GetDynamicImageJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetDynamicImageJobRequest() = default;
};
class GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile() {}

  explicit GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile() = default;
};
class GetDynamicImageJobResponseBodyDynamicImageJobInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile> ossFile{};
  shared_ptr<string> type{};

  GetDynamicImageJobResponseBodyDynamicImageJobInput() {}

  explicit GetDynamicImageJobResponseBodyDynamicImageJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (ossFile) {
      res["OssFile"] = ossFile ? boost::any(ossFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("OssFile") != m.end() && !m["OssFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssFile"].type()) {
        GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssFile"]));
        ossFile = make_shared<GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDynamicImageJobResponseBodyDynamicImageJobInput() = default;
};
class GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile() {}

  explicit GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile() = default;
};
class GetDynamicImageJobResponseBodyDynamicImageJobOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile> ossFile{};
  shared_ptr<string> type{};

  GetDynamicImageJobResponseBodyDynamicImageJobOutput() {}

  explicit GetDynamicImageJobResponseBodyDynamicImageJobOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (ossFile) {
      res["OssFile"] = ossFile ? boost::any(ossFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("OssFile") != m.end() && !m["OssFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssFile"].type()) {
        GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssFile"]));
        ossFile = make_shared<GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDynamicImageJobResponseBodyDynamicImageJobOutput() = default;
};
class GetDynamicImageJobResponseBodyDynamicImageJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<GetDynamicImageJobResponseBodyDynamicImageJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<GetDynamicImageJobResponseBodyDynamicImageJobOutput> output{};
  shared_ptr<string> outputUrl{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  GetDynamicImageJobResponseBodyDynamicImageJob() {}

  explicit GetDynamicImageJobResponseBodyDynamicImageJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outputUrl) {
      res["OutputUrl"] = boost::any(*outputUrl);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        GetDynamicImageJobResponseBodyDynamicImageJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<GetDynamicImageJobResponseBodyDynamicImageJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        GetDynamicImageJobResponseBodyDynamicImageJobOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<GetDynamicImageJobResponseBodyDynamicImageJobOutput>(model1);
      }
    }
    if (m.find("OutputUrl") != m.end() && !m["OutputUrl"].empty()) {
      outputUrl = make_shared<string>(boost::any_cast<string>(m["OutputUrl"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetDynamicImageJobResponseBodyDynamicImageJob() = default;
};
class GetDynamicImageJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDynamicImageJobResponseBodyDynamicImageJob> dynamicImageJob{};
  shared_ptr<string> requestId{};

  GetDynamicImageJobResponseBody() {}

  explicit GetDynamicImageJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicImageJob) {
      res["DynamicImageJob"] = dynamicImageJob ? boost::any(dynamicImageJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicImageJob") != m.end() && !m["DynamicImageJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["DynamicImageJob"].type()) {
        GetDynamicImageJobResponseBodyDynamicImageJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DynamicImageJob"]));
        dynamicImageJob = make_shared<GetDynamicImageJobResponseBodyDynamicImageJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDynamicImageJobResponseBody() = default;
};
class GetDynamicImageJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDynamicImageJobResponseBody> body{};

  GetDynamicImageJobResponse() {}

  explicit GetDynamicImageJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDynamicImageJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDynamicImageJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetDynamicImageJobResponse() = default;
};
class GetEditingProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};

  GetEditingProjectRequest() {}

  explicit GetEditingProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~GetEditingProjectRequest() = default;
};
class GetEditingProjectResponseBodyProject : public Darabonba::Model {
public:
  shared_ptr<string> businessConfig{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> clipsParam{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createSource{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> duration{};
  shared_ptr<string> modifiedSource{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectType{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};
  shared_ptr<string> timeline{};
  shared_ptr<string> title{};

  GetEditingProjectResponseBodyProject() {}

  explicit GetEditingProjectResponseBodyProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessConfig) {
      res["BusinessConfig"] = boost::any(*businessConfig);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (modifiedSource) {
      res["ModifiedSource"] = boost::any(*modifiedSource);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectType) {
      res["ProjectType"] = boost::any(*projectType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessConfig") != m.end() && !m["BusinessConfig"].empty()) {
      businessConfig = make_shared<string>(boost::any_cast<string>(m["BusinessConfig"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("ModifiedSource") != m.end() && !m["ModifiedSource"].empty()) {
      modifiedSource = make_shared<string>(boost::any_cast<string>(m["ModifiedSource"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectType") != m.end() && !m["ProjectType"].empty()) {
      projectType = make_shared<string>(boost::any_cast<string>(m["ProjectType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetEditingProjectResponseBodyProject() = default;
};
class GetEditingProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetEditingProjectResponseBodyProject> project{};
  shared_ptr<string> requestId{};

  GetEditingProjectResponseBody() {}

  explicit GetEditingProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (project) {
      res["Project"] = project ? boost::any(project->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      if (typeid(map<string, boost::any>) == m["Project"].type()) {
        GetEditingProjectResponseBodyProject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Project"]));
        project = make_shared<GetEditingProjectResponseBodyProject>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetEditingProjectResponseBody() = default;
};
class GetEditingProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEditingProjectResponseBody> body{};

  GetEditingProjectResponse() {}

  explicit GetEditingProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEditingProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEditingProjectResponseBody>(model1);
      }
    }
  }


  virtual ~GetEditingProjectResponse() = default;
};
class GetEditingProjectMaterialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};

  GetEditingProjectMaterialsRequest() {}

  explicit GetEditingProjectMaterialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~GetEditingProjectMaterialsRequest() = default;
};
class GetEditingProjectMaterialsResponseBodyLiveMaterials : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> liveUrl{};
  shared_ptr<string> streamName{};

  GetEditingProjectMaterialsResponseBodyLiveMaterials() {}

  explicit GetEditingProjectMaterialsResponseBodyLiveMaterials(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (liveUrl) {
      res["LiveUrl"] = boost::any(*liveUrl);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LiveUrl") != m.end() && !m["LiveUrl"].empty()) {
      liveUrl = make_shared<string>(boost::any_cast<string>(m["LiveUrl"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBodyLiveMaterials() = default;
};
class GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo() {}

  explicit GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo() = default;
};
class GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList : public Darabonba::Model {
public:
  shared_ptr<GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo> fileBasicInfo{};

  GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList() {}

  explicit GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo>(model1);
      }
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList() = default;
};
class GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> snapshots{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteImages{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> transcodeStatus{};
  shared_ptr<string> userData{};

  GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo() {}

  explicit GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteImages) {
      res["SpriteImages"] = boost::any(*spriteImages);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (transcodeStatus) {
      res["TranscodeStatus"] = boost::any(*transcodeStatus);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      snapshots = make_shared<string>(boost::any_cast<string>(m["Snapshots"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteImages") != m.end() && !m["SpriteImages"].empty()) {
      spriteImages = make_shared<string>(boost::any_cast<string>(m["SpriteImages"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TranscodeStatus") != m.end() && !m["TranscodeStatus"].empty()) {
      transcodeStatus = make_shared<string>(boost::any_cast<string>(m["TranscodeStatus"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo() = default;
};
class GetEditingProjectMaterialsResponseBodyMediaInfos : public Darabonba::Model {
public:
  shared_ptr<vector<GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList>> fileInfoList{};
  shared_ptr<GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  GetEditingProjectMaterialsResponseBodyMediaInfos() {}

  explicit GetEditingProjectMaterialsResponseBodyMediaInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList>>(expect1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBodyMediaInfos() = default;
};
class GetEditingProjectMaterialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetEditingProjectMaterialsResponseBodyLiveMaterials>> liveMaterials{};
  shared_ptr<vector<GetEditingProjectMaterialsResponseBodyMediaInfos>> mediaInfos{};
  shared_ptr<string> projectId{};
  shared_ptr<vector<string>> projectMaterials{};
  shared_ptr<string> requestId{};

  GetEditingProjectMaterialsResponseBody() {}

  explicit GetEditingProjectMaterialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveMaterials) {
      vector<boost::any> temp1;
      for(auto item1:*liveMaterials){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveMaterials"] = boost::any(temp1);
    }
    if (mediaInfos) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInfos"] = boost::any(temp1);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectMaterials) {
      res["ProjectMaterials"] = boost::any(*projectMaterials);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveMaterials") != m.end() && !m["LiveMaterials"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveMaterials"].type()) {
        vector<GetEditingProjectMaterialsResponseBodyLiveMaterials> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveMaterials"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEditingProjectMaterialsResponseBodyLiveMaterials model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveMaterials = make_shared<vector<GetEditingProjectMaterialsResponseBodyLiveMaterials>>(expect1);
      }
    }
    if (m.find("MediaInfos") != m.end() && !m["MediaInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInfos"].type()) {
        vector<GetEditingProjectMaterialsResponseBodyMediaInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEditingProjectMaterialsResponseBodyMediaInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInfos = make_shared<vector<GetEditingProjectMaterialsResponseBodyMediaInfos>>(expect1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectMaterials") != m.end() && !m["ProjectMaterials"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProjectMaterials"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProjectMaterials"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      projectMaterials = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBody() = default;
};
class GetEditingProjectMaterialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEditingProjectMaterialsResponseBody> body{};

  GetEditingProjectMaterialsResponse() {}

  explicit GetEditingProjectMaterialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEditingProjectMaterialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEditingProjectMaterialsResponseBody>(model1);
      }
    }
  }


  virtual ~GetEditingProjectMaterialsResponse() = default;
};
class GetEventCallbackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> authKey{};
  shared_ptr<string> authSwitch{};
  shared_ptr<string> callbackQueueName{};
  shared_ptr<string> callbackType{};
  shared_ptr<string> callbackURL{};
  shared_ptr<string> eventTypeList{};
  shared_ptr<string> requestId{};

  GetEventCallbackResponseBody() {}

  explicit GetEventCallbackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (authSwitch) {
      res["AuthSwitch"] = boost::any(*authSwitch);
    }
    if (callbackQueueName) {
      res["CallbackQueueName"] = boost::any(*callbackQueueName);
    }
    if (callbackType) {
      res["CallbackType"] = boost::any(*callbackType);
    }
    if (callbackURL) {
      res["CallbackURL"] = boost::any(*callbackURL);
    }
    if (eventTypeList) {
      res["EventTypeList"] = boost::any(*eventTypeList);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("AuthSwitch") != m.end() && !m["AuthSwitch"].empty()) {
      authSwitch = make_shared<string>(boost::any_cast<string>(m["AuthSwitch"]));
    }
    if (m.find("CallbackQueueName") != m.end() && !m["CallbackQueueName"].empty()) {
      callbackQueueName = make_shared<string>(boost::any_cast<string>(m["CallbackQueueName"]));
    }
    if (m.find("CallbackType") != m.end() && !m["CallbackType"].empty()) {
      callbackType = make_shared<string>(boost::any_cast<string>(m["CallbackType"]));
    }
    if (m.find("CallbackURL") != m.end() && !m["CallbackURL"].empty()) {
      callbackURL = make_shared<string>(boost::any_cast<string>(m["CallbackURL"]));
    }
    if (m.find("EventTypeList") != m.end() && !m["EventTypeList"].empty()) {
      eventTypeList = make_shared<string>(boost::any_cast<string>(m["EventTypeList"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetEventCallbackResponseBody() = default;
};
class GetEventCallbackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEventCallbackResponseBody> body{};

  GetEventCallbackResponse() {}

  explicit GetEventCallbackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEventCallbackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEventCallbackResponseBody>(model1);
      }
    }
  }


  virtual ~GetEventCallbackResponse() = default;
};
class GetLiveEditingIndexFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> projectId{};
  shared_ptr<string> streamName{};

  GetLiveEditingIndexFileRequest() {}

  explicit GetLiveEditingIndexFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~GetLiveEditingIndexFileRequest() = default;
};
class GetLiveEditingIndexFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> indexFile{};
  shared_ptr<string> requestId{};

  GetLiveEditingIndexFileResponseBody() {}

  explicit GetLiveEditingIndexFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (indexFile) {
      res["IndexFile"] = boost::any(*indexFile);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IndexFile") != m.end() && !m["IndexFile"].empty()) {
      indexFile = make_shared<string>(boost::any_cast<string>(m["IndexFile"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLiveEditingIndexFileResponseBody() = default;
};
class GetLiveEditingIndexFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveEditingIndexFileResponseBody> body{};

  GetLiveEditingIndexFileResponse() {}

  explicit GetLiveEditingIndexFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveEditingIndexFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveEditingIndexFileResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveEditingIndexFileResponse() = default;
};
class GetLiveEditingJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetLiveEditingJobRequest() {}

  explicit GetLiveEditingJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetLiveEditingJobRequest() = default;
};
class GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> streamName{};

  GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig() {}

  explicit GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig() = default;
};
class GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig : public Darabonba::Model {
public:
  shared_ptr<string> mode{};

  GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig() {}

  explicit GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
  }


  virtual ~GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig() = default;
};
class GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig : public Darabonba::Model {
public:
  shared_ptr<long> bitrate{};
  shared_ptr<string> fileName{};
  shared_ptr<long> height{};
  shared_ptr<string> mediaURL{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> vodTemplateGroupId{};
  shared_ptr<long> width{};

  GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig() {}

  explicit GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaURL) {
      res["MediaURL"] = boost::any(*mediaURL);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (vodTemplateGroupId) {
      res["VodTemplateGroupId"] = boost::any(*vodTemplateGroupId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("MediaURL") != m.end() && !m["MediaURL"].empty()) {
      mediaURL = make_shared<string>(boost::any_cast<string>(m["MediaURL"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("VodTemplateGroupId") != m.end() && !m["VodTemplateGroupId"].empty()) {
      vodTemplateGroupId = make_shared<string>(boost::any_cast<string>(m["VodTemplateGroupId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig() = default;
};
class GetLiveEditingJobResponseBodyLiveEditingJob : public Darabonba::Model {
public:
  shared_ptr<string> clips{};
  shared_ptr<string> code{};
  shared_ptr<string> completeTime{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> jobId{};
  shared_ptr<GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig> liveStreamConfig{};
  shared_ptr<string> mediaId{};
  shared_ptr<GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig> mediaProduceConfig{};
  shared_ptr<string> mediaURL{};
  shared_ptr<string> message{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig> outputMediaConfig{};
  shared_ptr<string> projectId{};
  shared_ptr<string> status{};
  shared_ptr<string> userData{};

  GetLiveEditingJobResponseBodyLiveEditingJob() {}

  explicit GetLiveEditingJobResponseBodyLiveEditingJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clips) {
      res["Clips"] = boost::any(*clips);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (liveStreamConfig) {
      res["LiveStreamConfig"] = liveStreamConfig ? boost::any(liveStreamConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaProduceConfig) {
      res["MediaProduceConfig"] = mediaProduceConfig ? boost::any(mediaProduceConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaURL) {
      res["MediaURL"] = boost::any(*mediaURL);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (outputMediaConfig) {
      res["OutputMediaConfig"] = outputMediaConfig ? boost::any(outputMediaConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clips") != m.end() && !m["Clips"].empty()) {
      clips = make_shared<string>(boost::any_cast<string>(m["Clips"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("LiveStreamConfig") != m.end() && !m["LiveStreamConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamConfig"].type()) {
        GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamConfig"]));
        liveStreamConfig = make_shared<GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaProduceConfig") != m.end() && !m["MediaProduceConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaProduceConfig"].type()) {
        GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaProduceConfig"]));
        mediaProduceConfig = make_shared<GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig>(model1);
      }
    }
    if (m.find("MediaURL") != m.end() && !m["MediaURL"].empty()) {
      mediaURL = make_shared<string>(boost::any_cast<string>(m["MediaURL"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OutputMediaConfig") != m.end() && !m["OutputMediaConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputMediaConfig"].type()) {
        GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputMediaConfig"]));
        outputMediaConfig = make_shared<GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetLiveEditingJobResponseBodyLiveEditingJob() = default;
};
class GetLiveEditingJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetLiveEditingJobResponseBodyLiveEditingJob> liveEditingJob{};
  shared_ptr<string> requestId{};

  GetLiveEditingJobResponseBody() {}

  explicit GetLiveEditingJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveEditingJob) {
      res["LiveEditingJob"] = liveEditingJob ? boost::any(liveEditingJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveEditingJob") != m.end() && !m["LiveEditingJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveEditingJob"].type()) {
        GetLiveEditingJobResponseBodyLiveEditingJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveEditingJob"]));
        liveEditingJob = make_shared<GetLiveEditingJobResponseBodyLiveEditingJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLiveEditingJobResponseBody() = default;
};
class GetLiveEditingJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveEditingJobResponseBody> body{};

  GetLiveEditingJobResponse() {}

  explicit GetLiveEditingJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveEditingJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveEditingJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveEditingJobResponse() = default;
};
class GetLiveRecordJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetLiveRecordJobRequest() {}

  explicit GetLiveRecordJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetLiveRecordJobRequest() = default;
};
class GetLiveRecordJobResponseBodyRecordJobRecordOutput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> type{};

  GetLiveRecordJobResponseBodyRecordJobRecordOutput() {}

  explicit GetLiveRecordJobResponseBodyRecordJobRecordOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetLiveRecordJobResponseBodyRecordJobRecordOutput() = default;
};
class GetLiveRecordJobResponseBodyRecordJobStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  GetLiveRecordJobResponseBodyRecordJobStreamInput() {}

  explicit GetLiveRecordJobResponseBodyRecordJobStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetLiveRecordJobResponseBodyRecordJobStreamInput() = default;
};
class GetLiveRecordJobResponseBodyRecordJob : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<GetLiveRecordJobResponseBodyRecordJobRecordOutput> recordOutput{};
  shared_ptr<string> status{};
  shared_ptr<GetLiveRecordJobResponseBodyRecordJobStreamInput> streamInput{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  GetLiveRecordJobResponseBodyRecordJob() {}

  explicit GetLiveRecordJobResponseBodyRecordJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (recordOutput) {
      res["RecordOutput"] = recordOutput ? boost::any(recordOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("RecordOutput") != m.end() && !m["RecordOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordOutput"].type()) {
        GetLiveRecordJobResponseBodyRecordJobRecordOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordOutput"]));
        recordOutput = make_shared<GetLiveRecordJobResponseBodyRecordJobRecordOutput>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        GetLiveRecordJobResponseBodyRecordJobStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<GetLiveRecordJobResponseBodyRecordJobStreamInput>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~GetLiveRecordJobResponseBodyRecordJob() = default;
};
class GetLiveRecordJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetLiveRecordJobResponseBodyRecordJob> recordJob{};
  shared_ptr<string> requestId{};

  GetLiveRecordJobResponseBody() {}

  explicit GetLiveRecordJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordJob) {
      res["RecordJob"] = recordJob ? boost::any(recordJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordJob") != m.end() && !m["RecordJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordJob"].type()) {
        GetLiveRecordJobResponseBodyRecordJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordJob"]));
        recordJob = make_shared<GetLiveRecordJobResponseBodyRecordJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLiveRecordJobResponseBody() = default;
};
class GetLiveRecordJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveRecordJobResponseBody> body{};

  GetLiveRecordJobResponse() {}

  explicit GetLiveRecordJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveRecordJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveRecordJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveRecordJobResponse() = default;
};
class GetLiveRecordTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> templateId{};

  GetLiveRecordTemplateRequest() {}

  explicit GetLiveRecordTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetLiveRecordTemplateRequest() = default;
};
class GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<long> sliceDuration{};
  shared_ptr<string> sliceOssObjectPrefix{};

  GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList() {}

  explicit GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList() = default;
};
class GetLiveRecordTemplateResponseBodyRecordTemplate : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> name{};
  shared_ptr<vector<GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList>> recordFormatList{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  GetLiveRecordTemplateResponseBodyRecordTemplate() {}

  explicit GetLiveRecordTemplateResponseBodyRecordTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordFormatList) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormatList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormatList"] = boost::any(temp1);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordFormatList") != m.end() && !m["RecordFormatList"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormatList"].type()) {
        vector<GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormatList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormatList = make_shared<vector<GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList>>(expect1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetLiveRecordTemplateResponseBodyRecordTemplate() = default;
};
class GetLiveRecordTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetLiveRecordTemplateResponseBodyRecordTemplate> recordTemplate{};
  shared_ptr<string> requestId{};

  GetLiveRecordTemplateResponseBody() {}

  explicit GetLiveRecordTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordTemplate) {
      res["RecordTemplate"] = recordTemplate ? boost::any(recordTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordTemplate") != m.end() && !m["RecordTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordTemplate"].type()) {
        GetLiveRecordTemplateResponseBodyRecordTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordTemplate"]));
        recordTemplate = make_shared<GetLiveRecordTemplateResponseBodyRecordTemplate>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLiveRecordTemplateResponseBody() = default;
};
class GetLiveRecordTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveRecordTemplateResponseBody> body{};

  GetLiveRecordTemplateResponse() {}

  explicit GetLiveRecordTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveRecordTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveRecordTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveRecordTemplateResponse() = default;
};
class GetLiveSnapshotJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetLiveSnapshotJobRequest() {}

  explicit GetLiveSnapshotJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetLiveSnapshotJobRequest() = default;
};
class GetLiveSnapshotJobResponseBodySnapshotOutput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> storageType{};

  GetLiveSnapshotJobResponseBodySnapshotOutput() {}

  explicit GetLiveSnapshotJobResponseBodySnapshotOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~GetLiveSnapshotJobResponseBodySnapshotOutput() = default;
};
class GetLiveSnapshotJobResponseBodyStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  GetLiveSnapshotJobResponseBodyStreamInput() {}

  explicit GetLiveSnapshotJobResponseBodyStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetLiveSnapshotJobResponseBodyStreamInput() = default;
};
class GetLiveSnapshotJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> createTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> overwriteFormat{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sequenceFormat{};
  shared_ptr<GetLiveSnapshotJobResponseBodySnapshotOutput> snapshotOutput{};
  shared_ptr<string> status{};
  shared_ptr<GetLiveSnapshotJobResponseBodyStreamInput> streamInput{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> timeInterval{};

  GetLiveSnapshotJobResponseBody() {}

  explicit GetLiveSnapshotJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (overwriteFormat) {
      res["OverwriteFormat"] = boost::any(*overwriteFormat);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sequenceFormat) {
      res["SequenceFormat"] = boost::any(*sequenceFormat);
    }
    if (snapshotOutput) {
      res["SnapshotOutput"] = snapshotOutput ? boost::any(snapshotOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("OverwriteFormat") != m.end() && !m["OverwriteFormat"].empty()) {
      overwriteFormat = make_shared<string>(boost::any_cast<string>(m["OverwriteFormat"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SequenceFormat") != m.end() && !m["SequenceFormat"].empty()) {
      sequenceFormat = make_shared<string>(boost::any_cast<string>(m["SequenceFormat"]));
    }
    if (m.find("SnapshotOutput") != m.end() && !m["SnapshotOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotOutput"].type()) {
        GetLiveSnapshotJobResponseBodySnapshotOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotOutput"]));
        snapshotOutput = make_shared<GetLiveSnapshotJobResponseBodySnapshotOutput>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        GetLiveSnapshotJobResponseBodyStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<GetLiveSnapshotJobResponseBodyStreamInput>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
  }


  virtual ~GetLiveSnapshotJobResponseBody() = default;
};
class GetLiveSnapshotJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveSnapshotJobResponseBody> body{};

  GetLiveSnapshotJobResponse() {}

  explicit GetLiveSnapshotJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveSnapshotJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveSnapshotJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveSnapshotJobResponse() = default;
};
class GetLiveSnapshotTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  GetLiveSnapshotTemplateRequest() {}

  explicit GetLiveSnapshotTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetLiveSnapshotTemplateRequest() = default;
};
class GetLiveSnapshotTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> overwriteFormat{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sequenceFormat{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> timeInterval{};
  shared_ptr<string> type{};

  GetLiveSnapshotTemplateResponseBody() {}

  explicit GetLiveSnapshotTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (overwriteFormat) {
      res["OverwriteFormat"] = boost::any(*overwriteFormat);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sequenceFormat) {
      res["SequenceFormat"] = boost::any(*sequenceFormat);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("OverwriteFormat") != m.end() && !m["OverwriteFormat"].empty()) {
      overwriteFormat = make_shared<string>(boost::any_cast<string>(m["OverwriteFormat"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SequenceFormat") != m.end() && !m["SequenceFormat"].empty()) {
      sequenceFormat = make_shared<string>(boost::any_cast<string>(m["SequenceFormat"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetLiveSnapshotTemplateResponseBody() = default;
};
class GetLiveSnapshotTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveSnapshotTemplateResponseBody> body{};

  GetLiveSnapshotTemplateResponse() {}

  explicit GetLiveSnapshotTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveSnapshotTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveSnapshotTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveSnapshotTemplateResponse() = default;
};
class GetLiveTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetLiveTranscodeJobRequest() {}

  explicit GetLiveTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetLiveTranscodeJobRequest() = default;
};
class GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos : public Darabonba::Model {
public:
  shared_ptr<string> outputUrl{};
  shared_ptr<string> type{};

  GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos() {}

  explicit GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputUrl) {
      res["OutputUrl"] = boost::any(*outputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputUrl") != m.end() && !m["OutputUrl"].empty()) {
      outputUrl = make_shared<string>(boost::any_cast<string>(m["OutputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos() = default;
};
class GetLiveTranscodeJobResponseBodyJobOutputStream : public Darabonba::Model {
public:
  shared_ptr<vector<GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos>> streamInfos{};

  GetLiveTranscodeJobResponseBodyJobOutputStream() {}

  explicit GetLiveTranscodeJobResponseBodyJobOutputStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamInfos) {
      vector<boost::any> temp1;
      for(auto item1:*streamInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamInfos") != m.end() && !m["StreamInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamInfos"].type()) {
        vector<GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamInfos = make_shared<vector<GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos>>(expect1);
      }
    }
  }


  virtual ~GetLiveTranscodeJobResponseBodyJobOutputStream() = default;
};
class GetLiveTranscodeJobResponseBodyJobStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> inputUrl{};
  shared_ptr<string> type{};

  GetLiveTranscodeJobResponseBodyJobStreamInput() {}

  explicit GetLiveTranscodeJobResponseBodyJobStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputUrl) {
      res["InputUrl"] = boost::any(*inputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputUrl") != m.end() && !m["InputUrl"].empty()) {
      inputUrl = make_shared<string>(boost::any_cast<string>(m["InputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetLiveTranscodeJobResponseBodyJobStreamInput() = default;
};
class GetLiveTranscodeJobResponseBodyJob : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<GetLiveTranscodeJobResponseBodyJobOutputStream> outputStream{};
  shared_ptr<long> startMode{};
  shared_ptr<long> status{};
  shared_ptr<GetLiveTranscodeJobResponseBodyJobStreamInput> streamInput{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateType{};

  GetLiveTranscodeJobResponseBodyJob() {}

  explicit GetLiveTranscodeJobResponseBodyJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputStream) {
      res["OutputStream"] = outputStream ? boost::any(outputStream->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startMode) {
      res["StartMode"] = boost::any(*startMode);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputStream") != m.end() && !m["OutputStream"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputStream"].type()) {
        GetLiveTranscodeJobResponseBodyJobOutputStream model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputStream"]));
        outputStream = make_shared<GetLiveTranscodeJobResponseBodyJobOutputStream>(model1);
      }
    }
    if (m.find("StartMode") != m.end() && !m["StartMode"].empty()) {
      startMode = make_shared<long>(boost::any_cast<long>(m["StartMode"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        GetLiveTranscodeJobResponseBodyJobStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<GetLiveTranscodeJobResponseBodyJobStreamInput>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~GetLiveTranscodeJobResponseBodyJob() = default;
};
class GetLiveTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetLiveTranscodeJobResponseBodyJob> job{};
  shared_ptr<string> requestId{};

  GetLiveTranscodeJobResponseBody() {}

  explicit GetLiveTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      res["Job"] = job ? boost::any(job->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(map<string, boost::any>) == m["Job"].type()) {
        GetLiveTranscodeJobResponseBodyJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Job"]));
        job = make_shared<GetLiveTranscodeJobResponseBodyJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLiveTranscodeJobResponseBody() = default;
};
class GetLiveTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveTranscodeJobResponseBody> body{};

  GetLiveTranscodeJobResponse() {}

  explicit GetLiveTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveTranscodeJobResponse() = default;
};
class GetLiveTranscodeTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  GetLiveTranscodeTemplateRequest() {}

  explicit GetLiveTranscodeTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetLiveTranscodeTemplateRequest() = default;
};
class GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> samplerate{};

  GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams() {}

  explicit GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams() = default;
};
class GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> codec{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> profile{};
  shared_ptr<string> width{};

  GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams() {}

  explicit GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams() = default;
};
class GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig : public Darabonba::Model {
public:
  shared_ptr<GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams> audioParams{};
  shared_ptr<GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams> videoParams{};

  GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig() {}

  explicit GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioParams) {
      res["AudioParams"] = audioParams ? boost::any(audioParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoParams) {
      res["VideoParams"] = videoParams ? boost::any(videoParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioParams") != m.end() && !m["AudioParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioParams"].type()) {
        GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioParams"]));
        audioParams = make_shared<GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams>(model1);
      }
    }
    if (m.find("VideoParams") != m.end() && !m["VideoParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoParams"].type()) {
        GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoParams"]));
        videoParams = make_shared<GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams>(model1);
      }
    }
  }


  virtual ~GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig() = default;
};
class GetLiveTranscodeTemplateResponseBodyTemplateContent : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<string> name{};
  shared_ptr<GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  GetLiveTranscodeTemplateResponseBodyTemplateContent() {}

  explicit GetLiveTranscodeTemplateResponseBodyTemplateContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetLiveTranscodeTemplateResponseBodyTemplateContent() = default;
};
class GetLiveTranscodeTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetLiveTranscodeTemplateResponseBodyTemplateContent> templateContent{};

  GetLiveTranscodeTemplateResponseBody() {}

  explicit GetLiveTranscodeTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateContent) {
      res["TemplateContent"] = templateContent ? boost::any(templateContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateContent"].type()) {
        GetLiveTranscodeTemplateResponseBodyTemplateContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateContent"]));
        templateContent = make_shared<GetLiveTranscodeTemplateResponseBodyTemplateContent>(model1);
      }
    }
  }


  virtual ~GetLiveTranscodeTemplateResponseBody() = default;
};
class GetLiveTranscodeTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveTranscodeTemplateResponseBody> body{};

  GetLiveTranscodeTemplateResponse() {}

  explicit GetLiveTranscodeTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveTranscodeTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveTranscodeTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveTranscodeTemplateResponse() = default;
};
class GetMediaInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> outputType{};

  GetMediaInfoRequest() {}

  explicit GetMediaInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (outputType) {
      res["OutputType"] = boost::any(*outputType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OutputType") != m.end() && !m["OutputType"].empty()) {
      outputType = make_shared<string>(boost::any_cast<string>(m["OutputType"]));
    }
  }


  virtual ~GetMediaInfoRequest() = default;
};
class GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList() {}

  explicit GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList() = default;
};
class GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> createTime{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo() {}

  explicit GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo() = default;
};
class GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList() {}

  explicit GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList() = default;
};
class GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> nbFrames{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList() {}

  explicit GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (nbFrames) {
      res["Nb_frames"] = boost::any(*nbFrames);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Nb_frames") != m.end() && !m["Nb_frames"].empty()) {
      nbFrames = make_shared<string>(boost::any_cast<string>(m["Nb_frames"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList() = default;
};
class GetMediaInfoResponseBodyMediaInfoFileInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList>> subtitleStreamInfoList{};
  shared_ptr<vector<GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList>> videoStreamInfoList{};

  GetMediaInfoResponseBodyMediaInfoFileInfoList() {}

  explicit GetMediaInfoResponseBodyMediaInfoFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStreamInfoList"] = boost::any(temp1);
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo>(model1);
      }
    }
    if (m.find("SubtitleStreamInfoList") != m.end() && !m["SubtitleStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStreamInfoList"].type()) {
        vector<GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStreamInfoList = make_shared<vector<GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList>>(expect1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfoFileInfoList() = default;
};
class GetMediaInfoResponseBodyMediaInfoMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> biz{};
  shared_ptr<string> businessType{};
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteImages{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> uploadSource{};
  shared_ptr<string> userData{};

  GetMediaInfoResponseBodyMediaInfoMediaBasicInfo() {}

  explicit GetMediaInfoResponseBodyMediaInfoMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (biz) {
      res["Biz"] = boost::any(*biz);
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteImages) {
      res["SpriteImages"] = boost::any(*spriteImages);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (uploadSource) {
      res["UploadSource"] = boost::any(*uploadSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Biz") != m.end() && !m["Biz"].empty()) {
      biz = make_shared<string>(boost::any_cast<string>(m["Biz"]));
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteImages") != m.end() && !m["SpriteImages"].empty()) {
      spriteImages = make_shared<string>(boost::any_cast<string>(m["SpriteImages"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UploadSource") != m.end() && !m["UploadSource"].empty()) {
      uploadSource = make_shared<string>(boost::any_cast<string>(m["UploadSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfoMediaBasicInfo() = default;
};
class GetMediaInfoResponseBodyMediaInfo : public Darabonba::Model {
public:
  shared_ptr<vector<GetMediaInfoResponseBodyMediaInfoFileInfoList>> fileInfoList{};
  shared_ptr<GetMediaInfoResponseBodyMediaInfoMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  GetMediaInfoResponseBodyMediaInfo() {}

  explicit GetMediaInfoResponseBodyMediaInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<GetMediaInfoResponseBodyMediaInfoFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaInfoResponseBodyMediaInfoFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<GetMediaInfoResponseBodyMediaInfoFileInfoList>>(expect1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        GetMediaInfoResponseBodyMediaInfoMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<GetMediaInfoResponseBodyMediaInfoMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfo() = default;
};
class GetMediaInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaInfoResponseBodyMediaInfo> mediaInfo{};
  shared_ptr<string> requestId{};

  GetMediaInfoResponseBody() {}

  explicit GetMediaInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfo) {
      res["MediaInfo"] = mediaInfo ? boost::any(mediaInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfo") != m.end() && !m["MediaInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfo"].type()) {
        GetMediaInfoResponseBodyMediaInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfo"]));
        mediaInfo = make_shared<GetMediaInfoResponseBodyMediaInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMediaInfoResponseBody() = default;
};
class GetMediaInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaInfoResponseBody> body{};

  GetMediaInfoResponse() {}

  explicit GetMediaInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaInfoResponse() = default;
};
class GetMediaInfoJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetMediaInfoJobRequest() {}

  explicit GetMediaInfoJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetMediaInfoJobRequest() = default;
};
class GetMediaInfoJobResponseBodyMediaInfoJobInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetMediaInfoJobResponseBodyMediaInfoJobInput() {}

  explicit GetMediaInfoJobResponseBodyMediaInfoJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetMediaInfoJobResponseBodyMediaInfoJobInput() = default;
};
class GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList() {}

  explicit GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList() = default;
};
class GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo() {}

  explicit GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo() = default;
};
class GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFps{};
  shared_ptr<string> bitRate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeBase{};
  shared_ptr<string> width{};

  GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList() {}

  explicit GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFps) {
      res["Avg_fps"] = boost::any(*avgFps);
    }
    if (bitRate) {
      res["Bit_rate"] = boost::any(*bitRate);
    }
    if (codecLongName) {
      res["Codec_long_name"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["Codec_name"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["Codec_tag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["Codec_tag_string"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["Codec_time_base"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["Has_b_frames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["Start_time"] = boost::any(*startTime);
    }
    if (timeBase) {
      res["Time_base"] = boost::any(*timeBase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avg_fps") != m.end() && !m["Avg_fps"].empty()) {
      avgFps = make_shared<string>(boost::any_cast<string>(m["Avg_fps"]));
    }
    if (m.find("Bit_rate") != m.end() && !m["Bit_rate"].empty()) {
      bitRate = make_shared<string>(boost::any_cast<string>(m["Bit_rate"]));
    }
    if (m.find("Codec_long_name") != m.end() && !m["Codec_long_name"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["Codec_long_name"]));
    }
    if (m.find("Codec_name") != m.end() && !m["Codec_name"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["Codec_name"]));
    }
    if (m.find("Codec_tag") != m.end() && !m["Codec_tag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["Codec_tag"]));
    }
    if (m.find("Codec_tag_string") != m.end() && !m["Codec_tag_string"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["Codec_tag_string"]));
    }
    if (m.find("Codec_time_base") != m.end() && !m["Codec_time_base"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["Codec_time_base"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Has_b_frames") != m.end() && !m["Has_b_frames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["Has_b_frames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Start_time") != m.end() && !m["Start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["Start_time"]));
    }
    if (m.find("Time_base") != m.end() && !m["Time_base"].empty()) {
      timeBase = make_shared<string>(boost::any_cast<string>(m["Time_base"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList() = default;
};
class GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty : public Darabonba::Model {
public:
  shared_ptr<vector<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList>> videoStreamInfoList{};

  GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty() {}

  explicit GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo>(model1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty() = default;
};
class GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig() {}

  explicit GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig() = default;
};
class GetMediaInfoJobResponseBodyMediaInfoJob : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> finishTime{};
  shared_ptr<GetMediaInfoJobResponseBodyMediaInfoJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty> mediaInfoProperty{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> submitResultJson{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  GetMediaInfoJobResponseBodyMediaInfoJob() {}

  explicit GetMediaInfoJobResponseBodyMediaInfoJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaInfoProperty) {
      res["MediaInfoProperty"] = mediaInfoProperty ? boost::any(mediaInfoProperty->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitResultJson) {
      res["SubmitResultJson"] = boost::any(*submitResultJson);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        GetMediaInfoJobResponseBodyMediaInfoJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<GetMediaInfoJobResponseBodyMediaInfoJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaInfoProperty") != m.end() && !m["MediaInfoProperty"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoProperty"].type()) {
        GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoProperty"]));
        mediaInfoProperty = make_shared<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitResultJson") != m.end() && !m["SubmitResultJson"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SubmitResultJson"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      submitResultJson = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetMediaInfoJobResponseBodyMediaInfoJob() = default;
};
class GetMediaInfoJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaInfoJobResponseBodyMediaInfoJob> mediaInfoJob{};
  shared_ptr<string> requestId{};

  GetMediaInfoJobResponseBody() {}

  explicit GetMediaInfoJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfoJob) {
      res["MediaInfoJob"] = mediaInfoJob ? boost::any(mediaInfoJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfoJob") != m.end() && !m["MediaInfoJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoJob"].type()) {
        GetMediaInfoJobResponseBodyMediaInfoJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoJob"]));
        mediaInfoJob = make_shared<GetMediaInfoJobResponseBodyMediaInfoJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMediaInfoJobResponseBody() = default;
};
class GetMediaInfoJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaInfoJobResponseBody> body{};

  GetMediaInfoJobResponse() {}

  explicit GetMediaInfoJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaInfoJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaInfoJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaInfoJobResponse() = default;
};
class GetMediaProducingJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetMediaProducingJobRequest() {}

  explicit GetMediaProducingJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetMediaProducingJobRequest() = default;
};
class GetMediaProducingJobResponseBodyMediaProducingJob : public Darabonba::Model {
public:
  shared_ptr<string> clipsParam{};
  shared_ptr<string> code{};
  shared_ptr<string> completeTime{};
  shared_ptr<string> createTime{};
  shared_ptr<double> duration{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaURL{};
  shared_ptr<string> message{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> projectId{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> timeline{};
  shared_ptr<string> vodMediaId{};

  GetMediaProducingJobResponseBodyMediaProducingJob() {}

  explicit GetMediaProducingJobResponseBodyMediaProducingJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaURL) {
      res["MediaURL"] = boost::any(*mediaURL);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (vodMediaId) {
      res["VodMediaId"] = boost::any(*vodMediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaURL") != m.end() && !m["MediaURL"].empty()) {
      mediaURL = make_shared<string>(boost::any_cast<string>(m["MediaURL"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("VodMediaId") != m.end() && !m["VodMediaId"].empty()) {
      vodMediaId = make_shared<string>(boost::any_cast<string>(m["VodMediaId"]));
    }
  }


  virtual ~GetMediaProducingJobResponseBodyMediaProducingJob() = default;
};
class GetMediaProducingJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaProducingJobResponseBodyMediaProducingJob> mediaProducingJob{};
  shared_ptr<string> requestId{};

  GetMediaProducingJobResponseBody() {}

  explicit GetMediaProducingJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaProducingJob) {
      res["MediaProducingJob"] = mediaProducingJob ? boost::any(mediaProducingJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaProducingJob") != m.end() && !m["MediaProducingJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaProducingJob"].type()) {
        GetMediaProducingJobResponseBodyMediaProducingJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaProducingJob"]));
        mediaProducingJob = make_shared<GetMediaProducingJobResponseBodyMediaProducingJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMediaProducingJobResponseBody() = default;
};
class GetMediaProducingJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaProducingJobResponseBody> body{};

  GetMediaProducingJobResponse() {}

  explicit GetMediaProducingJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaProducingJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaProducingJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaProducingJobResponse() = default;
};
class GetPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};

  GetPipelineRequest() {}

  explicit GetPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~GetPipelineRequest() = default;
};
class GetPipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};
  shared_ptr<string> speed{};
  shared_ptr<string> status{};

  GetPipelineResponseBodyPipeline() {}

  explicit GetPipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetPipelineResponseBodyPipeline() = default;
};
class GetPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPipelineResponseBodyPipeline> pipeline{};
  shared_ptr<string> requestId{};

  GetPipelineResponseBody() {}

  explicit GetPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        GetPipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<GetPipelineResponseBodyPipeline>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPipelineResponseBody() = default;
};
class GetPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPipelineResponseBody> body{};

  GetPipelineResponse() {}

  explicit GetPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~GetPipelineResponse() = default;
};
class GetPlayInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};

  GetPlayInfoRequest() {}

  explicit GetPlayInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~GetPlayInfoRequest() = default;
};
class GetPlayInfoResponseBodyMediaBase : public Darabonba::Model {
public:
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};

  GetPlayInfoResponseBodyMediaBase() {}

  explicit GetPlayInfoResponseBodyMediaBase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetPlayInfoResponseBodyMediaBase() = default;
};
class GetPlayInfoResponseBodyPlayInfoList : public Darabonba::Model {
public:
  shared_ptr<long> bitDepth{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> definition{};
  shared_ptr<string> duration{};
  shared_ptr<long> encrypt{};
  shared_ptr<string> encryptType{};
  shared_ptr<string> fileURL{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> HDRType{};
  shared_ptr<long> height{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> narrowBandType{};
  shared_ptr<string> playURL{};
  shared_ptr<long> size{};
  shared_ptr<string> status{};
  shared_ptr<string> streamType{};
  shared_ptr<string> transTemplateType{};
  shared_ptr<string> watermarkId{};
  shared_ptr<long> width{};

  GetPlayInfoResponseBodyPlayInfoList() {}

  explicit GetPlayInfoResponseBodyPlayInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitDepth) {
      res["BitDepth"] = boost::any(*bitDepth);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (encrypt) {
      res["Encrypt"] = boost::any(*encrypt);
    }
    if (encryptType) {
      res["EncryptType"] = boost::any(*encryptType);
    }
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (HDRType) {
      res["HDRType"] = boost::any(*HDRType);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (narrowBandType) {
      res["NarrowBandType"] = boost::any(*narrowBandType);
    }
    if (playURL) {
      res["PlayURL"] = boost::any(*playURL);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    if (transTemplateType) {
      res["TransTemplateType"] = boost::any(*transTemplateType);
    }
    if (watermarkId) {
      res["WatermarkId"] = boost::any(*watermarkId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BitDepth") != m.end() && !m["BitDepth"].empty()) {
      bitDepth = make_shared<long>(boost::any_cast<long>(m["BitDepth"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Encrypt") != m.end() && !m["Encrypt"].empty()) {
      encrypt = make_shared<long>(boost::any_cast<long>(m["Encrypt"]));
    }
    if (m.find("EncryptType") != m.end() && !m["EncryptType"].empty()) {
      encryptType = make_shared<string>(boost::any_cast<string>(m["EncryptType"]));
    }
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HDRType") != m.end() && !m["HDRType"].empty()) {
      HDRType = make_shared<string>(boost::any_cast<string>(m["HDRType"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("NarrowBandType") != m.end() && !m["NarrowBandType"].empty()) {
      narrowBandType = make_shared<string>(boost::any_cast<string>(m["NarrowBandType"]));
    }
    if (m.find("PlayURL") != m.end() && !m["PlayURL"].empty()) {
      playURL = make_shared<string>(boost::any_cast<string>(m["PlayURL"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
    if (m.find("TransTemplateType") != m.end() && !m["TransTemplateType"].empty()) {
      transTemplateType = make_shared<string>(boost::any_cast<string>(m["TransTemplateType"]));
    }
    if (m.find("WatermarkId") != m.end() && !m["WatermarkId"].empty()) {
      watermarkId = make_shared<string>(boost::any_cast<string>(m["WatermarkId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~GetPlayInfoResponseBodyPlayInfoList() = default;
};
class GetPlayInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPlayInfoResponseBodyMediaBase> mediaBase{};
  shared_ptr<vector<GetPlayInfoResponseBodyPlayInfoList>> playInfoList{};
  shared_ptr<string> requestId{};

  GetPlayInfoResponseBody() {}

  explicit GetPlayInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaBase) {
      res["MediaBase"] = mediaBase ? boost::any(mediaBase->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (playInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*playInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PlayInfoList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaBase") != m.end() && !m["MediaBase"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBase"].type()) {
        GetPlayInfoResponseBodyMediaBase model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBase"]));
        mediaBase = make_shared<GetPlayInfoResponseBodyMediaBase>(model1);
      }
    }
    if (m.find("PlayInfoList") != m.end() && !m["PlayInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["PlayInfoList"].type()) {
        vector<GetPlayInfoResponseBodyPlayInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PlayInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPlayInfoResponseBodyPlayInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        playInfoList = make_shared<vector<GetPlayInfoResponseBodyPlayInfoList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPlayInfoResponseBody() = default;
};
class GetPlayInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPlayInfoResponseBody> body{};

  GetPlayInfoResponse() {}

  explicit GetPlayInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPlayInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPlayInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetPlayInfoResponse() = default;
};
class GetPublicMediaInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};

  GetPublicMediaInfoRequest() {}

  explicit GetPublicMediaInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~GetPublicMediaInfoRequest() = default;
};
class GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> type{};

  GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData() {}

  explicit GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData() = default;
};
class GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList() {}

  explicit GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList() = default;
};
class GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo() {}

  explicit GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo() = default;
};
class GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList() {}

  explicit GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList() = default;
};
class GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> nbFrames{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList() {}

  explicit GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (nbFrames) {
      res["Nb_frames"] = boost::any(*nbFrames);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Nb_frames") != m.end() && !m["Nb_frames"].empty()) {
      nbFrames = make_shared<string>(boost::any_cast<string>(m["Nb_frames"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList() = default;
};
class GetPublicMediaInfoResponseBodyMediaInfoFileInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList>> subtitleStreamInfoList{};
  shared_ptr<vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList>> videoStreamInfoList{};

  GetPublicMediaInfoResponseBodyMediaInfoFileInfoList() {}

  explicit GetPublicMediaInfoResponseBodyMediaInfoFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStreamInfoList"] = boost::any(temp1);
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo>(model1);
      }
    }
    if (m.find("SubtitleStreamInfoList") != m.end() && !m["SubtitleStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStreamInfoList"].type()) {
        vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStreamInfoList = make_shared<vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList>>(expect1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~GetPublicMediaInfoResponseBodyMediaInfoFileInfoList() = default;
};
class GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteImages{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo() {}

  explicit GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteImages) {
      res["SpriteImages"] = boost::any(*spriteImages);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteImages") != m.end() && !m["SpriteImages"].empty()) {
      spriteImages = make_shared<string>(boost::any_cast<string>(m["SpriteImages"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo() = default;
};
class GetPublicMediaInfoResponseBodyMediaInfo : public Darabonba::Model {
public:
  shared_ptr<GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData> dynamicMetaData{};
  shared_ptr<vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoList>> fileInfoList{};
  shared_ptr<GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  GetPublicMediaInfoResponseBodyMediaInfo() {}

  explicit GetPublicMediaInfoResponseBodyMediaInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicMetaData) {
      res["DynamicMetaData"] = dynamicMetaData ? boost::any(dynamicMetaData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicMetaData") != m.end() && !m["DynamicMetaData"].empty()) {
      if (typeid(map<string, boost::any>) == m["DynamicMetaData"].type()) {
        GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DynamicMetaData"]));
        dynamicMetaData = make_shared<GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData>(model1);
      }
    }
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPublicMediaInfoResponseBodyMediaInfoFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoList>>(expect1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~GetPublicMediaInfoResponseBodyMediaInfo() = default;
};
class GetPublicMediaInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPublicMediaInfoResponseBodyMediaInfo> mediaInfo{};
  shared_ptr<string> requestId{};

  GetPublicMediaInfoResponseBody() {}

  explicit GetPublicMediaInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfo) {
      res["MediaInfo"] = mediaInfo ? boost::any(mediaInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfo") != m.end() && !m["MediaInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfo"].type()) {
        GetPublicMediaInfoResponseBodyMediaInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfo"]));
        mediaInfo = make_shared<GetPublicMediaInfoResponseBodyMediaInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPublicMediaInfoResponseBody() = default;
};
class GetPublicMediaInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPublicMediaInfoResponseBody> body{};

  GetPublicMediaInfoResponse() {}

  explicit GetPublicMediaInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPublicMediaInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPublicMediaInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetPublicMediaInfoResponse() = default;
};
class GetSmartHandleJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetSmartHandleJobRequest() {}

  explicit GetSmartHandleJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetSmartHandleJobRequest() = default;
};
class GetSmartHandleJobResponseBodySmartJobInfoInputConfig : public Darabonba::Model {
public:
  shared_ptr<string> inputFile{};

  GetSmartHandleJobResponseBodySmartJobInfoInputConfig() {}

  explicit GetSmartHandleJobResponseBodySmartJobInfoInputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputFile) {
      res["InputFile"] = boost::any(*inputFile);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      inputFile = make_shared<string>(boost::any_cast<string>(m["InputFile"]));
    }
  }


  virtual ~GetSmartHandleJobResponseBodySmartJobInfoInputConfig() = default;
};
class GetSmartHandleJobResponseBodySmartJobInfoOutputConfig : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> object{};

  GetSmartHandleJobResponseBodySmartJobInfoOutputConfig() {}

  explicit GetSmartHandleJobResponseBodySmartJobInfoOutputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~GetSmartHandleJobResponseBodySmartJobInfoOutputConfig() = default;
};
class GetSmartHandleJobResponseBodySmartJobInfo : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<GetSmartHandleJobResponseBodySmartJobInfoInputConfig> inputConfig{};
  shared_ptr<string> jobType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<GetSmartHandleJobResponseBodySmartJobInfoOutputConfig> outputConfig{};
  shared_ptr<string> title{};
  shared_ptr<string> userId{};

  GetSmartHandleJobResponseBodySmartJobInfo() {}

  explicit GetSmartHandleJobResponseBodySmartJobInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputConfig) {
      res["InputConfig"] = inputConfig ? boost::any(inputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (outputConfig) {
      res["OutputConfig"] = outputConfig ? boost::any(outputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputConfig"].type()) {
        GetSmartHandleJobResponseBodySmartJobInfoInputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputConfig"]));
        inputConfig = make_shared<GetSmartHandleJobResponseBodySmartJobInfoInputConfig>(model1);
      }
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputConfig"].type()) {
        GetSmartHandleJobResponseBodySmartJobInfoOutputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputConfig"]));
        outputConfig = make_shared<GetSmartHandleJobResponseBodySmartJobInfoOutputConfig>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetSmartHandleJobResponseBodySmartJobInfo() = default;
};
class GetSmartHandleJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> output{};
  shared_ptr<string> requestId{};
  shared_ptr<GetSmartHandleJobResponseBodySmartJobInfo> smartJobInfo{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};

  GetSmartHandleJobResponseBody() {}

  explicit GetSmartHandleJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (smartJobInfo) {
      res["SmartJobInfo"] = smartJobInfo ? boost::any(smartJobInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SmartJobInfo") != m.end() && !m["SmartJobInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmartJobInfo"].type()) {
        GetSmartHandleJobResponseBodySmartJobInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmartJobInfo"]));
        smartJobInfo = make_shared<GetSmartHandleJobResponseBodySmartJobInfo>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetSmartHandleJobResponseBody() = default;
};
class GetSmartHandleJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSmartHandleJobResponseBody> body{};

  GetSmartHandleJobResponse() {}

  explicit GetSmartHandleJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSmartHandleJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSmartHandleJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetSmartHandleJobResponse() = default;
};
class GetSnapshotJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetSnapshotJobRequest() {}

  explicit GetSnapshotJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetSnapshotJobRequest() = default;
};
class GetSnapshotJobResponseBodySnapshotJobInputOssFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  GetSnapshotJobResponseBodySnapshotJobInputOssFile() {}

  explicit GetSnapshotJobResponseBodySnapshotJobInputOssFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~GetSnapshotJobResponseBodySnapshotJobInputOssFile() = default;
};
class GetSnapshotJobResponseBodySnapshotJobInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<GetSnapshotJobResponseBodySnapshotJobInputOssFile> ossFile{};
  shared_ptr<string> type{};

  GetSnapshotJobResponseBodySnapshotJobInput() {}

  explicit GetSnapshotJobResponseBodySnapshotJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (ossFile) {
      res["OssFile"] = ossFile ? boost::any(ossFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("OssFile") != m.end() && !m["OssFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssFile"].type()) {
        GetSnapshotJobResponseBodySnapshotJobInputOssFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssFile"]));
        ossFile = make_shared<GetSnapshotJobResponseBodySnapshotJobInputOssFile>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetSnapshotJobResponseBodySnapshotJobInput() = default;
};
class GetSnapshotJobResponseBodySnapshotJobOutputOssFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  GetSnapshotJobResponseBodySnapshotJobOutputOssFile() {}

  explicit GetSnapshotJobResponseBodySnapshotJobOutputOssFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~GetSnapshotJobResponseBodySnapshotJobOutputOssFile() = default;
};
class GetSnapshotJobResponseBodySnapshotJobOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<GetSnapshotJobResponseBodySnapshotJobOutputOssFile> ossFile{};
  shared_ptr<string> type{};

  GetSnapshotJobResponseBodySnapshotJobOutput() {}

  explicit GetSnapshotJobResponseBodySnapshotJobOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (ossFile) {
      res["OssFile"] = ossFile ? boost::any(ossFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("OssFile") != m.end() && !m["OssFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssFile"].type()) {
        GetSnapshotJobResponseBodySnapshotJobOutputOssFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssFile"]));
        ossFile = make_shared<GetSnapshotJobResponseBodySnapshotJobOutputOssFile>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetSnapshotJobResponseBodySnapshotJobOutput() = default;
};
class GetSnapshotJobResponseBodySnapshotJob : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> code{};
  shared_ptr<long> count{};
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<GetSnapshotJobResponseBodySnapshotJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<GetSnapshotJobResponseBodySnapshotJobOutput> output{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> type{};
  shared_ptr<string> userData{};

  GetSnapshotJobResponseBodySnapshotJob() {}

  explicit GetSnapshotJobResponseBodySnapshotJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        GetSnapshotJobResponseBodySnapshotJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<GetSnapshotJobResponseBodySnapshotJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        GetSnapshotJobResponseBodySnapshotJobOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<GetSnapshotJobResponseBodySnapshotJobOutput>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetSnapshotJobResponseBodySnapshotJob() = default;
};
class GetSnapshotJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetSnapshotJobResponseBodySnapshotJob> snapshotJob{};

  GetSnapshotJobResponseBody() {}

  explicit GetSnapshotJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotJob) {
      res["SnapshotJob"] = snapshotJob ? boost::any(snapshotJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotJob") != m.end() && !m["SnapshotJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotJob"].type()) {
        GetSnapshotJobResponseBodySnapshotJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotJob"]));
        snapshotJob = make_shared<GetSnapshotJobResponseBodySnapshotJob>(model1);
      }
    }
  }


  virtual ~GetSnapshotJobResponseBody() = default;
};
class GetSnapshotJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSnapshotJobResponseBody> body{};

  GetSnapshotJobResponse() {}

  explicit GetSnapshotJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSnapshotJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSnapshotJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetSnapshotJobResponse() = default;
};
class GetSnapshotUrlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> timeout{};

  GetSnapshotUrlsRequest() {}

  explicit GetSnapshotUrlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~GetSnapshotUrlsRequest() = default;
};
class GetSnapshotUrlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> snapshotUrls{};
  shared_ptr<long> total{};
  shared_ptr<string> webVTTUrl{};

  GetSnapshotUrlsResponseBody() {}

  explicit GetSnapshotUrlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotUrls) {
      res["SnapshotUrls"] = boost::any(*snapshotUrls);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (webVTTUrl) {
      res["WebVTTUrl"] = boost::any(*webVTTUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotUrls") != m.end() && !m["SnapshotUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SnapshotUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SnapshotUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snapshotUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("WebVTTUrl") != m.end() && !m["WebVTTUrl"].empty()) {
      webVTTUrl = make_shared<string>(boost::any_cast<string>(m["WebVTTUrl"]));
    }
  }


  virtual ~GetSnapshotUrlsResponseBody() = default;
};
class GetSnapshotUrlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSnapshotUrlsResponseBody> body{};

  GetSnapshotUrlsResponse() {}

  explicit GetSnapshotUrlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSnapshotUrlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSnapshotUrlsResponseBody>(model1);
      }
    }
  }


  virtual ~GetSnapshotUrlsResponse() = default;
};
class GetSystemTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  GetSystemTemplateRequest() {}

  explicit GetSystemTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetSystemTemplateRequest() = default;
};
class GetSystemTemplateResponseBodySystemTemplate : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> subtype{};
  shared_ptr<string> subtypeName{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> type{};
  shared_ptr<string> typeName_{};

  GetSystemTemplateResponseBodySystemTemplate() {}

  explicit GetSystemTemplateResponseBodySystemTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (subtypeName) {
      res["SubtypeName"] = boost::any(*subtypeName);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<long>(boost::any_cast<long>(m["Subtype"]));
    }
    if (m.find("SubtypeName") != m.end() && !m["SubtypeName"].empty()) {
      subtypeName = make_shared<string>(boost::any_cast<string>(m["SubtypeName"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~GetSystemTemplateResponseBodySystemTemplate() = default;
};
class GetSystemTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetSystemTemplateResponseBodySystemTemplate> systemTemplate{};

  GetSystemTemplateResponseBody() {}

  explicit GetSystemTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (systemTemplate) {
      res["SystemTemplate"] = systemTemplate ? boost::any(systemTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SystemTemplate") != m.end() && !m["SystemTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemTemplate"].type()) {
        GetSystemTemplateResponseBodySystemTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemTemplate"]));
        systemTemplate = make_shared<GetSystemTemplateResponseBodySystemTemplate>(model1);
      }
    }
  }


  virtual ~GetSystemTemplateResponseBody() = default;
};
class GetSystemTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSystemTemplateResponseBody> body{};

  GetSystemTemplateResponse() {}

  explicit GetSystemTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSystemTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSystemTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetSystemTemplateResponse() = default;
};
class GetTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> relatedMediaidFlag{};
  shared_ptr<string> templateId{};

  GetTemplateRequest() {}

  explicit GetTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (relatedMediaidFlag) {
      res["RelatedMediaidFlag"] = boost::any(*relatedMediaidFlag);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RelatedMediaidFlag") != m.end() && !m["RelatedMediaidFlag"].empty()) {
      relatedMediaidFlag = make_shared<string>(boost::any_cast<string>(m["RelatedMediaidFlag"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTemplateRequest() = default;
};
class GetTemplateResponseBodyTemplate : public Darabonba::Model {
public:
  shared_ptr<string> clipsParam{};
  shared_ptr<string> config{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createSource{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> modifiedSource{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<string> previewMedia{};
  shared_ptr<string> previewMediaStatus{};
  shared_ptr<string> relatedMediaids{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  GetTemplateResponseBodyTemplate() {}

  explicit GetTemplateResponseBodyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (modifiedSource) {
      res["ModifiedSource"] = boost::any(*modifiedSource);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (previewMedia) {
      res["PreviewMedia"] = boost::any(*previewMedia);
    }
    if (previewMediaStatus) {
      res["PreviewMediaStatus"] = boost::any(*previewMediaStatus);
    }
    if (relatedMediaids) {
      res["RelatedMediaids"] = boost::any(*relatedMediaids);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ModifiedSource") != m.end() && !m["ModifiedSource"].empty()) {
      modifiedSource = make_shared<string>(boost::any_cast<string>(m["ModifiedSource"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PreviewMedia") != m.end() && !m["PreviewMedia"].empty()) {
      previewMedia = make_shared<string>(boost::any_cast<string>(m["PreviewMedia"]));
    }
    if (m.find("PreviewMediaStatus") != m.end() && !m["PreviewMediaStatus"].empty()) {
      previewMediaStatus = make_shared<string>(boost::any_cast<string>(m["PreviewMediaStatus"]));
    }
    if (m.find("RelatedMediaids") != m.end() && !m["RelatedMediaids"].empty()) {
      relatedMediaids = make_shared<string>(boost::any_cast<string>(m["RelatedMediaids"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTemplateResponseBodyTemplate() = default;
};
class GetTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetTemplateResponseBodyTemplate> template_{};

  GetTemplateResponseBody() {}

  explicit GetTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (template_) {
      res["Template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(map<string, boost::any>) == m["Template"].type()) {
        GetTemplateResponseBodyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Template"]));
        template_ = make_shared<GetTemplateResponseBodyTemplate>(model1);
      }
    }
  }


  virtual ~GetTemplateResponseBody() = default;
};
class GetTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTemplateResponseBody> body{};

  GetTemplateResponse() {}

  explicit GetTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetTemplateResponse() = default;
};
class GetTemplateMaterialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileList{};
  shared_ptr<string> templateId{};

  GetTemplateMaterialsRequest() {}

  explicit GetTemplateMaterialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileList) {
      res["FileList"] = boost::any(*fileList);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileList") != m.end() && !m["FileList"].empty()) {
      fileList = make_shared<string>(boost::any_cast<string>(m["FileList"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTemplateMaterialsRequest() = default;
};
class GetTemplateMaterialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> materialUrls{};
  shared_ptr<string> requestId{};

  GetTemplateMaterialsResponseBody() {}

  explicit GetTemplateMaterialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (materialUrls) {
      res["MaterialUrls"] = boost::any(*materialUrls);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaterialUrls") != m.end() && !m["MaterialUrls"].empty()) {
      materialUrls = make_shared<string>(boost::any_cast<string>(m["MaterialUrls"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetTemplateMaterialsResponseBody() = default;
};
class GetTemplateMaterialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTemplateMaterialsResponseBody> body{};

  GetTemplateMaterialsResponse() {}

  explicit GetTemplateMaterialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTemplateMaterialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTemplateMaterialsResponseBody>(model1);
      }
    }
  }


  virtual ~GetTemplateMaterialsResponse() = default;
};
class GetTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetTranscodeJobRequest() {}

  explicit GetTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetTranscodeJobRequest() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobInputGroup : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetTranscodeJobResponseBodyTranscodeParentJobInputGroup() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobInputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobInputGroup() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile> file{};
  shared_ptr<string> height{};
  shared_ptr<string> referPos{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline> timeline{};
  shared_ptr<string> width{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile> file{};
  shared_ptr<string> format{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> adaptive{};
  shared_ptr<string> borderColor{};
  shared_ptr<long> borderWidth{};
  shared_ptr<string> content{};
  shared_ptr<string> fontAlpha{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<long> fontSize{};
  shared_ptr<string> left{};
  shared_ptr<string> top{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adaptive) {
      res["Adaptive"] = boost::any(*adaptive);
    }
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidth) {
      res["BorderWidth"] = boost::any(*borderWidth);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fontAlpha) {
      res["FontAlpha"] = boost::any(*fontAlpha);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSize) {
      res["FontSize"] = boost::any(*fontSize);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adaptive") != m.end() && !m["Adaptive"].empty()) {
      adaptive = make_shared<string>(boost::any_cast<string>(m["Adaptive"]));
    }
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidth") != m.end() && !m["BorderWidth"].empty()) {
      borderWidth = make_shared<long>(boost::any_cast<long>(m["BorderWidth"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FontAlpha") != m.end() && !m["FontAlpha"].empty()) {
      fontAlpha = make_shared<string>(boost::any_cast<string>(m["FontAlpha"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSize") != m.end() && !m["FontSize"].empty()) {
      fontSize = make_shared<long>(boost::any_cast<long>(m["FontSize"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> integratedLoudnessTarget{};
  shared_ptr<string> loudnessRangeTarget{};
  shared_ptr<string> method{};
  shared_ptr<string> truePeak{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedLoudnessTarget) {
      res["IntegratedLoudnessTarget"] = boost::any(*integratedLoudnessTarget);
    }
    if (loudnessRangeTarget) {
      res["LoudnessRangeTarget"] = boost::any(*loudnessRangeTarget);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (truePeak) {
      res["TruePeak"] = boost::any(*truePeak);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedLoudnessTarget") != m.end() && !m["IntegratedLoudnessTarget"].empty()) {
      integratedLoudnessTarget = make_shared<string>(boost::any_cast<string>(m["IntegratedLoudnessTarget"]));
    }
    if (m.find("LoudnessRangeTarget") != m.end() && !m["LoudnessRangeTarget"].empty()) {
      loudnessRangeTarget = make_shared<string>(boost::any_cast<string>(m["LoudnessRangeTarget"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("TruePeak") != m.end() && !m["TruePeak"].empty()) {
      truePeak = make_shared<string>(boost::any_cast<string>(m["TruePeak"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume> volume{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> forceSegTime{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (forceSegTime) {
      res["ForceSegTime"] = boost::any(*forceSegTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ForceSegTime") != m.end() && !m["ForceSegTime"].empty()) {
      forceSegTime = make_shared<string>(boost::any_cast<string>(m["ForceSegTime"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment> segment{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo : public Darabonba::Model {
public:
  shared_ptr<string> abrMax{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abrMax) {
      res["AbrMax"] = boost::any(*abrMax);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbrMax") != m.end() && !m["AbrMax"].empty()) {
      abrMax = make_shared<string>(boost::any_cast<string>(m["AbrMax"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio> audio{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer> container{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig> muxConfig{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo> video{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig : public Darabonba::Model {
public:
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks>> imageWatermarks{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles>> subtitles{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks>> textWatermarks{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode> transcode{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*imageWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageWatermarks"] = boost::any(temp1);
    }
    if (subtitles) {
      vector<boost::any> temp1;
      for(auto item1:*subtitles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitles"] = boost::any(temp1);
    }
    if (textWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*textWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextWatermarks"] = boost::any(temp1);
    }
    if (transcode) {
      res["Transcode"] = transcode ? boost::any(transcode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageWatermarks") != m.end() && !m["ImageWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageWatermarks"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageWatermarks = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks>>(expect1);
      }
    }
    if (m.find("Subtitles") != m.end() && !m["Subtitles"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitles"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitles = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles>>(expect1);
      }
    }
    if (m.find("TextWatermarks") != m.end() && !m["TextWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["TextWatermarks"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textWatermarks = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks>>(expect1);
      }
    }
    if (m.find("Transcode") != m.end() && !m["Transcode"].empty()) {
      if (typeid(map<string, boost::any>) == m["Transcode"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Transcode"]));
        transcode = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput> output{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig> processConfig{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (processConfig) {
      res["ProcessConfig"] = processConfig ? boost::any(processConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput>(model1);
      }
    }
    if (m.find("ProcessConfig") != m.end() && !m["ProcessConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProcessConfig"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProcessConfig"]));
        processConfig = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFps{};
  shared_ptr<string> bitRate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeBase{};
  shared_ptr<string> width{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFps) {
      res["Avg_fps"] = boost::any(*avgFps);
    }
    if (bitRate) {
      res["Bit_rate"] = boost::any(*bitRate);
    }
    if (codecLongName) {
      res["Codec_long_name"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["Codec_name"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["Codec_tag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["Codec_tag_string"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["Codec_time_base"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["Has_b_frames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["Start_time"] = boost::any(*startTime);
    }
    if (timeBase) {
      res["Time_base"] = boost::any(*timeBase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avg_fps") != m.end() && !m["Avg_fps"].empty()) {
      avgFps = make_shared<string>(boost::any_cast<string>(m["Avg_fps"]));
    }
    if (m.find("Bit_rate") != m.end() && !m["Bit_rate"].empty()) {
      bitRate = make_shared<string>(boost::any_cast<string>(m["Bit_rate"]));
    }
    if (m.find("Codec_long_name") != m.end() && !m["Codec_long_name"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["Codec_long_name"]));
    }
    if (m.find("Codec_name") != m.end() && !m["Codec_name"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["Codec_name"]));
    }
    if (m.find("Codec_tag") != m.end() && !m["Codec_tag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["Codec_tag"]));
    }
    if (m.find("Codec_tag_string") != m.end() && !m["Codec_tag_string"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["Codec_tag_string"]));
    }
    if (m.find("Codec_time_base") != m.end() && !m["Codec_time_base"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["Codec_time_base"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Has_b_frames") != m.end() && !m["Has_b_frames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["Has_b_frames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Start_time") != m.end() && !m["Start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["Start_time"]));
    }
    if (m.find("Time_base") != m.end() && !m["Time_base"].empty()) {
      timeBase = make_shared<string>(boost::any_cast<string>(m["Time_base"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta : public Darabonba::Model {
public:
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList>> videoStreamInfoList{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo>(model1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile> file{};
  shared_ptr<string> height{};
  shared_ptr<string> referPos{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline> timeline{};
  shared_ptr<string> width{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile> file{};
  shared_ptr<string> format{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> adaptive{};
  shared_ptr<string> borderColor{};
  shared_ptr<long> borderWidth{};
  shared_ptr<string> content{};
  shared_ptr<string> fontAlpha{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<long> fontSize{};
  shared_ptr<string> left{};
  shared_ptr<string> top{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adaptive) {
      res["Adaptive"] = boost::any(*adaptive);
    }
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidth) {
      res["BorderWidth"] = boost::any(*borderWidth);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fontAlpha) {
      res["FontAlpha"] = boost::any(*fontAlpha);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSize) {
      res["FontSize"] = boost::any(*fontSize);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adaptive") != m.end() && !m["Adaptive"].empty()) {
      adaptive = make_shared<string>(boost::any_cast<string>(m["Adaptive"]));
    }
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidth") != m.end() && !m["BorderWidth"].empty()) {
      borderWidth = make_shared<long>(boost::any_cast<long>(m["BorderWidth"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FontAlpha") != m.end() && !m["FontAlpha"].empty()) {
      fontAlpha = make_shared<string>(boost::any_cast<string>(m["FontAlpha"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSize") != m.end() && !m["FontSize"].empty()) {
      fontSize = make_shared<long>(boost::any_cast<long>(m["FontSize"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> integratedLoudnessTarget{};
  shared_ptr<string> loudnessRangeTarget{};
  shared_ptr<string> method{};
  shared_ptr<string> truePeak{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedLoudnessTarget) {
      res["IntegratedLoudnessTarget"] = boost::any(*integratedLoudnessTarget);
    }
    if (loudnessRangeTarget) {
      res["LoudnessRangeTarget"] = boost::any(*loudnessRangeTarget);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (truePeak) {
      res["TruePeak"] = boost::any(*truePeak);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedLoudnessTarget") != m.end() && !m["IntegratedLoudnessTarget"].empty()) {
      integratedLoudnessTarget = make_shared<string>(boost::any_cast<string>(m["IntegratedLoudnessTarget"]));
    }
    if (m.find("LoudnessRangeTarget") != m.end() && !m["LoudnessRangeTarget"].empty()) {
      loudnessRangeTarget = make_shared<string>(boost::any_cast<string>(m["LoudnessRangeTarget"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("TruePeak") != m.end() && !m["TruePeak"].empty()) {
      truePeak = make_shared<string>(boost::any_cast<string>(m["TruePeak"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume> volume{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> forceSegTime{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (forceSegTime) {
      res["ForceSegTime"] = boost::any(*forceSegTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ForceSegTime") != m.end() && !m["ForceSegTime"].empty()) {
      forceSegTime = make_shared<string>(boost::any_cast<string>(m["ForceSegTime"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment> segment{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo : public Darabonba::Model {
public:
  shared_ptr<string> abrMax{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abrMax) {
      res["AbrMax"] = boost::any(*abrMax);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbrMax") != m.end() && !m["AbrMax"].empty()) {
      abrMax = make_shared<string>(boost::any_cast<string>(m["AbrMax"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio> audio{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer> container{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig> muxConfig{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo> video{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig : public Darabonba::Model {
public:
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks>> imageWatermarks{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles>> subtitles{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks>> textWatermarks{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode> transcode{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*imageWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageWatermarks"] = boost::any(temp1);
    }
    if (subtitles) {
      vector<boost::any> temp1;
      for(auto item1:*subtitles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitles"] = boost::any(temp1);
    }
    if (textWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*textWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextWatermarks"] = boost::any(temp1);
    }
    if (transcode) {
      res["Transcode"] = transcode ? boost::any(transcode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageWatermarks") != m.end() && !m["ImageWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageWatermarks"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageWatermarks = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks>>(expect1);
      }
    }
    if (m.find("Subtitles") != m.end() && !m["Subtitles"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitles"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitles = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles>>(expect1);
      }
    }
    if (m.find("TextWatermarks") != m.end() && !m["TextWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["TextWatermarks"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textWatermarks = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks>>(expect1);
      }
    }
    if (m.find("Transcode") != m.end() && !m["Transcode"].empty()) {
      if (typeid(map<string, boost::any>) == m["Transcode"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Transcode"]));
        transcode = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup>> inputGroup{};
  shared_ptr<string> jobId{};
  shared_ptr<long> jobIndex{};
  shared_ptr<string> name{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta> outFileMeta{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput> output{};
  shared_ptr<string> parentJobId{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig> processConfig{};
  shared_ptr<string> requestId{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> submitResultJson{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> userData{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (inputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*inputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputGroup"] = boost::any(temp1);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobIndex) {
      res["JobIndex"] = boost::any(*jobIndex);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outFileMeta) {
      res["OutFileMeta"] = outFileMeta ? boost::any(outFileMeta->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentJobId) {
      res["ParentJobId"] = boost::any(*parentJobId);
    }
    if (processConfig) {
      res["ProcessConfig"] = processConfig ? boost::any(processConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitResultJson) {
      res["SubmitResultJson"] = boost::any(*submitResultJson);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("InputGroup") != m.end() && !m["InputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["InputGroup"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputGroup = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup>>(expect1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobIndex") != m.end() && !m["JobIndex"].empty()) {
      jobIndex = make_shared<long>(boost::any_cast<long>(m["JobIndex"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutFileMeta") != m.end() && !m["OutFileMeta"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutFileMeta"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutFileMeta"]));
        outFileMeta = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta>(model1);
      }
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput>(model1);
      }
    }
    if (m.find("ParentJobId") != m.end() && !m["ParentJobId"].empty()) {
      parentJobId = make_shared<string>(boost::any_cast<string>(m["ParentJobId"]));
    }
    if (m.find("ProcessConfig") != m.end() && !m["ProcessConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProcessConfig"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProcessConfig"]));
        processConfig = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitResultJson") != m.end() && !m["SubmitResultJson"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SubmitResultJson"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      submitResultJson = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJob : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobInputGroup>> inputGroup{};
  shared_ptr<long> jobCount{};
  shared_ptr<string> name{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup>> outputGroup{};
  shared_ptr<string> parentJobId{};
  shared_ptr<long> percent{};
  shared_ptr<string> requestId{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList>> transcodeJobList{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  GetTranscodeJobResponseBodyTranscodeParentJob() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (inputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*inputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputGroup"] = boost::any(temp1);
    }
    if (jobCount) {
      res["JobCount"] = boost::any(*jobCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroup"] = boost::any(temp1);
    }
    if (parentJobId) {
      res["ParentJobId"] = boost::any(*parentJobId);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (transcodeJobList) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeJobList"] = boost::any(temp1);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("InputGroup") != m.end() && !m["InputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["InputGroup"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobInputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobInputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputGroup = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobInputGroup>>(expect1);
      }
    }
    if (m.find("JobCount") != m.end() && !m["JobCount"].empty()) {
      jobCount = make_shared<long>(boost::any_cast<long>(m["JobCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputGroup") != m.end() && !m["OutputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroup"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroup = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup>>(expect1);
      }
    }
    if (m.find("ParentJobId") != m.end() && !m["ParentJobId"].empty()) {
      parentJobId = make_shared<string>(boost::any_cast<string>(m["ParentJobId"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TranscodeJobList") != m.end() && !m["TranscodeJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeJobList"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeJobList = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList>>(expect1);
      }
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJob() = default;
};
class GetTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJob> transcodeParentJob{};

  GetTranscodeJobResponseBody() {}

  explicit GetTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transcodeParentJob) {
      res["TranscodeParentJob"] = transcodeParentJob ? boost::any(transcodeParentJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TranscodeParentJob") != m.end() && !m["TranscodeParentJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeParentJob"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeParentJob"]));
        transcodeParentJob = make_shared<GetTranscodeJobResponseBodyTranscodeParentJob>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBody() = default;
};
class GetTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTranscodeJobResponseBody> body{};

  GetTranscodeJobResponse() {}

  explicit GetTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponse() = default;
};
class GetUrlUploadInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobIds{};
  shared_ptr<string> uploadURLs{};

  GetUrlUploadInfosRequest() {}

  explicit GetUrlUploadInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (uploadURLs) {
      res["UploadURLs"] = boost::any(*uploadURLs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("UploadURLs") != m.end() && !m["UploadURLs"].empty()) {
      uploadURLs = make_shared<string>(boost::any_cast<string>(m["UploadURLs"]));
    }
  }


  virtual ~GetUrlUploadInfosRequest() = default;
};
class GetUrlUploadInfosResponseBodyURLUploadInfoList : public Darabonba::Model {
public:
  shared_ptr<string> completeTime{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> status{};
  shared_ptr<string> uploadURL{};
  shared_ptr<string> userData{};

  GetUrlUploadInfosResponseBodyURLUploadInfoList() {}

  explicit GetUrlUploadInfosResponseBodyURLUploadInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uploadURL) {
      res["UploadURL"] = boost::any(*uploadURL);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UploadURL") != m.end() && !m["UploadURL"].empty()) {
      uploadURL = make_shared<string>(boost::any_cast<string>(m["UploadURL"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetUrlUploadInfosResponseBodyURLUploadInfoList() = default;
};
class GetUrlUploadInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> nonExists{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetUrlUploadInfosResponseBodyURLUploadInfoList>> URLUploadInfoList{};

  GetUrlUploadInfosResponseBody() {}

  explicit GetUrlUploadInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExists) {
      res["NonExists"] = boost::any(*nonExists);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (URLUploadInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*URLUploadInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["URLUploadInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExists") != m.end() && !m["NonExists"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExists"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExists"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExists = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("URLUploadInfoList") != m.end() && !m["URLUploadInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["URLUploadInfoList"].type()) {
        vector<GetUrlUploadInfosResponseBodyURLUploadInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["URLUploadInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUrlUploadInfosResponseBodyURLUploadInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        URLUploadInfoList = make_shared<vector<GetUrlUploadInfosResponseBodyURLUploadInfoList>>(expect1);
      }
    }
  }


  virtual ~GetUrlUploadInfosResponseBody() = default;
};
class GetUrlUploadInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUrlUploadInfosResponseBody> body{};

  GetUrlUploadInfosResponse() {}

  explicit GetUrlUploadInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUrlUploadInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUrlUploadInfosResponseBody>(model1);
      }
    }
  }


  virtual ~GetUrlUploadInfosResponse() = default;
};
class ListAllPublicMediaTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> entityId{};

  ListAllPublicMediaTagsRequest() {}

  explicit ListAllPublicMediaTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
  }


  virtual ~ListAllPublicMediaTagsRequest() = default;
};
class ListAllPublicMediaTagsResponseBodyMediaTagListOptions : public Darabonba::Model {
public:
  shared_ptr<string> optionChineseName{};
  shared_ptr<string> optionEnglishName{};
  shared_ptr<string> optionId{};

  ListAllPublicMediaTagsResponseBodyMediaTagListOptions() {}

  explicit ListAllPublicMediaTagsResponseBodyMediaTagListOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (optionChineseName) {
      res["OptionChineseName"] = boost::any(*optionChineseName);
    }
    if (optionEnglishName) {
      res["OptionEnglishName"] = boost::any(*optionEnglishName);
    }
    if (optionId) {
      res["OptionId"] = boost::any(*optionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OptionChineseName") != m.end() && !m["OptionChineseName"].empty()) {
      optionChineseName = make_shared<string>(boost::any_cast<string>(m["OptionChineseName"]));
    }
    if (m.find("OptionEnglishName") != m.end() && !m["OptionEnglishName"].empty()) {
      optionEnglishName = make_shared<string>(boost::any_cast<string>(m["OptionEnglishName"]));
    }
    if (m.find("OptionId") != m.end() && !m["OptionId"].empty()) {
      optionId = make_shared<string>(boost::any_cast<string>(m["OptionId"]));
    }
  }


  virtual ~ListAllPublicMediaTagsResponseBodyMediaTagListOptions() = default;
};
class ListAllPublicMediaTagsResponseBodyMediaTagList : public Darabonba::Model {
public:
  shared_ptr<string> mediaTagId{};
  shared_ptr<string> mediaTagNameChinese{};
  shared_ptr<string> mediaTagNameEnglish{};
  shared_ptr<vector<ListAllPublicMediaTagsResponseBodyMediaTagListOptions>> options{};

  ListAllPublicMediaTagsResponseBodyMediaTagList() {}

  explicit ListAllPublicMediaTagsResponseBodyMediaTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaTagId) {
      res["MediaTagId"] = boost::any(*mediaTagId);
    }
    if (mediaTagNameChinese) {
      res["MediaTagNameChinese"] = boost::any(*mediaTagNameChinese);
    }
    if (mediaTagNameEnglish) {
      res["MediaTagNameEnglish"] = boost::any(*mediaTagNameEnglish);
    }
    if (options) {
      vector<boost::any> temp1;
      for(auto item1:*options){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Options"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaTagId") != m.end() && !m["MediaTagId"].empty()) {
      mediaTagId = make_shared<string>(boost::any_cast<string>(m["MediaTagId"]));
    }
    if (m.find("MediaTagNameChinese") != m.end() && !m["MediaTagNameChinese"].empty()) {
      mediaTagNameChinese = make_shared<string>(boost::any_cast<string>(m["MediaTagNameChinese"]));
    }
    if (m.find("MediaTagNameEnglish") != m.end() && !m["MediaTagNameEnglish"].empty()) {
      mediaTagNameEnglish = make_shared<string>(boost::any_cast<string>(m["MediaTagNameEnglish"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      if (typeid(vector<boost::any>) == m["Options"].type()) {
        vector<ListAllPublicMediaTagsResponseBodyMediaTagListOptions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Options"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllPublicMediaTagsResponseBodyMediaTagListOptions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        options = make_shared<vector<ListAllPublicMediaTagsResponseBodyMediaTagListOptions>>(expect1);
      }
    }
  }


  virtual ~ListAllPublicMediaTagsResponseBodyMediaTagList() = default;
};
class ListAllPublicMediaTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAllPublicMediaTagsResponseBodyMediaTagList>> mediaTagList{};
  shared_ptr<string> requestId{};

  ListAllPublicMediaTagsResponseBody() {}

  explicit ListAllPublicMediaTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaTagList) {
      vector<boost::any> temp1;
      for(auto item1:*mediaTagList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaTagList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaTagList") != m.end() && !m["MediaTagList"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaTagList"].type()) {
        vector<ListAllPublicMediaTagsResponseBodyMediaTagList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaTagList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllPublicMediaTagsResponseBodyMediaTagList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaTagList = make_shared<vector<ListAllPublicMediaTagsResponseBodyMediaTagList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAllPublicMediaTagsResponseBody() = default;
};
class ListAllPublicMediaTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAllPublicMediaTagsResponseBody> body{};

  ListAllPublicMediaTagsResponse() {}

  explicit ListAllPublicMediaTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAllPublicMediaTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAllPublicMediaTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAllPublicMediaTagsResponse() = default;
};
class ListCustomTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> subtype{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  ListCustomTemplatesRequest() {}

  explicit ListCustomTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<string>(boost::any_cast<string>(m["Subtype"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListCustomTemplatesRequest() = default;
};
class ListCustomTemplatesResponseBodyCustomTemplateList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> status{};
  shared_ptr<long> subtype{};
  shared_ptr<string> subtypeName{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> type{};
  shared_ptr<string> typeName_{};

  ListCustomTemplatesResponseBodyCustomTemplateList() {}

  explicit ListCustomTemplatesResponseBodyCustomTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (subtypeName) {
      res["SubtypeName"] = boost::any(*subtypeName);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<long>(boost::any_cast<long>(m["Subtype"]));
    }
    if (m.find("SubtypeName") != m.end() && !m["SubtypeName"].empty()) {
      subtypeName = make_shared<string>(boost::any_cast<string>(m["SubtypeName"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~ListCustomTemplatesResponseBodyCustomTemplateList() = default;
};
class ListCustomTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomTemplatesResponseBodyCustomTemplateList>> customTemplateList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListCustomTemplatesResponseBody() {}

  explicit ListCustomTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTemplateList) {
      vector<boost::any> temp1;
      for(auto item1:*customTemplateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomTemplateList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTemplateList") != m.end() && !m["CustomTemplateList"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomTemplateList"].type()) {
        vector<ListCustomTemplatesResponseBodyCustomTemplateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomTemplateList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomTemplatesResponseBodyCustomTemplateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customTemplateList = make_shared<vector<ListCustomTemplatesResponseBodyCustomTemplateList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListCustomTemplatesResponseBody() = default;
};
class ListCustomTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomTemplatesResponseBody> body{};

  ListCustomTemplatesResponse() {}

  explicit ListCustomTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomTemplatesResponse() = default;
};
class ListDynamicImageJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfCreateTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startOfCreateTime{};
  shared_ptr<string> status{};

  ListDynamicImageJobsRequest() {}

  explicit ListDynamicImageJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfCreateTime) {
      res["EndOfCreateTime"] = boost::any(*endOfCreateTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startOfCreateTime) {
      res["StartOfCreateTime"] = boost::any(*startOfCreateTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfCreateTime") != m.end() && !m["EndOfCreateTime"].empty()) {
      endOfCreateTime = make_shared<string>(boost::any_cast<string>(m["EndOfCreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartOfCreateTime") != m.end() && !m["StartOfCreateTime"].empty()) {
      startOfCreateTime = make_shared<string>(boost::any_cast<string>(m["StartOfCreateTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListDynamicImageJobsRequest() = default;
};
class ListDynamicImageJobsResponseBodyJobsInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListDynamicImageJobsResponseBodyJobsInput() {}

  explicit ListDynamicImageJobsResponseBodyJobsInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDynamicImageJobsResponseBodyJobsInput() = default;
};
class ListDynamicImageJobsResponseBodyJobsOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListDynamicImageJobsResponseBodyJobsOutput() {}

  explicit ListDynamicImageJobsResponseBodyJobsOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDynamicImageJobsResponseBodyJobsOutput() = default;
};
class ListDynamicImageJobsResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<ListDynamicImageJobsResponseBodyJobsInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<ListDynamicImageJobsResponseBodyJobsOutput> output{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> templateId{};
  shared_ptr<string> triggerSource{};

  ListDynamicImageJobsResponseBodyJobs() {}

  explicit ListDynamicImageJobsResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListDynamicImageJobsResponseBodyJobsInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListDynamicImageJobsResponseBodyJobsInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        ListDynamicImageJobsResponseBodyJobsOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<ListDynamicImageJobsResponseBodyJobsOutput>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
  }


  virtual ~ListDynamicImageJobsResponseBodyJobs() = default;
};
class ListDynamicImageJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDynamicImageJobsResponseBodyJobs>> jobs{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListDynamicImageJobsResponseBody() {}

  explicit ListDynamicImageJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Jobs"] = boost::any(temp1);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["Jobs"].type()) {
        vector<ListDynamicImageJobsResponseBodyJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDynamicImageJobsResponseBodyJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<ListDynamicImageJobsResponseBodyJobs>>(expect1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDynamicImageJobsResponseBody() = default;
};
class ListDynamicImageJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDynamicImageJobsResponseBody> body{};

  ListDynamicImageJobsResponse() {}

  explicit ListDynamicImageJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDynamicImageJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDynamicImageJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDynamicImageJobsResponse() = default;
};
class ListLiveRecordFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<vector<string>> jobIds{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> recordFormat{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};

  ListLiveRecordFilesRequest() {}

  explicit ListLiveRecordFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (recordFormat) {
      res["RecordFormat"] = boost::any(*recordFormat);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      recordFormat = make_shared<string>(boost::any_cast<string>(m["RecordFormat"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ListLiveRecordFilesRequest() = default;
};
class ListLiveRecordFilesResponseBodyFiles : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<double> duration{};
  shared_ptr<string> endTime{};
  shared_ptr<string> format{};
  shared_ptr<long> height{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> recordId{};
  shared_ptr<string> recordOutput{};
  shared_ptr<string> recordUrl{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamUrl{};
  shared_ptr<long> width{};

  ListLiveRecordFilesResponseBodyFiles() {}

  explicit ListLiveRecordFilesResponseBodyFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordOutput) {
      res["RecordOutput"] = boost::any(*recordOutput);
    }
    if (recordUrl) {
      res["RecordUrl"] = boost::any(*recordUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RecordOutput") != m.end() && !m["RecordOutput"].empty()) {
      recordOutput = make_shared<string>(boost::any_cast<string>(m["RecordOutput"]));
    }
    if (m.find("RecordUrl") != m.end() && !m["RecordUrl"].empty()) {
      recordUrl = make_shared<string>(boost::any_cast<string>(m["RecordUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~ListLiveRecordFilesResponseBodyFiles() = default;
};
class ListLiveRecordFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveRecordFilesResponseBodyFiles>> files{};
  shared_ptr<long> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> totalCount{};

  ListLiveRecordFilesResponseBody() {}

  explicit ListLiveRecordFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<ListLiveRecordFilesResponseBodyFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveRecordFilesResponseBodyFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<ListLiveRecordFilesResponseBodyFiles>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListLiveRecordFilesResponseBody() = default;
};
class ListLiveRecordFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveRecordFilesResponseBody> body{};

  ListLiveRecordFilesResponse() {}

  explicit ListLiveRecordFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveRecordFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveRecordFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveRecordFilesResponse() = default;
};
class ListLiveRecordJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  ListLiveRecordJobsRequest() {}

  explicit ListLiveRecordJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListLiveRecordJobsRequest() = default;
};
class ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> type{};

  ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput() {}

  explicit ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput() = default;
};
class ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput() {}

  explicit ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput() = default;
};
class ListLiveRecordJobsResponseBodyLiveRecordJobs : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput> recordOutput{};
  shared_ptr<string> status{};
  shared_ptr<ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput> streamInput{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  ListLiveRecordJobsResponseBodyLiveRecordJobs() {}

  explicit ListLiveRecordJobsResponseBodyLiveRecordJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (recordOutput) {
      res["RecordOutput"] = recordOutput ? boost::any(recordOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("RecordOutput") != m.end() && !m["RecordOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordOutput"].type()) {
        ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordOutput"]));
        recordOutput = make_shared<ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~ListLiveRecordJobsResponseBodyLiveRecordJobs() = default;
};
class ListLiveRecordJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveRecordJobsResponseBodyLiveRecordJobs>> liveRecordJobs{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> totalCount{};

  ListLiveRecordJobsResponseBody() {}

  explicit ListLiveRecordJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveRecordJobs) {
      vector<boost::any> temp1;
      for(auto item1:*liveRecordJobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveRecordJobs"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveRecordJobs") != m.end() && !m["LiveRecordJobs"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveRecordJobs"].type()) {
        vector<ListLiveRecordJobsResponseBodyLiveRecordJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveRecordJobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveRecordJobsResponseBodyLiveRecordJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveRecordJobs = make_shared<vector<ListLiveRecordJobsResponseBodyLiveRecordJobs>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLiveRecordJobsResponseBody() = default;
};
class ListLiveRecordJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveRecordJobsResponseBody> body{};

  ListLiveRecordJobsResponse() {}

  explicit ListLiveRecordJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveRecordJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveRecordJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveRecordJobsResponse() = default;
};
class ListLiveRecordTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<vector<string>> templateIds{};
  shared_ptr<string> type{};

  ListLiveRecordTemplatesRequest() {}

  explicit ListLiveRecordTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (templateIds) {
      res["TemplateIds"] = boost::any(*templateIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TemplateIds") != m.end() && !m["TemplateIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TemplateIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TemplateIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      templateIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveRecordTemplatesRequest() = default;
};
class ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<long> sliceDuration{};
  shared_ptr<string> sliceOssObjectPrefix{};

  ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList() {}

  explicit ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList() = default;
};
class ListLiveRecordTemplatesResponseBodyRecordTemplateList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList>> recordFormatList{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  ListLiveRecordTemplatesResponseBodyRecordTemplateList() {}

  explicit ListLiveRecordTemplatesResponseBodyRecordTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordFormatList) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormatList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormatList"] = boost::any(temp1);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordFormatList") != m.end() && !m["RecordFormatList"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormatList"].type()) {
        vector<ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormatList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormatList = make_shared<vector<ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList>>(expect1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveRecordTemplatesResponseBodyRecordTemplateList() = default;
};
class ListLiveRecordTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListLiveRecordTemplatesResponseBodyRecordTemplateList>> recordTemplateList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> totalCount{};

  ListLiveRecordTemplatesResponseBody() {}

  explicit ListLiveRecordTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (recordTemplateList) {
      vector<boost::any> temp1;
      for(auto item1:*recordTemplateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordTemplateList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RecordTemplateList") != m.end() && !m["RecordTemplateList"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordTemplateList"].type()) {
        vector<ListLiveRecordTemplatesResponseBodyRecordTemplateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordTemplateList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveRecordTemplatesResponseBodyRecordTemplateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordTemplateList = make_shared<vector<ListLiveRecordTemplatesResponseBodyRecordTemplateList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLiveRecordTemplatesResponseBody() = default;
};
class ListLiveRecordTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveRecordTemplatesResponseBody> body{};

  ListLiveRecordTemplatesResponse() {}

  explicit ListLiveRecordTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveRecordTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveRecordTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveRecordTemplatesResponse() = default;
};
class ListLiveSnapshotFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> jobId{};
  shared_ptr<long> limit{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};

  ListLiveSnapshotFilesRequest() {}

  explicit ListLiveSnapshotFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ListLiveSnapshotFilesRequest() = default;
};
class ListLiveSnapshotFilesResponseBodyFileList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<bool> isOverlay{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};

  ListLiveSnapshotFilesResponseBodyFileList() {}

  explicit ListLiveSnapshotFilesResponseBodyFileList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (isOverlay) {
      res["IsOverlay"] = boost::any(*isOverlay);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("IsOverlay") != m.end() && !m["IsOverlay"].empty()) {
      isOverlay = make_shared<bool>(boost::any_cast<bool>(m["IsOverlay"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
  }


  virtual ~ListLiveSnapshotFilesResponseBodyFileList() = default;
};
class ListLiveSnapshotFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveSnapshotFilesResponseBodyFileList>> fileList{};
  shared_ptr<string> nextStartTime{};
  shared_ptr<string> requestId{};

  ListLiveSnapshotFilesResponseBody() {}

  explicit ListLiveSnapshotFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileList) {
      vector<boost::any> temp1;
      for(auto item1:*fileList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileList"] = boost::any(temp1);
    }
    if (nextStartTime) {
      res["NextStartTime"] = boost::any(*nextStartTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileList") != m.end() && !m["FileList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileList"].type()) {
        vector<ListLiveSnapshotFilesResponseBodyFileList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveSnapshotFilesResponseBodyFileList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileList = make_shared<vector<ListLiveSnapshotFilesResponseBodyFileList>>(expect1);
      }
    }
    if (m.find("NextStartTime") != m.end() && !m["NextStartTime"].empty()) {
      nextStartTime = make_shared<string>(boost::any_cast<string>(m["NextStartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListLiveSnapshotFilesResponseBody() = default;
};
class ListLiveSnapshotFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveSnapshotFilesResponseBody> body{};

  ListLiveSnapshotFilesResponse() {}

  explicit ListLiveSnapshotFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveSnapshotFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveSnapshotFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveSnapshotFilesResponse() = default;
};
class ListLiveSnapshotJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKeyWord{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  ListLiveSnapshotJobsRequest() {}

  explicit ListLiveSnapshotJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKeyWord) {
      res["SearchKeyWord"] = boost::any(*searchKeyWord);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKeyWord") != m.end() && !m["SearchKeyWord"].empty()) {
      searchKeyWord = make_shared<string>(boost::any_cast<string>(m["SearchKeyWord"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListLiveSnapshotJobsRequest() = default;
};
class ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> storageType{};

  ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput() {}

  explicit ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput() = default;
};
class ListLiveSnapshotJobsResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput> snapshotOutput{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> timeInterval{};

  ListLiveSnapshotJobsResponseBodyJobList() {}

  explicit ListLiveSnapshotJobsResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (snapshotOutput) {
      res["SnapshotOutput"] = snapshotOutput ? boost::any(snapshotOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("SnapshotOutput") != m.end() && !m["SnapshotOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotOutput"].type()) {
        ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotOutput"]));
        snapshotOutput = make_shared<ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
  }


  virtual ~ListLiveSnapshotJobsResponseBodyJobList() = default;
};
class ListLiveSnapshotJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveSnapshotJobsResponseBodyJobList>> jobList{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> totalCount{};

  ListLiveSnapshotJobsResponseBody() {}

  explicit ListLiveSnapshotJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobList) {
      vector<boost::any> temp1;
      for(auto item1:*jobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobList"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(vector<boost::any>) == m["JobList"].type()) {
        vector<ListLiveSnapshotJobsResponseBodyJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveSnapshotJobsResponseBodyJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobList = make_shared<vector<ListLiveSnapshotJobsResponseBodyJobList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLiveSnapshotJobsResponseBody() = default;
};
class ListLiveSnapshotJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveSnapshotJobsResponseBody> body{};

  ListLiveSnapshotJobsResponse() {}

  explicit ListLiveSnapshotJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveSnapshotJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveSnapshotJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveSnapshotJobsResponse() = default;
};
class ListLiveSnapshotTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKeyWord{};
  shared_ptr<string> sortBy{};
  shared_ptr<vector<string>> templateIds{};
  shared_ptr<string> type{};

  ListLiveSnapshotTemplatesRequest() {}

  explicit ListLiveSnapshotTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKeyWord) {
      res["SearchKeyWord"] = boost::any(*searchKeyWord);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (templateIds) {
      res["TemplateIds"] = boost::any(*templateIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKeyWord") != m.end() && !m["SearchKeyWord"].empty()) {
      searchKeyWord = make_shared<string>(boost::any_cast<string>(m["SearchKeyWord"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TemplateIds") != m.end() && !m["TemplateIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TemplateIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TemplateIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      templateIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveSnapshotTemplatesRequest() = default;
};
class ListLiveSnapshotTemplatesResponseBodyTemplateList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> timeInterval{};
  shared_ptr<string> type{};

  ListLiveSnapshotTemplatesResponseBodyTemplateList() {}

  explicit ListLiveSnapshotTemplatesResponseBodyTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveSnapshotTemplatesResponseBodyTemplateList() = default;
};
class ListLiveSnapshotTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<vector<ListLiveSnapshotTemplatesResponseBodyTemplateList>> templateList{};
  shared_ptr<long> totalCount{};

  ListLiveSnapshotTemplatesResponseBody() {}

  explicit ListLiveSnapshotTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (templateList) {
      vector<boost::any> temp1;
      for(auto item1:*templateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateList"].type()) {
        vector<ListLiveSnapshotTemplatesResponseBodyTemplateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveSnapshotTemplatesResponseBodyTemplateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateList = make_shared<vector<ListLiveSnapshotTemplatesResponseBodyTemplateList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLiveSnapshotTemplatesResponseBody() = default;
};
class ListLiveSnapshotTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveSnapshotTemplatesResponseBody> body{};

  ListLiveSnapshotTemplatesResponse() {}

  explicit ListLiveSnapshotTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveSnapshotTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveSnapshotTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveSnapshotTemplatesResponse() = default;
};
class ListLiveTranscodeJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyWord{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> startMode{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  ListLiveTranscodeJobsRequest() {}

  explicit ListLiveTranscodeJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyWord) {
      res["KeyWord"] = boost::any(*keyWord);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startMode) {
      res["StartMode"] = boost::any(*startMode);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyWord") != m.end() && !m["KeyWord"].empty()) {
      keyWord = make_shared<string>(boost::any_cast<string>(m["KeyWord"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartMode") != m.end() && !m["StartMode"].empty()) {
      startMode = make_shared<long>(boost::any_cast<long>(m["StartMode"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveTranscodeJobsRequest() = default;
};
class ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos : public Darabonba::Model {
public:
  shared_ptr<string> outputUrl{};
  shared_ptr<string> type{};

  ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos() {}

  explicit ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputUrl) {
      res["OutputUrl"] = boost::any(*outputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputUrl") != m.end() && !m["OutputUrl"].empty()) {
      outputUrl = make_shared<string>(boost::any_cast<string>(m["OutputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos() = default;
};
class ListLiveTranscodeJobsResponseBodyJobListOutputStream : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos>> streamInfos{};

  ListLiveTranscodeJobsResponseBodyJobListOutputStream() {}

  explicit ListLiveTranscodeJobsResponseBodyJobListOutputStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamInfos) {
      vector<boost::any> temp1;
      for(auto item1:*streamInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamInfos") != m.end() && !m["StreamInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamInfos"].type()) {
        vector<ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamInfos = make_shared<vector<ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos>>(expect1);
      }
    }
  }


  virtual ~ListLiveTranscodeJobsResponseBodyJobListOutputStream() = default;
};
class ListLiveTranscodeJobsResponseBodyJobListStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> inputUrl{};
  shared_ptr<string> type{};

  ListLiveTranscodeJobsResponseBodyJobListStreamInput() {}

  explicit ListLiveTranscodeJobsResponseBodyJobListStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputUrl) {
      res["InputUrl"] = boost::any(*inputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputUrl") != m.end() && !m["InputUrl"].empty()) {
      inputUrl = make_shared<string>(boost::any_cast<string>(m["InputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveTranscodeJobsResponseBodyJobListStreamInput() = default;
};
class ListLiveTranscodeJobsResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<ListLiveTranscodeJobsResponseBodyJobListOutputStream> outputStream{};
  shared_ptr<long> startMode{};
  shared_ptr<long> status{};
  shared_ptr<ListLiveTranscodeJobsResponseBodyJobListStreamInput> streamInput{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateType{};

  ListLiveTranscodeJobsResponseBodyJobList() {}

  explicit ListLiveTranscodeJobsResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputStream) {
      res["OutputStream"] = outputStream ? boost::any(outputStream->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startMode) {
      res["StartMode"] = boost::any(*startMode);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputStream") != m.end() && !m["OutputStream"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputStream"].type()) {
        ListLiveTranscodeJobsResponseBodyJobListOutputStream model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputStream"]));
        outputStream = make_shared<ListLiveTranscodeJobsResponseBodyJobListOutputStream>(model1);
      }
    }
    if (m.find("StartMode") != m.end() && !m["StartMode"].empty()) {
      startMode = make_shared<long>(boost::any_cast<long>(m["StartMode"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        ListLiveTranscodeJobsResponseBodyJobListStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<ListLiveTranscodeJobsResponseBodyJobListStreamInput>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~ListLiveTranscodeJobsResponseBodyJobList() = default;
};
class ListLiveTranscodeJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveTranscodeJobsResponseBodyJobList>> jobList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListLiveTranscodeJobsResponseBody() {}

  explicit ListLiveTranscodeJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobList) {
      vector<boost::any> temp1;
      for(auto item1:*jobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(vector<boost::any>) == m["JobList"].type()) {
        vector<ListLiveTranscodeJobsResponseBodyJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveTranscodeJobsResponseBodyJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobList = make_shared<vector<ListLiveTranscodeJobsResponseBodyJobList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLiveTranscodeJobsResponseBody() = default;
};
class ListLiveTranscodeJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveTranscodeJobsResponseBody> body{};

  ListLiveTranscodeJobsResponse() {}

  explicit ListLiveTranscodeJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveTranscodeJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveTranscodeJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveTranscodeJobsResponse() = default;
};
class ListLiveTranscodeTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> keyWord{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> type{};
  shared_ptr<string> videoCodec{};

  ListLiveTranscodeTemplatesRequest() {}

  explicit ListLiveTranscodeTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (keyWord) {
      res["KeyWord"] = boost::any(*keyWord);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (videoCodec) {
      res["VideoCodec"] = boost::any(*videoCodec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("KeyWord") != m.end() && !m["KeyWord"].empty()) {
      keyWord = make_shared<string>(boost::any_cast<string>(m["KeyWord"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VideoCodec") != m.end() && !m["VideoCodec"].empty()) {
      videoCodec = make_shared<string>(boost::any_cast<string>(m["VideoCodec"]));
    }
  }


  virtual ~ListLiveTranscodeTemplatesRequest() = default;
};
class ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> samplerate{};

  ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams() {}

  explicit ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams() = default;
};
class ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> codec{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> profile{};
  shared_ptr<string> width{};

  ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams() {}

  explicit ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams() = default;
};
class ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig : public Darabonba::Model {
public:
  shared_ptr<ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams> audioParams{};
  shared_ptr<ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams> videoParams{};

  ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig() {}

  explicit ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioParams) {
      res["AudioParams"] = audioParams ? boost::any(audioParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoParams) {
      res["VideoParams"] = videoParams ? boost::any(videoParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioParams") != m.end() && !m["AudioParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioParams"].type()) {
        ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioParams"]));
        audioParams = make_shared<ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams>(model1);
      }
    }
    if (m.find("VideoParams") != m.end() && !m["VideoParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoParams"].type()) {
        ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoParams"]));
        videoParams = make_shared<ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams>(model1);
      }
    }
  }


  virtual ~ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig() = default;
};
class ListLiveTranscodeTemplatesResponseBodyTemplateContentList : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<string> name{};
  shared_ptr<ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  ListLiveTranscodeTemplatesResponseBodyTemplateContentList() {}

  explicit ListLiveTranscodeTemplatesResponseBodyTemplateContentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveTranscodeTemplatesResponseBodyTemplateContentList() = default;
};
class ListLiveTranscodeTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListLiveTranscodeTemplatesResponseBodyTemplateContentList>> templateContentList{};
  shared_ptr<long> totalCount{};

  ListLiveTranscodeTemplatesResponseBody() {}

  explicit ListLiveTranscodeTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateContentList) {
      vector<boost::any> temp1;
      for(auto item1:*templateContentList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateContentList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateContentList") != m.end() && !m["TemplateContentList"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateContentList"].type()) {
        vector<ListLiveTranscodeTemplatesResponseBodyTemplateContentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateContentList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveTranscodeTemplatesResponseBodyTemplateContentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateContentList = make_shared<vector<ListLiveTranscodeTemplatesResponseBodyTemplateContentList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLiveTranscodeTemplatesResponseBody() = default;
};
class ListLiveTranscodeTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveTranscodeTemplatesResponseBody> body{};

  ListLiveTranscodeTemplatesResponse() {}

  explicit ListLiveTranscodeTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveTranscodeTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveTranscodeTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveTranscodeTemplatesResponse() = default;
};
class ListMediaBasicInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> endTime{};
  shared_ptr<bool> includeFileBasicInfo{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> source{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  ListMediaBasicInfosRequest() {}

  explicit ListMediaBasicInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (includeFileBasicInfo) {
      res["IncludeFileBasicInfo"] = boost::any(*includeFileBasicInfo);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IncludeFileBasicInfo") != m.end() && !m["IncludeFileBasicInfo"].empty()) {
      includeFileBasicInfo = make_shared<bool>(boost::any_cast<bool>(m["IncludeFileBasicInfo"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListMediaBasicInfosRequest() = default;
};
class ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> createTime{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo() {}

  explicit ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo() = default;
};
class ListMediaBasicInfosResponseBodyMediaInfosFileInfoList : public Darabonba::Model {
public:
  shared_ptr<ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo> fileBasicInfo{};

  ListMediaBasicInfosResponseBodyMediaInfosFileInfoList() {}

  explicit ListMediaBasicInfosResponseBodyMediaInfosFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo>(model1);
      }
    }
  }


  virtual ~ListMediaBasicInfosResponseBodyMediaInfosFileInfoList() = default;
};
class ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> biz{};
  shared_ptr<string> businessType{};
  shared_ptr<long> cateId{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> snapshots{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteImages{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> transcodeStatus{};
  shared_ptr<string> uploadSource{};
  shared_ptr<string> userData{};

  ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo() {}

  explicit ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (biz) {
      res["Biz"] = boost::any(*biz);
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteImages) {
      res["SpriteImages"] = boost::any(*spriteImages);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (transcodeStatus) {
      res["TranscodeStatus"] = boost::any(*transcodeStatus);
    }
    if (uploadSource) {
      res["UploadSource"] = boost::any(*uploadSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Biz") != m.end() && !m["Biz"].empty()) {
      biz = make_shared<string>(boost::any_cast<string>(m["Biz"]));
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      snapshots = make_shared<string>(boost::any_cast<string>(m["Snapshots"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteImages") != m.end() && !m["SpriteImages"].empty()) {
      spriteImages = make_shared<string>(boost::any_cast<string>(m["SpriteImages"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TranscodeStatus") != m.end() && !m["TranscodeStatus"].empty()) {
      transcodeStatus = make_shared<string>(boost::any_cast<string>(m["TranscodeStatus"]));
    }
    if (m.find("UploadSource") != m.end() && !m["UploadSource"].empty()) {
      uploadSource = make_shared<string>(boost::any_cast<string>(m["UploadSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo() = default;
};
class ListMediaBasicInfosResponseBodyMediaInfos : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaBasicInfosResponseBodyMediaInfosFileInfoList>> fileInfoList{};
  shared_ptr<ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  ListMediaBasicInfosResponseBodyMediaInfos() {}

  explicit ListMediaBasicInfosResponseBodyMediaInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<ListMediaBasicInfosResponseBodyMediaInfosFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaBasicInfosResponseBodyMediaInfosFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<ListMediaBasicInfosResponseBodyMediaInfosFileInfoList>>(expect1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~ListMediaBasicInfosResponseBodyMediaInfos() = default;
};
class ListMediaBasicInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<vector<ListMediaBasicInfosResponseBodyMediaInfos>> mediaInfos{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListMediaBasicInfosResponseBody() {}

  explicit ListMediaBasicInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (mediaInfos) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInfos"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("MediaInfos") != m.end() && !m["MediaInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInfos"].type()) {
        vector<ListMediaBasicInfosResponseBodyMediaInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaBasicInfosResponseBodyMediaInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInfos = make_shared<vector<ListMediaBasicInfosResponseBodyMediaInfos>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMediaBasicInfosResponseBody() = default;
};
class ListMediaBasicInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMediaBasicInfosResponseBody> body{};

  ListMediaBasicInfosResponse() {}

  explicit ListMediaBasicInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMediaBasicInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMediaBasicInfosResponseBody>(model1);
      }
    }
  }


  virtual ~ListMediaBasicInfosResponse() = default;
};
class ListMediaInfoJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfCreateTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startOfCreateTime{};
  shared_ptr<string> status{};

  ListMediaInfoJobsRequest() {}

  explicit ListMediaInfoJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfCreateTime) {
      res["EndOfCreateTime"] = boost::any(*endOfCreateTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startOfCreateTime) {
      res["StartOfCreateTime"] = boost::any(*startOfCreateTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfCreateTime") != m.end() && !m["EndOfCreateTime"].empty()) {
      endOfCreateTime = make_shared<string>(boost::any_cast<string>(m["EndOfCreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartOfCreateTime") != m.end() && !m["StartOfCreateTime"].empty()) {
      startOfCreateTime = make_shared<string>(boost::any_cast<string>(m["StartOfCreateTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListMediaInfoJobsRequest() = default;
};
class ListMediaInfoJobsResponseBodyJobsInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListMediaInfoJobsResponseBodyJobsInput() {}

  explicit ListMediaInfoJobsResponseBodyJobsInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListMediaInfoJobsResponseBodyJobsInput() = default;
};
class ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList() {}

  explicit ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList() = default;
};
class ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo() {}

  explicit ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo() = default;
};
class ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFps{};
  shared_ptr<string> bitRate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeBase{};
  shared_ptr<string> width{};

  ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList() {}

  explicit ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFps) {
      res["Avg_fps"] = boost::any(*avgFps);
    }
    if (bitRate) {
      res["Bit_rate"] = boost::any(*bitRate);
    }
    if (codecLongName) {
      res["Codec_long_name"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["Codec_name"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["Codec_tag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["Codec_tag_string"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["Codec_time_base"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["Has_b_frames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["Start_time"] = boost::any(*startTime);
    }
    if (timeBase) {
      res["Time_base"] = boost::any(*timeBase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avg_fps") != m.end() && !m["Avg_fps"].empty()) {
      avgFps = make_shared<string>(boost::any_cast<string>(m["Avg_fps"]));
    }
    if (m.find("Bit_rate") != m.end() && !m["Bit_rate"].empty()) {
      bitRate = make_shared<string>(boost::any_cast<string>(m["Bit_rate"]));
    }
    if (m.find("Codec_long_name") != m.end() && !m["Codec_long_name"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["Codec_long_name"]));
    }
    if (m.find("Codec_name") != m.end() && !m["Codec_name"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["Codec_name"]));
    }
    if (m.find("Codec_tag") != m.end() && !m["Codec_tag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["Codec_tag"]));
    }
    if (m.find("Codec_tag_string") != m.end() && !m["Codec_tag_string"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["Codec_tag_string"]));
    }
    if (m.find("Codec_time_base") != m.end() && !m["Codec_time_base"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["Codec_time_base"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Has_b_frames") != m.end() && !m["Has_b_frames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["Has_b_frames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Start_time") != m.end() && !m["Start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["Start_time"]));
    }
    if (m.find("Time_base") != m.end() && !m["Time_base"].empty()) {
      timeBase = make_shared<string>(boost::any_cast<string>(m["Time_base"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList() = default;
};
class ListMediaInfoJobsResponseBodyJobsMediaInfoProperty : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList>> videoStreamInfoList{};

  ListMediaInfoJobsResponseBodyJobsMediaInfoProperty() {}

  explicit ListMediaInfoJobsResponseBodyJobsMediaInfoProperty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo>(model1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~ListMediaInfoJobsResponseBodyJobsMediaInfoProperty() = default;
};
class ListMediaInfoJobsResponseBodyJobsScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  ListMediaInfoJobsResponseBodyJobsScheduleConfig() {}

  explicit ListMediaInfoJobsResponseBodyJobsScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~ListMediaInfoJobsResponseBodyJobsScheduleConfig() = default;
};
class ListMediaInfoJobsResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> finishTime{};
  shared_ptr<ListMediaInfoJobsResponseBodyJobsInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<ListMediaInfoJobsResponseBodyJobsMediaInfoProperty> mediaInfoProperty{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<ListMediaInfoJobsResponseBodyJobsScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> submitResultJson{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  ListMediaInfoJobsResponseBodyJobs() {}

  explicit ListMediaInfoJobsResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaInfoProperty) {
      res["MediaInfoProperty"] = mediaInfoProperty ? boost::any(mediaInfoProperty->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitResultJson) {
      res["SubmitResultJson"] = boost::any(*submitResultJson);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListMediaInfoJobsResponseBodyJobsInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListMediaInfoJobsResponseBodyJobsInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaInfoProperty") != m.end() && !m["MediaInfoProperty"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoProperty"].type()) {
        ListMediaInfoJobsResponseBodyJobsMediaInfoProperty model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoProperty"]));
        mediaInfoProperty = make_shared<ListMediaInfoJobsResponseBodyJobsMediaInfoProperty>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        ListMediaInfoJobsResponseBodyJobsScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<ListMediaInfoJobsResponseBodyJobsScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitResultJson") != m.end() && !m["SubmitResultJson"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SubmitResultJson"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      submitResultJson = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ListMediaInfoJobsResponseBodyJobs() = default;
};
class ListMediaInfoJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaInfoJobsResponseBodyJobs>> jobs{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListMediaInfoJobsResponseBody() {}

  explicit ListMediaInfoJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Jobs"] = boost::any(temp1);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["Jobs"].type()) {
        vector<ListMediaInfoJobsResponseBodyJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaInfoJobsResponseBodyJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<ListMediaInfoJobsResponseBodyJobs>>(expect1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListMediaInfoJobsResponseBody() = default;
};
class ListMediaInfoJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMediaInfoJobsResponseBody> body{};

  ListMediaInfoJobsResponse() {}

  explicit ListMediaInfoJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMediaInfoJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMediaInfoJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMediaInfoJobsResponse() = default;
};
class ListPipelinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> speed{};

  ListPipelinesRequest() {}

  explicit ListPipelinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
  }


  virtual ~ListPipelinesRequest() = default;
};
class ListPipelinesResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};
  shared_ptr<string> speed{};
  shared_ptr<string> status{};

  ListPipelinesResponseBodyPipelineList() {}

  explicit ListPipelinesResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListPipelinesResponseBodyPipelineList() = default;
};
class ListPipelinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListPipelinesResponseBodyPipelineList>> pipelineList{};
  shared_ptr<string> requestId{};

  ListPipelinesResponseBody() {}

  explicit ListPipelinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineList) {
      vector<boost::any> temp1;
      for(auto item1:*pipelineList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PipelineList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(vector<boost::any>) == m["PipelineList"].type()) {
        vector<ListPipelinesResponseBodyPipelineList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PipelineList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPipelinesResponseBodyPipelineList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipelineList = make_shared<vector<ListPipelinesResponseBodyPipelineList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPipelinesResponseBody() = default;
};
class ListPipelinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPipelinesResponseBody> body{};

  ListPipelinesResponse() {}

  explicit ListPipelinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPipelinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPipelinesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPipelinesResponse() = default;
};
class ListPublicMediaBasicInfosRequest : public Darabonba::Model {
public:
  shared_ptr<bool> includeFileBasicInfo{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> mediaTagId{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};

  ListPublicMediaBasicInfosRequest() {}

  explicit ListPublicMediaBasicInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (includeFileBasicInfo) {
      res["IncludeFileBasicInfo"] = boost::any(*includeFileBasicInfo);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (mediaTagId) {
      res["MediaTagId"] = boost::any(*mediaTagId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IncludeFileBasicInfo") != m.end() && !m["IncludeFileBasicInfo"].empty()) {
      includeFileBasicInfo = make_shared<bool>(boost::any_cast<bool>(m["IncludeFileBasicInfo"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("MediaTagId") != m.end() && !m["MediaTagId"].empty()) {
      mediaTagId = make_shared<string>(boost::any_cast<string>(m["MediaTagId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListPublicMediaBasicInfosRequest() = default;
};
class ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo() {}

  explicit ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo() = default;
};
class ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList : public Darabonba::Model {
public:
  shared_ptr<ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo> fileBasicInfo{};

  ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList() {}

  explicit ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo>(model1);
      }
    }
  }


  virtual ~ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList() = default;
};
class ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> snapshots{};
  shared_ptr<string> source{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> transcodeStatus{};
  shared_ptr<string> userData{};

  ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo() {}

  explicit ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (transcodeStatus) {
      res["TranscodeStatus"] = boost::any(*transcodeStatus);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      snapshots = make_shared<string>(boost::any_cast<string>(m["Snapshots"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TranscodeStatus") != m.end() && !m["TranscodeStatus"].empty()) {
      transcodeStatus = make_shared<string>(boost::any_cast<string>(m["TranscodeStatus"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo() = default;
};
class ListPublicMediaBasicInfosResponseBodyMediaInfos : public Darabonba::Model {
public:
  shared_ptr<vector<ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList>> fileInfoList{};
  shared_ptr<ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  ListPublicMediaBasicInfosResponseBodyMediaInfos() {}

  explicit ListPublicMediaBasicInfosResponseBodyMediaInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList>>(expect1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~ListPublicMediaBasicInfosResponseBodyMediaInfos() = default;
};
class ListPublicMediaBasicInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<vector<ListPublicMediaBasicInfosResponseBodyMediaInfos>> mediaInfos{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListPublicMediaBasicInfosResponseBody() {}

  explicit ListPublicMediaBasicInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (mediaInfos) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInfos"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("MediaInfos") != m.end() && !m["MediaInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInfos"].type()) {
        vector<ListPublicMediaBasicInfosResponseBodyMediaInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPublicMediaBasicInfosResponseBodyMediaInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInfos = make_shared<vector<ListPublicMediaBasicInfosResponseBodyMediaInfos>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPublicMediaBasicInfosResponseBody() = default;
};
class ListPublicMediaBasicInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPublicMediaBasicInfosResponseBody> body{};

  ListPublicMediaBasicInfosResponse() {}

  explicit ListPublicMediaBasicInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPublicMediaBasicInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPublicMediaBasicInfosResponseBody>(model1);
      }
    }
  }


  virtual ~ListPublicMediaBasicInfosResponse() = default;
};
class ListSmartJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobState{};
  shared_ptr<string> jobType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};

  ListSmartJobsRequest() {}

  explicit ListSmartJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobState) {
      res["JobState"] = boost::any(*jobState);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobState") != m.end() && !m["JobState"].empty()) {
      jobState = make_shared<string>(boost::any_cast<string>(m["JobState"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~ListSmartJobsRequest() = default;
};
class ListSmartJobsResponseBodySmartJobListInputConfig : public Darabonba::Model {
public:
  shared_ptr<string> inputFile{};
  shared_ptr<string> keyword{};

  ListSmartJobsResponseBodySmartJobListInputConfig() {}

  explicit ListSmartJobsResponseBodySmartJobListInputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputFile) {
      res["InputFile"] = boost::any(*inputFile);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      inputFile = make_shared<string>(boost::any_cast<string>(m["InputFile"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
  }


  virtual ~ListSmartJobsResponseBodySmartJobListInputConfig() = default;
};
class ListSmartJobsResponseBodySmartJobListOutputConfig : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> object{};

  ListSmartJobsResponseBodySmartJobListOutputConfig() {}

  explicit ListSmartJobsResponseBodySmartJobListOutputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~ListSmartJobsResponseBodySmartJobListOutputConfig() = default;
};
class ListSmartJobsResponseBodySmartJobList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> editingConfig{};
  shared_ptr<ListSmartJobsResponseBodySmartJobListInputConfig> inputConfig{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobState{};
  shared_ptr<string> jobType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<ListSmartJobsResponseBodySmartJobListOutputConfig> outputConfig{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};
  shared_ptr<long> userId{};

  ListSmartJobsResponseBodySmartJobList() {}

  explicit ListSmartJobsResponseBodySmartJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (editingConfig) {
      res["EditingConfig"] = boost::any(*editingConfig);
    }
    if (inputConfig) {
      res["InputConfig"] = inputConfig ? boost::any(inputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobState) {
      res["JobState"] = boost::any(*jobState);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (outputConfig) {
      res["OutputConfig"] = outputConfig ? boost::any(outputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      editingConfig = make_shared<string>(boost::any_cast<string>(m["EditingConfig"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputConfig"].type()) {
        ListSmartJobsResponseBodySmartJobListInputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputConfig"]));
        inputConfig = make_shared<ListSmartJobsResponseBodySmartJobListInputConfig>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobState") != m.end() && !m["JobState"].empty()) {
      jobState = make_shared<string>(boost::any_cast<string>(m["JobState"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputConfig"].type()) {
        ListSmartJobsResponseBodySmartJobListOutputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputConfig"]));
        outputConfig = make_shared<ListSmartJobsResponseBodySmartJobListOutputConfig>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~ListSmartJobsResponseBodySmartJobList() = default;
};
class ListSmartJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSmartJobsResponseBodySmartJobList>> smartJobList{};
  shared_ptr<string> totalCount{};

  ListSmartJobsResponseBody() {}

  explicit ListSmartJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (smartJobList) {
      vector<boost::any> temp1;
      for(auto item1:*smartJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmartJobList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<string>(boost::any_cast<string>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SmartJobList") != m.end() && !m["SmartJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["SmartJobList"].type()) {
        vector<ListSmartJobsResponseBodySmartJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmartJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSmartJobsResponseBodySmartJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smartJobList = make_shared<vector<ListSmartJobsResponseBodySmartJobList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListSmartJobsResponseBody() = default;
};
class ListSmartJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSmartJobsResponseBody> body{};

  ListSmartJobsResponse() {}

  explicit ListSmartJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSmartJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSmartJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSmartJobsResponse() = default;
};
class ListSnapshotJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfCreateTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startOfCreateTime{};
  shared_ptr<string> status{};

  ListSnapshotJobsRequest() {}

  explicit ListSnapshotJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfCreateTime) {
      res["EndOfCreateTime"] = boost::any(*endOfCreateTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startOfCreateTime) {
      res["StartOfCreateTime"] = boost::any(*startOfCreateTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfCreateTime") != m.end() && !m["EndOfCreateTime"].empty()) {
      endOfCreateTime = make_shared<string>(boost::any_cast<string>(m["EndOfCreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartOfCreateTime") != m.end() && !m["StartOfCreateTime"].empty()) {
      startOfCreateTime = make_shared<string>(boost::any_cast<string>(m["StartOfCreateTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListSnapshotJobsRequest() = default;
};
class ListSnapshotJobsResponseBodyJobsInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListSnapshotJobsResponseBodyJobsInput() {}

  explicit ListSnapshotJobsResponseBodyJobsInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListSnapshotJobsResponseBodyJobsInput() = default;
};
class ListSnapshotJobsResponseBodyJobsOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListSnapshotJobsResponseBodyJobsOutput() {}

  explicit ListSnapshotJobsResponseBodyJobsOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListSnapshotJobsResponseBodyJobsOutput() = default;
};
class ListSnapshotJobsResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<long> count{};
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<ListSnapshotJobsResponseBodyJobsInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<ListSnapshotJobsResponseBodyJobsOutput> output{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> templateId{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> type{};

  ListSnapshotJobsResponseBodyJobs() {}

  explicit ListSnapshotJobsResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListSnapshotJobsResponseBodyJobsInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListSnapshotJobsResponseBodyJobsInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        ListSnapshotJobsResponseBodyJobsOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<ListSnapshotJobsResponseBodyJobsOutput>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListSnapshotJobsResponseBodyJobs() = default;
};
class ListSnapshotJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListSnapshotJobsResponseBodyJobs>> jobs{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListSnapshotJobsResponseBody() {}

  explicit ListSnapshotJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Jobs"] = boost::any(temp1);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["Jobs"].type()) {
        vector<ListSnapshotJobsResponseBodyJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSnapshotJobsResponseBodyJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<ListSnapshotJobsResponseBodyJobs>>(expect1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListSnapshotJobsResponseBody() = default;
};
class ListSnapshotJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSnapshotJobsResponseBody> body{};

  ListSnapshotJobsResponse() {}

  explicit ListSnapshotJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSnapshotJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSnapshotJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSnapshotJobsResponse() = default;
};
class ListSystemTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};
  shared_ptr<string> subtype{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  ListSystemTemplatesRequest() {}

  explicit ListSystemTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<string>(boost::any_cast<string>(m["Subtype"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListSystemTemplatesRequest() = default;
};
class ListSystemTemplatesResponseBodySystemTemplateList : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> subtype{};
  shared_ptr<string> subtypeName{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> type{};
  shared_ptr<string> typeName_{};

  ListSystemTemplatesResponseBodySystemTemplateList() {}

  explicit ListSystemTemplatesResponseBodySystemTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (subtypeName) {
      res["SubtypeName"] = boost::any(*subtypeName);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<long>(boost::any_cast<long>(m["Subtype"]));
    }
    if (m.find("SubtypeName") != m.end() && !m["SubtypeName"].empty()) {
      subtypeName = make_shared<string>(boost::any_cast<string>(m["SubtypeName"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~ListSystemTemplatesResponseBodySystemTemplateList() = default;
};
class ListSystemTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSystemTemplatesResponseBodySystemTemplateList>> systemTemplateList{};
  shared_ptr<long> total{};

  ListSystemTemplatesResponseBody() {}

  explicit ListSystemTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (systemTemplateList) {
      vector<boost::any> temp1;
      for(auto item1:*systemTemplateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemTemplateList"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SystemTemplateList") != m.end() && !m["SystemTemplateList"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemTemplateList"].type()) {
        vector<ListSystemTemplatesResponseBodySystemTemplateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemTemplateList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSystemTemplatesResponseBodySystemTemplateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemTemplateList = make_shared<vector<ListSystemTemplatesResponseBodySystemTemplateList>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSystemTemplatesResponseBody() = default;
};
class ListSystemTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSystemTemplatesResponseBody> body{};

  ListSystemTemplatesResponse() {}

  explicit ListSystemTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSystemTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSystemTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSystemTemplatesResponse() = default;
};
class ListTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> createSource{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortType{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListTemplatesRequest() {}

  explicit ListTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<string>(boost::any_cast<string>(m["SortType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListTemplatesRequest() = default;
};
class ListTemplatesResponseBodyTemplates : public Darabonba::Model {
public:
  shared_ptr<string> clipsParam{};
  shared_ptr<string> config{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createSource{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> modifiedSource{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<string> previewMedia{};
  shared_ptr<string> previewMediaStatus{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  ListTemplatesResponseBodyTemplates() {}

  explicit ListTemplatesResponseBodyTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (modifiedSource) {
      res["ModifiedSource"] = boost::any(*modifiedSource);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (previewMedia) {
      res["PreviewMedia"] = boost::any(*previewMedia);
    }
    if (previewMediaStatus) {
      res["PreviewMediaStatus"] = boost::any(*previewMediaStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ModifiedSource") != m.end() && !m["ModifiedSource"].empty()) {
      modifiedSource = make_shared<string>(boost::any_cast<string>(m["ModifiedSource"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PreviewMedia") != m.end() && !m["PreviewMedia"].empty()) {
      previewMedia = make_shared<string>(boost::any_cast<string>(m["PreviewMedia"]));
    }
    if (m.find("PreviewMediaStatus") != m.end() && !m["PreviewMediaStatus"].empty()) {
      previewMediaStatus = make_shared<string>(boost::any_cast<string>(m["PreviewMediaStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListTemplatesResponseBodyTemplates() = default;
};
class ListTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTemplatesResponseBodyTemplates>> templates{};
  shared_ptr<long> totalCount{};

  ListTemplatesResponseBody() {}

  explicit ListTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templates) {
      vector<boost::any> temp1;
      for(auto item1:*templates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Templates"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      if (typeid(vector<boost::any>) == m["Templates"].type()) {
        vector<ListTemplatesResponseBodyTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Templates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTemplatesResponseBodyTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templates = make_shared<vector<ListTemplatesResponseBodyTemplates>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTemplatesResponseBody() = default;
};
class ListTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTemplatesResponseBody> body{};

  ListTemplatesResponse() {}

  explicit ListTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTemplatesResponse() = default;
};
class ListTranscodeJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfCreateTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startOfCreateTime{};
  shared_ptr<string> status{};

  ListTranscodeJobsRequest() {}

  explicit ListTranscodeJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfCreateTime) {
      res["EndOfCreateTime"] = boost::any(*endOfCreateTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startOfCreateTime) {
      res["StartOfCreateTime"] = boost::any(*startOfCreateTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfCreateTime") != m.end() && !m["EndOfCreateTime"].empty()) {
      endOfCreateTime = make_shared<string>(boost::any_cast<string>(m["EndOfCreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartOfCreateTime") != m.end() && !m["StartOfCreateTime"].empty()) {
      startOfCreateTime = make_shared<string>(boost::any_cast<string>(m["StartOfCreateTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListTranscodeJobsRequest() = default;
};
class ListTranscodeJobsResponseBodyJobsInputGroup : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListTranscodeJobsResponseBodyJobsInputGroup() {}

  explicit ListTranscodeJobsResponseBodyJobsInputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsInputGroup() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListTranscodeJobsResponseBodyJobsOutputGroupOutput() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupOutput() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile> file{};
  shared_ptr<string> height{};
  shared_ptr<string> referPos{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline> timeline{};
  shared_ptr<string> width{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks : public Darabonba::Model {
public:
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile> file{};
  shared_ptr<string> format{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles : public Darabonba::Model {
public:
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> adaptive{};
  shared_ptr<string> borderColor{};
  shared_ptr<long> borderWidth{};
  shared_ptr<string> content{};
  shared_ptr<string> fontAlpha{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<long> fontSize{};
  shared_ptr<string> left{};
  shared_ptr<string> top{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adaptive) {
      res["Adaptive"] = boost::any(*adaptive);
    }
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidth) {
      res["BorderWidth"] = boost::any(*borderWidth);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fontAlpha) {
      res["FontAlpha"] = boost::any(*fontAlpha);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSize) {
      res["FontSize"] = boost::any(*fontSize);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adaptive") != m.end() && !m["Adaptive"].empty()) {
      adaptive = make_shared<string>(boost::any_cast<string>(m["Adaptive"]));
    }
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidth") != m.end() && !m["BorderWidth"].empty()) {
      borderWidth = make_shared<long>(boost::any_cast<long>(m["BorderWidth"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FontAlpha") != m.end() && !m["FontAlpha"].empty()) {
      fontAlpha = make_shared<string>(boost::any_cast<string>(m["FontAlpha"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSize") != m.end() && !m["FontSize"].empty()) {
      fontSize = make_shared<long>(boost::any_cast<long>(m["FontSize"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks : public Darabonba::Model {
public:
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> integratedLoudnessTarget{};
  shared_ptr<string> loudnessRangeTarget{};
  shared_ptr<string> method{};
  shared_ptr<string> truePeak{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedLoudnessTarget) {
      res["IntegratedLoudnessTarget"] = boost::any(*integratedLoudnessTarget);
    }
    if (loudnessRangeTarget) {
      res["LoudnessRangeTarget"] = boost::any(*loudnessRangeTarget);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (truePeak) {
      res["TruePeak"] = boost::any(*truePeak);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedLoudnessTarget") != m.end() && !m["IntegratedLoudnessTarget"].empty()) {
      integratedLoudnessTarget = make_shared<string>(boost::any_cast<string>(m["IntegratedLoudnessTarget"]));
    }
    if (m.find("LoudnessRangeTarget") != m.end() && !m["LoudnessRangeTarget"].empty()) {
      loudnessRangeTarget = make_shared<string>(boost::any_cast<string>(m["LoudnessRangeTarget"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("TruePeak") != m.end() && !m["TruePeak"].empty()) {
      truePeak = make_shared<string>(boost::any_cast<string>(m["TruePeak"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume> volume{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume>(model1);
      }
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> forceSegTime{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (forceSegTime) {
      res["ForceSegTime"] = boost::any(*forceSegTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ForceSegTime") != m.end() && !m["ForceSegTime"].empty()) {
      forceSegTime = make_shared<string>(boost::any_cast<string>(m["ForceSegTime"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig : public Darabonba::Model {
public:
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment> segment{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo : public Darabonba::Model {
public:
  shared_ptr<string> abrMax{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abrMax) {
      res["AbrMax"] = boost::any(*abrMax);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbrMax") != m.end() && !m["AbrMax"].empty()) {
      abrMax = make_shared<string>(boost::any_cast<string>(m["AbrMax"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio> audio{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer> container{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig> muxConfig{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo> video{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo>(model1);
      }
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode : public Darabonba::Model {
public:
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig : public Darabonba::Model {
public:
  shared_ptr<vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks>> imageWatermarks{};
  shared_ptr<vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles>> subtitles{};
  shared_ptr<vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks>> textWatermarks{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode> transcode{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*imageWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageWatermarks"] = boost::any(temp1);
    }
    if (subtitles) {
      vector<boost::any> temp1;
      for(auto item1:*subtitles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitles"] = boost::any(temp1);
    }
    if (textWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*textWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextWatermarks"] = boost::any(temp1);
    }
    if (transcode) {
      res["Transcode"] = transcode ? boost::any(transcode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageWatermarks") != m.end() && !m["ImageWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageWatermarks"].type()) {
        vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageWatermarks = make_shared<vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks>>(expect1);
      }
    }
    if (m.find("Subtitles") != m.end() && !m["Subtitles"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitles"].type()) {
        vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitles = make_shared<vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles>>(expect1);
      }
    }
    if (m.find("TextWatermarks") != m.end() && !m["TextWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["TextWatermarks"].type()) {
        vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textWatermarks = make_shared<vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks>>(expect1);
      }
    }
    if (m.find("Transcode") != m.end() && !m["Transcode"].empty()) {
      if (typeid(map<string, boost::any>) == m["Transcode"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Transcode"]));
        transcode = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode>(model1);
      }
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroup : public Darabonba::Model {
public:
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupOutput> output{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig> processConfig{};

  ListTranscodeJobsResponseBodyJobsOutputGroup() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (processConfig) {
      res["ProcessConfig"] = processConfig ? boost::any(processConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupOutput>(model1);
      }
    }
    if (m.find("ProcessConfig") != m.end() && !m["ProcessConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProcessConfig"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProcessConfig"]));
        processConfig = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig>(model1);
      }
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroup() = default;
};
class ListTranscodeJobsResponseBodyJobsScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  ListTranscodeJobsResponseBodyJobsScheduleConfig() {}

  explicit ListTranscodeJobsResponseBodyJobsScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsScheduleConfig() = default;
};
class ListTranscodeJobsResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<vector<ListTranscodeJobsResponseBodyJobsInputGroup>> inputGroup{};
  shared_ptr<long> jobCount{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListTranscodeJobsResponseBodyJobsOutputGroup>> outputGroup{};
  shared_ptr<string> parentJobId{};
  shared_ptr<long> percent{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  ListTranscodeJobsResponseBodyJobs() {}

  explicit ListTranscodeJobsResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (inputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*inputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputGroup"] = boost::any(temp1);
    }
    if (jobCount) {
      res["JobCount"] = boost::any(*jobCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroup"] = boost::any(temp1);
    }
    if (parentJobId) {
      res["ParentJobId"] = boost::any(*parentJobId);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("InputGroup") != m.end() && !m["InputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["InputGroup"].type()) {
        vector<ListTranscodeJobsResponseBodyJobsInputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTranscodeJobsResponseBodyJobsInputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputGroup = make_shared<vector<ListTranscodeJobsResponseBodyJobsInputGroup>>(expect1);
      }
    }
    if (m.find("JobCount") != m.end() && !m["JobCount"].empty()) {
      jobCount = make_shared<long>(boost::any_cast<long>(m["JobCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputGroup") != m.end() && !m["OutputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroup"].type()) {
        vector<ListTranscodeJobsResponseBodyJobsOutputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTranscodeJobsResponseBodyJobsOutputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroup = make_shared<vector<ListTranscodeJobsResponseBodyJobsOutputGroup>>(expect1);
      }
    }
    if (m.find("ParentJobId") != m.end() && !m["ParentJobId"].empty()) {
      parentJobId = make_shared<string>(boost::any_cast<string>(m["ParentJobId"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        ListTranscodeJobsResponseBodyJobsScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<ListTranscodeJobsResponseBodyJobsScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobs() = default;
};
class ListTranscodeJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListTranscodeJobsResponseBodyJobs>> jobs{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListTranscodeJobsResponseBody() {}

  explicit ListTranscodeJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Jobs"] = boost::any(temp1);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["Jobs"].type()) {
        vector<ListTranscodeJobsResponseBodyJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTranscodeJobsResponseBodyJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<ListTranscodeJobsResponseBodyJobs>>(expect1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBody() = default;
};
class ListTranscodeJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTranscodeJobsResponseBody> body{};

  ListTranscodeJobsResponse() {}

  explicit ListTranscodeJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTranscodeJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTranscodeJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTranscodeJobsResponse() = default;
};
class QueryCensorJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryCensorJobListRequest() {}

  explicit QueryCensorJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryCensorJobListRequest() = default;
};
class QueryCensorJobListResponseBodyJobsCensorJobCensorConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryCensorJobListResponseBodyJobsCensorJobCensorConfigOutputFile() {}

  explicit QueryCensorJobListResponseBodyJobsCensorJobCensorConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobsCensorJobCensorConfigOutputFile() = default;
};
class QueryCensorJobListResponseBodyJobsCensorJobCensorConfig : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<string> interval{};
  shared_ptr<QueryCensorJobListResponseBodyJobsCensorJobCensorConfigOutputFile> outputFile{};
  shared_ptr<string> saveType{};
  shared_ptr<string> scenes{};

  QueryCensorJobListResponseBodyJobsCensorJobCensorConfig() {}

  explicit QueryCensorJobListResponseBodyJobsCensorJobCensorConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (saveType) {
      res["SaveType"] = boost::any(*saveType);
    }
    if (scenes) {
      res["Scenes"] = boost::any(*scenes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryCensorJobListResponseBodyJobsCensorJobCensorConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryCensorJobListResponseBodyJobsCensorJobCensorConfigOutputFile>(model1);
      }
    }
    if (m.find("SaveType") != m.end() && !m["SaveType"].empty()) {
      saveType = make_shared<string>(boost::any_cast<string>(m["SaveType"]));
    }
    if (m.find("Scenes") != m.end() && !m["Scenes"].empty()) {
      scenes = make_shared<string>(boost::any_cast<string>(m["Scenes"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobsCensorJobCensorConfig() = default;
};
class QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterListCounter : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> label{};

  QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterListCounter() {}

  explicit QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterListCounter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterListCounter() = default;
};
class QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterListCounter>> counter{};

  QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterList() {}

  explicit QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (counter) {
      vector<boost::any> temp1;
      for(auto item1:*counter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Counter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Counter") != m.end() && !m["Counter"].empty()) {
      if (typeid(vector<boost::any>) == m["Counter"].type()) {
        vector<QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterListCounter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Counter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterListCounter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        counter = make_shared<vector<QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterListCounter>>(expect1);
      }
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterList() = default;
};
class QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopListTop : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> label{};
  shared_ptr<string> object{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};

  QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopListTop() {}

  explicit QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopListTop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopListTop() = default;
};
class QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopListTop>> top{};

  QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopList() {}

  explicit QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (top) {
      vector<boost::any> temp1;
      for(auto item1:*top){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Top"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      if (typeid(vector<boost::any>) == m["Top"].type()) {
        vector<QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopListTop> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Top"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopListTop model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        top = make_shared<vector<QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopListTop>>(expect1);
      }
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopList() = default;
};
class QueryCensorJobListResponseBodyJobsCensorJobCensorPornResult : public Darabonba::Model {
public:
  shared_ptr<string> averageScore{};
  shared_ptr<string> label{};
  shared_ptr<string> maxScore{};
  shared_ptr<QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterList> pornCounterList{};
  shared_ptr<QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopList> pornTopList{};
  shared_ptr<string> suggestion{};

  QueryCensorJobListResponseBodyJobsCensorJobCensorPornResult() {}

  explicit QueryCensorJobListResponseBodyJobsCensorJobCensorPornResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageScore) {
      res["AverageScore"] = boost::any(*averageScore);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    if (pornCounterList) {
      res["PornCounterList"] = pornCounterList ? boost::any(pornCounterList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pornTopList) {
      res["PornTopList"] = pornTopList ? boost::any(pornTopList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageScore") != m.end() && !m["AverageScore"].empty()) {
      averageScore = make_shared<string>(boost::any_cast<string>(m["AverageScore"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
    if (m.find("PornCounterList") != m.end() && !m["PornCounterList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PornCounterList"].type()) {
        QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PornCounterList"]));
        pornCounterList = make_shared<QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterList>(model1);
      }
    }
    if (m.find("PornTopList") != m.end() && !m["PornTopList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PornTopList"].type()) {
        QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PornTopList"]));
        pornTopList = make_shared<QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopList>(model1);
      }
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobsCensorJobCensorPornResult() = default;
};
class QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterListCounter : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> label{};

  QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterListCounter() {}

  explicit QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterListCounter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterListCounter() = default;
};
class QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterListCounter>> counter{};

  QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterList() {}

  explicit QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (counter) {
      vector<boost::any> temp1;
      for(auto item1:*counter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Counter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Counter") != m.end() && !m["Counter"].empty()) {
      if (typeid(vector<boost::any>) == m["Counter"].type()) {
        vector<QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterListCounter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Counter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterListCounter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        counter = make_shared<vector<QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterListCounter>>(expect1);
      }
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterList() = default;
};
class QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopListTop : public Darabonba::Model {
public:
  shared_ptr<string> index{};
  shared_ptr<string> label{};
  shared_ptr<string> object{};
  shared_ptr<string> score{};
  shared_ptr<string> timestamp{};

  QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopListTop() {}

  explicit QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopListTop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<string>(boost::any_cast<string>(m["Score"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopListTop() = default;
};
class QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopListTop>> top{};

  QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopList() {}

  explicit QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (top) {
      vector<boost::any> temp1;
      for(auto item1:*top){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Top"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      if (typeid(vector<boost::any>) == m["Top"].type()) {
        vector<QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopListTop> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Top"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopListTop model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        top = make_shared<vector<QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopListTop>>(expect1);
      }
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopList() = default;
};
class QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResult : public Darabonba::Model {
public:
  shared_ptr<string> averageScore{};
  shared_ptr<string> label{};
  shared_ptr<string> maxScore{};
  shared_ptr<string> suggestion{};
  shared_ptr<QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterList> terrorismCounterList{};
  shared_ptr<QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopList> terrorismTopList{};

  QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResult() {}

  explicit QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageScore) {
      res["AverageScore"] = boost::any(*averageScore);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (maxScore) {
      res["MaxScore"] = boost::any(*maxScore);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (terrorismCounterList) {
      res["TerrorismCounterList"] = terrorismCounterList ? boost::any(terrorismCounterList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (terrorismTopList) {
      res["TerrorismTopList"] = terrorismTopList ? boost::any(terrorismTopList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageScore") != m.end() && !m["AverageScore"].empty()) {
      averageScore = make_shared<string>(boost::any_cast<string>(m["AverageScore"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("MaxScore") != m.end() && !m["MaxScore"].empty()) {
      maxScore = make_shared<string>(boost::any_cast<string>(m["MaxScore"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TerrorismCounterList") != m.end() && !m["TerrorismCounterList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerrorismCounterList"].type()) {
        QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerrorismCounterList"]));
        terrorismCounterList = make_shared<QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterList>(model1);
      }
    }
    if (m.find("TerrorismTopList") != m.end() && !m["TerrorismTopList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TerrorismTopList"].type()) {
        QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TerrorismTopList"]));
        terrorismTopList = make_shared<QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopList>(model1);
      }
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResult() = default;
};
class QueryCensorJobListResponseBodyJobsCensorJobImageCensorResultsImageCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> imageBucket{};
  shared_ptr<string> imageLocation{};
  shared_ptr<string> imageObject{};
  shared_ptr<string> result{};

  QueryCensorJobListResponseBodyJobsCensorJobImageCensorResultsImageCensorResult() {}

  explicit QueryCensorJobListResponseBodyJobsCensorJobImageCensorResultsImageCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageBucket) {
      res["ImageBucket"] = boost::any(*imageBucket);
    }
    if (imageLocation) {
      res["ImageLocation"] = boost::any(*imageLocation);
    }
    if (imageObject) {
      res["ImageObject"] = boost::any(*imageObject);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageBucket") != m.end() && !m["ImageBucket"].empty()) {
      imageBucket = make_shared<string>(boost::any_cast<string>(m["ImageBucket"]));
    }
    if (m.find("ImageLocation") != m.end() && !m["ImageLocation"].empty()) {
      imageLocation = make_shared<string>(boost::any_cast<string>(m["ImageLocation"]));
    }
    if (m.find("ImageObject") != m.end() && !m["ImageObject"].empty()) {
      imageObject = make_shared<string>(boost::any_cast<string>(m["ImageObject"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobsCensorJobImageCensorResultsImageCensorResult() = default;
};
class QueryCensorJobListResponseBodyJobsCensorJobImageCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCensorJobListResponseBodyJobsCensorJobImageCensorResultsImageCensorResult>> imageCensorResult{};

  QueryCensorJobListResponseBodyJobsCensorJobImageCensorResults() {}

  explicit QueryCensorJobListResponseBodyJobsCensorJobImageCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageCensorResult) {
      vector<boost::any> temp1;
      for(auto item1:*imageCensorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageCensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageCensorResult") != m.end() && !m["ImageCensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageCensorResult"].type()) {
        vector<QueryCensorJobListResponseBodyJobsCensorJobImageCensorResultsImageCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageCensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCensorJobListResponseBodyJobsCensorJobImageCensorResultsImageCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageCensorResult = make_shared<vector<QueryCensorJobListResponseBodyJobsCensorJobImageCensorResultsImageCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobsCensorJobImageCensorResults() = default;
};
class QueryCensorJobListResponseBodyJobsCensorJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryCensorJobListResponseBodyJobsCensorJobInput() {}

  explicit QueryCensorJobListResponseBodyJobsCensorJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobsCensorJobInput() = default;
};
class QueryCensorJobListResponseBodyJobsCensorJob : public Darabonba::Model {
public:
  shared_ptr<string> barrageCensorResult{};
  shared_ptr<QueryCensorJobListResponseBodyJobsCensorJobCensorConfig> censorConfig{};
  shared_ptr<QueryCensorJobListResponseBodyJobsCensorJobCensorPornResult> censorPornResult{};
  shared_ptr<QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResult> censorTerrorismResult{};
  shared_ptr<string> code{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> descCensorResult{};
  shared_ptr<string> id{};
  shared_ptr<QueryCensorJobListResponseBodyJobsCensorJobImageCensorResults> imageCensorResults{};
  shared_ptr<QueryCensorJobListResponseBodyJobsCensorJobInput> input{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resultSaveObject{};
  shared_ptr<string> state{};
  shared_ptr<string> titleCensorResult{};
  shared_ptr<string> userData{};

  QueryCensorJobListResponseBodyJobsCensorJob() {}

  explicit QueryCensorJobListResponseBodyJobsCensorJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (barrageCensorResult) {
      res["BarrageCensorResult"] = boost::any(*barrageCensorResult);
    }
    if (censorConfig) {
      res["CensorConfig"] = censorConfig ? boost::any(censorConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (censorPornResult) {
      res["CensorPornResult"] = censorPornResult ? boost::any(censorPornResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (censorTerrorismResult) {
      res["CensorTerrorismResult"] = censorTerrorismResult ? boost::any(censorTerrorismResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (descCensorResult) {
      res["DescCensorResult"] = boost::any(*descCensorResult);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (imageCensorResults) {
      res["ImageCensorResults"] = imageCensorResults ? boost::any(imageCensorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resultSaveObject) {
      res["ResultSaveObject"] = boost::any(*resultSaveObject);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (titleCensorResult) {
      res["TitleCensorResult"] = boost::any(*titleCensorResult);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BarrageCensorResult") != m.end() && !m["BarrageCensorResult"].empty()) {
      barrageCensorResult = make_shared<string>(boost::any_cast<string>(m["BarrageCensorResult"]));
    }
    if (m.find("CensorConfig") != m.end() && !m["CensorConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorConfig"].type()) {
        QueryCensorJobListResponseBodyJobsCensorJobCensorConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorConfig"]));
        censorConfig = make_shared<QueryCensorJobListResponseBodyJobsCensorJobCensorConfig>(model1);
      }
    }
    if (m.find("CensorPornResult") != m.end() && !m["CensorPornResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorPornResult"].type()) {
        QueryCensorJobListResponseBodyJobsCensorJobCensorPornResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorPornResult"]));
        censorPornResult = make_shared<QueryCensorJobListResponseBodyJobsCensorJobCensorPornResult>(model1);
      }
    }
    if (m.find("CensorTerrorismResult") != m.end() && !m["CensorTerrorismResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorTerrorismResult"].type()) {
        QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorTerrorismResult"]));
        censorTerrorismResult = make_shared<QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResult>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DescCensorResult") != m.end() && !m["DescCensorResult"].empty()) {
      descCensorResult = make_shared<string>(boost::any_cast<string>(m["DescCensorResult"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ImageCensorResults") != m.end() && !m["ImageCensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageCensorResults"].type()) {
        QueryCensorJobListResponseBodyJobsCensorJobImageCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageCensorResults"]));
        imageCensorResults = make_shared<QueryCensorJobListResponseBodyJobsCensorJobImageCensorResults>(model1);
      }
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryCensorJobListResponseBodyJobsCensorJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryCensorJobListResponseBodyJobsCensorJobInput>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResultSaveObject") != m.end() && !m["ResultSaveObject"].empty()) {
      resultSaveObject = make_shared<string>(boost::any_cast<string>(m["ResultSaveObject"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TitleCensorResult") != m.end() && !m["TitleCensorResult"].empty()) {
      titleCensorResult = make_shared<string>(boost::any_cast<string>(m["TitleCensorResult"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobsCensorJob() = default;
};
class QueryCensorJobListResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCensorJobListResponseBodyJobsCensorJob>> censorJob{};

  QueryCensorJobListResponseBodyJobs() {}

  explicit QueryCensorJobListResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorJob) {
      vector<boost::any> temp1;
      for(auto item1:*censorJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CensorJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorJob") != m.end() && !m["CensorJob"].empty()) {
      if (typeid(vector<boost::any>) == m["CensorJob"].type()) {
        vector<QueryCensorJobListResponseBodyJobsCensorJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CensorJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCensorJobListResponseBodyJobsCensorJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        censorJob = make_shared<vector<QueryCensorJobListResponseBodyJobsCensorJob>>(expect1);
      }
    }
  }


  virtual ~QueryCensorJobListResponseBodyJobs() = default;
};
class QueryCensorJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryCensorJobListResponseBodyNonExistIds() {}

  explicit QueryCensorJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryCensorJobListResponseBodyNonExistIds() = default;
};
class QueryCensorJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryCensorJobListResponseBodyJobs> jobs{};
  shared_ptr<QueryCensorJobListResponseBodyNonExistIds> nonExistIds{};
  shared_ptr<string> requestId{};

  QueryCensorJobListResponseBody() {}

  explicit QueryCensorJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobs) {
      res["Jobs"] = jobs ? boost::any(jobs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Jobs"].type()) {
        QueryCensorJobListResponseBodyJobs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Jobs"]));
        jobs = make_shared<QueryCensorJobListResponseBodyJobs>(model1);
      }
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryCensorJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryCensorJobListResponseBodyNonExistIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryCensorJobListResponseBody() = default;
};
class QueryCensorJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCensorJobListResponseBody> body{};

  QueryCensorJobListResponse() {}

  explicit QueryCensorJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCensorJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCensorJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCensorJobListResponse() = default;
};
class QueryIProductionJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> jobId{};

  QueryIProductionJobRequest() {}

  explicit QueryIProductionJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryIProductionJobRequest() = default;
};
class QueryIProductionJobResponseBodyInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  QueryIProductionJobResponseBodyInput() {}

  explicit QueryIProductionJobResponseBodyInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryIProductionJobResponseBodyInput() = default;
};
class QueryIProductionJobResponseBodyOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  QueryIProductionJobResponseBodyOutput() {}

  explicit QueryIProductionJobResponseBodyOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryIProductionJobResponseBodyOutput() = default;
};
class QueryIProductionJobResponseBodyScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  QueryIProductionJobResponseBodyScheduleConfig() {}

  explicit QueryIProductionJobResponseBodyScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~QueryIProductionJobResponseBodyScheduleConfig() = default;
};
class QueryIProductionJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> functionName{};
  shared_ptr<QueryIProductionJobResponseBodyInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> name{};
  shared_ptr<QueryIProductionJobResponseBodyOutput> output{};
  shared_ptr<vector<string>> outputFiles{};
  shared_ptr<vector<string>> outputUrls{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<QueryIProductionJobResponseBodyScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> userData{};

  QueryIProductionJobResponseBody() {}

  explicit QueryIProductionJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outputFiles) {
      res["OutputFiles"] = boost::any(*outputFiles);
    }
    if (outputUrls) {
      res["OutputUrls"] = boost::any(*outputUrls);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryIProductionJobResponseBodyInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryIProductionJobResponseBodyInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        QueryIProductionJobResponseBodyOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<QueryIProductionJobResponseBodyOutput>(model1);
      }
    }
    if (m.find("OutputFiles") != m.end() && !m["OutputFiles"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OutputFiles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OutputFiles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      outputFiles = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OutputUrls") != m.end() && !m["OutputUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OutputUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OutputUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      outputUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        QueryIProductionJobResponseBodyScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<QueryIProductionJobResponseBodyScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QueryIProductionJobResponseBody() = default;
};
class QueryIProductionJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryIProductionJobResponseBody> body{};

  QueryIProductionJobResponse() {}

  explicit QueryIProductionJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryIProductionJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryIProductionJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryIProductionJobResponse() = default;
};
class QueryMediaCensorJobDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMediaCensorJobDetailRequest() {}

  explicit QueryMediaCensorJobDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailRequest() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult>> result{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults> results{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (results) {
      res["Results"] = results ? boost::any(results->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(map<string, boost::any>) == m["Results"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Results"]));
        results = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult>> coverImageCensorResult{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverImageCensorResult) {
      vector<boost::any> temp1;
      for(auto item1:*coverImageCensorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CoverImageCensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverImageCensorResult") != m.end() && !m["CoverImageCensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CoverImageCensorResult"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CoverImageCensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coverImageCensorResult = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult>> censorResult{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResult) {
      vector<boost::any> temp1;
      for(auto item1:*censorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResult") != m.end() && !m["CensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CensorResult"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        censorResult = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult>> censorResult{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResult) {
      vector<boost::any> temp1;
      for(auto item1:*censorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResult") != m.end() && !m["CensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CensorResult"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        censorResult = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults> censorResults{};
  shared_ptr<string> object{};
  shared_ptr<string> timestamp{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResults) {
      res["CensorResults"] = censorResults ? boost::any(censorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResults") != m.end() && !m["CensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorResults"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorResults"]));
        censorResults = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults>(model1);
      }
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline>> videoTimeline{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoTimeline) {
      vector<boost::any> temp1;
      for(auto item1:*videoTimeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoTimeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoTimeline") != m.end() && !m["VideoTimeline"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoTimeline"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoTimeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoTimeline = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults> censorResults{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines> videoTimelines{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResults) {
      res["CensorResults"] = censorResults ? boost::any(censorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (videoTimelines) {
      res["VideoTimelines"] = videoTimelines ? boost::any(videoTimelines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResults") != m.end() && !m["CensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorResults"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorResults"]));
        censorResults = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("VideoTimelines") != m.end() && !m["VideoTimelines"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoTimelines"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoTimelines"]));
        videoTimelines = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile> outputFile{};
  shared_ptr<string> videoCensor{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCensor) {
      res["VideoCensor"] = boost::any(*videoCensor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile>(model1);
      }
    }
    if (m.find("VideoCensor") != m.end() && !m["VideoCensor"].empty()) {
      videoCensor = make_shared<string>(boost::any_cast<string>(m["VideoCensor"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult> barrageCensorResult{};
  shared_ptr<string> code{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults> coverImageCensorResults{};
  shared_ptr<string> creationTime{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult> descCensorResult{};
  shared_ptr<string> finishTime{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> state{};
  shared_ptr<string> suggestion{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult> titleCensorResult{};
  shared_ptr<string> userData{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult> vensorCensorResult{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig> videoCensorConfig{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (barrageCensorResult) {
      res["BarrageCensorResult"] = barrageCensorResult ? boost::any(barrageCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (coverImageCensorResults) {
      res["CoverImageCensorResults"] = coverImageCensorResults ? boost::any(coverImageCensorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (descCensorResult) {
      res["DescCensorResult"] = descCensorResult ? boost::any(descCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (titleCensorResult) {
      res["TitleCensorResult"] = titleCensorResult ? boost::any(titleCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (vensorCensorResult) {
      res["VensorCensorResult"] = vensorCensorResult ? boost::any(vensorCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCensorConfig) {
      res["VideoCensorConfig"] = videoCensorConfig ? boost::any(videoCensorConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BarrageCensorResult") != m.end() && !m["BarrageCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["BarrageCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BarrageCensorResult"]));
        barrageCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CoverImageCensorResults") != m.end() && !m["CoverImageCensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CoverImageCensorResults"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CoverImageCensorResults"]));
        coverImageCensorResults = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DescCensorResult") != m.end() && !m["DescCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["DescCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DescCensorResult"]));
        descCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult>(model1);
      }
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TitleCensorResult") != m.end() && !m["TitleCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TitleCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TitleCensorResult"]));
        titleCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VensorCensorResult") != m.end() && !m["VensorCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VensorCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VensorCensorResult"]));
        vensorCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult>(model1);
      }
    }
    if (m.find("VideoCensorConfig") != m.end() && !m["VideoCensorConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoCensorConfig"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoCensorConfig"]));
        videoCensorConfig = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail() = default;
};
class QueryMediaCensorJobDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail> mediaCensorJobDetail{};
  shared_ptr<string> requestId{};

  QueryMediaCensorJobDetailResponseBody() {}

  explicit QueryMediaCensorJobDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaCensorJobDetail) {
      res["MediaCensorJobDetail"] = mediaCensorJobDetail ? boost::any(mediaCensorJobDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaCensorJobDetail") != m.end() && !m["MediaCensorJobDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaCensorJobDetail"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaCensorJobDetail"]));
        mediaCensorJobDetail = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBody() = default;
};
class QueryMediaCensorJobDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaCensorJobDetailResponseBody> body{};

  QueryMediaCensorJobDetailResponse() {}

  explicit QueryMediaCensorJobDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaCensorJobDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaCensorJobDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponse() = default;
};
class QuerySmarttagJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> params{};

  QuerySmarttagJobRequest() {}

  explicit QuerySmarttagJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
  }


  virtual ~QuerySmarttagJobRequest() = default;
};
class QuerySmarttagJobResponseBodyResultsResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> type{};

  QuerySmarttagJobResponseBodyResultsResult() {}

  explicit QuerySmarttagJobResponseBodyResultsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QuerySmarttagJobResponseBodyResultsResult() = default;
};
class QuerySmarttagJobResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmarttagJobResponseBodyResultsResult>> result{};

  QuerySmarttagJobResponseBodyResults() {}

  explicit QuerySmarttagJobResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QuerySmarttagJobResponseBodyResultsResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmarttagJobResponseBodyResultsResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QuerySmarttagJobResponseBodyResultsResult>>(expect1);
      }
    }
  }


  virtual ~QuerySmarttagJobResponseBodyResults() = default;
};
class QuerySmarttagJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<QuerySmarttagJobResponseBodyResults> results{};
  shared_ptr<string> userData{};

  QuerySmarttagJobResponseBody() {}

  explicit QuerySmarttagJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      res["Results"] = results ? boost::any(results->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(map<string, boost::any>) == m["Results"].type()) {
        QuerySmarttagJobResponseBodyResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Results"]));
        results = make_shared<QuerySmarttagJobResponseBodyResults>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QuerySmarttagJobResponseBody() = default;
};
class QuerySmarttagJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmarttagJobResponseBody> body{};

  QuerySmarttagJobResponse() {}

  explicit QuerySmarttagJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmarttagJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmarttagJobResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmarttagJobResponse() = default;
};
class RefreshUploadMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};

  RefreshUploadMediaRequest() {}

  explicit RefreshUploadMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~RefreshUploadMediaRequest() = default;
};
class RefreshUploadMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> uploadAddress{};
  shared_ptr<string> uploadAuth{};

  RefreshUploadMediaResponseBody() {}

  explicit RefreshUploadMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadAddress) {
      res["UploadAddress"] = boost::any(*uploadAddress);
    }
    if (uploadAuth) {
      res["UploadAuth"] = boost::any(*uploadAuth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadAddress") != m.end() && !m["UploadAddress"].empty()) {
      uploadAddress = make_shared<string>(boost::any_cast<string>(m["UploadAddress"]));
    }
    if (m.find("UploadAuth") != m.end() && !m["UploadAuth"].empty()) {
      uploadAuth = make_shared<string>(boost::any_cast<string>(m["UploadAuth"]));
    }
  }


  virtual ~RefreshUploadMediaResponseBody() = default;
};
class RefreshUploadMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshUploadMediaResponseBody> body{};

  RefreshUploadMediaResponse() {}

  explicit RefreshUploadMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshUploadMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshUploadMediaResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshUploadMediaResponse() = default;
};
class RegisterMediaInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<long> cateId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<bool> overwrite{};
  shared_ptr<string> registerConfig{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};
  shared_ptr<string> workflowId{};

  RegisterMediaInfoRequest() {}

  explicit RegisterMediaInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (overwrite) {
      res["Overwrite"] = boost::any(*overwrite);
    }
    if (registerConfig) {
      res["RegisterConfig"] = boost::any(*registerConfig);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("Overwrite") != m.end() && !m["Overwrite"].empty()) {
      overwrite = make_shared<bool>(boost::any_cast<bool>(m["Overwrite"]));
    }
    if (m.find("RegisterConfig") != m.end() && !m["RegisterConfig"].empty()) {
      registerConfig = make_shared<string>(boost::any_cast<string>(m["RegisterConfig"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<string>(boost::any_cast<string>(m["WorkflowId"]));
    }
  }


  virtual ~RegisterMediaInfoRequest() = default;
};
class RegisterMediaInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};

  RegisterMediaInfoResponseBody() {}

  explicit RegisterMediaInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RegisterMediaInfoResponseBody() = default;
};
class RegisterMediaInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegisterMediaInfoResponseBody> body{};

  RegisterMediaInfoResponse() {}

  explicit RegisterMediaInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterMediaInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterMediaInfoResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterMediaInfoResponse() = default;
};
class RegisterMediaStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> userData{};

  RegisterMediaStreamRequest() {}

  explicit RegisterMediaStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~RegisterMediaStreamRequest() = default;
};
class RegisterMediaStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};

  RegisterMediaStreamResponseBody() {}

  explicit RegisterMediaStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RegisterMediaStreamResponseBody() = default;
};
class RegisterMediaStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegisterMediaStreamResponseBody> body{};

  RegisterMediaStreamResponse() {}

  explicit RegisterMediaStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterMediaStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterMediaStreamResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterMediaStreamResponse() = default;
};
class SearchEditingProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> createSource{};
  shared_ptr<string> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> projectType{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> templateType{};

  SearchEditingProjectRequest() {}

  explicit SearchEditingProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (projectType) {
      res["ProjectType"] = boost::any(*projectType);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ProjectType") != m.end() && !m["ProjectType"].empty()) {
      projectType = make_shared<string>(boost::any_cast<string>(m["ProjectType"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~SearchEditingProjectRequest() = default;
};
class SearchEditingProjectResponseBodyProjectList : public Darabonba::Model {
public:
  shared_ptr<string> businessConfig{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createSource{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> duration{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> modifiedSource{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectType{};
  shared_ptr<string> status{};
  shared_ptr<string> templateType{};
  shared_ptr<string> timeline{};
  shared_ptr<string> title{};

  SearchEditingProjectResponseBodyProjectList() {}

  explicit SearchEditingProjectResponseBodyProjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessConfig) {
      res["BusinessConfig"] = boost::any(*businessConfig);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (modifiedSource) {
      res["ModifiedSource"] = boost::any(*modifiedSource);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectType) {
      res["ProjectType"] = boost::any(*projectType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessConfig") != m.end() && !m["BusinessConfig"].empty()) {
      businessConfig = make_shared<string>(boost::any_cast<string>(m["BusinessConfig"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ModifiedSource") != m.end() && !m["ModifiedSource"].empty()) {
      modifiedSource = make_shared<string>(boost::any_cast<string>(m["ModifiedSource"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectType") != m.end() && !m["ProjectType"].empty()) {
      projectType = make_shared<string>(boost::any_cast<string>(m["ProjectType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~SearchEditingProjectResponseBodyProjectList() = default;
};
class SearchEditingProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<SearchEditingProjectResponseBodyProjectList>> projectList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  SearchEditingProjectResponseBody() {}

  explicit SearchEditingProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (projectList) {
      vector<boost::any> temp1;
      for(auto item1:*projectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ProjectList") != m.end() && !m["ProjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectList"].type()) {
        vector<SearchEditingProjectResponseBodyProjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchEditingProjectResponseBodyProjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectList = make_shared<vector<SearchEditingProjectResponseBodyProjectList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchEditingProjectResponseBody() = default;
};
class SearchEditingProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchEditingProjectResponseBody> body{};

  SearchEditingProjectResponse() {}

  explicit SearchEditingProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchEditingProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchEditingProjectResponseBody>(model1);
      }
    }
  }


  virtual ~SearchEditingProjectResponse() = default;
};
class SearchMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<string> match{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};

  SearchMediaRequest() {}

  explicit SearchMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (match) {
      res["Match"] = boost::any(*match);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("Match") != m.end() && !m["Match"].empty()) {
      match = make_shared<string>(boost::any_cast<string>(m["Match"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~SearchMediaRequest() = default;
};
class SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> createTime{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo() {}

  explicit SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo() = default;
};
class SearchMediaResponseBodyMediaInfoListFileInfoList : public Darabonba::Model {
public:
  shared_ptr<SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo> fileBasicInfo{};

  SearchMediaResponseBodyMediaInfoListFileInfoList() {}

  explicit SearchMediaResponseBodyMediaInfoListFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo>(model1);
      }
    }
  }


  virtual ~SearchMediaResponseBodyMediaInfoListFileInfoList() = default;
};
class SearchMediaResponseBodyMediaInfoListMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> biz{};
  shared_ptr<string> businessType{};
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> snapshots{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteImages{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> transcodeStatus{};
  shared_ptr<string> uploadSource{};
  shared_ptr<string> userData{};

  SearchMediaResponseBodyMediaInfoListMediaBasicInfo() {}

  explicit SearchMediaResponseBodyMediaInfoListMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (biz) {
      res["Biz"] = boost::any(*biz);
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteImages) {
      res["SpriteImages"] = boost::any(*spriteImages);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (transcodeStatus) {
      res["TranscodeStatus"] = boost::any(*transcodeStatus);
    }
    if (uploadSource) {
      res["UploadSource"] = boost::any(*uploadSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Biz") != m.end() && !m["Biz"].empty()) {
      biz = make_shared<string>(boost::any_cast<string>(m["Biz"]));
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      snapshots = make_shared<string>(boost::any_cast<string>(m["Snapshots"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteImages") != m.end() && !m["SpriteImages"].empty()) {
      spriteImages = make_shared<string>(boost::any_cast<string>(m["SpriteImages"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TranscodeStatus") != m.end() && !m["TranscodeStatus"].empty()) {
      transcodeStatus = make_shared<string>(boost::any_cast<string>(m["TranscodeStatus"]));
    }
    if (m.find("UploadSource") != m.end() && !m["UploadSource"].empty()) {
      uploadSource = make_shared<string>(boost::any_cast<string>(m["UploadSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaInfoListMediaBasicInfo() = default;
};
class SearchMediaResponseBodyMediaInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchMediaResponseBodyMediaInfoListFileInfoList>> fileInfoList{};
  shared_ptr<SearchMediaResponseBodyMediaInfoListMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  SearchMediaResponseBodyMediaInfoList() {}

  explicit SearchMediaResponseBodyMediaInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<SearchMediaResponseBodyMediaInfoListFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaResponseBodyMediaInfoListFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<SearchMediaResponseBodyMediaInfoListFileInfoList>>(expect1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        SearchMediaResponseBodyMediaInfoListMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<SearchMediaResponseBodyMediaInfoListMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaInfoList() = default;
};
class SearchMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<SearchMediaResponseBodyMediaInfoList>> mediaInfoList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<long> total{};

  SearchMediaResponseBody() {}

  explicit SearchMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (mediaInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInfoList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("MediaInfoList") != m.end() && !m["MediaInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInfoList"].type()) {
        vector<SearchMediaResponseBodyMediaInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaResponseBodyMediaInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInfoList = make_shared<vector<SearchMediaResponseBodyMediaInfoList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~SearchMediaResponseBody() = default;
};
class SearchMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchMediaResponseBody> body{};

  SearchMediaResponse() {}

  explicit SearchMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchMediaResponseBody>(model1);
      }
    }
  }


  virtual ~SearchMediaResponse() = default;
};
class SearchPublicMediaInfoRequest : public Darabonba::Model {
public:
  shared_ptr<bool> authorized{};
  shared_ptr<string> dynamicMetaDataMatchFields{};
  shared_ptr<string> entityId{};
  shared_ptr<bool> favorite{};
  shared_ptr<string> mediaIds{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};

  SearchPublicMediaInfoRequest() {}

  explicit SearchPublicMediaInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorized) {
      res["Authorized"] = boost::any(*authorized);
    }
    if (dynamicMetaDataMatchFields) {
      res["DynamicMetaDataMatchFields"] = boost::any(*dynamicMetaDataMatchFields);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (favorite) {
      res["Favorite"] = boost::any(*favorite);
    }
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Authorized") != m.end() && !m["Authorized"].empty()) {
      authorized = make_shared<bool>(boost::any_cast<bool>(m["Authorized"]));
    }
    if (m.find("DynamicMetaDataMatchFields") != m.end() && !m["DynamicMetaDataMatchFields"].empty()) {
      dynamicMetaDataMatchFields = make_shared<string>(boost::any_cast<string>(m["DynamicMetaDataMatchFields"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("Favorite") != m.end() && !m["Favorite"].empty()) {
      favorite = make_shared<bool>(boost::any_cast<bool>(m["Favorite"]));
    }
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~SearchPublicMediaInfoRequest() = default;
};
class SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> type{};

  SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData() {}

  explicit SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData() = default;
};
class SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteImages{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo() {}

  explicit SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteImages) {
      res["SpriteImages"] = boost::any(*spriteImages);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteImages") != m.end() && !m["SpriteImages"].empty()) {
      spriteImages = make_shared<string>(boost::any_cast<string>(m["SpriteImages"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo() = default;
};
class SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo : public Darabonba::Model {
public:
  shared_ptr<SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData> dynamicMetaData{};
  shared_ptr<SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo() {}

  explicit SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicMetaData) {
      res["DynamicMetaData"] = dynamicMetaData ? boost::any(dynamicMetaData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicMetaData") != m.end() && !m["DynamicMetaData"].empty()) {
      if (typeid(map<string, boost::any>) == m["DynamicMetaData"].type()) {
        SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DynamicMetaData"]));
        dynamicMetaData = make_shared<SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData>(model1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo() = default;
};
class SearchPublicMediaInfoResponseBodyPublicMediaInfos : public Darabonba::Model {
public:
  shared_ptr<bool> authorized{};
  shared_ptr<bool> favorite{};
  shared_ptr<SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo> mediaInfo{};
  shared_ptr<string> remainingAuthTime{};

  SearchPublicMediaInfoResponseBodyPublicMediaInfos() {}

  explicit SearchPublicMediaInfoResponseBodyPublicMediaInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorized) {
      res["Authorized"] = boost::any(*authorized);
    }
    if (favorite) {
      res["Favorite"] = boost::any(*favorite);
    }
    if (mediaInfo) {
      res["MediaInfo"] = mediaInfo ? boost::any(mediaInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (remainingAuthTime) {
      res["RemainingAuthTime"] = boost::any(*remainingAuthTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Authorized") != m.end() && !m["Authorized"].empty()) {
      authorized = make_shared<bool>(boost::any_cast<bool>(m["Authorized"]));
    }
    if (m.find("Favorite") != m.end() && !m["Favorite"].empty()) {
      favorite = make_shared<bool>(boost::any_cast<bool>(m["Favorite"]));
    }
    if (m.find("MediaInfo") != m.end() && !m["MediaInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfo"].type()) {
        SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfo"]));
        mediaInfo = make_shared<SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo>(model1);
      }
    }
    if (m.find("RemainingAuthTime") != m.end() && !m["RemainingAuthTime"].empty()) {
      remainingAuthTime = make_shared<string>(boost::any_cast<string>(m["RemainingAuthTime"]));
    }
  }


  virtual ~SearchPublicMediaInfoResponseBodyPublicMediaInfos() = default;
};
class SearchPublicMediaInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<SearchPublicMediaInfoResponseBodyPublicMediaInfos>> publicMediaInfos{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  SearchPublicMediaInfoResponseBody() {}

  explicit SearchPublicMediaInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publicMediaInfos) {
      vector<boost::any> temp1;
      for(auto item1:*publicMediaInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublicMediaInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PublicMediaInfos") != m.end() && !m["PublicMediaInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["PublicMediaInfos"].type()) {
        vector<SearchPublicMediaInfoResponseBodyPublicMediaInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublicMediaInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchPublicMediaInfoResponseBodyPublicMediaInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publicMediaInfos = make_shared<vector<SearchPublicMediaInfoResponseBodyPublicMediaInfos>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchPublicMediaInfoResponseBody() = default;
};
class SearchPublicMediaInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchPublicMediaInfoResponseBody> body{};

  SearchPublicMediaInfoResponse() {}

  explicit SearchPublicMediaInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchPublicMediaInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchPublicMediaInfoResponseBody>(model1);
      }
    }
  }


  virtual ~SearchPublicMediaInfoResponse() = default;
};
class SendLiveSnapshotJobCommandRequest : public Darabonba::Model {
public:
  shared_ptr<string> command{};
  shared_ptr<string> jobId{};

  SendLiveSnapshotJobCommandRequest() {}

  explicit SendLiveSnapshotJobCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SendLiveSnapshotJobCommandRequest() = default;
};
class SendLiveSnapshotJobCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SendLiveSnapshotJobCommandResponseBody() {}

  explicit SendLiveSnapshotJobCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendLiveSnapshotJobCommandResponseBody() = default;
};
class SendLiveSnapshotJobCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendLiveSnapshotJobCommandResponseBody> body{};

  SendLiveSnapshotJobCommandResponse() {}

  explicit SendLiveSnapshotJobCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendLiveSnapshotJobCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendLiveSnapshotJobCommandResponseBody>(model1);
      }
    }
  }


  virtual ~SendLiveSnapshotJobCommandResponse() = default;
};
class SendLiveTranscodeJobCommandRequest : public Darabonba::Model {
public:
  shared_ptr<string> command{};
  shared_ptr<string> jobId{};

  SendLiveTranscodeJobCommandRequest() {}

  explicit SendLiveTranscodeJobCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SendLiveTranscodeJobCommandRequest() = default;
};
class SendLiveTranscodeJobCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SendLiveTranscodeJobCommandResponseBody() {}

  explicit SendLiveTranscodeJobCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendLiveTranscodeJobCommandResponseBody() = default;
};
class SendLiveTranscodeJobCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendLiveTranscodeJobCommandResponseBody> body{};

  SendLiveTranscodeJobCommandResponse() {}

  explicit SendLiveTranscodeJobCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendLiveTranscodeJobCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendLiveTranscodeJobCommandResponseBody>(model1);
      }
    }
  }


  virtual ~SendLiveTranscodeJobCommandResponse() = default;
};
class SetDefaultCustomTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  SetDefaultCustomTemplateRequest() {}

  explicit SetDefaultCustomTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SetDefaultCustomTemplateRequest() = default;
};
class SetDefaultCustomTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SetDefaultCustomTemplateResponseBody() {}

  explicit SetDefaultCustomTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetDefaultCustomTemplateResponseBody() = default;
};
class SetDefaultCustomTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDefaultCustomTemplateResponseBody> body{};

  SetDefaultCustomTemplateResponse() {}

  explicit SetDefaultCustomTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDefaultCustomTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDefaultCustomTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~SetDefaultCustomTemplateResponse() = default;
};
class SetDefaultStorageLocationRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> path{};
  shared_ptr<string> storageType{};

  SetDefaultStorageLocationRequest() {}

  explicit SetDefaultStorageLocationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~SetDefaultStorageLocationRequest() = default;
};
class SetDefaultStorageLocationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SetDefaultStorageLocationResponseBody() {}

  explicit SetDefaultStorageLocationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetDefaultStorageLocationResponseBody() = default;
};
class SetDefaultStorageLocationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDefaultStorageLocationResponseBody> body{};

  SetDefaultStorageLocationResponse() {}

  explicit SetDefaultStorageLocationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDefaultStorageLocationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDefaultStorageLocationResponseBody>(model1);
      }
    }
  }


  virtual ~SetDefaultStorageLocationResponse() = default;
};
class SetEventCallbackRequest : public Darabonba::Model {
public:
  shared_ptr<string> authKey{};
  shared_ptr<string> authSwitch{};
  shared_ptr<string> callbackQueueName{};
  shared_ptr<string> callbackType{};
  shared_ptr<string> callbackURL{};
  shared_ptr<string> eventTypeList{};

  SetEventCallbackRequest() {}

  explicit SetEventCallbackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (authSwitch) {
      res["AuthSwitch"] = boost::any(*authSwitch);
    }
    if (callbackQueueName) {
      res["CallbackQueueName"] = boost::any(*callbackQueueName);
    }
    if (callbackType) {
      res["CallbackType"] = boost::any(*callbackType);
    }
    if (callbackURL) {
      res["CallbackURL"] = boost::any(*callbackURL);
    }
    if (eventTypeList) {
      res["EventTypeList"] = boost::any(*eventTypeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("AuthSwitch") != m.end() && !m["AuthSwitch"].empty()) {
      authSwitch = make_shared<string>(boost::any_cast<string>(m["AuthSwitch"]));
    }
    if (m.find("CallbackQueueName") != m.end() && !m["CallbackQueueName"].empty()) {
      callbackQueueName = make_shared<string>(boost::any_cast<string>(m["CallbackQueueName"]));
    }
    if (m.find("CallbackType") != m.end() && !m["CallbackType"].empty()) {
      callbackType = make_shared<string>(boost::any_cast<string>(m["CallbackType"]));
    }
    if (m.find("CallbackURL") != m.end() && !m["CallbackURL"].empty()) {
      callbackURL = make_shared<string>(boost::any_cast<string>(m["CallbackURL"]));
    }
    if (m.find("EventTypeList") != m.end() && !m["EventTypeList"].empty()) {
      eventTypeList = make_shared<string>(boost::any_cast<string>(m["EventTypeList"]));
    }
  }


  virtual ~SetEventCallbackRequest() = default;
};
class SetEventCallbackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SetEventCallbackResponseBody() {}

  explicit SetEventCallbackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetEventCallbackResponseBody() = default;
};
class SetEventCallbackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetEventCallbackResponseBody> body{};

  SetEventCallbackResponse() {}

  explicit SetEventCallbackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetEventCallbackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetEventCallbackResponseBody>(model1);
      }
    }
  }


  virtual ~SetEventCallbackResponse() = default;
};
class SubmitASRJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> duration{};
  shared_ptr<string> inputFile{};
  shared_ptr<string> startTime{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SubmitASRJobRequest() {}

  explicit SubmitASRJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (inputFile) {
      res["InputFile"] = boost::any(*inputFile);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      inputFile = make_shared<string>(boost::any_cast<string>(m["InputFile"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitASRJobRequest() = default;
};
class SubmitASRJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  SubmitASRJobResponseBody() {}

  explicit SubmitASRJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~SubmitASRJobResponseBody() = default;
};
class SubmitASRJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitASRJobResponseBody> body{};

  SubmitASRJobResponse() {}

  explicit SubmitASRJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitASRJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitASRJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitASRJobResponse() = default;
};
class SubmitAudioProduceJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> editingConfig{};
  shared_ptr<string> inputConfig{};
  shared_ptr<string> outputConfig{};
  shared_ptr<bool> overwrite{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SubmitAudioProduceJobRequest() {}

  explicit SubmitAudioProduceJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (editingConfig) {
      res["EditingConfig"] = boost::any(*editingConfig);
    }
    if (inputConfig) {
      res["InputConfig"] = boost::any(*inputConfig);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (overwrite) {
      res["Overwrite"] = boost::any(*overwrite);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      editingConfig = make_shared<string>(boost::any_cast<string>(m["EditingConfig"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      inputConfig = make_shared<string>(boost::any_cast<string>(m["InputConfig"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("Overwrite") != m.end() && !m["Overwrite"].empty()) {
      overwrite = make_shared<bool>(boost::any_cast<bool>(m["Overwrite"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitAudioProduceJobRequest() = default;
};
class SubmitAudioProduceJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  SubmitAudioProduceJobResponseBody() {}

  explicit SubmitAudioProduceJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~SubmitAudioProduceJobResponseBody() = default;
};
class SubmitAudioProduceJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitAudioProduceJobResponseBody> body{};

  SubmitAudioProduceJobResponse() {}

  explicit SubmitAudioProduceJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitAudioProduceJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitAudioProduceJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitAudioProduceJobResponse() = default;
};
class SubmitDynamicChartJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> axisParams{};
  shared_ptr<string> background{};
  shared_ptr<string> chartConfig{};
  shared_ptr<string> chartTitle{};
  shared_ptr<string> chartType{};
  shared_ptr<string> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> input{};
  shared_ptr<string> outputConfig{};
  shared_ptr<string> subtitle{};
  shared_ptr<string> title{};
  shared_ptr<string> unit{};
  shared_ptr<string> userData{};

  SubmitDynamicChartJobRequest() {}

  explicit SubmitDynamicChartJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (axisParams) {
      res["AxisParams"] = boost::any(*axisParams);
    }
    if (background) {
      res["Background"] = boost::any(*background);
    }
    if (chartConfig) {
      res["ChartConfig"] = boost::any(*chartConfig);
    }
    if (chartTitle) {
      res["ChartTitle"] = boost::any(*chartTitle);
    }
    if (chartType) {
      res["ChartType"] = boost::any(*chartType);
    }
    if (dataSource) {
      res["DataSource"] = boost::any(*dataSource);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (subtitle) {
      res["Subtitle"] = boost::any(*subtitle);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AxisParams") != m.end() && !m["AxisParams"].empty()) {
      axisParams = make_shared<string>(boost::any_cast<string>(m["AxisParams"]));
    }
    if (m.find("Background") != m.end() && !m["Background"].empty()) {
      background = make_shared<string>(boost::any_cast<string>(m["Background"]));
    }
    if (m.find("ChartConfig") != m.end() && !m["ChartConfig"].empty()) {
      chartConfig = make_shared<string>(boost::any_cast<string>(m["ChartConfig"]));
    }
    if (m.find("ChartTitle") != m.end() && !m["ChartTitle"].empty()) {
      chartTitle = make_shared<string>(boost::any_cast<string>(m["ChartTitle"]));
    }
    if (m.find("ChartType") != m.end() && !m["ChartType"].empty()) {
      chartType = make_shared<string>(boost::any_cast<string>(m["ChartType"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      dataSource = make_shared<string>(boost::any_cast<string>(m["DataSource"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      subtitle = make_shared<string>(boost::any_cast<string>(m["Subtitle"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitDynamicChartJobRequest() = default;
};
class SubmitDynamicChartJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitDynamicChartJobResponseBody() {}

  explicit SubmitDynamicChartJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitDynamicChartJobResponseBody() = default;
};
class SubmitDynamicChartJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitDynamicChartJobResponseBody> body{};

  SubmitDynamicChartJobResponse() {}

  explicit SubmitDynamicChartJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitDynamicChartJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitDynamicChartJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitDynamicChartJobResponse() = default;
};
class SubmitDynamicImageJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitDynamicImageJobRequestInput() {}

  explicit SubmitDynamicImageJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitDynamicImageJobRequestInput() = default;
};
class SubmitDynamicImageJobRequestOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitDynamicImageJobRequestOutput() {}

  explicit SubmitDynamicImageJobRequestOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitDynamicImageJobRequestOutput() = default;
};
class SubmitDynamicImageJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitDynamicImageJobRequestScheduleConfig() {}

  explicit SubmitDynamicImageJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitDynamicImageJobRequestScheduleConfig() = default;
};
class SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> end{};
  shared_ptr<string> seek{};

  SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan() {}

  explicit SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
  }


  virtual ~SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan() = default;
};
class SubmitDynamicImageJobRequestTemplateConfigOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<long> fps{};
  shared_ptr<long> height{};
  shared_ptr<bool> longShortMode{};
  shared_ptr<string> scanMode{};
  shared_ptr<SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan> timeSpan{};
  shared_ptr<long> width{};

  SubmitDynamicImageJobRequestTemplateConfigOverwriteParams() {}

  explicit SubmitDynamicImageJobRequestTemplateConfigOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<long>(boost::any_cast<long>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<bool>(boost::any_cast<bool>(m["LongShortMode"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~SubmitDynamicImageJobRequestTemplateConfigOverwriteParams() = default;
};
class SubmitDynamicImageJobRequestTemplateConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitDynamicImageJobRequestTemplateConfigOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitDynamicImageJobRequestTemplateConfig() {}

  explicit SubmitDynamicImageJobRequestTemplateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitDynamicImageJobRequestTemplateConfigOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitDynamicImageJobRequestTemplateConfigOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitDynamicImageJobRequestTemplateConfig() = default;
};
class SubmitDynamicImageJobRequest : public Darabonba::Model {
public:
  shared_ptr<SubmitDynamicImageJobRequestInput> input{};
  shared_ptr<string> name{};
  shared_ptr<SubmitDynamicImageJobRequestOutput> output{};
  shared_ptr<SubmitDynamicImageJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<SubmitDynamicImageJobRequestTemplateConfig> templateConfig{};
  shared_ptr<string> userData{};

  SubmitDynamicImageJobRequest() {}

  explicit SubmitDynamicImageJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitDynamicImageJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitDynamicImageJobRequestInput>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitDynamicImageJobRequestOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitDynamicImageJobRequestOutput>(model1);
      }
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitDynamicImageJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitDynamicImageJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        SubmitDynamicImageJobRequestTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<SubmitDynamicImageJobRequestTemplateConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitDynamicImageJobRequest() = default;
};
class SubmitDynamicImageJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> outputShrink{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> templateConfigShrink{};
  shared_ptr<string> userData{};

  SubmitDynamicImageJobShrinkRequest() {}

  explicit SubmitDynamicImageJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputShrink) {
      res["Output"] = boost::any(*outputShrink);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (templateConfigShrink) {
      res["TemplateConfig"] = boost::any(*templateConfigShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      outputShrink = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfigShrink = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitDynamicImageJobShrinkRequest() = default;
};
class SubmitDynamicImageJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitDynamicImageJobResponseBody() {}

  explicit SubmitDynamicImageJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitDynamicImageJobResponseBody() = default;
};
class SubmitDynamicImageJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitDynamicImageJobResponseBody> body{};

  SubmitDynamicImageJobResponse() {}

  explicit SubmitDynamicImageJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitDynamicImageJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitDynamicImageJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitDynamicImageJobResponse() = default;
};
class SubmitIProductionJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitIProductionJobRequestInput() {}

  explicit SubmitIProductionJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitIProductionJobRequestInput() = default;
};
class SubmitIProductionJobRequestOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitIProductionJobRequestOutput() {}

  explicit SubmitIProductionJobRequestOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitIProductionJobRequestOutput() = default;
};
class SubmitIProductionJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitIProductionJobRequestScheduleConfig() {}

  explicit SubmitIProductionJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitIProductionJobRequestScheduleConfig() = default;
};
class SubmitIProductionJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionName{};
  shared_ptr<SubmitIProductionJobRequestInput> input{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> name{};
  shared_ptr<SubmitIProductionJobRequestOutput> output{};
  shared_ptr<SubmitIProductionJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> userData{};

  SubmitIProductionJobRequest() {}

  explicit SubmitIProductionJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitIProductionJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitIProductionJobRequestInput>(model1);
      }
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitIProductionJobRequestOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitIProductionJobRequestOutput>(model1);
      }
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitIProductionJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitIProductionJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitIProductionJobRequest() = default;
};
class SubmitIProductionJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionName{};
  shared_ptr<string> inputShrink{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> name{};
  shared_ptr<string> outputShrink{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> templateId{};
  shared_ptr<string> userData{};

  SubmitIProductionJobShrinkRequest() {}

  explicit SubmitIProductionJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputShrink) {
      res["Output"] = boost::any(*outputShrink);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      outputShrink = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitIProductionJobShrinkRequest() = default;
};
class SubmitIProductionJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitIProductionJobResponseBody() {}

  explicit SubmitIProductionJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitIProductionJobResponseBody() = default;
};
class SubmitIProductionJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitIProductionJobResponseBody> body{};

  SubmitIProductionJobResponse() {}

  explicit SubmitIProductionJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitIProductionJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitIProductionJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitIProductionJobResponse() = default;
};
class SubmitLiveEditingJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clips{};
  shared_ptr<string> liveStreamConfig{};
  shared_ptr<string> mediaProduceConfig{};
  shared_ptr<string> outputMediaConfig{};
  shared_ptr<string> outputMediaTarget{};
  shared_ptr<string> projectId{};
  shared_ptr<string> userData{};

  SubmitLiveEditingJobRequest() {}

  explicit SubmitLiveEditingJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clips) {
      res["Clips"] = boost::any(*clips);
    }
    if (liveStreamConfig) {
      res["LiveStreamConfig"] = boost::any(*liveStreamConfig);
    }
    if (mediaProduceConfig) {
      res["MediaProduceConfig"] = boost::any(*mediaProduceConfig);
    }
    if (outputMediaConfig) {
      res["OutputMediaConfig"] = boost::any(*outputMediaConfig);
    }
    if (outputMediaTarget) {
      res["OutputMediaTarget"] = boost::any(*outputMediaTarget);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clips") != m.end() && !m["Clips"].empty()) {
      clips = make_shared<string>(boost::any_cast<string>(m["Clips"]));
    }
    if (m.find("LiveStreamConfig") != m.end() && !m["LiveStreamConfig"].empty()) {
      liveStreamConfig = make_shared<string>(boost::any_cast<string>(m["LiveStreamConfig"]));
    }
    if (m.find("MediaProduceConfig") != m.end() && !m["MediaProduceConfig"].empty()) {
      mediaProduceConfig = make_shared<string>(boost::any_cast<string>(m["MediaProduceConfig"]));
    }
    if (m.find("OutputMediaConfig") != m.end() && !m["OutputMediaConfig"].empty()) {
      outputMediaConfig = make_shared<string>(boost::any_cast<string>(m["OutputMediaConfig"]));
    }
    if (m.find("OutputMediaTarget") != m.end() && !m["OutputMediaTarget"].empty()) {
      outputMediaTarget = make_shared<string>(boost::any_cast<string>(m["OutputMediaTarget"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitLiveEditingJobRequest() = default;
};
class SubmitLiveEditingJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaURL{};
  shared_ptr<string> projectId{};
  shared_ptr<string> requestId{};

  SubmitLiveEditingJobResponseBody() {}

  explicit SubmitLiveEditingJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaURL) {
      res["MediaURL"] = boost::any(*mediaURL);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaURL") != m.end() && !m["MediaURL"].empty()) {
      mediaURL = make_shared<string>(boost::any_cast<string>(m["MediaURL"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitLiveEditingJobResponseBody() = default;
};
class SubmitLiveEditingJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitLiveEditingJobResponseBody> body{};

  SubmitLiveEditingJobResponse() {}

  explicit SubmitLiveEditingJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitLiveEditingJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitLiveEditingJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitLiveEditingJobResponse() = default;
};
class SubmitLiveRecordJobRequestRecordOutput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> type{};

  SubmitLiveRecordJobRequestRecordOutput() {}

  explicit SubmitLiveRecordJobRequestRecordOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitLiveRecordJobRequestRecordOutput() = default;
};
class SubmitLiveRecordJobRequestStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  SubmitLiveRecordJobRequestStreamInput() {}

  explicit SubmitLiveRecordJobRequestStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~SubmitLiveRecordJobRequestStreamInput() = default;
};
class SubmitLiveRecordJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<SubmitLiveRecordJobRequestRecordOutput> recordOutput{};
  shared_ptr<SubmitLiveRecordJobRequestStreamInput> streamInput{};
  shared_ptr<string> templateId{};

  SubmitLiveRecordJobRequest() {}

  explicit SubmitLiveRecordJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (recordOutput) {
      res["RecordOutput"] = recordOutput ? boost::any(recordOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("RecordOutput") != m.end() && !m["RecordOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordOutput"].type()) {
        SubmitLiveRecordJobRequestRecordOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordOutput"]));
        recordOutput = make_shared<SubmitLiveRecordJobRequestRecordOutput>(model1);
      }
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        SubmitLiveRecordJobRequestStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<SubmitLiveRecordJobRequestStreamInput>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitLiveRecordJobRequest() = default;
};
class SubmitLiveRecordJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> recordOutputShrink{};
  shared_ptr<string> streamInputShrink{};
  shared_ptr<string> templateId{};

  SubmitLiveRecordJobShrinkRequest() {}

  explicit SubmitLiveRecordJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (recordOutputShrink) {
      res["RecordOutput"] = boost::any(*recordOutputShrink);
    }
    if (streamInputShrink) {
      res["StreamInput"] = boost::any(*streamInputShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("RecordOutput") != m.end() && !m["RecordOutput"].empty()) {
      recordOutputShrink = make_shared<string>(boost::any_cast<string>(m["RecordOutput"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      streamInputShrink = make_shared<string>(boost::any_cast<string>(m["StreamInput"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitLiveRecordJobShrinkRequest() = default;
};
class SubmitLiveRecordJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitLiveRecordJobResponseBody() {}

  explicit SubmitLiveRecordJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitLiveRecordJobResponseBody() = default;
};
class SubmitLiveRecordJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitLiveRecordJobResponseBody> body{};

  SubmitLiveRecordJobResponse() {}

  explicit SubmitLiveRecordJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitLiveRecordJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitLiveRecordJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitLiveRecordJobResponse() = default;
};
class SubmitLiveSnapshotJobRequestSnapshotOutput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> storageType{};

  SubmitLiveSnapshotJobRequestSnapshotOutput() {}

  explicit SubmitLiveSnapshotJobRequestSnapshotOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~SubmitLiveSnapshotJobRequestSnapshotOutput() = default;
};
class SubmitLiveSnapshotJobRequestStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  SubmitLiveSnapshotJobRequestStreamInput() {}

  explicit SubmitLiveSnapshotJobRequestStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~SubmitLiveSnapshotJobRequestStreamInput() = default;
};
class SubmitLiveSnapshotJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> jobName{};
  shared_ptr<SubmitLiveSnapshotJobRequestSnapshotOutput> snapshotOutput{};
  shared_ptr<SubmitLiveSnapshotJobRequestStreamInput> streamInput{};
  shared_ptr<string> templateId{};

  SubmitLiveSnapshotJobRequest() {}

  explicit SubmitLiveSnapshotJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (snapshotOutput) {
      res["SnapshotOutput"] = snapshotOutput ? boost::any(snapshotOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("SnapshotOutput") != m.end() && !m["SnapshotOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotOutput"].type()) {
        SubmitLiveSnapshotJobRequestSnapshotOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotOutput"]));
        snapshotOutput = make_shared<SubmitLiveSnapshotJobRequestSnapshotOutput>(model1);
      }
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        SubmitLiveSnapshotJobRequestStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<SubmitLiveSnapshotJobRequestStreamInput>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitLiveSnapshotJobRequest() = default;
};
class SubmitLiveSnapshotJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> jobName{};
  shared_ptr<string> snapshotOutputShrink{};
  shared_ptr<string> streamInputShrink{};
  shared_ptr<string> templateId{};

  SubmitLiveSnapshotJobShrinkRequest() {}

  explicit SubmitLiveSnapshotJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (snapshotOutputShrink) {
      res["SnapshotOutput"] = boost::any(*snapshotOutputShrink);
    }
    if (streamInputShrink) {
      res["StreamInput"] = boost::any(*streamInputShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("SnapshotOutput") != m.end() && !m["SnapshotOutput"].empty()) {
      snapshotOutputShrink = make_shared<string>(boost::any_cast<string>(m["SnapshotOutput"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      streamInputShrink = make_shared<string>(boost::any_cast<string>(m["StreamInput"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitLiveSnapshotJobShrinkRequest() = default;
};
class SubmitLiveSnapshotJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitLiveSnapshotJobResponseBody() {}

  explicit SubmitLiveSnapshotJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitLiveSnapshotJobResponseBody() = default;
};
class SubmitLiveSnapshotJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitLiveSnapshotJobResponseBody> body{};

  SubmitLiveSnapshotJobResponse() {}

  explicit SubmitLiveSnapshotJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitLiveSnapshotJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitLiveSnapshotJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitLiveSnapshotJobResponse() = default;
};
class SubmitLiveTranscodeJobRequestStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> inputUrl{};
  shared_ptr<string> type{};

  SubmitLiveTranscodeJobRequestStreamInput() {}

  explicit SubmitLiveTranscodeJobRequestStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputUrl) {
      res["InputUrl"] = boost::any(*inputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputUrl") != m.end() && !m["InputUrl"].empty()) {
      inputUrl = make_shared<string>(boost::any_cast<string>(m["InputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitLiveTranscodeJobRequestStreamInput() = default;
};
class SubmitLiveTranscodeJobRequestTimedConfig : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  SubmitLiveTranscodeJobRequestTimedConfig() {}

  explicit SubmitLiveTranscodeJobRequestTimedConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~SubmitLiveTranscodeJobRequestTimedConfig() = default;
};
class SubmitLiveTranscodeJobRequestTranscodeOutput : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> type{};

  SubmitLiveTranscodeJobRequestTranscodeOutput() {}

  explicit SubmitLiveTranscodeJobRequestTranscodeOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitLiveTranscodeJobRequestTranscodeOutput() = default;
};
class SubmitLiveTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> startMode{};
  shared_ptr<SubmitLiveTranscodeJobRequestStreamInput> streamInput{};
  shared_ptr<string> templateId{};
  shared_ptr<SubmitLiveTranscodeJobRequestTimedConfig> timedConfig{};
  shared_ptr<SubmitLiveTranscodeJobRequestTranscodeOutput> transcodeOutput{};

  SubmitLiveTranscodeJobRequest() {}

  explicit SubmitLiveTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startMode) {
      res["StartMode"] = boost::any(*startMode);
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (timedConfig) {
      res["TimedConfig"] = timedConfig ? boost::any(timedConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transcodeOutput) {
      res["TranscodeOutput"] = transcodeOutput ? boost::any(transcodeOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartMode") != m.end() && !m["StartMode"].empty()) {
      startMode = make_shared<long>(boost::any_cast<long>(m["StartMode"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        SubmitLiveTranscodeJobRequestStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<SubmitLiveTranscodeJobRequestStreamInput>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TimedConfig") != m.end() && !m["TimedConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimedConfig"].type()) {
        SubmitLiveTranscodeJobRequestTimedConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimedConfig"]));
        timedConfig = make_shared<SubmitLiveTranscodeJobRequestTimedConfig>(model1);
      }
    }
    if (m.find("TranscodeOutput") != m.end() && !m["TranscodeOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeOutput"].type()) {
        SubmitLiveTranscodeJobRequestTranscodeOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeOutput"]));
        transcodeOutput = make_shared<SubmitLiveTranscodeJobRequestTranscodeOutput>(model1);
      }
    }
  }


  virtual ~SubmitLiveTranscodeJobRequest() = default;
};
class SubmitLiveTranscodeJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> startMode{};
  shared_ptr<string> streamInputShrink{};
  shared_ptr<string> templateId{};
  shared_ptr<string> timedConfigShrink{};
  shared_ptr<string> transcodeOutputShrink{};

  SubmitLiveTranscodeJobShrinkRequest() {}

  explicit SubmitLiveTranscodeJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startMode) {
      res["StartMode"] = boost::any(*startMode);
    }
    if (streamInputShrink) {
      res["StreamInput"] = boost::any(*streamInputShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (timedConfigShrink) {
      res["TimedConfig"] = boost::any(*timedConfigShrink);
    }
    if (transcodeOutputShrink) {
      res["TranscodeOutput"] = boost::any(*transcodeOutputShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartMode") != m.end() && !m["StartMode"].empty()) {
      startMode = make_shared<long>(boost::any_cast<long>(m["StartMode"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      streamInputShrink = make_shared<string>(boost::any_cast<string>(m["StreamInput"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TimedConfig") != m.end() && !m["TimedConfig"].empty()) {
      timedConfigShrink = make_shared<string>(boost::any_cast<string>(m["TimedConfig"]));
    }
    if (m.find("TranscodeOutput") != m.end() && !m["TranscodeOutput"].empty()) {
      transcodeOutputShrink = make_shared<string>(boost::any_cast<string>(m["TranscodeOutput"]));
    }
  }


  virtual ~SubmitLiveTranscodeJobShrinkRequest() = default;
};
class SubmitLiveTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitLiveTranscodeJobResponseBody() {}

  explicit SubmitLiveTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitLiveTranscodeJobResponseBody() = default;
};
class SubmitLiveTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitLiveTranscodeJobResponseBody> body{};

  SubmitLiveTranscodeJobResponse() {}

  explicit SubmitLiveTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitLiveTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitLiveTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitLiveTranscodeJobResponse() = default;
};
class SubmitMediaCensorJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitMediaCensorJobRequestInput() {}

  explicit SubmitMediaCensorJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitMediaCensorJobRequestInput() = default;
};
class SubmitMediaCensorJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitMediaCensorJobRequestScheduleConfig() {}

  explicit SubmitMediaCensorJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitMediaCensorJobRequestScheduleConfig() = default;
};
class SubmitMediaCensorJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> barrages{};
  shared_ptr<string> coverImages{};
  shared_ptr<string> description{};
  shared_ptr<SubmitMediaCensorJobRequestInput> input{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> output{};
  shared_ptr<SubmitMediaCensorJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SubmitMediaCensorJobRequest() {}

  explicit SubmitMediaCensorJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (barrages) {
      res["Barrages"] = boost::any(*barrages);
    }
    if (coverImages) {
      res["CoverImages"] = boost::any(*coverImages);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Barrages") != m.end() && !m["Barrages"].empty()) {
      barrages = make_shared<string>(boost::any_cast<string>(m["Barrages"]));
    }
    if (m.find("CoverImages") != m.end() && !m["CoverImages"].empty()) {
      coverImages = make_shared<string>(boost::any_cast<string>(m["CoverImages"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitMediaCensorJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitMediaCensorJobRequestInput>(model1);
      }
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitMediaCensorJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitMediaCensorJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaCensorJobRequest() = default;
};
class SubmitMediaCensorJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> barrages{};
  shared_ptr<string> coverImages{};
  shared_ptr<string> description{};
  shared_ptr<string> inputShrink{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> output{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> templateId{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SubmitMediaCensorJobShrinkRequest() {}

  explicit SubmitMediaCensorJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (barrages) {
      res["Barrages"] = boost::any(*barrages);
    }
    if (coverImages) {
      res["CoverImages"] = boost::any(*coverImages);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Barrages") != m.end() && !m["Barrages"].empty()) {
      barrages = make_shared<string>(boost::any_cast<string>(m["Barrages"]));
    }
    if (m.find("CoverImages") != m.end() && !m["CoverImages"].empty()) {
      coverImages = make_shared<string>(boost::any_cast<string>(m["CoverImages"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaCensorJobShrinkRequest() = default;
};
class SubmitMediaCensorJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitMediaCensorJobResponseBody() {}

  explicit SubmitMediaCensorJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitMediaCensorJobResponseBody() = default;
};
class SubmitMediaCensorJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitMediaCensorJobResponseBody> body{};

  SubmitMediaCensorJobResponse() {}

  explicit SubmitMediaCensorJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMediaCensorJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMediaCensorJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMediaCensorJobResponse() = default;
};
class SubmitMediaInfoJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitMediaInfoJobRequestInput() {}

  explicit SubmitMediaInfoJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitMediaInfoJobRequestInput() = default;
};
class SubmitMediaInfoJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitMediaInfoJobRequestScheduleConfig() {}

  explicit SubmitMediaInfoJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitMediaInfoJobRequestScheduleConfig() = default;
};
class SubmitMediaInfoJobRequest : public Darabonba::Model {
public:
  shared_ptr<SubmitMediaInfoJobRequestInput> input{};
  shared_ptr<string> name{};
  shared_ptr<SubmitMediaInfoJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<string> userData{};

  SubmitMediaInfoJobRequest() {}

  explicit SubmitMediaInfoJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitMediaInfoJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitMediaInfoJobRequestInput>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitMediaInfoJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitMediaInfoJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaInfoJobRequest() = default;
};
class SubmitMediaInfoJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> userData{};

  SubmitMediaInfoJobShrinkRequest() {}

  explicit SubmitMediaInfoJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaInfoJobShrinkRequest() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobInput() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobInput() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFps{};
  shared_ptr<string> bitRate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeBase{};
  shared_ptr<string> width{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFps) {
      res["Avg_fps"] = boost::any(*avgFps);
    }
    if (bitRate) {
      res["Bit_rate"] = boost::any(*bitRate);
    }
    if (codecLongName) {
      res["Codec_long_name"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["Codec_name"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["Codec_tag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["Codec_tag_string"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["Codec_time_base"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["Has_b_frames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["Start_time"] = boost::any(*startTime);
    }
    if (timeBase) {
      res["Time_base"] = boost::any(*timeBase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avg_fps") != m.end() && !m["Avg_fps"].empty()) {
      avgFps = make_shared<string>(boost::any_cast<string>(m["Avg_fps"]));
    }
    if (m.find("Bit_rate") != m.end() && !m["Bit_rate"].empty()) {
      bitRate = make_shared<string>(boost::any_cast<string>(m["Bit_rate"]));
    }
    if (m.find("Codec_long_name") != m.end() && !m["Codec_long_name"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["Codec_long_name"]));
    }
    if (m.find("Codec_name") != m.end() && !m["Codec_name"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["Codec_name"]));
    }
    if (m.find("Codec_tag") != m.end() && !m["Codec_tag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["Codec_tag"]));
    }
    if (m.find("Codec_tag_string") != m.end() && !m["Codec_tag_string"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["Codec_tag_string"]));
    }
    if (m.find("Codec_time_base") != m.end() && !m["Codec_time_base"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["Codec_time_base"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Has_b_frames") != m.end() && !m["Has_b_frames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["Has_b_frames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Start_time") != m.end() && !m["Start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["Start_time"]));
    }
    if (m.find("Time_base") != m.end() && !m["Time_base"].empty()) {
      timeBase = make_shared<string>(boost::any_cast<string>(m["Time_base"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList>> videoStreamInfoList{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo>(model1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJob : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> finishTime{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty> mediaInfoProperty{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> submitResultJson{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  SubmitMediaInfoJobResponseBodyMediaInfoJob() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaInfoProperty) {
      res["MediaInfoProperty"] = mediaInfoProperty ? boost::any(mediaInfoProperty->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitResultJson) {
      res["SubmitResultJson"] = boost::any(*submitResultJson);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaInfoProperty") != m.end() && !m["MediaInfoProperty"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoProperty"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoProperty"]));
        mediaInfoProperty = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitResultJson") != m.end() && !m["SubmitResultJson"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SubmitResultJson"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      submitResultJson = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJob() = default;
};
class SubmitMediaInfoJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJob> mediaInfoJob{};
  shared_ptr<string> requestId{};

  SubmitMediaInfoJobResponseBody() {}

  explicit SubmitMediaInfoJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfoJob) {
      res["MediaInfoJob"] = mediaInfoJob ? boost::any(mediaInfoJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfoJob") != m.end() && !m["MediaInfoJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoJob"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoJob"]));
        mediaInfoJob = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBody() = default;
};
class SubmitMediaInfoJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitMediaInfoJobResponseBody> body{};

  SubmitMediaInfoJobResponse() {}

  explicit SubmitMediaInfoJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMediaInfoJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMediaInfoJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponse() = default;
};
class SubmitMediaProducingJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> clipsParam{};
  shared_ptr<string> editingProduceConfig{};
  shared_ptr<string> outputMediaConfig{};
  shared_ptr<string> outputMediaTarget{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectMetadata{};
  shared_ptr<string> source{};
  shared_ptr<string> templateId{};
  shared_ptr<string> timeline{};
  shared_ptr<string> userData{};

  SubmitMediaProducingJobRequest() {}

  explicit SubmitMediaProducingJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (editingProduceConfig) {
      res["EditingProduceConfig"] = boost::any(*editingProduceConfig);
    }
    if (outputMediaConfig) {
      res["OutputMediaConfig"] = boost::any(*outputMediaConfig);
    }
    if (outputMediaTarget) {
      res["OutputMediaTarget"] = boost::any(*outputMediaTarget);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectMetadata) {
      res["ProjectMetadata"] = boost::any(*projectMetadata);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("EditingProduceConfig") != m.end() && !m["EditingProduceConfig"].empty()) {
      editingProduceConfig = make_shared<string>(boost::any_cast<string>(m["EditingProduceConfig"]));
    }
    if (m.find("OutputMediaConfig") != m.end() && !m["OutputMediaConfig"].empty()) {
      outputMediaConfig = make_shared<string>(boost::any_cast<string>(m["OutputMediaConfig"]));
    }
    if (m.find("OutputMediaTarget") != m.end() && !m["OutputMediaTarget"].empty()) {
      outputMediaTarget = make_shared<string>(boost::any_cast<string>(m["OutputMediaTarget"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectMetadata") != m.end() && !m["ProjectMetadata"].empty()) {
      projectMetadata = make_shared<string>(boost::any_cast<string>(m["ProjectMetadata"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaProducingJobRequest() = default;
};
class SubmitMediaProducingJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vodMediaId{};

  SubmitMediaProducingJobResponseBody() {}

  explicit SubmitMediaProducingJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vodMediaId) {
      res["VodMediaId"] = boost::any(*vodMediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VodMediaId") != m.end() && !m["VodMediaId"].empty()) {
      vodMediaId = make_shared<string>(boost::any_cast<string>(m["VodMediaId"]));
    }
  }


  virtual ~SubmitMediaProducingJobResponseBody() = default;
};
class SubmitMediaProducingJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitMediaProducingJobResponseBody> body{};

  SubmitMediaProducingJobResponse() {}

  explicit SubmitMediaProducingJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMediaProducingJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMediaProducingJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMediaProducingJobResponse() = default;
};
class SubmitSmarttagJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitSmarttagJobRequestInput() {}

  explicit SubmitSmarttagJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitSmarttagJobRequestInput() = default;
};
class SubmitSmarttagJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<string> priority{};

  SubmitSmarttagJobRequestScheduleConfig() {}

  explicit SubmitSmarttagJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
  }


  virtual ~SubmitSmarttagJobRequestScheduleConfig() = default;
};
class SubmitSmarttagJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentAddr{};
  shared_ptr<string> contentType{};
  shared_ptr<SubmitSmarttagJobRequestInput> input{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> params{};
  shared_ptr<SubmitSmarttagJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SubmitSmarttagJobRequest() {}

  explicit SubmitSmarttagJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentAddr) {
      res["ContentAddr"] = boost::any(*contentAddr);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentAddr") != m.end() && !m["ContentAddr"].empty()) {
      contentAddr = make_shared<string>(boost::any_cast<string>(m["ContentAddr"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitSmarttagJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitSmarttagJobRequestInput>(model1);
      }
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitSmarttagJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitSmarttagJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSmarttagJobRequest() = default;
};
class SubmitSmarttagJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentAddr{};
  shared_ptr<string> contentType{};
  shared_ptr<string> inputShrink{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> params{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> templateId{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SubmitSmarttagJobShrinkRequest() {}

  explicit SubmitSmarttagJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentAddr) {
      res["ContentAddr"] = boost::any(*contentAddr);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentAddr") != m.end() && !m["ContentAddr"].empty()) {
      contentAddr = make_shared<string>(boost::any_cast<string>(m["ContentAddr"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSmarttagJobShrinkRequest() = default;
};
class SubmitSmarttagJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitSmarttagJobResponseBody() {}

  explicit SubmitSmarttagJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitSmarttagJobResponseBody() = default;
};
class SubmitSmarttagJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitSmarttagJobResponseBody> body{};

  SubmitSmarttagJobResponse() {}

  explicit SubmitSmarttagJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSmarttagJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSmarttagJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSmarttagJobResponse() = default;
};
class SubmitSnapshotJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitSnapshotJobRequestInput() {}

  explicit SubmitSnapshotJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitSnapshotJobRequestInput() = default;
};
class SubmitSnapshotJobRequestOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitSnapshotJobRequestOutput() {}

  explicit SubmitSnapshotJobRequestOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitSnapshotJobRequestOutput() = default;
};
class SubmitSnapshotJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};

  SubmitSnapshotJobRequestScheduleConfig() {}

  explicit SubmitSnapshotJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~SubmitSnapshotJobRequestScheduleConfig() = default;
};
class SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig : public Darabonba::Model {
public:
  shared_ptr<long> cellHeight{};
  shared_ptr<long> cellWidth{};
  shared_ptr<string> color{};
  shared_ptr<long> columns{};
  shared_ptr<long> lines{};
  shared_ptr<long> margin{};
  shared_ptr<long> padding{};

  SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig() {}

  explicit SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cellHeight) {
      res["CellHeight"] = boost::any(*cellHeight);
    }
    if (cellWidth) {
      res["CellWidth"] = boost::any(*cellWidth);
    }
    if (color) {
      res["Color"] = boost::any(*color);
    }
    if (columns) {
      res["Columns"] = boost::any(*columns);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (margin) {
      res["Margin"] = boost::any(*margin);
    }
    if (padding) {
      res["Padding"] = boost::any(*padding);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CellHeight") != m.end() && !m["CellHeight"].empty()) {
      cellHeight = make_shared<long>(boost::any_cast<long>(m["CellHeight"]));
    }
    if (m.find("CellWidth") != m.end() && !m["CellWidth"].empty()) {
      cellWidth = make_shared<long>(boost::any_cast<long>(m["CellWidth"]));
    }
    if (m.find("Color") != m.end() && !m["Color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["Color"]));
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      columns = make_shared<long>(boost::any_cast<long>(m["Columns"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<long>(boost::any_cast<long>(m["Lines"]));
    }
    if (m.find("Margin") != m.end() && !m["Margin"].empty()) {
      margin = make_shared<long>(boost::any_cast<long>(m["Margin"]));
    }
    if (m.find("Padding") != m.end() && !m["Padding"].empty()) {
      padding = make_shared<long>(boost::any_cast<long>(m["Padding"]));
    }
  }


  virtual ~SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig() = default;
};
class SubmitSnapshotJobRequestTemplateConfigOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<long> blackLevel{};
  shared_ptr<long> count{};
  shared_ptr<string> frameType{};
  shared_ptr<long> height{};
  shared_ptr<long> interval{};
  shared_ptr<bool> isSptFrag{};
  shared_ptr<long> pixelBlackThreshold{};
  shared_ptr<SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig> spriteSnapshotConfig{};
  shared_ptr<long> time{};
  shared_ptr<string> type{};
  shared_ptr<long> width{};

  SubmitSnapshotJobRequestTemplateConfigOverwriteParams() {}

  explicit SubmitSnapshotJobRequestTemplateConfigOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackLevel) {
      res["BlackLevel"] = boost::any(*blackLevel);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (frameType) {
      res["FrameType"] = boost::any(*frameType);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (isSptFrag) {
      res["IsSptFrag"] = boost::any(*isSptFrag);
    }
    if (pixelBlackThreshold) {
      res["PixelBlackThreshold"] = boost::any(*pixelBlackThreshold);
    }
    if (spriteSnapshotConfig) {
      res["SpriteSnapshotConfig"] = spriteSnapshotConfig ? boost::any(spriteSnapshotConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackLevel") != m.end() && !m["BlackLevel"].empty()) {
      blackLevel = make_shared<long>(boost::any_cast<long>(m["BlackLevel"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("FrameType") != m.end() && !m["FrameType"].empty()) {
      frameType = make_shared<string>(boost::any_cast<string>(m["FrameType"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IsSptFrag") != m.end() && !m["IsSptFrag"].empty()) {
      isSptFrag = make_shared<bool>(boost::any_cast<bool>(m["IsSptFrag"]));
    }
    if (m.find("PixelBlackThreshold") != m.end() && !m["PixelBlackThreshold"].empty()) {
      pixelBlackThreshold = make_shared<long>(boost::any_cast<long>(m["PixelBlackThreshold"]));
    }
    if (m.find("SpriteSnapshotConfig") != m.end() && !m["SpriteSnapshotConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpriteSnapshotConfig"].type()) {
        SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpriteSnapshotConfig"]));
        spriteSnapshotConfig = make_shared<SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig>(model1);
      }
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~SubmitSnapshotJobRequestTemplateConfigOverwriteParams() = default;
};
class SubmitSnapshotJobRequestTemplateConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitSnapshotJobRequestTemplateConfigOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitSnapshotJobRequestTemplateConfig() {}

  explicit SubmitSnapshotJobRequestTemplateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitSnapshotJobRequestTemplateConfigOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitSnapshotJobRequestTemplateConfigOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitSnapshotJobRequestTemplateConfig() = default;
};
class SubmitSnapshotJobRequest : public Darabonba::Model {
public:
  shared_ptr<SubmitSnapshotJobRequestInput> input{};
  shared_ptr<string> name{};
  shared_ptr<SubmitSnapshotJobRequestOutput> output{};
  shared_ptr<SubmitSnapshotJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<SubmitSnapshotJobRequestTemplateConfig> templateConfig{};
  shared_ptr<string> userData{};

  SubmitSnapshotJobRequest() {}

  explicit SubmitSnapshotJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitSnapshotJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitSnapshotJobRequestInput>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitSnapshotJobRequestOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitSnapshotJobRequestOutput>(model1);
      }
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitSnapshotJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitSnapshotJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        SubmitSnapshotJobRequestTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<SubmitSnapshotJobRequestTemplateConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSnapshotJobRequest() = default;
};
class SubmitSnapshotJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> outputShrink{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> templateConfigShrink{};
  shared_ptr<string> userData{};

  SubmitSnapshotJobShrinkRequest() {}

  explicit SubmitSnapshotJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputShrink) {
      res["Output"] = boost::any(*outputShrink);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (templateConfigShrink) {
      res["TemplateConfig"] = boost::any(*templateConfigShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      outputShrink = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfigShrink = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSnapshotJobShrinkRequest() = default;
};
class SubmitSnapshotJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitSnapshotJobResponseBody() {}

  explicit SubmitSnapshotJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBody() = default;
};
class SubmitSnapshotJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitSnapshotJobResponseBody> body{};

  SubmitSnapshotJobResponse() {}

  explicit SubmitSnapshotJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSnapshotJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSnapshotJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSnapshotJobResponse() = default;
};
class SubmitSubtitleProduceJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> editingConfig{};
  shared_ptr<string> inputConfig{};
  shared_ptr<long> isAsync{};
  shared_ptr<string> outputConfig{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<string> userData{};

  SubmitSubtitleProduceJobRequest() {}

  explicit SubmitSubtitleProduceJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (editingConfig) {
      res["EditingConfig"] = boost::any(*editingConfig);
    }
    if (inputConfig) {
      res["InputConfig"] = boost::any(*inputConfig);
    }
    if (isAsync) {
      res["IsAsync"] = boost::any(*isAsync);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      editingConfig = make_shared<string>(boost::any_cast<string>(m["EditingConfig"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      inputConfig = make_shared<string>(boost::any_cast<string>(m["InputConfig"]));
    }
    if (m.find("IsAsync") != m.end() && !m["IsAsync"].empty()) {
      isAsync = make_shared<long>(boost::any_cast<long>(m["IsAsync"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSubtitleProduceJobRequest() = default;
};
class SubmitSubtitleProduceJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitSubtitleProduceJobResponseBody() {}

  explicit SubmitSubtitleProduceJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitSubtitleProduceJobResponseBody() = default;
};
class SubmitSubtitleProduceJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitSubtitleProduceJobResponseBody> body{};

  SubmitSubtitleProduceJobResponse() {}

  explicit SubmitSubtitleProduceJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSubtitleProduceJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSubtitleProduceJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSubtitleProduceJobResponse() = default;
};
class SubmitSyncMediaInfoJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitSyncMediaInfoJobRequestInput() {}

  explicit SubmitSyncMediaInfoJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobRequestInput() = default;
};
class SubmitSyncMediaInfoJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitSyncMediaInfoJobRequestScheduleConfig() {}

  explicit SubmitSyncMediaInfoJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobRequestScheduleConfig() = default;
};
class SubmitSyncMediaInfoJobRequest : public Darabonba::Model {
public:
  shared_ptr<SubmitSyncMediaInfoJobRequestInput> input{};
  shared_ptr<string> name{};
  shared_ptr<SubmitSyncMediaInfoJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<string> userData{};

  SubmitSyncMediaInfoJobRequest() {}

  explicit SubmitSyncMediaInfoJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitSyncMediaInfoJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitSyncMediaInfoJobRequestInput>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitSyncMediaInfoJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitSyncMediaInfoJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobRequest() = default;
};
class SubmitSyncMediaInfoJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> userData{};

  SubmitSyncMediaInfoJobShrinkRequest() {}

  explicit SubmitSyncMediaInfoJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobShrinkRequest() = default;
};
class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput() {}

  explicit SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput() = default;
};
class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList() {}

  explicit SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList() = default;
};
class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo() {}

  explicit SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo() = default;
};
class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFps{};
  shared_ptr<string> bitRate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeBase{};
  shared_ptr<string> width{};

  SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList() {}

  explicit SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFps) {
      res["Avg_fps"] = boost::any(*avgFps);
    }
    if (bitRate) {
      res["Bit_rate"] = boost::any(*bitRate);
    }
    if (codecLongName) {
      res["Codec_long_name"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["Codec_name"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["Codec_tag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["Codec_tag_string"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["Codec_time_base"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["Has_b_frames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["Start_time"] = boost::any(*startTime);
    }
    if (timeBase) {
      res["Time_base"] = boost::any(*timeBase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avg_fps") != m.end() && !m["Avg_fps"].empty()) {
      avgFps = make_shared<string>(boost::any_cast<string>(m["Avg_fps"]));
    }
    if (m.find("Bit_rate") != m.end() && !m["Bit_rate"].empty()) {
      bitRate = make_shared<string>(boost::any_cast<string>(m["Bit_rate"]));
    }
    if (m.find("Codec_long_name") != m.end() && !m["Codec_long_name"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["Codec_long_name"]));
    }
    if (m.find("Codec_name") != m.end() && !m["Codec_name"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["Codec_name"]));
    }
    if (m.find("Codec_tag") != m.end() && !m["Codec_tag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["Codec_tag"]));
    }
    if (m.find("Codec_tag_string") != m.end() && !m["Codec_tag_string"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["Codec_tag_string"]));
    }
    if (m.find("Codec_time_base") != m.end() && !m["Codec_time_base"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["Codec_time_base"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Has_b_frames") != m.end() && !m["Has_b_frames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["Has_b_frames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Start_time") != m.end() && !m["Start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["Start_time"]));
    }
    if (m.find("Time_base") != m.end() && !m["Time_base"].empty()) {
      timeBase = make_shared<string>(boost::any_cast<string>(m["Time_base"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList() = default;
};
class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList>> videoStreamInfoList{};

  SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty() {}

  explicit SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo>(model1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty() = default;
};
class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig() {}

  explicit SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig() = default;
};
class SubmitSyncMediaInfoJobResponseBodyMediaInfoJob : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> finishTime{};
  shared_ptr<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty> mediaInfoProperty{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> submitResultJson{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  SubmitSyncMediaInfoJobResponseBodyMediaInfoJob() {}

  explicit SubmitSyncMediaInfoJobResponseBodyMediaInfoJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaInfoProperty) {
      res["MediaInfoProperty"] = mediaInfoProperty ? boost::any(mediaInfoProperty->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitResultJson) {
      res["SubmitResultJson"] = boost::any(*submitResultJson);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaInfoProperty") != m.end() && !m["MediaInfoProperty"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoProperty"].type()) {
        SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoProperty"]));
        mediaInfoProperty = make_shared<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitResultJson") != m.end() && !m["SubmitResultJson"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SubmitResultJson"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      submitResultJson = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponseBodyMediaInfoJob() = default;
};
class SubmitSyncMediaInfoJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitSyncMediaInfoJobResponseBodyMediaInfoJob> mediaInfoJob{};
  shared_ptr<string> requestId{};

  SubmitSyncMediaInfoJobResponseBody() {}

  explicit SubmitSyncMediaInfoJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfoJob) {
      res["MediaInfoJob"] = mediaInfoJob ? boost::any(mediaInfoJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfoJob") != m.end() && !m["MediaInfoJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoJob"].type()) {
        SubmitSyncMediaInfoJobResponseBodyMediaInfoJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoJob"]));
        mediaInfoJob = make_shared<SubmitSyncMediaInfoJobResponseBodyMediaInfoJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponseBody() = default;
};
class SubmitSyncMediaInfoJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitSyncMediaInfoJobResponseBody> body{};

  SubmitSyncMediaInfoJobResponse() {}

  explicit SubmitSyncMediaInfoJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSyncMediaInfoJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSyncMediaInfoJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponse() = default;
};
class SubmitTranscodeJobRequestInputGroup : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobRequestInputGroup() {}

  explicit SubmitTranscodeJobRequestInputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestInputGroup() = default;
};
class SubmitTranscodeJobRequestOutputGroupOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobRequestOutputGroupOutput() {}

  explicit SubmitTranscodeJobRequestOutputGroupOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupOutput() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile> file{};
  shared_ptr<string> height{};
  shared_ptr<string> referPos{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline> timeline{};
  shared_ptr<string> width{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile> file{};
  shared_ptr<string> format{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> adaptive{};
  shared_ptr<string> borderColor{};
  shared_ptr<long> borderWidth{};
  shared_ptr<string> content{};
  shared_ptr<string> fontAlpha{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<long> fontSize{};
  shared_ptr<string> left{};
  shared_ptr<string> top{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adaptive) {
      res["Adaptive"] = boost::any(*adaptive);
    }
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidth) {
      res["BorderWidth"] = boost::any(*borderWidth);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fontAlpha) {
      res["FontAlpha"] = boost::any(*fontAlpha);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSize) {
      res["FontSize"] = boost::any(*fontSize);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adaptive") != m.end() && !m["Adaptive"].empty()) {
      adaptive = make_shared<string>(boost::any_cast<string>(m["Adaptive"]));
    }
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidth") != m.end() && !m["BorderWidth"].empty()) {
      borderWidth = make_shared<long>(boost::any_cast<long>(m["BorderWidth"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FontAlpha") != m.end() && !m["FontAlpha"].empty()) {
      fontAlpha = make_shared<string>(boost::any_cast<string>(m["FontAlpha"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSize") != m.end() && !m["FontSize"].empty()) {
      fontSize = make_shared<long>(boost::any_cast<long>(m["FontSize"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> integratedLoudnessTarget{};
  shared_ptr<string> loudnessRangeTarget{};
  shared_ptr<string> method{};
  shared_ptr<string> truePeak{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedLoudnessTarget) {
      res["IntegratedLoudnessTarget"] = boost::any(*integratedLoudnessTarget);
    }
    if (loudnessRangeTarget) {
      res["LoudnessRangeTarget"] = boost::any(*loudnessRangeTarget);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (truePeak) {
      res["TruePeak"] = boost::any(*truePeak);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedLoudnessTarget") != m.end() && !m["IntegratedLoudnessTarget"].empty()) {
      integratedLoudnessTarget = make_shared<string>(boost::any_cast<string>(m["IntegratedLoudnessTarget"]));
    }
    if (m.find("LoudnessRangeTarget") != m.end() && !m["LoudnessRangeTarget"].empty()) {
      loudnessRangeTarget = make_shared<string>(boost::any_cast<string>(m["LoudnessRangeTarget"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("TruePeak") != m.end() && !m["TruePeak"].empty()) {
      truePeak = make_shared<string>(boost::any_cast<string>(m["TruePeak"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume> volume{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> forceSegTime{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (forceSegTime) {
      res["ForceSegTime"] = boost::any(*forceSegTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ForceSegTime") != m.end() && !m["ForceSegTime"].empty()) {
      forceSegTime = make_shared<string>(boost::any_cast<string>(m["ForceSegTime"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment> segment{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo : public Darabonba::Model {
public:
  shared_ptr<string> abrMax{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abrMax) {
      res["AbrMax"] = boost::any(*abrMax);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbrMax") != m.end() && !m["AbrMax"].empty()) {
      abrMax = make_shared<string>(boost::any_cast<string>(m["AbrMax"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio> audio{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer> container{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig> muxConfig{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo> video{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfig : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks>> imageWatermarks{};
  shared_ptr<vector<SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles>> subtitles{};
  shared_ptr<vector<SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks>> textWatermarks{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode> transcode{};

  SubmitTranscodeJobRequestOutputGroupProcessConfig() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*imageWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageWatermarks"] = boost::any(temp1);
    }
    if (subtitles) {
      vector<boost::any> temp1;
      for(auto item1:*subtitles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitles"] = boost::any(temp1);
    }
    if (textWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*textWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextWatermarks"] = boost::any(temp1);
    }
    if (transcode) {
      res["Transcode"] = transcode ? boost::any(transcode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageWatermarks") != m.end() && !m["ImageWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageWatermarks"].type()) {
        vector<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageWatermarks = make_shared<vector<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks>>(expect1);
      }
    }
    if (m.find("Subtitles") != m.end() && !m["Subtitles"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitles"].type()) {
        vector<SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitles = make_shared<vector<SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles>>(expect1);
      }
    }
    if (m.find("TextWatermarks") != m.end() && !m["TextWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["TextWatermarks"].type()) {
        vector<SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textWatermarks = make_shared<vector<SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks>>(expect1);
      }
    }
    if (m.find("Transcode") != m.end() && !m["Transcode"].empty()) {
      if (typeid(map<string, boost::any>) == m["Transcode"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Transcode"]));
        transcode = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfig() = default;
};
class SubmitTranscodeJobRequestOutputGroup : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobRequestOutputGroupOutput> output{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfig> processConfig{};

  SubmitTranscodeJobRequestOutputGroup() {}

  explicit SubmitTranscodeJobRequestOutputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (processConfig) {
      res["ProcessConfig"] = processConfig ? boost::any(processConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitTranscodeJobRequestOutputGroupOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitTranscodeJobRequestOutputGroupOutput>(model1);
      }
    }
    if (m.find("ProcessConfig") != m.end() && !m["ProcessConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProcessConfig"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProcessConfig"]));
        processConfig = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfig>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroup() = default;
};
class SubmitTranscodeJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitTranscodeJobRequestScheduleConfig() {}

  explicit SubmitTranscodeJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestScheduleConfig() = default;
};
class SubmitTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitTranscodeJobRequestInputGroup>> inputGroup{};
  shared_ptr<string> name{};
  shared_ptr<vector<SubmitTranscodeJobRequestOutputGroup>> outputGroup{};
  shared_ptr<SubmitTranscodeJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<string> userData{};

  SubmitTranscodeJobRequest() {}

  explicit SubmitTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*inputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputGroup"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroup"] = boost::any(temp1);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputGroup") != m.end() && !m["InputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["InputGroup"].type()) {
        vector<SubmitTranscodeJobRequestInputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobRequestInputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputGroup = make_shared<vector<SubmitTranscodeJobRequestInputGroup>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputGroup") != m.end() && !m["OutputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroup"].type()) {
        vector<SubmitTranscodeJobRequestOutputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobRequestOutputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroup = make_shared<vector<SubmitTranscodeJobRequestOutputGroup>>(expect1);
      }
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitTranscodeJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitTranscodeJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitTranscodeJobRequest() = default;
};
class SubmitTranscodeJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputGroupShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> outputGroupShrink{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> userData{};

  SubmitTranscodeJobShrinkRequest() {}

  explicit SubmitTranscodeJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputGroupShrink) {
      res["InputGroup"] = boost::any(*inputGroupShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputGroupShrink) {
      res["OutputGroup"] = boost::any(*outputGroupShrink);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputGroup") != m.end() && !m["InputGroup"].empty()) {
      inputGroupShrink = make_shared<string>(boost::any_cast<string>(m["InputGroup"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputGroup") != m.end() && !m["OutputGroup"].empty()) {
      outputGroupShrink = make_shared<string>(boost::any_cast<string>(m["OutputGroup"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitTranscodeJobShrinkRequest() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile> file{};
  shared_ptr<string> height{};
  shared_ptr<string> referPos{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline> timeline{};
  shared_ptr<string> width{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile> file{};
  shared_ptr<string> format{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> adaptive{};
  shared_ptr<string> borderColor{};
  shared_ptr<long> borderWidth{};
  shared_ptr<string> content{};
  shared_ptr<string> fontAlpha{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<long> fontSize{};
  shared_ptr<string> left{};
  shared_ptr<string> top{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adaptive) {
      res["Adaptive"] = boost::any(*adaptive);
    }
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidth) {
      res["BorderWidth"] = boost::any(*borderWidth);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fontAlpha) {
      res["FontAlpha"] = boost::any(*fontAlpha);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSize) {
      res["FontSize"] = boost::any(*fontSize);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adaptive") != m.end() && !m["Adaptive"].empty()) {
      adaptive = make_shared<string>(boost::any_cast<string>(m["Adaptive"]));
    }
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidth") != m.end() && !m["BorderWidth"].empty()) {
      borderWidth = make_shared<long>(boost::any_cast<long>(m["BorderWidth"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FontAlpha") != m.end() && !m["FontAlpha"].empty()) {
      fontAlpha = make_shared<string>(boost::any_cast<string>(m["FontAlpha"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSize") != m.end() && !m["FontSize"].empty()) {
      fontSize = make_shared<long>(boost::any_cast<long>(m["FontSize"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> integratedLoudnessTarget{};
  shared_ptr<string> loudnessRangeTarget{};
  shared_ptr<string> method{};
  shared_ptr<string> truePeak{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedLoudnessTarget) {
      res["IntegratedLoudnessTarget"] = boost::any(*integratedLoudnessTarget);
    }
    if (loudnessRangeTarget) {
      res["LoudnessRangeTarget"] = boost::any(*loudnessRangeTarget);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (truePeak) {
      res["TruePeak"] = boost::any(*truePeak);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedLoudnessTarget") != m.end() && !m["IntegratedLoudnessTarget"].empty()) {
      integratedLoudnessTarget = make_shared<string>(boost::any_cast<string>(m["IntegratedLoudnessTarget"]));
    }
    if (m.find("LoudnessRangeTarget") != m.end() && !m["LoudnessRangeTarget"].empty()) {
      loudnessRangeTarget = make_shared<string>(boost::any_cast<string>(m["LoudnessRangeTarget"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("TruePeak") != m.end() && !m["TruePeak"].empty()) {
      truePeak = make_shared<string>(boost::any_cast<string>(m["TruePeak"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume> volume{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> forceSegTime{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (forceSegTime) {
      res["ForceSegTime"] = boost::any(*forceSegTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ForceSegTime") != m.end() && !m["ForceSegTime"].empty()) {
      forceSegTime = make_shared<string>(boost::any_cast<string>(m["ForceSegTime"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment> segment{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo : public Darabonba::Model {
public:
  shared_ptr<string> abrMax{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abrMax) {
      res["AbrMax"] = boost::any(*abrMax);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbrMax") != m.end() && !m["AbrMax"].empty()) {
      abrMax = make_shared<string>(boost::any_cast<string>(m["AbrMax"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio> audio{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer> container{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig> muxConfig{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo> video{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks>> imageWatermarks{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles>> subtitles{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks>> textWatermarks{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode> transcode{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*imageWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageWatermarks"] = boost::any(temp1);
    }
    if (subtitles) {
      vector<boost::any> temp1;
      for(auto item1:*subtitles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitles"] = boost::any(temp1);
    }
    if (textWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*textWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextWatermarks"] = boost::any(temp1);
    }
    if (transcode) {
      res["Transcode"] = transcode ? boost::any(transcode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageWatermarks") != m.end() && !m["ImageWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageWatermarks"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageWatermarks = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks>>(expect1);
      }
    }
    if (m.find("Subtitles") != m.end() && !m["Subtitles"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitles"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitles = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles>>(expect1);
      }
    }
    if (m.find("TextWatermarks") != m.end() && !m["TextWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["TextWatermarks"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textWatermarks = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks>>(expect1);
      }
    }
    if (m.find("Transcode") != m.end() && !m["Transcode"].empty()) {
      if (typeid(map<string, boost::any>) == m["Transcode"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Transcode"]));
        transcode = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput> output{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig> processConfig{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (processConfig) {
      res["ProcessConfig"] = processConfig ? boost::any(processConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput>(model1);
      }
    }
    if (m.find("ProcessConfig") != m.end() && !m["ProcessConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProcessConfig"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProcessConfig"]));
        processConfig = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFps{};
  shared_ptr<string> bitRate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeBase{};
  shared_ptr<string> width{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFps) {
      res["Avg_fps"] = boost::any(*avgFps);
    }
    if (bitRate) {
      res["Bit_rate"] = boost::any(*bitRate);
    }
    if (codecLongName) {
      res["Codec_long_name"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["Codec_name"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["Codec_tag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["Codec_tag_string"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["Codec_time_base"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["Has_b_frames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["Start_time"] = boost::any(*startTime);
    }
    if (timeBase) {
      res["Time_base"] = boost::any(*timeBase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avg_fps") != m.end() && !m["Avg_fps"].empty()) {
      avgFps = make_shared<string>(boost::any_cast<string>(m["Avg_fps"]));
    }
    if (m.find("Bit_rate") != m.end() && !m["Bit_rate"].empty()) {
      bitRate = make_shared<string>(boost::any_cast<string>(m["Bit_rate"]));
    }
    if (m.find("Codec_long_name") != m.end() && !m["Codec_long_name"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["Codec_long_name"]));
    }
    if (m.find("Codec_name") != m.end() && !m["Codec_name"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["Codec_name"]));
    }
    if (m.find("Codec_tag") != m.end() && !m["Codec_tag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["Codec_tag"]));
    }
    if (m.find("Codec_tag_string") != m.end() && !m["Codec_tag_string"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["Codec_tag_string"]));
    }
    if (m.find("Codec_time_base") != m.end() && !m["Codec_time_base"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["Codec_time_base"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Has_b_frames") != m.end() && !m["Has_b_frames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["Has_b_frames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Start_time") != m.end() && !m["Start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["Start_time"]));
    }
    if (m.find("Time_base") != m.end() && !m["Time_base"].empty()) {
      timeBase = make_shared<string>(boost::any_cast<string>(m["Time_base"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList>> videoStreamInfoList{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo>(model1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile> file{};
  shared_ptr<string> height{};
  shared_ptr<string> referPos{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline> timeline{};
  shared_ptr<string> width{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile> file{};
  shared_ptr<string> format{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> adaptive{};
  shared_ptr<string> borderColor{};
  shared_ptr<long> borderWidth{};
  shared_ptr<string> content{};
  shared_ptr<string> fontAlpha{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<long> fontSize{};
  shared_ptr<string> left{};
  shared_ptr<string> top{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adaptive) {
      res["Adaptive"] = boost::any(*adaptive);
    }
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidth) {
      res["BorderWidth"] = boost::any(*borderWidth);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fontAlpha) {
      res["FontAlpha"] = boost::any(*fontAlpha);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSize) {
      res["FontSize"] = boost::any(*fontSize);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adaptive") != m.end() && !m["Adaptive"].empty()) {
      adaptive = make_shared<string>(boost::any_cast<string>(m["Adaptive"]));
    }
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidth") != m.end() && !m["BorderWidth"].empty()) {
      borderWidth = make_shared<long>(boost::any_cast<long>(m["BorderWidth"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FontAlpha") != m.end() && !m["FontAlpha"].empty()) {
      fontAlpha = make_shared<string>(boost::any_cast<string>(m["FontAlpha"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSize") != m.end() && !m["FontSize"].empty()) {
      fontSize = make_shared<long>(boost::any_cast<long>(m["FontSize"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> integratedLoudnessTarget{};
  shared_ptr<string> loudnessRangeTarget{};
  shared_ptr<string> method{};
  shared_ptr<string> truePeak{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedLoudnessTarget) {
      res["IntegratedLoudnessTarget"] = boost::any(*integratedLoudnessTarget);
    }
    if (loudnessRangeTarget) {
      res["LoudnessRangeTarget"] = boost::any(*loudnessRangeTarget);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (truePeak) {
      res["TruePeak"] = boost::any(*truePeak);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedLoudnessTarget") != m.end() && !m["IntegratedLoudnessTarget"].empty()) {
      integratedLoudnessTarget = make_shared<string>(boost::any_cast<string>(m["IntegratedLoudnessTarget"]));
    }
    if (m.find("LoudnessRangeTarget") != m.end() && !m["LoudnessRangeTarget"].empty()) {
      loudnessRangeTarget = make_shared<string>(boost::any_cast<string>(m["LoudnessRangeTarget"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("TruePeak") != m.end() && !m["TruePeak"].empty()) {
      truePeak = make_shared<string>(boost::any_cast<string>(m["TruePeak"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume> volume{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> forceSegTime{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (forceSegTime) {
      res["ForceSegTime"] = boost::any(*forceSegTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ForceSegTime") != m.end() && !m["ForceSegTime"].empty()) {
      forceSegTime = make_shared<string>(boost::any_cast<string>(m["ForceSegTime"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment> segment{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo : public Darabonba::Model {
public:
  shared_ptr<string> abrMax{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abrMax) {
      res["AbrMax"] = boost::any(*abrMax);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbrMax") != m.end() && !m["AbrMax"].empty()) {
      abrMax = make_shared<string>(boost::any_cast<string>(m["AbrMax"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio> audio{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer> container{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig> muxConfig{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo> video{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks>> imageWatermarks{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles>> subtitles{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks>> textWatermarks{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode> transcode{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*imageWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageWatermarks"] = boost::any(temp1);
    }
    if (subtitles) {
      vector<boost::any> temp1;
      for(auto item1:*subtitles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitles"] = boost::any(temp1);
    }
    if (textWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*textWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextWatermarks"] = boost::any(temp1);
    }
    if (transcode) {
      res["Transcode"] = transcode ? boost::any(transcode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageWatermarks") != m.end() && !m["ImageWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageWatermarks"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageWatermarks = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks>>(expect1);
      }
    }
    if (m.find("Subtitles") != m.end() && !m["Subtitles"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitles"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitles = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles>>(expect1);
      }
    }
    if (m.find("TextWatermarks") != m.end() && !m["TextWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["TextWatermarks"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textWatermarks = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks>>(expect1);
      }
    }
    if (m.find("Transcode") != m.end() && !m["Transcode"].empty()) {
      if (typeid(map<string, boost::any>) == m["Transcode"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Transcode"]));
        transcode = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup>> inputGroup{};
  shared_ptr<string> jobId{};
  shared_ptr<long> jobIndex{};
  shared_ptr<string> name{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta> outFileMeta{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput> output{};
  shared_ptr<string> parentJobId{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig> processConfig{};
  shared_ptr<string> requestId{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> submitResultJson{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> userData{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (inputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*inputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputGroup"] = boost::any(temp1);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobIndex) {
      res["JobIndex"] = boost::any(*jobIndex);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outFileMeta) {
      res["OutFileMeta"] = outFileMeta ? boost::any(outFileMeta->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentJobId) {
      res["ParentJobId"] = boost::any(*parentJobId);
    }
    if (processConfig) {
      res["ProcessConfig"] = processConfig ? boost::any(processConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitResultJson) {
      res["SubmitResultJson"] = boost::any(*submitResultJson);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("InputGroup") != m.end() && !m["InputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["InputGroup"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputGroup = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup>>(expect1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobIndex") != m.end() && !m["JobIndex"].empty()) {
      jobIndex = make_shared<long>(boost::any_cast<long>(m["JobIndex"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutFileMeta") != m.end() && !m["OutFileMeta"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutFileMeta"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutFileMeta"]));
        outFileMeta = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta>(model1);
      }
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput>(model1);
      }
    }
    if (m.find("ParentJobId") != m.end() && !m["ParentJobId"].empty()) {
      parentJobId = make_shared<string>(boost::any_cast<string>(m["ParentJobId"]));
    }
    if (m.find("ProcessConfig") != m.end() && !m["ProcessConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProcessConfig"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProcessConfig"]));
        processConfig = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitResultJson") != m.end() && !m["SubmitResultJson"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SubmitResultJson"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      submitResultJson = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJob : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup>> inputGroup{};
  shared_ptr<long> jobCount{};
  shared_ptr<string> name{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup>> outputGroup{};
  shared_ptr<string> parentJobId{};
  shared_ptr<long> percent{};
  shared_ptr<string> requestId{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList>> transcodeJobList{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  SubmitTranscodeJobResponseBodyTranscodeParentJob() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (inputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*inputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputGroup"] = boost::any(temp1);
    }
    if (jobCount) {
      res["JobCount"] = boost::any(*jobCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroup"] = boost::any(temp1);
    }
    if (parentJobId) {
      res["ParentJobId"] = boost::any(*parentJobId);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (transcodeJobList) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeJobList"] = boost::any(temp1);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("InputGroup") != m.end() && !m["InputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["InputGroup"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputGroup = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup>>(expect1);
      }
    }
    if (m.find("JobCount") != m.end() && !m["JobCount"].empty()) {
      jobCount = make_shared<long>(boost::any_cast<long>(m["JobCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputGroup") != m.end() && !m["OutputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroup"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroup = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup>>(expect1);
      }
    }
    if (m.find("ParentJobId") != m.end() && !m["ParentJobId"].empty()) {
      parentJobId = make_shared<string>(boost::any_cast<string>(m["ParentJobId"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TranscodeJobList") != m.end() && !m["TranscodeJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeJobList"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeJobList = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList>>(expect1);
      }
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJob() = default;
};
class SubmitTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJob> transcodeParentJob{};

  SubmitTranscodeJobResponseBody() {}

  explicit SubmitTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transcodeParentJob) {
      res["TranscodeParentJob"] = transcodeParentJob ? boost::any(transcodeParentJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TranscodeParentJob") != m.end() && !m["TranscodeParentJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeParentJob"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeParentJob"]));
        transcodeParentJob = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJob>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBody() = default;
};
class SubmitTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitTranscodeJobResponseBody> body{};

  SubmitTranscodeJobResponse() {}

  explicit SubmitTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponse() = default;
};
class UpdateCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};

  UpdateCategoryRequest() {}

  explicit UpdateCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
  }


  virtual ~UpdateCategoryRequest() = default;
};
class UpdateCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCategoryResponseBody() {}

  explicit UpdateCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCategoryResponseBody() = default;
};
class UpdateCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCategoryResponseBody> body{};

  UpdateCategoryResponse() {}

  explicit UpdateCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCategoryResponse() = default;
};
class UpdateCustomTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};

  UpdateCustomTemplateRequest() {}

  explicit UpdateCustomTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateCustomTemplateRequest() = default;
};
class UpdateCustomTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCustomTemplateResponseBody() {}

  explicit UpdateCustomTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCustomTemplateResponseBody() = default;
};
class UpdateCustomTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCustomTemplateResponseBody> body{};

  UpdateCustomTemplateResponse() {}

  explicit UpdateCustomTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCustomTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCustomTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCustomTemplateResponse() = default;
};
class UpdateEditingProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessStatus{};
  shared_ptr<string> clipsParam{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> projectId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> timeline{};
  shared_ptr<string> title{};

  UpdateEditingProjectRequest() {}

  explicit UpdateEditingProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateEditingProjectRequest() = default;
};
class UpdateEditingProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateEditingProjectResponseBody() {}

  explicit UpdateEditingProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateEditingProjectResponseBody() = default;
};
class UpdateEditingProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEditingProjectResponseBody> body{};

  UpdateEditingProjectResponse() {}

  explicit UpdateEditingProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEditingProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEditingProjectResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEditingProjectResponse() = default;
};
class UpdateLiveRecordTemplateRequestRecordFormat : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<long> sliceDuration{};
  shared_ptr<string> sliceOssObjectPrefix{};

  UpdateLiveRecordTemplateRequestRecordFormat() {}

  explicit UpdateLiveRecordTemplateRequestRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~UpdateLiveRecordTemplateRequestRecordFormat() = default;
};
class UpdateLiveRecordTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<vector<UpdateLiveRecordTemplateRequestRecordFormat>> recordFormat{};
  shared_ptr<string> templateId{};

  UpdateLiveRecordTemplateRequest() {}

  explicit UpdateLiveRecordTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordFormat) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormat"] = boost::any(temp1);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormat"].type()) {
        vector<UpdateLiveRecordTemplateRequestRecordFormat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateLiveRecordTemplateRequestRecordFormat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormat = make_shared<vector<UpdateLiveRecordTemplateRequestRecordFormat>>(expect1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateLiveRecordTemplateRequest() = default;
};
class UpdateLiveRecordTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> recordFormatShrink{};
  shared_ptr<string> templateId{};

  UpdateLiveRecordTemplateShrinkRequest() {}

  explicit UpdateLiveRecordTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordFormatShrink) {
      res["RecordFormat"] = boost::any(*recordFormatShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      recordFormatShrink = make_shared<string>(boost::any_cast<string>(m["RecordFormat"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateLiveRecordTemplateShrinkRequest() = default;
};
class UpdateLiveRecordTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveRecordTemplateResponseBody() {}

  explicit UpdateLiveRecordTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveRecordTemplateResponseBody() = default;
};
class UpdateLiveRecordTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveRecordTemplateResponseBody> body{};

  UpdateLiveRecordTemplateResponse() {}

  explicit UpdateLiveRecordTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveRecordTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveRecordTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveRecordTemplateResponse() = default;
};
class UpdateLiveSnapshotTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> overwriteFormat{};
  shared_ptr<string> sequenceFormat{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> timeInterval{};

  UpdateLiveSnapshotTemplateRequest() {}

  explicit UpdateLiveSnapshotTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteFormat) {
      res["OverwriteFormat"] = boost::any(*overwriteFormat);
    }
    if (sequenceFormat) {
      res["SequenceFormat"] = boost::any(*sequenceFormat);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteFormat") != m.end() && !m["OverwriteFormat"].empty()) {
      overwriteFormat = make_shared<string>(boost::any_cast<string>(m["OverwriteFormat"]));
    }
    if (m.find("SequenceFormat") != m.end() && !m["SequenceFormat"].empty()) {
      sequenceFormat = make_shared<string>(boost::any_cast<string>(m["SequenceFormat"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
  }


  virtual ~UpdateLiveSnapshotTemplateRequest() = default;
};
class UpdateLiveSnapshotTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveSnapshotTemplateResponseBody() {}

  explicit UpdateLiveSnapshotTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveSnapshotTemplateResponseBody() = default;
};
class UpdateLiveSnapshotTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveSnapshotTemplateResponseBody> body{};

  UpdateLiveSnapshotTemplateResponse() {}

  explicit UpdateLiveSnapshotTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveSnapshotTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveSnapshotTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveSnapshotTemplateResponse() = default;
};
class UpdateLiveTranscodeJobRequestStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> inputUrl{};
  shared_ptr<string> type{};

  UpdateLiveTranscodeJobRequestStreamInput() {}

  explicit UpdateLiveTranscodeJobRequestStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputUrl) {
      res["InputUrl"] = boost::any(*inputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputUrl") != m.end() && !m["InputUrl"].empty()) {
      inputUrl = make_shared<string>(boost::any_cast<string>(m["InputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateLiveTranscodeJobRequestStreamInput() = default;
};
class UpdateLiveTranscodeJobRequestTimedConfig : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  UpdateLiveTranscodeJobRequestTimedConfig() {}

  explicit UpdateLiveTranscodeJobRequestTimedConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~UpdateLiveTranscodeJobRequestTimedConfig() = default;
};
class UpdateLiveTranscodeJobRequestTranscodeOutput : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> type{};

  UpdateLiveTranscodeJobRequestTranscodeOutput() {}

  explicit UpdateLiveTranscodeJobRequestTranscodeOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateLiveTranscodeJobRequestTranscodeOutput() = default;
};
class UpdateLiveTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<UpdateLiveTranscodeJobRequestStreamInput> streamInput{};
  shared_ptr<UpdateLiveTranscodeJobRequestTimedConfig> timedConfig{};
  shared_ptr<UpdateLiveTranscodeJobRequestTranscodeOutput> transcodeOutput{};

  UpdateLiveTranscodeJobRequest() {}

  explicit UpdateLiveTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timedConfig) {
      res["TimedConfig"] = timedConfig ? boost::any(timedConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transcodeOutput) {
      res["TranscodeOutput"] = transcodeOutput ? boost::any(transcodeOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        UpdateLiveTranscodeJobRequestStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<UpdateLiveTranscodeJobRequestStreamInput>(model1);
      }
    }
    if (m.find("TimedConfig") != m.end() && !m["TimedConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimedConfig"].type()) {
        UpdateLiveTranscodeJobRequestTimedConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimedConfig"]));
        timedConfig = make_shared<UpdateLiveTranscodeJobRequestTimedConfig>(model1);
      }
    }
    if (m.find("TranscodeOutput") != m.end() && !m["TranscodeOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeOutput"].type()) {
        UpdateLiveTranscodeJobRequestTranscodeOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeOutput"]));
        transcodeOutput = make_shared<UpdateLiveTranscodeJobRequestTranscodeOutput>(model1);
      }
    }
  }


  virtual ~UpdateLiveTranscodeJobRequest() = default;
};
class UpdateLiveTranscodeJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<string> streamInputShrink{};
  shared_ptr<string> timedConfigShrink{};
  shared_ptr<string> transcodeOutputShrink{};

  UpdateLiveTranscodeJobShrinkRequest() {}

  explicit UpdateLiveTranscodeJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (streamInputShrink) {
      res["StreamInput"] = boost::any(*streamInputShrink);
    }
    if (timedConfigShrink) {
      res["TimedConfig"] = boost::any(*timedConfigShrink);
    }
    if (transcodeOutputShrink) {
      res["TranscodeOutput"] = boost::any(*transcodeOutputShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      streamInputShrink = make_shared<string>(boost::any_cast<string>(m["StreamInput"]));
    }
    if (m.find("TimedConfig") != m.end() && !m["TimedConfig"].empty()) {
      timedConfigShrink = make_shared<string>(boost::any_cast<string>(m["TimedConfig"]));
    }
    if (m.find("TranscodeOutput") != m.end() && !m["TranscodeOutput"].empty()) {
      transcodeOutputShrink = make_shared<string>(boost::any_cast<string>(m["TranscodeOutput"]));
    }
  }


  virtual ~UpdateLiveTranscodeJobShrinkRequest() = default;
};
class UpdateLiveTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveTranscodeJobResponseBody() {}

  explicit UpdateLiveTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveTranscodeJobResponseBody() = default;
};
class UpdateLiveTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveTranscodeJobResponseBody> body{};

  UpdateLiveTranscodeJobResponse() {}

  explicit UpdateLiveTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveTranscodeJobResponse() = default;
};
class UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> samplerate{};

  UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams() {}

  explicit UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams() = default;
};
class UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> codec{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> profile{};
  shared_ptr<string> width{};

  UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams() {}

  explicit UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams() = default;
};
class UpdateLiveTranscodeTemplateRequestTemplateConfig : public Darabonba::Model {
public:
  shared_ptr<UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams> audioParams{};
  shared_ptr<UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams> videoParams{};

  UpdateLiveTranscodeTemplateRequestTemplateConfig() {}

  explicit UpdateLiveTranscodeTemplateRequestTemplateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioParams) {
      res["AudioParams"] = audioParams ? boost::any(audioParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoParams) {
      res["VideoParams"] = videoParams ? boost::any(videoParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioParams") != m.end() && !m["AudioParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioParams"].type()) {
        UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioParams"]));
        audioParams = make_shared<UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams>(model1);
      }
    }
    if (m.find("VideoParams") != m.end() && !m["VideoParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoParams"].type()) {
        UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoParams"]));
        videoParams = make_shared<UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams>(model1);
      }
    }
  }


  virtual ~UpdateLiveTranscodeTemplateRequestTemplateConfig() = default;
};
class UpdateLiveTranscodeTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<UpdateLiveTranscodeTemplateRequestTemplateConfig> templateConfig{};
  shared_ptr<string> templateId{};

  UpdateLiveTranscodeTemplateRequest() {}

  explicit UpdateLiveTranscodeTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        UpdateLiveTranscodeTemplateRequestTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<UpdateLiveTranscodeTemplateRequestTemplateConfig>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateLiveTranscodeTemplateRequest() = default;
};
class UpdateLiveTranscodeTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> templateConfigShrink{};
  shared_ptr<string> templateId{};

  UpdateLiveTranscodeTemplateShrinkRequest() {}

  explicit UpdateLiveTranscodeTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfigShrink) {
      res["TemplateConfig"] = boost::any(*templateConfigShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfigShrink = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateLiveTranscodeTemplateShrinkRequest() = default;
};
class UpdateLiveTranscodeTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveTranscodeTemplateResponseBody() {}

  explicit UpdateLiveTranscodeTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveTranscodeTemplateResponseBody() = default;
};
class UpdateLiveTranscodeTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveTranscodeTemplateResponseBody> body{};

  UpdateLiveTranscodeTemplateResponse() {}

  explicit UpdateLiveTranscodeTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveTranscodeTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveTranscodeTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveTranscodeTemplateResponse() = default;
};
class UpdateMediaInfoRequest : public Darabonba::Model {
public:
  shared_ptr<bool> appendTags{};
  shared_ptr<string> businessType{};
  shared_ptr<long> cateId{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  UpdateMediaInfoRequest() {}

  explicit UpdateMediaInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appendTags) {
      res["AppendTags"] = boost::any(*appendTags);
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppendTags") != m.end() && !m["AppendTags"].empty()) {
      appendTags = make_shared<bool>(boost::any_cast<bool>(m["AppendTags"]));
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~UpdateMediaInfoRequest() = default;
};
class UpdateMediaInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};

  UpdateMediaInfoResponseBody() {}

  explicit UpdateMediaInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaInfoResponseBody() = default;
};
class UpdateMediaInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaInfoResponseBody> body{};

  UpdateMediaInfoResponse() {}

  explicit UpdateMediaInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaInfoResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaInfoResponse() = default;
};
class UpdatePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};
  shared_ptr<string> status{};

  UpdatePipelineRequest() {}

  explicit UpdatePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdatePipelineRequest() = default;
};
class UpdatePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdatePipelineResponseBody() {}

  explicit UpdatePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdatePipelineResponseBody() = default;
};
class UpdatePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePipelineResponseBody> body{};

  UpdatePipelineResponse() {}

  explicit UpdatePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePipelineResponse() = default;
};
class UpdateSmartJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> FEExtend{};
  shared_ptr<string> jobId{};

  UpdateSmartJobRequest() {}

  explicit UpdateSmartJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (FEExtend) {
      res["FEExtend"] = boost::any(*FEExtend);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FEExtend") != m.end() && !m["FEExtend"].empty()) {
      FEExtend = make_shared<string>(boost::any_cast<string>(m["FEExtend"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~UpdateSmartJobRequest() = default;
};
class UpdateSmartJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> FEExtend{};
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  UpdateSmartJobResponseBody() {}

  explicit UpdateSmartJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (FEExtend) {
      res["FEExtend"] = boost::any(*FEExtend);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FEExtend") != m.end() && !m["FEExtend"].empty()) {
      FEExtend = make_shared<string>(boost::any_cast<string>(m["FEExtend"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSmartJobResponseBody() = default;
};
class UpdateSmartJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSmartJobResponseBody> body{};

  UpdateSmartJobResponse() {}

  explicit UpdateSmartJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSmartJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSmartJobResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSmartJobResponse() = default;
};
class UpdateTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> coverUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> previewMedia{};
  shared_ptr<string> relatedMediaids{};
  shared_ptr<string> source{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};

  UpdateTemplateRequest() {}

  explicit UpdateTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (previewMedia) {
      res["PreviewMedia"] = boost::any(*previewMedia);
    }
    if (relatedMediaids) {
      res["RelatedMediaids"] = boost::any(*relatedMediaids);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PreviewMedia") != m.end() && !m["PreviewMedia"].empty()) {
      previewMedia = make_shared<string>(boost::any_cast<string>(m["PreviewMedia"]));
    }
    if (m.find("RelatedMediaids") != m.end() && !m["RelatedMediaids"].empty()) {
      relatedMediaids = make_shared<string>(boost::any_cast<string>(m["RelatedMediaids"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateTemplateRequest() = default;
};
class UpdateTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateTemplateResponseBody() {}

  explicit UpdateTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateTemplateResponseBody() = default;
};
class UpdateTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTemplateResponseBody> body{};

  UpdateTemplateResponse() {}

  explicit UpdateTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTemplateResponse() = default;
};
class UploadMediaByURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> entityId{};
  shared_ptr<string> mediaMetaData{};
  shared_ptr<string> postProcessConfig{};
  shared_ptr<string> uploadTargetConfig{};
  shared_ptr<string> uploadURLs{};
  shared_ptr<string> userData{};

  UploadMediaByURLRequest() {}

  explicit UploadMediaByURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (mediaMetaData) {
      res["MediaMetaData"] = boost::any(*mediaMetaData);
    }
    if (postProcessConfig) {
      res["PostProcessConfig"] = boost::any(*postProcessConfig);
    }
    if (uploadTargetConfig) {
      res["UploadTargetConfig"] = boost::any(*uploadTargetConfig);
    }
    if (uploadURLs) {
      res["UploadURLs"] = boost::any(*uploadURLs);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("MediaMetaData") != m.end() && !m["MediaMetaData"].empty()) {
      mediaMetaData = make_shared<string>(boost::any_cast<string>(m["MediaMetaData"]));
    }
    if (m.find("PostProcessConfig") != m.end() && !m["PostProcessConfig"].empty()) {
      postProcessConfig = make_shared<string>(boost::any_cast<string>(m["PostProcessConfig"]));
    }
    if (m.find("UploadTargetConfig") != m.end() && !m["UploadTargetConfig"].empty()) {
      uploadTargetConfig = make_shared<string>(boost::any_cast<string>(m["UploadTargetConfig"]));
    }
    if (m.find("UploadURLs") != m.end() && !m["UploadURLs"].empty()) {
      uploadURLs = make_shared<string>(boost::any_cast<string>(m["UploadURLs"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~UploadMediaByURLRequest() = default;
};
class UploadMediaByURLResponseBodyUploadJobs : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> sourceURL{};

  UploadMediaByURLResponseBodyUploadJobs() {}

  explicit UploadMediaByURLResponseBodyUploadJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (sourceURL) {
      res["SourceURL"] = boost::any(*sourceURL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("SourceURL") != m.end() && !m["SourceURL"].empty()) {
      sourceURL = make_shared<string>(boost::any_cast<string>(m["SourceURL"]));
    }
  }


  virtual ~UploadMediaByURLResponseBodyUploadJobs() = default;
};
class UploadMediaByURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<UploadMediaByURLResponseBodyUploadJobs>> uploadJobs{};

  UploadMediaByURLResponseBody() {}

  explicit UploadMediaByURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadJobs) {
      vector<boost::any> temp1;
      for(auto item1:*uploadJobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UploadJobs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadJobs") != m.end() && !m["UploadJobs"].empty()) {
      if (typeid(vector<boost::any>) == m["UploadJobs"].type()) {
        vector<UploadMediaByURLResponseBodyUploadJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UploadJobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UploadMediaByURLResponseBodyUploadJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        uploadJobs = make_shared<vector<UploadMediaByURLResponseBodyUploadJobs>>(expect1);
      }
    }
  }


  virtual ~UploadMediaByURLResponseBody() = default;
};
class UploadMediaByURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadMediaByURLResponseBody> body{};

  UploadMediaByURLResponse() {}

  explicit UploadMediaByURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadMediaByURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadMediaByURLResponseBody>(model1);
      }
    }
  }


  virtual ~UploadMediaByURLResponse() = default;
};
class UploadStreamByURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> definition{};
  shared_ptr<string> fileExtension{};
  shared_ptr<string> HDRType{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> streamURL{};
  shared_ptr<string> userData{};

  UploadStreamByURLRequest() {}

  explicit UploadStreamByURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (fileExtension) {
      res["FileExtension"] = boost::any(*fileExtension);
    }
    if (HDRType) {
      res["HDRType"] = boost::any(*HDRType);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (streamURL) {
      res["StreamURL"] = boost::any(*streamURL);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("FileExtension") != m.end() && !m["FileExtension"].empty()) {
      fileExtension = make_shared<string>(boost::any_cast<string>(m["FileExtension"]));
    }
    if (m.find("HDRType") != m.end() && !m["HDRType"].empty()) {
      HDRType = make_shared<string>(boost::any_cast<string>(m["HDRType"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("StreamURL") != m.end() && !m["StreamURL"].empty()) {
      streamURL = make_shared<string>(boost::any_cast<string>(m["StreamURL"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~UploadStreamByURLRequest() = default;
};
class UploadStreamByURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fileURL{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sourceURL{};

  UploadStreamByURLResponseBody() {}

  explicit UploadStreamByURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceURL) {
      res["SourceURL"] = boost::any(*sourceURL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceURL") != m.end() && !m["SourceURL"].empty()) {
      sourceURL = make_shared<string>(boost::any_cast<string>(m["SourceURL"]));
    }
  }


  virtual ~UploadStreamByURLResponseBody() = default;
};
class UploadStreamByURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadStreamByURLResponseBody> body{};

  UploadStreamByURLResponse() {}

  explicit UploadStreamByURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadStreamByURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadStreamByURLResponseBody>(model1);
      }
    }
  }


  virtual ~UploadStreamByURLResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddCategoryResponse addCategoryWithOptions(shared_ptr<AddCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCategoryResponse addCategory(shared_ptr<AddCategoryRequest> request);
  AddEditingProjectMaterialsResponse addEditingProjectMaterialsWithOptions(shared_ptr<AddEditingProjectMaterialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddEditingProjectMaterialsResponse addEditingProjectMaterials(shared_ptr<AddEditingProjectMaterialsRequest> request);
  AddFavoritePublicMediaResponse addFavoritePublicMediaWithOptions(shared_ptr<AddFavoritePublicMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddFavoritePublicMediaResponse addFavoritePublicMedia(shared_ptr<AddFavoritePublicMediaRequest> request);
  AddTemplateResponse addTemplateWithOptions(shared_ptr<AddTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTemplateResponse addTemplate(shared_ptr<AddTemplateRequest> request);
  BatchGetMediaInfosResponse batchGetMediaInfosWithOptions(shared_ptr<BatchGetMediaInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetMediaInfosResponse batchGetMediaInfos(shared_ptr<BatchGetMediaInfosRequest> request);
  CancelFavoritePublicMediaResponse cancelFavoritePublicMediaWithOptions(shared_ptr<CancelFavoritePublicMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelFavoritePublicMediaResponse cancelFavoritePublicMedia(shared_ptr<CancelFavoritePublicMediaRequest> request);
  CreateCustomTemplateResponse createCustomTemplateWithOptions(shared_ptr<CreateCustomTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomTemplateResponse createCustomTemplate(shared_ptr<CreateCustomTemplateRequest> request);
  CreateEditingProjectResponse createEditingProjectWithOptions(shared_ptr<CreateEditingProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEditingProjectResponse createEditingProject(shared_ptr<CreateEditingProjectRequest> request);
  CreateLiveRecordTemplateResponse createLiveRecordTemplateWithOptions(shared_ptr<CreateLiveRecordTemplateRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveRecordTemplateResponse createLiveRecordTemplate(shared_ptr<CreateLiveRecordTemplateRequest> request);
  CreateLiveSnapshotTemplateResponse createLiveSnapshotTemplateWithOptions(shared_ptr<CreateLiveSnapshotTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveSnapshotTemplateResponse createLiveSnapshotTemplate(shared_ptr<CreateLiveSnapshotTemplateRequest> request);
  CreateLiveTranscodeTemplateResponse createLiveTranscodeTemplateWithOptions(shared_ptr<CreateLiveTranscodeTemplateRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveTranscodeTemplateResponse createLiveTranscodeTemplate(shared_ptr<CreateLiveTranscodeTemplateRequest> request);
  CreatePipelineResponse createPipelineWithOptions(shared_ptr<CreatePipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePipelineResponse createPipeline(shared_ptr<CreatePipelineRequest> request);
  CreateUploadMediaResponse createUploadMediaWithOptions(shared_ptr<CreateUploadMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUploadMediaResponse createUploadMedia(shared_ptr<CreateUploadMediaRequest> request);
  CreateUploadStreamResponse createUploadStreamWithOptions(shared_ptr<CreateUploadStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUploadStreamResponse createUploadStream(shared_ptr<CreateUploadStreamRequest> request);
  DeleteCategoryResponse deleteCategoryWithOptions(shared_ptr<DeleteCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCategoryResponse deleteCategory(shared_ptr<DeleteCategoryRequest> request);
  DeleteCustomTemplateResponse deleteCustomTemplateWithOptions(shared_ptr<DeleteCustomTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomTemplateResponse deleteCustomTemplate(shared_ptr<DeleteCustomTemplateRequest> request);
  DeleteEditingProjectMaterialsResponse deleteEditingProjectMaterialsWithOptions(shared_ptr<DeleteEditingProjectMaterialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEditingProjectMaterialsResponse deleteEditingProjectMaterials(shared_ptr<DeleteEditingProjectMaterialsRequest> request);
  DeleteEditingProjectsResponse deleteEditingProjectsWithOptions(shared_ptr<DeleteEditingProjectsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEditingProjectsResponse deleteEditingProjects(shared_ptr<DeleteEditingProjectsRequest> request);
  DeleteLiveRecordFilesResponse deleteLiveRecordFilesWithOptions(shared_ptr<DeleteLiveRecordFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveRecordFilesResponse deleteLiveRecordFiles(shared_ptr<DeleteLiveRecordFilesRequest> request);
  DeleteLiveRecordTemplateResponse deleteLiveRecordTemplateWithOptions(shared_ptr<DeleteLiveRecordTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveRecordTemplateResponse deleteLiveRecordTemplate(shared_ptr<DeleteLiveRecordTemplateRequest> request);
  DeleteLiveSnapshotFilesResponse deleteLiveSnapshotFilesWithOptions(shared_ptr<DeleteLiveSnapshotFilesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveSnapshotFilesResponse deleteLiveSnapshotFiles(shared_ptr<DeleteLiveSnapshotFilesRequest> request);
  DeleteLiveSnapshotTemplateResponse deleteLiveSnapshotTemplateWithOptions(shared_ptr<DeleteLiveSnapshotTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveSnapshotTemplateResponse deleteLiveSnapshotTemplate(shared_ptr<DeleteLiveSnapshotTemplateRequest> request);
  DeleteLiveTranscodeJobResponse deleteLiveTranscodeJobWithOptions(shared_ptr<DeleteLiveTranscodeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveTranscodeJobResponse deleteLiveTranscodeJob(shared_ptr<DeleteLiveTranscodeJobRequest> request);
  DeleteLiveTranscodeTemplateResponse deleteLiveTranscodeTemplateWithOptions(shared_ptr<DeleteLiveTranscodeTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveTranscodeTemplateResponse deleteLiveTranscodeTemplate(shared_ptr<DeleteLiveTranscodeTemplateRequest> request);
  DeleteMediaInfosResponse deleteMediaInfosWithOptions(shared_ptr<DeleteMediaInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaInfosResponse deleteMediaInfos(shared_ptr<DeleteMediaInfosRequest> request);
  DeletePipelineResponse deletePipelineWithOptions(shared_ptr<DeletePipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePipelineResponse deletePipeline(shared_ptr<DeletePipelineRequest> request);
  DeletePlayInfoResponse deletePlayInfoWithOptions(shared_ptr<DeletePlayInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePlayInfoResponse deletePlayInfo(shared_ptr<DeletePlayInfoRequest> request);
  DeleteSmartJobResponse deleteSmartJobWithOptions(shared_ptr<DeleteSmartJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSmartJobResponse deleteSmartJob(shared_ptr<DeleteSmartJobRequest> request);
  DeleteTemplateResponse deleteTemplateWithOptions(shared_ptr<DeleteTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTemplateResponse deleteTemplate(shared_ptr<DeleteTemplateRequest> request);
  DescribeFilterConfigsResponse describeFilterConfigsWithOptions(shared_ptr<DescribeFilterConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFilterConfigsResponse describeFilterConfigs(shared_ptr<DescribeFilterConfigsRequest> request);
  DescribeMeterIceEditUsageResponse describeMeterIceEditUsageWithOptions(shared_ptr<DescribeMeterIceEditUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterIceEditUsageResponse describeMeterIceEditUsage(shared_ptr<DescribeMeterIceEditUsageRequest> request);
  DescribeMeterIceLiveMediaConvertUsageResponse describeMeterIceLiveMediaConvertUsageWithOptions(shared_ptr<DescribeMeterIceLiveMediaConvertUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterIceLiveMediaConvertUsageResponse describeMeterIceLiveMediaConvertUsage(shared_ptr<DescribeMeterIceLiveMediaConvertUsageRequest> request);
  DescribeMeterIceMediaConvertUHDUsageResponse describeMeterIceMediaConvertUHDUsageWithOptions(shared_ptr<DescribeMeterIceMediaConvertUHDUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterIceMediaConvertUHDUsageResponse describeMeterIceMediaConvertUHDUsage(shared_ptr<DescribeMeterIceMediaConvertUHDUsageRequest> request);
  DescribeMeterIceMediaConvertUsageResponse describeMeterIceMediaConvertUsageWithOptions(shared_ptr<DescribeMeterIceMediaConvertUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterIceMediaConvertUsageResponse describeMeterIceMediaConvertUsage(shared_ptr<DescribeMeterIceMediaConvertUsageRequest> request);
  DescribeMeterIceMpsAiUsageResponse describeMeterIceMpsAiUsageWithOptions(shared_ptr<DescribeMeterIceMpsAiUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterIceMpsAiUsageResponse describeMeterIceMpsAiUsage(shared_ptr<DescribeMeterIceMpsAiUsageRequest> request);
  DescribeMeterImsEditUsageResponse describeMeterImsEditUsageWithOptions(shared_ptr<DescribeMeterImsEditUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterImsEditUsageResponse describeMeterImsEditUsage(shared_ptr<DescribeMeterImsEditUsageRequest> request);
  DescribeMeterImsLiveEditUsageResponse describeMeterImsLiveEditUsageWithOptions(shared_ptr<DescribeMeterImsLiveEditUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterImsLiveEditUsageResponse describeMeterImsLiveEditUsage(shared_ptr<DescribeMeterImsLiveEditUsageRequest> request);
  DescribeMeterImsLiveMediaConvertUsageResponse describeMeterImsLiveMediaConvertUsageWithOptions(shared_ptr<DescribeMeterImsLiveMediaConvertUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterImsLiveMediaConvertUsageResponse describeMeterImsLiveMediaConvertUsage(shared_ptr<DescribeMeterImsLiveMediaConvertUsageRequest> request);
  DescribeMeterImsLiveRecordUsageResponse describeMeterImsLiveRecordUsageWithOptions(shared_ptr<DescribeMeterImsLiveRecordUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterImsLiveRecordUsageResponse describeMeterImsLiveRecordUsage(shared_ptr<DescribeMeterImsLiveRecordUsageRequest> request);
  DescribeMeterImsLiveSnapshotUsageResponse describeMeterImsLiveSnapshotUsageWithOptions(shared_ptr<DescribeMeterImsLiveSnapshotUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterImsLiveSnapshotUsageResponse describeMeterImsLiveSnapshotUsage(shared_ptr<DescribeMeterImsLiveSnapshotUsageRequest> request);
  DescribeMeterImsMediaConvertUHDUsageResponse describeMeterImsMediaConvertUHDUsageWithOptions(shared_ptr<DescribeMeterImsMediaConvertUHDUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterImsMediaConvertUHDUsageResponse describeMeterImsMediaConvertUHDUsage(shared_ptr<DescribeMeterImsMediaConvertUHDUsageRequest> request);
  DescribeMeterImsMediaConvertUsageResponse describeMeterImsMediaConvertUsageWithOptions(shared_ptr<DescribeMeterImsMediaConvertUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterImsMediaConvertUsageResponse describeMeterImsMediaConvertUsage(shared_ptr<DescribeMeterImsMediaConvertUsageRequest> request);
  DescribeMeterImsMpsAiUsageResponse describeMeterImsMpsAiUsageWithOptions(shared_ptr<DescribeMeterImsMpsAiUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterImsMpsAiUsageResponse describeMeterImsMpsAiUsage(shared_ptr<DescribeMeterImsMpsAiUsageRequest> request);
  DescribeMeterImsSummaryResponse describeMeterImsSummaryWithOptions(shared_ptr<DescribeMeterImsSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterImsSummaryResponse describeMeterImsSummary(shared_ptr<DescribeMeterImsSummaryRequest> request);
  DescribePlayDetailResponse describePlayDetailWithOptions(shared_ptr<DescribePlayDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePlayDetailResponse describePlayDetail(shared_ptr<DescribePlayDetailRequest> request);
  DescribePlayEventListResponse describePlayEventListWithOptions(shared_ptr<DescribePlayEventListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePlayEventListResponse describePlayEventList(shared_ptr<DescribePlayEventListRequest> request);
  DescribePlayFirstFrameDurationMetricDataResponse describePlayFirstFrameDurationMetricDataWithOptions(shared_ptr<DescribePlayFirstFrameDurationMetricDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePlayFirstFrameDurationMetricDataResponse describePlayFirstFrameDurationMetricData(shared_ptr<DescribePlayFirstFrameDurationMetricDataRequest> request);
  DescribePlayListResponse describePlayListWithOptions(shared_ptr<DescribePlayListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePlayListResponse describePlayList(shared_ptr<DescribePlayListRequest> request);
  DescribePlayMetricDataResponse describePlayMetricDataWithOptions(shared_ptr<DescribePlayMetricDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePlayMetricDataResponse describePlayMetricData(shared_ptr<DescribePlayMetricDataRequest> request);
  DescribePlayQoeListResponse describePlayQoeListWithOptions(shared_ptr<DescribePlayQoeListRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePlayQoeListResponse describePlayQoeList(shared_ptr<DescribePlayQoeListRequest> request);
  DescribePlayQosListResponse describePlayQosListWithOptions(shared_ptr<DescribePlayQosListRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePlayQosListResponse describePlayQosList(shared_ptr<DescribePlayQosListRequest> request);
  DescribeQueryConfigsResponse describeQueryConfigsWithOptions(shared_ptr<DescribeQueryConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeQueryConfigsResponse describeQueryConfigs(shared_ptr<DescribeQueryConfigsRequest> request);
  GetCategoriesResponse getCategoriesWithOptions(shared_ptr<GetCategoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCategoriesResponse getCategories(shared_ptr<GetCategoriesRequest> request);
  GetCustomTemplateResponse getCustomTemplateWithOptions(shared_ptr<GetCustomTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCustomTemplateResponse getCustomTemplate(shared_ptr<GetCustomTemplateRequest> request);
  GetDefaultStorageLocationResponse getDefaultStorageLocationWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDefaultStorageLocationResponse getDefaultStorageLocation();
  GetDynamicImageJobResponse getDynamicImageJobWithOptions(shared_ptr<GetDynamicImageJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDynamicImageJobResponse getDynamicImageJob(shared_ptr<GetDynamicImageJobRequest> request);
  GetEditingProjectResponse getEditingProjectWithOptions(shared_ptr<GetEditingProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEditingProjectResponse getEditingProject(shared_ptr<GetEditingProjectRequest> request);
  GetEditingProjectMaterialsResponse getEditingProjectMaterialsWithOptions(shared_ptr<GetEditingProjectMaterialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEditingProjectMaterialsResponse getEditingProjectMaterials(shared_ptr<GetEditingProjectMaterialsRequest> request);
  GetEventCallbackResponse getEventCallbackWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEventCallbackResponse getEventCallback();
  GetLiveEditingIndexFileResponse getLiveEditingIndexFileWithOptions(shared_ptr<GetLiveEditingIndexFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveEditingIndexFileResponse getLiveEditingIndexFile(shared_ptr<GetLiveEditingIndexFileRequest> request);
  GetLiveEditingJobResponse getLiveEditingJobWithOptions(shared_ptr<GetLiveEditingJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveEditingJobResponse getLiveEditingJob(shared_ptr<GetLiveEditingJobRequest> request);
  GetLiveRecordJobResponse getLiveRecordJobWithOptions(shared_ptr<GetLiveRecordJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveRecordJobResponse getLiveRecordJob(shared_ptr<GetLiveRecordJobRequest> request);
  GetLiveRecordTemplateResponse getLiveRecordTemplateWithOptions(shared_ptr<GetLiveRecordTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveRecordTemplateResponse getLiveRecordTemplate(shared_ptr<GetLiveRecordTemplateRequest> request);
  GetLiveSnapshotJobResponse getLiveSnapshotJobWithOptions(shared_ptr<GetLiveSnapshotJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveSnapshotJobResponse getLiveSnapshotJob(shared_ptr<GetLiveSnapshotJobRequest> request);
  GetLiveSnapshotTemplateResponse getLiveSnapshotTemplateWithOptions(shared_ptr<GetLiveSnapshotTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveSnapshotTemplateResponse getLiveSnapshotTemplate(shared_ptr<GetLiveSnapshotTemplateRequest> request);
  GetLiveTranscodeJobResponse getLiveTranscodeJobWithOptions(shared_ptr<GetLiveTranscodeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveTranscodeJobResponse getLiveTranscodeJob(shared_ptr<GetLiveTranscodeJobRequest> request);
  GetLiveTranscodeTemplateResponse getLiveTranscodeTemplateWithOptions(shared_ptr<GetLiveTranscodeTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveTranscodeTemplateResponse getLiveTranscodeTemplate(shared_ptr<GetLiveTranscodeTemplateRequest> request);
  GetMediaInfoResponse getMediaInfoWithOptions(shared_ptr<GetMediaInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaInfoResponse getMediaInfo(shared_ptr<GetMediaInfoRequest> request);
  GetMediaInfoJobResponse getMediaInfoJobWithOptions(shared_ptr<GetMediaInfoJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaInfoJobResponse getMediaInfoJob(shared_ptr<GetMediaInfoJobRequest> request);
  GetMediaProducingJobResponse getMediaProducingJobWithOptions(shared_ptr<GetMediaProducingJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaProducingJobResponse getMediaProducingJob(shared_ptr<GetMediaProducingJobRequest> request);
  GetPipelineResponse getPipelineWithOptions(shared_ptr<GetPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPipelineResponse getPipeline(shared_ptr<GetPipelineRequest> request);
  GetPlayInfoResponse getPlayInfoWithOptions(shared_ptr<GetPlayInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPlayInfoResponse getPlayInfo(shared_ptr<GetPlayInfoRequest> request);
  GetPublicMediaInfoResponse getPublicMediaInfoWithOptions(shared_ptr<GetPublicMediaInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPublicMediaInfoResponse getPublicMediaInfo(shared_ptr<GetPublicMediaInfoRequest> request);
  GetSmartHandleJobResponse getSmartHandleJobWithOptions(shared_ptr<GetSmartHandleJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSmartHandleJobResponse getSmartHandleJob(shared_ptr<GetSmartHandleJobRequest> request);
  GetSnapshotJobResponse getSnapshotJobWithOptions(shared_ptr<GetSnapshotJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSnapshotJobResponse getSnapshotJob(shared_ptr<GetSnapshotJobRequest> request);
  GetSnapshotUrlsResponse getSnapshotUrlsWithOptions(shared_ptr<GetSnapshotUrlsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSnapshotUrlsResponse getSnapshotUrls(shared_ptr<GetSnapshotUrlsRequest> request);
  GetSystemTemplateResponse getSystemTemplateWithOptions(shared_ptr<GetSystemTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSystemTemplateResponse getSystemTemplate(shared_ptr<GetSystemTemplateRequest> request);
  GetTemplateResponse getTemplateWithOptions(shared_ptr<GetTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTemplateResponse getTemplate(shared_ptr<GetTemplateRequest> request);
  GetTemplateMaterialsResponse getTemplateMaterialsWithOptions(shared_ptr<GetTemplateMaterialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTemplateMaterialsResponse getTemplateMaterials(shared_ptr<GetTemplateMaterialsRequest> request);
  GetTranscodeJobResponse getTranscodeJobWithOptions(shared_ptr<GetTranscodeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTranscodeJobResponse getTranscodeJob(shared_ptr<GetTranscodeJobRequest> request);
  GetUrlUploadInfosResponse getUrlUploadInfosWithOptions(shared_ptr<GetUrlUploadInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUrlUploadInfosResponse getUrlUploadInfos(shared_ptr<GetUrlUploadInfosRequest> request);
  ListAllPublicMediaTagsResponse listAllPublicMediaTagsWithOptions(shared_ptr<ListAllPublicMediaTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAllPublicMediaTagsResponse listAllPublicMediaTags(shared_ptr<ListAllPublicMediaTagsRequest> request);
  ListCustomTemplatesResponse listCustomTemplatesWithOptions(shared_ptr<ListCustomTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomTemplatesResponse listCustomTemplates(shared_ptr<ListCustomTemplatesRequest> request);
  ListDynamicImageJobsResponse listDynamicImageJobsWithOptions(shared_ptr<ListDynamicImageJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDynamicImageJobsResponse listDynamicImageJobs(shared_ptr<ListDynamicImageJobsRequest> request);
  ListLiveRecordFilesResponse listLiveRecordFilesWithOptions(shared_ptr<ListLiveRecordFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveRecordFilesResponse listLiveRecordFiles(shared_ptr<ListLiveRecordFilesRequest> request);
  ListLiveRecordJobsResponse listLiveRecordJobsWithOptions(shared_ptr<ListLiveRecordJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveRecordJobsResponse listLiveRecordJobs(shared_ptr<ListLiveRecordJobsRequest> request);
  ListLiveRecordTemplatesResponse listLiveRecordTemplatesWithOptions(shared_ptr<ListLiveRecordTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveRecordTemplatesResponse listLiveRecordTemplates(shared_ptr<ListLiveRecordTemplatesRequest> request);
  ListLiveSnapshotFilesResponse listLiveSnapshotFilesWithOptions(shared_ptr<ListLiveSnapshotFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveSnapshotFilesResponse listLiveSnapshotFiles(shared_ptr<ListLiveSnapshotFilesRequest> request);
  ListLiveSnapshotJobsResponse listLiveSnapshotJobsWithOptions(shared_ptr<ListLiveSnapshotJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveSnapshotJobsResponse listLiveSnapshotJobs(shared_ptr<ListLiveSnapshotJobsRequest> request);
  ListLiveSnapshotTemplatesResponse listLiveSnapshotTemplatesWithOptions(shared_ptr<ListLiveSnapshotTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveSnapshotTemplatesResponse listLiveSnapshotTemplates(shared_ptr<ListLiveSnapshotTemplatesRequest> request);
  ListLiveTranscodeJobsResponse listLiveTranscodeJobsWithOptions(shared_ptr<ListLiveTranscodeJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveTranscodeJobsResponse listLiveTranscodeJobs(shared_ptr<ListLiveTranscodeJobsRequest> request);
  ListLiveTranscodeTemplatesResponse listLiveTranscodeTemplatesWithOptions(shared_ptr<ListLiveTranscodeTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveTranscodeTemplatesResponse listLiveTranscodeTemplates(shared_ptr<ListLiveTranscodeTemplatesRequest> request);
  ListMediaBasicInfosResponse listMediaBasicInfosWithOptions(shared_ptr<ListMediaBasicInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMediaBasicInfosResponse listMediaBasicInfos(shared_ptr<ListMediaBasicInfosRequest> request);
  ListMediaInfoJobsResponse listMediaInfoJobsWithOptions(shared_ptr<ListMediaInfoJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMediaInfoJobsResponse listMediaInfoJobs(shared_ptr<ListMediaInfoJobsRequest> request);
  ListPipelinesResponse listPipelinesWithOptions(shared_ptr<ListPipelinesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPipelinesResponse listPipelines(shared_ptr<ListPipelinesRequest> request);
  ListPublicMediaBasicInfosResponse listPublicMediaBasicInfosWithOptions(shared_ptr<ListPublicMediaBasicInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPublicMediaBasicInfosResponse listPublicMediaBasicInfos(shared_ptr<ListPublicMediaBasicInfosRequest> request);
  ListSmartJobsResponse listSmartJobsWithOptions(shared_ptr<ListSmartJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSmartJobsResponse listSmartJobs(shared_ptr<ListSmartJobsRequest> request);
  ListSnapshotJobsResponse listSnapshotJobsWithOptions(shared_ptr<ListSnapshotJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSnapshotJobsResponse listSnapshotJobs(shared_ptr<ListSnapshotJobsRequest> request);
  ListSystemTemplatesResponse listSystemTemplatesWithOptions(shared_ptr<ListSystemTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSystemTemplatesResponse listSystemTemplates(shared_ptr<ListSystemTemplatesRequest> request);
  ListTemplatesResponse listTemplatesWithOptions(shared_ptr<ListTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTemplatesResponse listTemplates(shared_ptr<ListTemplatesRequest> request);
  ListTranscodeJobsResponse listTranscodeJobsWithOptions(shared_ptr<ListTranscodeJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTranscodeJobsResponse listTranscodeJobs(shared_ptr<ListTranscodeJobsRequest> request);
  QueryCensorJobListResponse queryCensorJobListWithOptions(shared_ptr<QueryCensorJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCensorJobListResponse queryCensorJobList(shared_ptr<QueryCensorJobListRequest> request);
  QueryIProductionJobResponse queryIProductionJobWithOptions(shared_ptr<QueryIProductionJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryIProductionJobResponse queryIProductionJob(shared_ptr<QueryIProductionJobRequest> request);
  QueryMediaCensorJobDetailResponse queryMediaCensorJobDetailWithOptions(shared_ptr<QueryMediaCensorJobDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaCensorJobDetailResponse queryMediaCensorJobDetail(shared_ptr<QueryMediaCensorJobDetailRequest> request);
  QuerySmarttagJobResponse querySmarttagJobWithOptions(shared_ptr<QuerySmarttagJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmarttagJobResponse querySmarttagJob(shared_ptr<QuerySmarttagJobRequest> request);
  RefreshUploadMediaResponse refreshUploadMediaWithOptions(shared_ptr<RefreshUploadMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshUploadMediaResponse refreshUploadMedia(shared_ptr<RefreshUploadMediaRequest> request);
  RegisterMediaInfoResponse registerMediaInfoWithOptions(shared_ptr<RegisterMediaInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterMediaInfoResponse registerMediaInfo(shared_ptr<RegisterMediaInfoRequest> request);
  RegisterMediaStreamResponse registerMediaStreamWithOptions(shared_ptr<RegisterMediaStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterMediaStreamResponse registerMediaStream(shared_ptr<RegisterMediaStreamRequest> request);
  SearchEditingProjectResponse searchEditingProjectWithOptions(shared_ptr<SearchEditingProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchEditingProjectResponse searchEditingProject(shared_ptr<SearchEditingProjectRequest> request);
  SearchMediaResponse searchMediaWithOptions(shared_ptr<SearchMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchMediaResponse searchMedia(shared_ptr<SearchMediaRequest> request);
  SearchPublicMediaInfoResponse searchPublicMediaInfoWithOptions(shared_ptr<SearchPublicMediaInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchPublicMediaInfoResponse searchPublicMediaInfo(shared_ptr<SearchPublicMediaInfoRequest> request);
  SendLiveSnapshotJobCommandResponse sendLiveSnapshotJobCommandWithOptions(shared_ptr<SendLiveSnapshotJobCommandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendLiveSnapshotJobCommandResponse sendLiveSnapshotJobCommand(shared_ptr<SendLiveSnapshotJobCommandRequest> request);
  SendLiveTranscodeJobCommandResponse sendLiveTranscodeJobCommandWithOptions(shared_ptr<SendLiveTranscodeJobCommandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendLiveTranscodeJobCommandResponse sendLiveTranscodeJobCommand(shared_ptr<SendLiveTranscodeJobCommandRequest> request);
  SetDefaultCustomTemplateResponse setDefaultCustomTemplateWithOptions(shared_ptr<SetDefaultCustomTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDefaultCustomTemplateResponse setDefaultCustomTemplate(shared_ptr<SetDefaultCustomTemplateRequest> request);
  SetDefaultStorageLocationResponse setDefaultStorageLocationWithOptions(shared_ptr<SetDefaultStorageLocationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDefaultStorageLocationResponse setDefaultStorageLocation(shared_ptr<SetDefaultStorageLocationRequest> request);
  SetEventCallbackResponse setEventCallbackWithOptions(shared_ptr<SetEventCallbackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetEventCallbackResponse setEventCallback(shared_ptr<SetEventCallbackRequest> request);
  SubmitASRJobResponse submitASRJobWithOptions(shared_ptr<SubmitASRJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitASRJobResponse submitASRJob(shared_ptr<SubmitASRJobRequest> request);
  SubmitAudioProduceJobResponse submitAudioProduceJobWithOptions(shared_ptr<SubmitAudioProduceJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitAudioProduceJobResponse submitAudioProduceJob(shared_ptr<SubmitAudioProduceJobRequest> request);
  SubmitDynamicChartJobResponse submitDynamicChartJobWithOptions(shared_ptr<SubmitDynamicChartJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitDynamicChartJobResponse submitDynamicChartJob(shared_ptr<SubmitDynamicChartJobRequest> request);
  SubmitDynamicImageJobResponse submitDynamicImageJobWithOptions(shared_ptr<SubmitDynamicImageJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitDynamicImageJobResponse submitDynamicImageJob(shared_ptr<SubmitDynamicImageJobRequest> request);
  SubmitIProductionJobResponse submitIProductionJobWithOptions(shared_ptr<SubmitIProductionJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitIProductionJobResponse submitIProductionJob(shared_ptr<SubmitIProductionJobRequest> request);
  SubmitLiveEditingJobResponse submitLiveEditingJobWithOptions(shared_ptr<SubmitLiveEditingJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitLiveEditingJobResponse submitLiveEditingJob(shared_ptr<SubmitLiveEditingJobRequest> request);
  SubmitLiveRecordJobResponse submitLiveRecordJobWithOptions(shared_ptr<SubmitLiveRecordJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitLiveRecordJobResponse submitLiveRecordJob(shared_ptr<SubmitLiveRecordJobRequest> request);
  SubmitLiveSnapshotJobResponse submitLiveSnapshotJobWithOptions(shared_ptr<SubmitLiveSnapshotJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitLiveSnapshotJobResponse submitLiveSnapshotJob(shared_ptr<SubmitLiveSnapshotJobRequest> request);
  SubmitLiveTranscodeJobResponse submitLiveTranscodeJobWithOptions(shared_ptr<SubmitLiveTranscodeJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitLiveTranscodeJobResponse submitLiveTranscodeJob(shared_ptr<SubmitLiveTranscodeJobRequest> request);
  SubmitMediaCensorJobResponse submitMediaCensorJobWithOptions(shared_ptr<SubmitMediaCensorJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMediaCensorJobResponse submitMediaCensorJob(shared_ptr<SubmitMediaCensorJobRequest> request);
  SubmitMediaInfoJobResponse submitMediaInfoJobWithOptions(shared_ptr<SubmitMediaInfoJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMediaInfoJobResponse submitMediaInfoJob(shared_ptr<SubmitMediaInfoJobRequest> request);
  SubmitMediaProducingJobResponse submitMediaProducingJobWithOptions(shared_ptr<SubmitMediaProducingJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMediaProducingJobResponse submitMediaProducingJob(shared_ptr<SubmitMediaProducingJobRequest> request);
  SubmitSmarttagJobResponse submitSmarttagJobWithOptions(shared_ptr<SubmitSmarttagJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSmarttagJobResponse submitSmarttagJob(shared_ptr<SubmitSmarttagJobRequest> request);
  SubmitSnapshotJobResponse submitSnapshotJobWithOptions(shared_ptr<SubmitSnapshotJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSnapshotJobResponse submitSnapshotJob(shared_ptr<SubmitSnapshotJobRequest> request);
  SubmitSubtitleProduceJobResponse submitSubtitleProduceJobWithOptions(shared_ptr<SubmitSubtitleProduceJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSubtitleProduceJobResponse submitSubtitleProduceJob(shared_ptr<SubmitSubtitleProduceJobRequest> request);
  SubmitSyncMediaInfoJobResponse submitSyncMediaInfoJobWithOptions(shared_ptr<SubmitSyncMediaInfoJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSyncMediaInfoJobResponse submitSyncMediaInfoJob(shared_ptr<SubmitSyncMediaInfoJobRequest> request);
  SubmitTranscodeJobResponse submitTranscodeJobWithOptions(shared_ptr<SubmitTranscodeJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitTranscodeJobResponse submitTranscodeJob(shared_ptr<SubmitTranscodeJobRequest> request);
  UpdateCategoryResponse updateCategoryWithOptions(shared_ptr<UpdateCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCategoryResponse updateCategory(shared_ptr<UpdateCategoryRequest> request);
  UpdateCustomTemplateResponse updateCustomTemplateWithOptions(shared_ptr<UpdateCustomTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCustomTemplateResponse updateCustomTemplate(shared_ptr<UpdateCustomTemplateRequest> request);
  UpdateEditingProjectResponse updateEditingProjectWithOptions(shared_ptr<UpdateEditingProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEditingProjectResponse updateEditingProject(shared_ptr<UpdateEditingProjectRequest> request);
  UpdateLiveRecordTemplateResponse updateLiveRecordTemplateWithOptions(shared_ptr<UpdateLiveRecordTemplateRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveRecordTemplateResponse updateLiveRecordTemplate(shared_ptr<UpdateLiveRecordTemplateRequest> request);
  UpdateLiveSnapshotTemplateResponse updateLiveSnapshotTemplateWithOptions(shared_ptr<UpdateLiveSnapshotTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveSnapshotTemplateResponse updateLiveSnapshotTemplate(shared_ptr<UpdateLiveSnapshotTemplateRequest> request);
  UpdateLiveTranscodeJobResponse updateLiveTranscodeJobWithOptions(shared_ptr<UpdateLiveTranscodeJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveTranscodeJobResponse updateLiveTranscodeJob(shared_ptr<UpdateLiveTranscodeJobRequest> request);
  UpdateLiveTranscodeTemplateResponse updateLiveTranscodeTemplateWithOptions(shared_ptr<UpdateLiveTranscodeTemplateRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveTranscodeTemplateResponse updateLiveTranscodeTemplate(shared_ptr<UpdateLiveTranscodeTemplateRequest> request);
  UpdateMediaInfoResponse updateMediaInfoWithOptions(shared_ptr<UpdateMediaInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaInfoResponse updateMediaInfo(shared_ptr<UpdateMediaInfoRequest> request);
  UpdatePipelineResponse updatePipelineWithOptions(shared_ptr<UpdatePipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePipelineResponse updatePipeline(shared_ptr<UpdatePipelineRequest> request);
  UpdateSmartJobResponse updateSmartJobWithOptions(shared_ptr<UpdateSmartJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSmartJobResponse updateSmartJob(shared_ptr<UpdateSmartJobRequest> request);
  UpdateTemplateResponse updateTemplateWithOptions(shared_ptr<UpdateTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTemplateResponse updateTemplate(shared_ptr<UpdateTemplateRequest> request);
  UploadMediaByURLResponse uploadMediaByURLWithOptions(shared_ptr<UploadMediaByURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadMediaByURLResponse uploadMediaByURL(shared_ptr<UploadMediaByURLRequest> request);
  UploadStreamByURLResponse uploadStreamByURLWithOptions(shared_ptr<UploadStreamByURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadStreamByURLResponse uploadStreamByURL(shared_ptr<UploadStreamByURLRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_ICE20201109

#endif
