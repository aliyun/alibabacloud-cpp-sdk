// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_ICE20201109_H_
#define ALIBABACLOUD_ICE20201109_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_ICE20201109 {
class AIAgentConfigAsrConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> asrHotWords{};
  shared_ptr<string> asrLanguageId{};
  shared_ptr<long> asrMaxSilence{};
  shared_ptr<string> customParams{};
  shared_ptr<long> vadLevel{};

  AIAgentConfigAsrConfig() {}

  explicit AIAgentConfigAsrConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asrHotWords) {
      res["AsrHotWords"] = boost::any(*asrHotWords);
    }
    if (asrLanguageId) {
      res["AsrLanguageId"] = boost::any(*asrLanguageId);
    }
    if (asrMaxSilence) {
      res["AsrMaxSilence"] = boost::any(*asrMaxSilence);
    }
    if (customParams) {
      res["CustomParams"] = boost::any(*customParams);
    }
    if (vadLevel) {
      res["VadLevel"] = boost::any(*vadLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsrHotWords") != m.end() && !m["AsrHotWords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AsrHotWords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AsrHotWords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      asrHotWords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AsrLanguageId") != m.end() && !m["AsrLanguageId"].empty()) {
      asrLanguageId = make_shared<string>(boost::any_cast<string>(m["AsrLanguageId"]));
    }
    if (m.find("AsrMaxSilence") != m.end() && !m["AsrMaxSilence"].empty()) {
      asrMaxSilence = make_shared<long>(boost::any_cast<long>(m["AsrMaxSilence"]));
    }
    if (m.find("CustomParams") != m.end() && !m["CustomParams"].empty()) {
      customParams = make_shared<string>(boost::any_cast<string>(m["CustomParams"]));
    }
    if (m.find("VadLevel") != m.end() && !m["VadLevel"].empty()) {
      vadLevel = make_shared<long>(boost::any_cast<long>(m["VadLevel"]));
    }
  }


  virtual ~AIAgentConfigAsrConfig() = default;
};
class AIAgentConfigAvatarConfig : public Darabonba::Model {
public:
  shared_ptr<string> avatarId{};

  AIAgentConfigAvatarConfig() {}

  explicit AIAgentConfigAvatarConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarId) {
      res["AvatarId"] = boost::any(*avatarId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarId") != m.end() && !m["AvatarId"].empty()) {
      avatarId = make_shared<string>(boost::any_cast<string>(m["AvatarId"]));
    }
  }


  virtual ~AIAgentConfigAvatarConfig() = default;
};
class AIAgentConfigInterruptConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableVoiceInterrupt{};
  shared_ptr<vector<string>> interruptWords{};

  AIAgentConfigInterruptConfig() {}

  explicit AIAgentConfigInterruptConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableVoiceInterrupt) {
      res["EnableVoiceInterrupt"] = boost::any(*enableVoiceInterrupt);
    }
    if (interruptWords) {
      res["InterruptWords"] = boost::any(*interruptWords);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableVoiceInterrupt") != m.end() && !m["EnableVoiceInterrupt"].empty()) {
      enableVoiceInterrupt = make_shared<bool>(boost::any_cast<bool>(m["EnableVoiceInterrupt"]));
    }
    if (m.find("InterruptWords") != m.end() && !m["InterruptWords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InterruptWords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InterruptWords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      interruptWords = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AIAgentConfigInterruptConfig() = default;
};
class AIAgentConfigLlmConfigLlmHistory : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> role{};

  AIAgentConfigLlmConfigLlmHistory() {}

  explicit AIAgentConfigLlmConfigLlmHistory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~AIAgentConfigLlmConfigLlmHistory() = default;
};
class AIAgentConfigLlmConfig : public Darabonba::Model {
public:
  shared_ptr<string> bailianAppParams{};
  shared_ptr<vector<AIAgentConfigLlmConfigLlmHistory>> llmHistory{};
  shared_ptr<long> llmHistoryLimit{};
  shared_ptr<string> llmSystemPrompt{};

  AIAgentConfigLlmConfig() {}

  explicit AIAgentConfigLlmConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bailianAppParams) {
      res["BailianAppParams"] = boost::any(*bailianAppParams);
    }
    if (llmHistory) {
      vector<boost::any> temp1;
      for(auto item1:*llmHistory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LlmHistory"] = boost::any(temp1);
    }
    if (llmHistoryLimit) {
      res["LlmHistoryLimit"] = boost::any(*llmHistoryLimit);
    }
    if (llmSystemPrompt) {
      res["LlmSystemPrompt"] = boost::any(*llmSystemPrompt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BailianAppParams") != m.end() && !m["BailianAppParams"].empty()) {
      bailianAppParams = make_shared<string>(boost::any_cast<string>(m["BailianAppParams"]));
    }
    if (m.find("LlmHistory") != m.end() && !m["LlmHistory"].empty()) {
      if (typeid(vector<boost::any>) == m["LlmHistory"].type()) {
        vector<AIAgentConfigLlmConfigLlmHistory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LlmHistory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AIAgentConfigLlmConfigLlmHistory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        llmHistory = make_shared<vector<AIAgentConfigLlmConfigLlmHistory>>(expect1);
      }
    }
    if (m.find("LlmHistoryLimit") != m.end() && !m["LlmHistoryLimit"].empty()) {
      llmHistoryLimit = make_shared<long>(boost::any_cast<long>(m["LlmHistoryLimit"]));
    }
    if (m.find("LlmSystemPrompt") != m.end() && !m["LlmSystemPrompt"].empty()) {
      llmSystemPrompt = make_shared<string>(boost::any_cast<string>(m["LlmSystemPrompt"]));
    }
  }


  virtual ~AIAgentConfigLlmConfig() = default;
};
class AIAgentConfigTtsConfigPronunciationRules : public Darabonba::Model {
public:
  shared_ptr<string> pronunciation{};
  shared_ptr<string> type{};
  shared_ptr<string> word{};

  AIAgentConfigTtsConfigPronunciationRules() {}

  explicit AIAgentConfigTtsConfigPronunciationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pronunciation) {
      res["Pronunciation"] = boost::any(*pronunciation);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (word) {
      res["Word"] = boost::any(*word);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pronunciation") != m.end() && !m["Pronunciation"].empty()) {
      pronunciation = make_shared<string>(boost::any_cast<string>(m["Pronunciation"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Word") != m.end() && !m["Word"].empty()) {
      word = make_shared<string>(boost::any_cast<string>(m["Word"]));
    }
  }


  virtual ~AIAgentConfigTtsConfigPronunciationRules() = default;
};
class AIAgentConfigTtsConfig : public Darabonba::Model {
public:
  shared_ptr<vector<AIAgentConfigTtsConfigPronunciationRules>> pronunciationRules{};
  shared_ptr<string> voiceId{};
  shared_ptr<vector<string>> voiceIdList{};

  AIAgentConfigTtsConfig() {}

  explicit AIAgentConfigTtsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pronunciationRules) {
      vector<boost::any> temp1;
      for(auto item1:*pronunciationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PronunciationRules"] = boost::any(temp1);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    if (voiceIdList) {
      res["VoiceIdList"] = boost::any(*voiceIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PronunciationRules") != m.end() && !m["PronunciationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["PronunciationRules"].type()) {
        vector<AIAgentConfigTtsConfigPronunciationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PronunciationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AIAgentConfigTtsConfigPronunciationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pronunciationRules = make_shared<vector<AIAgentConfigTtsConfigPronunciationRules>>(expect1);
      }
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
    if (m.find("VoiceIdList") != m.end() && !m["VoiceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VoiceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VoiceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      voiceIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AIAgentConfigTtsConfig() = default;
};
class AIAgentConfigTurnDetectionConfig : public Darabonba::Model {
public:
  shared_ptr<string> mode{};
  shared_ptr<long> semanticWaitDuration{};
  shared_ptr<vector<string>> turnEndWords{};

  AIAgentConfigTurnDetectionConfig() {}

  explicit AIAgentConfigTurnDetectionConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (semanticWaitDuration) {
      res["SemanticWaitDuration"] = boost::any(*semanticWaitDuration);
    }
    if (turnEndWords) {
      res["TurnEndWords"] = boost::any(*turnEndWords);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("SemanticWaitDuration") != m.end() && !m["SemanticWaitDuration"].empty()) {
      semanticWaitDuration = make_shared<long>(boost::any_cast<long>(m["SemanticWaitDuration"]));
    }
    if (m.find("TurnEndWords") != m.end() && !m["TurnEndWords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TurnEndWords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TurnEndWords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      turnEndWords = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AIAgentConfigTurnDetectionConfig() = default;
};
class AIAgentConfigVcrConfigEquipment : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};

  AIAgentConfigVcrConfigEquipment() {}

  explicit AIAgentConfigVcrConfigEquipment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
  }


  virtual ~AIAgentConfigVcrConfigEquipment() = default;
};
class AIAgentConfigVcrConfigHeadMotion : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};

  AIAgentConfigVcrConfigHeadMotion() {}

  explicit AIAgentConfigVcrConfigHeadMotion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
  }


  virtual ~AIAgentConfigVcrConfigHeadMotion() = default;
};
class AIAgentConfigVcrConfigInvalidFrameMotion : public Darabonba::Model {
public:
  shared_ptr<long> callbackDelay{};
  shared_ptr<bool> enabled{};

  AIAgentConfigVcrConfigInvalidFrameMotion() {}

  explicit AIAgentConfigVcrConfigInvalidFrameMotion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackDelay) {
      res["CallbackDelay"] = boost::any(*callbackDelay);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackDelay") != m.end() && !m["CallbackDelay"].empty()) {
      callbackDelay = make_shared<long>(boost::any_cast<long>(m["CallbackDelay"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
  }


  virtual ~AIAgentConfigVcrConfigInvalidFrameMotion() = default;
};
class AIAgentConfigVcrConfigPeopleCount : public Darabonba::Model {
public:
  shared_ptr<bool> enabled{};

  AIAgentConfigVcrConfigPeopleCount() {}

  explicit AIAgentConfigVcrConfigPeopleCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
  }


  virtual ~AIAgentConfigVcrConfigPeopleCount() = default;
};
class AIAgentConfigVcrConfigStillFrameMotion : public Darabonba::Model {
public:
  shared_ptr<long> callbackDelay{};
  shared_ptr<bool> enabled{};

  AIAgentConfigVcrConfigStillFrameMotion() {}

  explicit AIAgentConfigVcrConfigStillFrameMotion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackDelay) {
      res["CallbackDelay"] = boost::any(*callbackDelay);
    }
    if (enabled) {
      res["Enabled"] = boost::any(*enabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackDelay") != m.end() && !m["CallbackDelay"].empty()) {
      callbackDelay = make_shared<long>(boost::any_cast<long>(m["CallbackDelay"]));
    }
    if (m.find("Enabled") != m.end() && !m["Enabled"].empty()) {
      enabled = make_shared<bool>(boost::any_cast<bool>(m["Enabled"]));
    }
  }


  virtual ~AIAgentConfigVcrConfigStillFrameMotion() = default;
};
class AIAgentConfigVcrConfig : public Darabonba::Model {
public:
  shared_ptr<AIAgentConfigVcrConfigEquipment> equipment{};
  shared_ptr<AIAgentConfigVcrConfigHeadMotion> headMotion{};
  shared_ptr<AIAgentConfigVcrConfigInvalidFrameMotion> invalidFrameMotion{};
  shared_ptr<AIAgentConfigVcrConfigPeopleCount> peopleCount{};
  shared_ptr<AIAgentConfigVcrConfigStillFrameMotion> stillFrameMotion{};

  AIAgentConfigVcrConfig() {}

  explicit AIAgentConfigVcrConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (equipment) {
      res["Equipment"] = equipment ? boost::any(equipment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (headMotion) {
      res["HeadMotion"] = headMotion ? boost::any(headMotion->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (invalidFrameMotion) {
      res["InvalidFrameMotion"] = invalidFrameMotion ? boost::any(invalidFrameMotion->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (peopleCount) {
      res["PeopleCount"] = peopleCount ? boost::any(peopleCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stillFrameMotion) {
      res["StillFrameMotion"] = stillFrameMotion ? boost::any(stillFrameMotion->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Equipment") != m.end() && !m["Equipment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Equipment"].type()) {
        AIAgentConfigVcrConfigEquipment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Equipment"]));
        equipment = make_shared<AIAgentConfigVcrConfigEquipment>(model1);
      }
    }
    if (m.find("HeadMotion") != m.end() && !m["HeadMotion"].empty()) {
      if (typeid(map<string, boost::any>) == m["HeadMotion"].type()) {
        AIAgentConfigVcrConfigHeadMotion model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HeadMotion"]));
        headMotion = make_shared<AIAgentConfigVcrConfigHeadMotion>(model1);
      }
    }
    if (m.find("InvalidFrameMotion") != m.end() && !m["InvalidFrameMotion"].empty()) {
      if (typeid(map<string, boost::any>) == m["InvalidFrameMotion"].type()) {
        AIAgentConfigVcrConfigInvalidFrameMotion model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InvalidFrameMotion"]));
        invalidFrameMotion = make_shared<AIAgentConfigVcrConfigInvalidFrameMotion>(model1);
      }
    }
    if (m.find("PeopleCount") != m.end() && !m["PeopleCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["PeopleCount"].type()) {
        AIAgentConfigVcrConfigPeopleCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PeopleCount"]));
        peopleCount = make_shared<AIAgentConfigVcrConfigPeopleCount>(model1);
      }
    }
    if (m.find("StillFrameMotion") != m.end() && !m["StillFrameMotion"].empty()) {
      if (typeid(map<string, boost::any>) == m["StillFrameMotion"].type()) {
        AIAgentConfigVcrConfigStillFrameMotion model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StillFrameMotion"]));
        stillFrameMotion = make_shared<AIAgentConfigVcrConfigStillFrameMotion>(model1);
      }
    }
  }


  virtual ~AIAgentConfigVcrConfig() = default;
};
class AIAgentConfigVoiceprintConfig : public Darabonba::Model {
public:
  shared_ptr<bool> useVoiceprint{};
  shared_ptr<string> voiceprintId{};

  AIAgentConfigVoiceprintConfig() {}

  explicit AIAgentConfigVoiceprintConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (useVoiceprint) {
      res["UseVoiceprint"] = boost::any(*useVoiceprint);
    }
    if (voiceprintId) {
      res["VoiceprintId"] = boost::any(*voiceprintId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UseVoiceprint") != m.end() && !m["UseVoiceprint"].empty()) {
      useVoiceprint = make_shared<bool>(boost::any_cast<bool>(m["UseVoiceprint"]));
    }
    if (m.find("VoiceprintId") != m.end() && !m["VoiceprintId"].empty()) {
      voiceprintId = make_shared<string>(boost::any_cast<string>(m["VoiceprintId"]));
    }
  }


  virtual ~AIAgentConfigVoiceprintConfig() = default;
};
class AIAgentConfig : public Darabonba::Model {
public:
  shared_ptr<AIAgentConfigAsrConfig> asrConfig{};
  shared_ptr<AIAgentConfigAvatarConfig> avatarConfig{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> avatarUrlType{};
  shared_ptr<bool> enableIntelligentSegment{};
  shared_ptr<bool> enablePushToTalk{};
  shared_ptr<string> experimentalConfig{};
  shared_ptr<bool> gracefulShutdown{};
  shared_ptr<string> greeting{};
  shared_ptr<AIAgentConfigInterruptConfig> interruptConfig{};
  shared_ptr<AIAgentConfigLlmConfig> llmConfig{};
  shared_ptr<long> maxIdleTime{};
  shared_ptr<AIAgentConfigTtsConfig> ttsConfig{};
  shared_ptr<AIAgentConfigTurnDetectionConfig> turnDetectionConfig{};
  shared_ptr<long> userOfflineTimeout{};
  shared_ptr<long> userOnlineTimeout{};
  shared_ptr<AIAgentConfigVcrConfig> vcrConfig{};
  shared_ptr<AIAgentConfigVoiceprintConfig> voiceprintConfig{};
  shared_ptr<long> volume{};
  shared_ptr<string> wakeUpQuery{};
  shared_ptr<string> workflowOverrideParams{};

  AIAgentConfig() {}

  explicit AIAgentConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asrConfig) {
      res["AsrConfig"] = asrConfig ? boost::any(asrConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (avatarConfig) {
      res["AvatarConfig"] = avatarConfig ? boost::any(avatarConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (avatarUrl) {
      res["AvatarUrl"] = boost::any(*avatarUrl);
    }
    if (avatarUrlType) {
      res["AvatarUrlType"] = boost::any(*avatarUrlType);
    }
    if (enableIntelligentSegment) {
      res["EnableIntelligentSegment"] = boost::any(*enableIntelligentSegment);
    }
    if (enablePushToTalk) {
      res["EnablePushToTalk"] = boost::any(*enablePushToTalk);
    }
    if (experimentalConfig) {
      res["ExperimentalConfig"] = boost::any(*experimentalConfig);
    }
    if (gracefulShutdown) {
      res["GracefulShutdown"] = boost::any(*gracefulShutdown);
    }
    if (greeting) {
      res["Greeting"] = boost::any(*greeting);
    }
    if (interruptConfig) {
      res["InterruptConfig"] = interruptConfig ? boost::any(interruptConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (llmConfig) {
      res["LlmConfig"] = llmConfig ? boost::any(llmConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (maxIdleTime) {
      res["MaxIdleTime"] = boost::any(*maxIdleTime);
    }
    if (ttsConfig) {
      res["TtsConfig"] = ttsConfig ? boost::any(ttsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (turnDetectionConfig) {
      res["TurnDetectionConfig"] = turnDetectionConfig ? boost::any(turnDetectionConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userOfflineTimeout) {
      res["UserOfflineTimeout"] = boost::any(*userOfflineTimeout);
    }
    if (userOnlineTimeout) {
      res["UserOnlineTimeout"] = boost::any(*userOnlineTimeout);
    }
    if (vcrConfig) {
      res["VcrConfig"] = vcrConfig ? boost::any(vcrConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (voiceprintConfig) {
      res["VoiceprintConfig"] = voiceprintConfig ? boost::any(voiceprintConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    if (wakeUpQuery) {
      res["WakeUpQuery"] = boost::any(*wakeUpQuery);
    }
    if (workflowOverrideParams) {
      res["WorkflowOverrideParams"] = boost::any(*workflowOverrideParams);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsrConfig") != m.end() && !m["AsrConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AsrConfig"].type()) {
        AIAgentConfigAsrConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AsrConfig"]));
        asrConfig = make_shared<AIAgentConfigAsrConfig>(model1);
      }
    }
    if (m.find("AvatarConfig") != m.end() && !m["AvatarConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvatarConfig"].type()) {
        AIAgentConfigAvatarConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvatarConfig"]));
        avatarConfig = make_shared<AIAgentConfigAvatarConfig>(model1);
      }
    }
    if (m.find("AvatarUrl") != m.end() && !m["AvatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["AvatarUrl"]));
    }
    if (m.find("AvatarUrlType") != m.end() && !m["AvatarUrlType"].empty()) {
      avatarUrlType = make_shared<string>(boost::any_cast<string>(m["AvatarUrlType"]));
    }
    if (m.find("EnableIntelligentSegment") != m.end() && !m["EnableIntelligentSegment"].empty()) {
      enableIntelligentSegment = make_shared<bool>(boost::any_cast<bool>(m["EnableIntelligentSegment"]));
    }
    if (m.find("EnablePushToTalk") != m.end() && !m["EnablePushToTalk"].empty()) {
      enablePushToTalk = make_shared<bool>(boost::any_cast<bool>(m["EnablePushToTalk"]));
    }
    if (m.find("ExperimentalConfig") != m.end() && !m["ExperimentalConfig"].empty()) {
      experimentalConfig = make_shared<string>(boost::any_cast<string>(m["ExperimentalConfig"]));
    }
    if (m.find("GracefulShutdown") != m.end() && !m["GracefulShutdown"].empty()) {
      gracefulShutdown = make_shared<bool>(boost::any_cast<bool>(m["GracefulShutdown"]));
    }
    if (m.find("Greeting") != m.end() && !m["Greeting"].empty()) {
      greeting = make_shared<string>(boost::any_cast<string>(m["Greeting"]));
    }
    if (m.find("InterruptConfig") != m.end() && !m["InterruptConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["InterruptConfig"].type()) {
        AIAgentConfigInterruptConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InterruptConfig"]));
        interruptConfig = make_shared<AIAgentConfigInterruptConfig>(model1);
      }
    }
    if (m.find("LlmConfig") != m.end() && !m["LlmConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LlmConfig"].type()) {
        AIAgentConfigLlmConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LlmConfig"]));
        llmConfig = make_shared<AIAgentConfigLlmConfig>(model1);
      }
    }
    if (m.find("MaxIdleTime") != m.end() && !m["MaxIdleTime"].empty()) {
      maxIdleTime = make_shared<long>(boost::any_cast<long>(m["MaxIdleTime"]));
    }
    if (m.find("TtsConfig") != m.end() && !m["TtsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TtsConfig"].type()) {
        AIAgentConfigTtsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TtsConfig"]));
        ttsConfig = make_shared<AIAgentConfigTtsConfig>(model1);
      }
    }
    if (m.find("TurnDetectionConfig") != m.end() && !m["TurnDetectionConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TurnDetectionConfig"].type()) {
        AIAgentConfigTurnDetectionConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TurnDetectionConfig"]));
        turnDetectionConfig = make_shared<AIAgentConfigTurnDetectionConfig>(model1);
      }
    }
    if (m.find("UserOfflineTimeout") != m.end() && !m["UserOfflineTimeout"].empty()) {
      userOfflineTimeout = make_shared<long>(boost::any_cast<long>(m["UserOfflineTimeout"]));
    }
    if (m.find("UserOnlineTimeout") != m.end() && !m["UserOnlineTimeout"].empty()) {
      userOnlineTimeout = make_shared<long>(boost::any_cast<long>(m["UserOnlineTimeout"]));
    }
    if (m.find("VcrConfig") != m.end() && !m["VcrConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VcrConfig"].type()) {
        AIAgentConfigVcrConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VcrConfig"]));
        vcrConfig = make_shared<AIAgentConfigVcrConfig>(model1);
      }
    }
    if (m.find("VoiceprintConfig") != m.end() && !m["VoiceprintConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VoiceprintConfig"].type()) {
        AIAgentConfigVoiceprintConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VoiceprintConfig"]));
        voiceprintConfig = make_shared<AIAgentConfigVoiceprintConfig>(model1);
      }
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
    if (m.find("WakeUpQuery") != m.end() && !m["WakeUpQuery"].empty()) {
      wakeUpQuery = make_shared<string>(boost::any_cast<string>(m["WakeUpQuery"]));
    }
    if (m.find("WorkflowOverrideParams") != m.end() && !m["WorkflowOverrideParams"].empty()) {
      workflowOverrideParams = make_shared<string>(boost::any_cast<string>(m["WorkflowOverrideParams"]));
    }
  }


  virtual ~AIAgentConfig() = default;
};
class AIAgentOutboundCallConfigAsrConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> asrHotWords{};
  shared_ptr<string> asrLanguageId{};
  shared_ptr<long> asrMaxSilence{};
  shared_ptr<string> customParams{};
  shared_ptr<long> vadLevel{};

  AIAgentOutboundCallConfigAsrConfig() {}

  explicit AIAgentOutboundCallConfigAsrConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asrHotWords) {
      res["AsrHotWords"] = boost::any(*asrHotWords);
    }
    if (asrLanguageId) {
      res["AsrLanguageId"] = boost::any(*asrLanguageId);
    }
    if (asrMaxSilence) {
      res["AsrMaxSilence"] = boost::any(*asrMaxSilence);
    }
    if (customParams) {
      res["CustomParams"] = boost::any(*customParams);
    }
    if (vadLevel) {
      res["VadLevel"] = boost::any(*vadLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsrHotWords") != m.end() && !m["AsrHotWords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AsrHotWords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AsrHotWords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      asrHotWords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AsrLanguageId") != m.end() && !m["AsrLanguageId"].empty()) {
      asrLanguageId = make_shared<string>(boost::any_cast<string>(m["AsrLanguageId"]));
    }
    if (m.find("AsrMaxSilence") != m.end() && !m["AsrMaxSilence"].empty()) {
      asrMaxSilence = make_shared<long>(boost::any_cast<long>(m["AsrMaxSilence"]));
    }
    if (m.find("CustomParams") != m.end() && !m["CustomParams"].empty()) {
      customParams = make_shared<string>(boost::any_cast<string>(m["CustomParams"]));
    }
    if (m.find("VadLevel") != m.end() && !m["VadLevel"].empty()) {
      vadLevel = make_shared<long>(boost::any_cast<long>(m["VadLevel"]));
    }
  }


  virtual ~AIAgentOutboundCallConfigAsrConfig() = default;
};
class AIAgentOutboundCallConfigInterruptConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableVoiceInterrupt{};
  shared_ptr<vector<string>> interruptWords{};

  AIAgentOutboundCallConfigInterruptConfig() {}

  explicit AIAgentOutboundCallConfigInterruptConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableVoiceInterrupt) {
      res["EnableVoiceInterrupt"] = boost::any(*enableVoiceInterrupt);
    }
    if (interruptWords) {
      res["InterruptWords"] = boost::any(*interruptWords);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableVoiceInterrupt") != m.end() && !m["EnableVoiceInterrupt"].empty()) {
      enableVoiceInterrupt = make_shared<bool>(boost::any_cast<bool>(m["EnableVoiceInterrupt"]));
    }
    if (m.find("InterruptWords") != m.end() && !m["InterruptWords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InterruptWords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InterruptWords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      interruptWords = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AIAgentOutboundCallConfigInterruptConfig() = default;
};
class AIAgentOutboundCallConfigLlmConfigLlmHistory : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> role{};

  AIAgentOutboundCallConfigLlmConfigLlmHistory() {}

  explicit AIAgentOutboundCallConfigLlmConfigLlmHistory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~AIAgentOutboundCallConfigLlmConfigLlmHistory() = default;
};
class AIAgentOutboundCallConfigLlmConfig : public Darabonba::Model {
public:
  shared_ptr<string> bailianAppParams{};
  shared_ptr<vector<AIAgentOutboundCallConfigLlmConfigLlmHistory>> llmHistory{};
  shared_ptr<long> llmHistoryLimit{};
  shared_ptr<string> llmSystemPrompt{};

  AIAgentOutboundCallConfigLlmConfig() {}

  explicit AIAgentOutboundCallConfigLlmConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bailianAppParams) {
      res["BailianAppParams"] = boost::any(*bailianAppParams);
    }
    if (llmHistory) {
      vector<boost::any> temp1;
      for(auto item1:*llmHistory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LlmHistory"] = boost::any(temp1);
    }
    if (llmHistoryLimit) {
      res["LlmHistoryLimit"] = boost::any(*llmHistoryLimit);
    }
    if (llmSystemPrompt) {
      res["LlmSystemPrompt"] = boost::any(*llmSystemPrompt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BailianAppParams") != m.end() && !m["BailianAppParams"].empty()) {
      bailianAppParams = make_shared<string>(boost::any_cast<string>(m["BailianAppParams"]));
    }
    if (m.find("LlmHistory") != m.end() && !m["LlmHistory"].empty()) {
      if (typeid(vector<boost::any>) == m["LlmHistory"].type()) {
        vector<AIAgentOutboundCallConfigLlmConfigLlmHistory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LlmHistory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AIAgentOutboundCallConfigLlmConfigLlmHistory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        llmHistory = make_shared<vector<AIAgentOutboundCallConfigLlmConfigLlmHistory>>(expect1);
      }
    }
    if (m.find("LlmHistoryLimit") != m.end() && !m["LlmHistoryLimit"].empty()) {
      llmHistoryLimit = make_shared<long>(boost::any_cast<long>(m["LlmHistoryLimit"]));
    }
    if (m.find("LlmSystemPrompt") != m.end() && !m["LlmSystemPrompt"].empty()) {
      llmSystemPrompt = make_shared<string>(boost::any_cast<string>(m["LlmSystemPrompt"]));
    }
  }


  virtual ~AIAgentOutboundCallConfigLlmConfig() = default;
};
class AIAgentOutboundCallConfigTtsConfigPronunciationRules : public Darabonba::Model {
public:
  shared_ptr<string> pronunciation{};
  shared_ptr<string> type{};
  shared_ptr<string> word{};

  AIAgentOutboundCallConfigTtsConfigPronunciationRules() {}

  explicit AIAgentOutboundCallConfigTtsConfigPronunciationRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pronunciation) {
      res["Pronunciation"] = boost::any(*pronunciation);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (word) {
      res["Word"] = boost::any(*word);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pronunciation") != m.end() && !m["Pronunciation"].empty()) {
      pronunciation = make_shared<string>(boost::any_cast<string>(m["Pronunciation"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Word") != m.end() && !m["Word"].empty()) {
      word = make_shared<string>(boost::any_cast<string>(m["Word"]));
    }
  }


  virtual ~AIAgentOutboundCallConfigTtsConfigPronunciationRules() = default;
};
class AIAgentOutboundCallConfigTtsConfig : public Darabonba::Model {
public:
  shared_ptr<vector<AIAgentOutboundCallConfigTtsConfigPronunciationRules>> pronunciationRules{};
  shared_ptr<string> voiceId{};
  shared_ptr<vector<string>> voiceIdList{};

  AIAgentOutboundCallConfigTtsConfig() {}

  explicit AIAgentOutboundCallConfigTtsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pronunciationRules) {
      vector<boost::any> temp1;
      for(auto item1:*pronunciationRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PronunciationRules"] = boost::any(temp1);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    if (voiceIdList) {
      res["VoiceIdList"] = boost::any(*voiceIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PronunciationRules") != m.end() && !m["PronunciationRules"].empty()) {
      if (typeid(vector<boost::any>) == m["PronunciationRules"].type()) {
        vector<AIAgentOutboundCallConfigTtsConfigPronunciationRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PronunciationRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AIAgentOutboundCallConfigTtsConfigPronunciationRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pronunciationRules = make_shared<vector<AIAgentOutboundCallConfigTtsConfigPronunciationRules>>(expect1);
      }
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
    if (m.find("VoiceIdList") != m.end() && !m["VoiceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VoiceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VoiceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      voiceIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AIAgentOutboundCallConfigTtsConfig() = default;
};
class AIAgentOutboundCallConfigTurnDetectionConfig : public Darabonba::Model {
public:
  shared_ptr<string> mode{};
  shared_ptr<long> semanticWaitDuration{};
  shared_ptr<vector<string>> turnEndWords{};

  AIAgentOutboundCallConfigTurnDetectionConfig() {}

  explicit AIAgentOutboundCallConfigTurnDetectionConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (semanticWaitDuration) {
      res["SemanticWaitDuration"] = boost::any(*semanticWaitDuration);
    }
    if (turnEndWords) {
      res["TurnEndWords"] = boost::any(*turnEndWords);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("SemanticWaitDuration") != m.end() && !m["SemanticWaitDuration"].empty()) {
      semanticWaitDuration = make_shared<long>(boost::any_cast<long>(m["SemanticWaitDuration"]));
    }
    if (m.find("TurnEndWords") != m.end() && !m["TurnEndWords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TurnEndWords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TurnEndWords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      turnEndWords = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AIAgentOutboundCallConfigTurnDetectionConfig() = default;
};
class AIAgentOutboundCallConfig : public Darabonba::Model {
public:
  shared_ptr<AIAgentOutboundCallConfigAsrConfig> asrConfig{};
  shared_ptr<bool> enableIntelligentSegment{};
  shared_ptr<string> greeting{};
  shared_ptr<long> greetingDelay{};
  shared_ptr<AIAgentOutboundCallConfigInterruptConfig> interruptConfig{};
  shared_ptr<AIAgentOutboundCallConfigLlmConfig> llmConfig{};
  shared_ptr<AIAgentOutboundCallConfigTtsConfig> ttsConfig{};
  shared_ptr<AIAgentOutboundCallConfigTurnDetectionConfig> turnDetectionConfig{};

  AIAgentOutboundCallConfig() {}

  explicit AIAgentOutboundCallConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asrConfig) {
      res["AsrConfig"] = asrConfig ? boost::any(asrConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (enableIntelligentSegment) {
      res["EnableIntelligentSegment"] = boost::any(*enableIntelligentSegment);
    }
    if (greeting) {
      res["Greeting"] = boost::any(*greeting);
    }
    if (greetingDelay) {
      res["GreetingDelay"] = boost::any(*greetingDelay);
    }
    if (interruptConfig) {
      res["InterruptConfig"] = interruptConfig ? boost::any(interruptConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (llmConfig) {
      res["LlmConfig"] = llmConfig ? boost::any(llmConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ttsConfig) {
      res["TtsConfig"] = ttsConfig ? boost::any(ttsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (turnDetectionConfig) {
      res["TurnDetectionConfig"] = turnDetectionConfig ? boost::any(turnDetectionConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsrConfig") != m.end() && !m["AsrConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AsrConfig"].type()) {
        AIAgentOutboundCallConfigAsrConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AsrConfig"]));
        asrConfig = make_shared<AIAgentOutboundCallConfigAsrConfig>(model1);
      }
    }
    if (m.find("EnableIntelligentSegment") != m.end() && !m["EnableIntelligentSegment"].empty()) {
      enableIntelligentSegment = make_shared<bool>(boost::any_cast<bool>(m["EnableIntelligentSegment"]));
    }
    if (m.find("Greeting") != m.end() && !m["Greeting"].empty()) {
      greeting = make_shared<string>(boost::any_cast<string>(m["Greeting"]));
    }
    if (m.find("GreetingDelay") != m.end() && !m["GreetingDelay"].empty()) {
      greetingDelay = make_shared<long>(boost::any_cast<long>(m["GreetingDelay"]));
    }
    if (m.find("InterruptConfig") != m.end() && !m["InterruptConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["InterruptConfig"].type()) {
        AIAgentOutboundCallConfigInterruptConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InterruptConfig"]));
        interruptConfig = make_shared<AIAgentOutboundCallConfigInterruptConfig>(model1);
      }
    }
    if (m.find("LlmConfig") != m.end() && !m["LlmConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LlmConfig"].type()) {
        AIAgentOutboundCallConfigLlmConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LlmConfig"]));
        llmConfig = make_shared<AIAgentOutboundCallConfigLlmConfig>(model1);
      }
    }
    if (m.find("TtsConfig") != m.end() && !m["TtsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TtsConfig"].type()) {
        AIAgentOutboundCallConfigTtsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TtsConfig"]));
        ttsConfig = make_shared<AIAgentOutboundCallConfigTtsConfig>(model1);
      }
    }
    if (m.find("TurnDetectionConfig") != m.end() && !m["TurnDetectionConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TurnDetectionConfig"].type()) {
        AIAgentOutboundCallConfigTurnDetectionConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TurnDetectionConfig"]));
        turnDetectionConfig = make_shared<AIAgentOutboundCallConfigTurnDetectionConfig>(model1);
      }
    }
  }


  virtual ~AIAgentOutboundCallConfig() = default;
};
class AIAgentRuntimeConfigAvatarChat3D : public Darabonba::Model {
public:
  shared_ptr<string> agentUserId{};
  shared_ptr<string> authToken{};
  shared_ptr<string> channelId{};

  AIAgentRuntimeConfigAvatarChat3D() {}

  explicit AIAgentRuntimeConfigAvatarChat3D(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentUserId) {
      res["AgentUserId"] = boost::any(*agentUserId);
    }
    if (authToken) {
      res["AuthToken"] = boost::any(*authToken);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentUserId") != m.end() && !m["AgentUserId"].empty()) {
      agentUserId = make_shared<string>(boost::any_cast<string>(m["AgentUserId"]));
    }
    if (m.find("AuthToken") != m.end() && !m["AuthToken"].empty()) {
      authToken = make_shared<string>(boost::any_cast<string>(m["AuthToken"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
  }


  virtual ~AIAgentRuntimeConfigAvatarChat3D() = default;
};
class AIAgentRuntimeConfigVisionChat : public Darabonba::Model {
public:
  shared_ptr<string> agentUserId{};
  shared_ptr<string> authToken{};
  shared_ptr<string> channelId{};

  AIAgentRuntimeConfigVisionChat() {}

  explicit AIAgentRuntimeConfigVisionChat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentUserId) {
      res["AgentUserId"] = boost::any(*agentUserId);
    }
    if (authToken) {
      res["AuthToken"] = boost::any(*authToken);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentUserId") != m.end() && !m["AgentUserId"].empty()) {
      agentUserId = make_shared<string>(boost::any_cast<string>(m["AgentUserId"]));
    }
    if (m.find("AuthToken") != m.end() && !m["AuthToken"].empty()) {
      authToken = make_shared<string>(boost::any_cast<string>(m["AuthToken"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
  }


  virtual ~AIAgentRuntimeConfigVisionChat() = default;
};
class AIAgentRuntimeConfigVoiceChat : public Darabonba::Model {
public:
  shared_ptr<string> agentUserId{};
  shared_ptr<string> authToken{};
  shared_ptr<string> channelId{};

  AIAgentRuntimeConfigVoiceChat() {}

  explicit AIAgentRuntimeConfigVoiceChat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentUserId) {
      res["AgentUserId"] = boost::any(*agentUserId);
    }
    if (authToken) {
      res["AuthToken"] = boost::any(*authToken);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentUserId") != m.end() && !m["AgentUserId"].empty()) {
      agentUserId = make_shared<string>(boost::any_cast<string>(m["AgentUserId"]));
    }
    if (m.find("AuthToken") != m.end() && !m["AuthToken"].empty()) {
      authToken = make_shared<string>(boost::any_cast<string>(m["AuthToken"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
  }


  virtual ~AIAgentRuntimeConfigVoiceChat() = default;
};
class AIAgentRuntimeConfig : public Darabonba::Model {
public:
  shared_ptr<string> agentUserId{};
  shared_ptr<string> authToken{};
  shared_ptr<AIAgentRuntimeConfigAvatarChat3D> avatarChat3D{};
  shared_ptr<string> channelId{};
  shared_ptr<AIAgentRuntimeConfigVisionChat> visionChat{};
  shared_ptr<AIAgentRuntimeConfigVoiceChat> voiceChat{};

  AIAgentRuntimeConfig() {}

  explicit AIAgentRuntimeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentUserId) {
      res["AgentUserId"] = boost::any(*agentUserId);
    }
    if (authToken) {
      res["AuthToken"] = boost::any(*authToken);
    }
    if (avatarChat3D) {
      res["AvatarChat3D"] = avatarChat3D ? boost::any(avatarChat3D->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (visionChat) {
      res["VisionChat"] = visionChat ? boost::any(visionChat->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (voiceChat) {
      res["VoiceChat"] = voiceChat ? boost::any(voiceChat->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentUserId") != m.end() && !m["AgentUserId"].empty()) {
      agentUserId = make_shared<string>(boost::any_cast<string>(m["AgentUserId"]));
    }
    if (m.find("AuthToken") != m.end() && !m["AuthToken"].empty()) {
      authToken = make_shared<string>(boost::any_cast<string>(m["AuthToken"]));
    }
    if (m.find("AvatarChat3D") != m.end() && !m["AvatarChat3D"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvatarChat3D"].type()) {
        AIAgentRuntimeConfigAvatarChat3D model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvatarChat3D"]));
        avatarChat3D = make_shared<AIAgentRuntimeConfigAvatarChat3D>(model1);
      }
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("VisionChat") != m.end() && !m["VisionChat"].empty()) {
      if (typeid(map<string, boost::any>) == m["VisionChat"].type()) {
        AIAgentRuntimeConfigVisionChat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VisionChat"]));
        visionChat = make_shared<AIAgentRuntimeConfigVisionChat>(model1);
      }
    }
    if (m.find("VoiceChat") != m.end() && !m["VoiceChat"].empty()) {
      if (typeid(map<string, boost::any>) == m["VoiceChat"].type()) {
        AIAgentRuntimeConfigVoiceChat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VoiceChat"]));
        voiceChat = make_shared<AIAgentRuntimeConfigVoiceChat>(model1);
      }
    }
  }


  virtual ~AIAgentRuntimeConfig() = default;
};
class AIAgentTemplateConfigAvatarChat3DLlmHistory : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> role{};

  AIAgentTemplateConfigAvatarChat3DLlmHistory() {}

  explicit AIAgentTemplateConfigAvatarChat3DLlmHistory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~AIAgentTemplateConfigAvatarChat3DLlmHistory() = default;
};
class AIAgentTemplateConfigAvatarChat3D : public Darabonba::Model {
public:
  shared_ptr<vector<string>> asrHotWords{};
  shared_ptr<string> asrLanguageId{};
  shared_ptr<long> asrMaxSilence{};
  shared_ptr<string> avatarId{};
  shared_ptr<string> bailianAppParams{};
  shared_ptr<bool> charBreak{};
  shared_ptr<bool> enableIntelligentSegment{};
  shared_ptr<bool> enablePushToTalk{};
  shared_ptr<bool> enableVoiceInterrupt{};
  shared_ptr<bool> gracefulShutdown{};
  shared_ptr<string> greeting{};
  shared_ptr<vector<string>> interruptWords{};
  shared_ptr<vector<AIAgentTemplateConfigAvatarChat3DLlmHistory>> llmHistory{};
  shared_ptr<long> llmHistoryLimit{};
  shared_ptr<string> llmSystemPrompt{};
  shared_ptr<long> maxIdleTime{};
  shared_ptr<bool> useVoiceprint{};
  shared_ptr<long> userOfflineTimeout{};
  shared_ptr<long> userOnlineTimeout{};
  shared_ptr<long> vadLevel{};
  shared_ptr<string> voiceId{};
  shared_ptr<vector<string>> voiceIdList{};
  shared_ptr<string> voiceprintId{};
  shared_ptr<long> volume{};
  shared_ptr<string> wakeUpQuery{};
  shared_ptr<string> workflowOverrideParams{};

  AIAgentTemplateConfigAvatarChat3D() {}

  explicit AIAgentTemplateConfigAvatarChat3D(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asrHotWords) {
      res["AsrHotWords"] = boost::any(*asrHotWords);
    }
    if (asrLanguageId) {
      res["AsrLanguageId"] = boost::any(*asrLanguageId);
    }
    if (asrMaxSilence) {
      res["AsrMaxSilence"] = boost::any(*asrMaxSilence);
    }
    if (avatarId) {
      res["AvatarId"] = boost::any(*avatarId);
    }
    if (bailianAppParams) {
      res["BailianAppParams"] = boost::any(*bailianAppParams);
    }
    if (charBreak) {
      res["CharBreak"] = boost::any(*charBreak);
    }
    if (enableIntelligentSegment) {
      res["EnableIntelligentSegment"] = boost::any(*enableIntelligentSegment);
    }
    if (enablePushToTalk) {
      res["EnablePushToTalk"] = boost::any(*enablePushToTalk);
    }
    if (enableVoiceInterrupt) {
      res["EnableVoiceInterrupt"] = boost::any(*enableVoiceInterrupt);
    }
    if (gracefulShutdown) {
      res["GracefulShutdown"] = boost::any(*gracefulShutdown);
    }
    if (greeting) {
      res["Greeting"] = boost::any(*greeting);
    }
    if (interruptWords) {
      res["InterruptWords"] = boost::any(*interruptWords);
    }
    if (llmHistory) {
      vector<boost::any> temp1;
      for(auto item1:*llmHistory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LlmHistory"] = boost::any(temp1);
    }
    if (llmHistoryLimit) {
      res["LlmHistoryLimit"] = boost::any(*llmHistoryLimit);
    }
    if (llmSystemPrompt) {
      res["LlmSystemPrompt"] = boost::any(*llmSystemPrompt);
    }
    if (maxIdleTime) {
      res["MaxIdleTime"] = boost::any(*maxIdleTime);
    }
    if (useVoiceprint) {
      res["UseVoiceprint"] = boost::any(*useVoiceprint);
    }
    if (userOfflineTimeout) {
      res["UserOfflineTimeout"] = boost::any(*userOfflineTimeout);
    }
    if (userOnlineTimeout) {
      res["UserOnlineTimeout"] = boost::any(*userOnlineTimeout);
    }
    if (vadLevel) {
      res["VadLevel"] = boost::any(*vadLevel);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    if (voiceIdList) {
      res["VoiceIdList"] = boost::any(*voiceIdList);
    }
    if (voiceprintId) {
      res["VoiceprintId"] = boost::any(*voiceprintId);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    if (wakeUpQuery) {
      res["WakeUpQuery"] = boost::any(*wakeUpQuery);
    }
    if (workflowOverrideParams) {
      res["WorkflowOverrideParams"] = boost::any(*workflowOverrideParams);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsrHotWords") != m.end() && !m["AsrHotWords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AsrHotWords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AsrHotWords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      asrHotWords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AsrLanguageId") != m.end() && !m["AsrLanguageId"].empty()) {
      asrLanguageId = make_shared<string>(boost::any_cast<string>(m["AsrLanguageId"]));
    }
    if (m.find("AsrMaxSilence") != m.end() && !m["AsrMaxSilence"].empty()) {
      asrMaxSilence = make_shared<long>(boost::any_cast<long>(m["AsrMaxSilence"]));
    }
    if (m.find("AvatarId") != m.end() && !m["AvatarId"].empty()) {
      avatarId = make_shared<string>(boost::any_cast<string>(m["AvatarId"]));
    }
    if (m.find("BailianAppParams") != m.end() && !m["BailianAppParams"].empty()) {
      bailianAppParams = make_shared<string>(boost::any_cast<string>(m["BailianAppParams"]));
    }
    if (m.find("CharBreak") != m.end() && !m["CharBreak"].empty()) {
      charBreak = make_shared<bool>(boost::any_cast<bool>(m["CharBreak"]));
    }
    if (m.find("EnableIntelligentSegment") != m.end() && !m["EnableIntelligentSegment"].empty()) {
      enableIntelligentSegment = make_shared<bool>(boost::any_cast<bool>(m["EnableIntelligentSegment"]));
    }
    if (m.find("EnablePushToTalk") != m.end() && !m["EnablePushToTalk"].empty()) {
      enablePushToTalk = make_shared<bool>(boost::any_cast<bool>(m["EnablePushToTalk"]));
    }
    if (m.find("EnableVoiceInterrupt") != m.end() && !m["EnableVoiceInterrupt"].empty()) {
      enableVoiceInterrupt = make_shared<bool>(boost::any_cast<bool>(m["EnableVoiceInterrupt"]));
    }
    if (m.find("GracefulShutdown") != m.end() && !m["GracefulShutdown"].empty()) {
      gracefulShutdown = make_shared<bool>(boost::any_cast<bool>(m["GracefulShutdown"]));
    }
    if (m.find("Greeting") != m.end() && !m["Greeting"].empty()) {
      greeting = make_shared<string>(boost::any_cast<string>(m["Greeting"]));
    }
    if (m.find("InterruptWords") != m.end() && !m["InterruptWords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InterruptWords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InterruptWords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      interruptWords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LlmHistory") != m.end() && !m["LlmHistory"].empty()) {
      if (typeid(vector<boost::any>) == m["LlmHistory"].type()) {
        vector<AIAgentTemplateConfigAvatarChat3DLlmHistory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LlmHistory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AIAgentTemplateConfigAvatarChat3DLlmHistory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        llmHistory = make_shared<vector<AIAgentTemplateConfigAvatarChat3DLlmHistory>>(expect1);
      }
    }
    if (m.find("LlmHistoryLimit") != m.end() && !m["LlmHistoryLimit"].empty()) {
      llmHistoryLimit = make_shared<long>(boost::any_cast<long>(m["LlmHistoryLimit"]));
    }
    if (m.find("LlmSystemPrompt") != m.end() && !m["LlmSystemPrompt"].empty()) {
      llmSystemPrompt = make_shared<string>(boost::any_cast<string>(m["LlmSystemPrompt"]));
    }
    if (m.find("MaxIdleTime") != m.end() && !m["MaxIdleTime"].empty()) {
      maxIdleTime = make_shared<long>(boost::any_cast<long>(m["MaxIdleTime"]));
    }
    if (m.find("UseVoiceprint") != m.end() && !m["UseVoiceprint"].empty()) {
      useVoiceprint = make_shared<bool>(boost::any_cast<bool>(m["UseVoiceprint"]));
    }
    if (m.find("UserOfflineTimeout") != m.end() && !m["UserOfflineTimeout"].empty()) {
      userOfflineTimeout = make_shared<long>(boost::any_cast<long>(m["UserOfflineTimeout"]));
    }
    if (m.find("UserOnlineTimeout") != m.end() && !m["UserOnlineTimeout"].empty()) {
      userOnlineTimeout = make_shared<long>(boost::any_cast<long>(m["UserOnlineTimeout"]));
    }
    if (m.find("VadLevel") != m.end() && !m["VadLevel"].empty()) {
      vadLevel = make_shared<long>(boost::any_cast<long>(m["VadLevel"]));
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
    if (m.find("VoiceIdList") != m.end() && !m["VoiceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VoiceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VoiceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      voiceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VoiceprintId") != m.end() && !m["VoiceprintId"].empty()) {
      voiceprintId = make_shared<string>(boost::any_cast<string>(m["VoiceprintId"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
    if (m.find("WakeUpQuery") != m.end() && !m["WakeUpQuery"].empty()) {
      wakeUpQuery = make_shared<string>(boost::any_cast<string>(m["WakeUpQuery"]));
    }
    if (m.find("WorkflowOverrideParams") != m.end() && !m["WorkflowOverrideParams"].empty()) {
      workflowOverrideParams = make_shared<string>(boost::any_cast<string>(m["WorkflowOverrideParams"]));
    }
  }


  virtual ~AIAgentTemplateConfigAvatarChat3D() = default;
};
class AIAgentTemplateConfigVisionChatLlmHistory : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> role{};

  AIAgentTemplateConfigVisionChatLlmHistory() {}

  explicit AIAgentTemplateConfigVisionChatLlmHistory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~AIAgentTemplateConfigVisionChatLlmHistory() = default;
};
class AIAgentTemplateConfigVisionChat : public Darabonba::Model {
public:
  shared_ptr<vector<string>> asrHotWords{};
  shared_ptr<string> asrLanguageId{};
  shared_ptr<long> asrMaxSilence{};
  shared_ptr<string> bailianAppParams{};
  shared_ptr<bool> charBreak{};
  shared_ptr<bool> enableIntelligentSegment{};
  shared_ptr<bool> enablePushToTalk{};
  shared_ptr<bool> enableVoiceInterrupt{};
  shared_ptr<bool> gracefulShutdown{};
  shared_ptr<string> greeting{};
  shared_ptr<vector<string>> interruptWords{};
  shared_ptr<vector<AIAgentTemplateConfigVisionChatLlmHistory>> llmHistory{};
  shared_ptr<long> llmHistoryLimit{};
  shared_ptr<string> llmSystemPrompt{};
  shared_ptr<long> maxIdleTime{};
  shared_ptr<bool> useVoiceprint{};
  shared_ptr<long> userOfflineTimeout{};
  shared_ptr<long> userOnlineTimeout{};
  shared_ptr<long> vadLevel{};
  shared_ptr<string> voiceId{};
  shared_ptr<vector<string>> voiceIdList{};
  shared_ptr<string> voiceprintId{};
  shared_ptr<long> volume{};
  shared_ptr<string> wakeUpQuery{};
  shared_ptr<string> workflowOverrideParams{};

  AIAgentTemplateConfigVisionChat() {}

  explicit AIAgentTemplateConfigVisionChat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asrHotWords) {
      res["AsrHotWords"] = boost::any(*asrHotWords);
    }
    if (asrLanguageId) {
      res["AsrLanguageId"] = boost::any(*asrLanguageId);
    }
    if (asrMaxSilence) {
      res["AsrMaxSilence"] = boost::any(*asrMaxSilence);
    }
    if (bailianAppParams) {
      res["BailianAppParams"] = boost::any(*bailianAppParams);
    }
    if (charBreak) {
      res["CharBreak"] = boost::any(*charBreak);
    }
    if (enableIntelligentSegment) {
      res["EnableIntelligentSegment"] = boost::any(*enableIntelligentSegment);
    }
    if (enablePushToTalk) {
      res["EnablePushToTalk"] = boost::any(*enablePushToTalk);
    }
    if (enableVoiceInterrupt) {
      res["EnableVoiceInterrupt"] = boost::any(*enableVoiceInterrupt);
    }
    if (gracefulShutdown) {
      res["GracefulShutdown"] = boost::any(*gracefulShutdown);
    }
    if (greeting) {
      res["Greeting"] = boost::any(*greeting);
    }
    if (interruptWords) {
      res["InterruptWords"] = boost::any(*interruptWords);
    }
    if (llmHistory) {
      vector<boost::any> temp1;
      for(auto item1:*llmHistory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LlmHistory"] = boost::any(temp1);
    }
    if (llmHistoryLimit) {
      res["LlmHistoryLimit"] = boost::any(*llmHistoryLimit);
    }
    if (llmSystemPrompt) {
      res["LlmSystemPrompt"] = boost::any(*llmSystemPrompt);
    }
    if (maxIdleTime) {
      res["MaxIdleTime"] = boost::any(*maxIdleTime);
    }
    if (useVoiceprint) {
      res["UseVoiceprint"] = boost::any(*useVoiceprint);
    }
    if (userOfflineTimeout) {
      res["UserOfflineTimeout"] = boost::any(*userOfflineTimeout);
    }
    if (userOnlineTimeout) {
      res["UserOnlineTimeout"] = boost::any(*userOnlineTimeout);
    }
    if (vadLevel) {
      res["VadLevel"] = boost::any(*vadLevel);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    if (voiceIdList) {
      res["VoiceIdList"] = boost::any(*voiceIdList);
    }
    if (voiceprintId) {
      res["VoiceprintId"] = boost::any(*voiceprintId);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    if (wakeUpQuery) {
      res["WakeUpQuery"] = boost::any(*wakeUpQuery);
    }
    if (workflowOverrideParams) {
      res["WorkflowOverrideParams"] = boost::any(*workflowOverrideParams);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsrHotWords") != m.end() && !m["AsrHotWords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AsrHotWords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AsrHotWords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      asrHotWords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AsrLanguageId") != m.end() && !m["AsrLanguageId"].empty()) {
      asrLanguageId = make_shared<string>(boost::any_cast<string>(m["AsrLanguageId"]));
    }
    if (m.find("AsrMaxSilence") != m.end() && !m["AsrMaxSilence"].empty()) {
      asrMaxSilence = make_shared<long>(boost::any_cast<long>(m["AsrMaxSilence"]));
    }
    if (m.find("BailianAppParams") != m.end() && !m["BailianAppParams"].empty()) {
      bailianAppParams = make_shared<string>(boost::any_cast<string>(m["BailianAppParams"]));
    }
    if (m.find("CharBreak") != m.end() && !m["CharBreak"].empty()) {
      charBreak = make_shared<bool>(boost::any_cast<bool>(m["CharBreak"]));
    }
    if (m.find("EnableIntelligentSegment") != m.end() && !m["EnableIntelligentSegment"].empty()) {
      enableIntelligentSegment = make_shared<bool>(boost::any_cast<bool>(m["EnableIntelligentSegment"]));
    }
    if (m.find("EnablePushToTalk") != m.end() && !m["EnablePushToTalk"].empty()) {
      enablePushToTalk = make_shared<bool>(boost::any_cast<bool>(m["EnablePushToTalk"]));
    }
    if (m.find("EnableVoiceInterrupt") != m.end() && !m["EnableVoiceInterrupt"].empty()) {
      enableVoiceInterrupt = make_shared<bool>(boost::any_cast<bool>(m["EnableVoiceInterrupt"]));
    }
    if (m.find("GracefulShutdown") != m.end() && !m["GracefulShutdown"].empty()) {
      gracefulShutdown = make_shared<bool>(boost::any_cast<bool>(m["GracefulShutdown"]));
    }
    if (m.find("Greeting") != m.end() && !m["Greeting"].empty()) {
      greeting = make_shared<string>(boost::any_cast<string>(m["Greeting"]));
    }
    if (m.find("InterruptWords") != m.end() && !m["InterruptWords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InterruptWords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InterruptWords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      interruptWords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LlmHistory") != m.end() && !m["LlmHistory"].empty()) {
      if (typeid(vector<boost::any>) == m["LlmHistory"].type()) {
        vector<AIAgentTemplateConfigVisionChatLlmHistory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LlmHistory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AIAgentTemplateConfigVisionChatLlmHistory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        llmHistory = make_shared<vector<AIAgentTemplateConfigVisionChatLlmHistory>>(expect1);
      }
    }
    if (m.find("LlmHistoryLimit") != m.end() && !m["LlmHistoryLimit"].empty()) {
      llmHistoryLimit = make_shared<long>(boost::any_cast<long>(m["LlmHistoryLimit"]));
    }
    if (m.find("LlmSystemPrompt") != m.end() && !m["LlmSystemPrompt"].empty()) {
      llmSystemPrompt = make_shared<string>(boost::any_cast<string>(m["LlmSystemPrompt"]));
    }
    if (m.find("MaxIdleTime") != m.end() && !m["MaxIdleTime"].empty()) {
      maxIdleTime = make_shared<long>(boost::any_cast<long>(m["MaxIdleTime"]));
    }
    if (m.find("UseVoiceprint") != m.end() && !m["UseVoiceprint"].empty()) {
      useVoiceprint = make_shared<bool>(boost::any_cast<bool>(m["UseVoiceprint"]));
    }
    if (m.find("UserOfflineTimeout") != m.end() && !m["UserOfflineTimeout"].empty()) {
      userOfflineTimeout = make_shared<long>(boost::any_cast<long>(m["UserOfflineTimeout"]));
    }
    if (m.find("UserOnlineTimeout") != m.end() && !m["UserOnlineTimeout"].empty()) {
      userOnlineTimeout = make_shared<long>(boost::any_cast<long>(m["UserOnlineTimeout"]));
    }
    if (m.find("VadLevel") != m.end() && !m["VadLevel"].empty()) {
      vadLevel = make_shared<long>(boost::any_cast<long>(m["VadLevel"]));
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
    if (m.find("VoiceIdList") != m.end() && !m["VoiceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VoiceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VoiceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      voiceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VoiceprintId") != m.end() && !m["VoiceprintId"].empty()) {
      voiceprintId = make_shared<string>(boost::any_cast<string>(m["VoiceprintId"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
    if (m.find("WakeUpQuery") != m.end() && !m["WakeUpQuery"].empty()) {
      wakeUpQuery = make_shared<string>(boost::any_cast<string>(m["WakeUpQuery"]));
    }
    if (m.find("WorkflowOverrideParams") != m.end() && !m["WorkflowOverrideParams"].empty()) {
      workflowOverrideParams = make_shared<string>(boost::any_cast<string>(m["WorkflowOverrideParams"]));
    }
  }


  virtual ~AIAgentTemplateConfigVisionChat() = default;
};
class AIAgentTemplateConfigVoiceChatLlmHistory : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> role{};

  AIAgentTemplateConfigVoiceChatLlmHistory() {}

  explicit AIAgentTemplateConfigVoiceChatLlmHistory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~AIAgentTemplateConfigVoiceChatLlmHistory() = default;
};
class AIAgentTemplateConfigVoiceChat : public Darabonba::Model {
public:
  shared_ptr<vector<string>> asrHotWords{};
  shared_ptr<string> asrLanguageId{};
  shared_ptr<long> asrMaxSilence{};
  shared_ptr<string> avatarUrl{};
  shared_ptr<string> avatarUrlType{};
  shared_ptr<string> bailianAppParams{};
  shared_ptr<bool> charBreak{};
  shared_ptr<bool> enableIntelligentSegment{};
  shared_ptr<bool> enablePushToTalk{};
  shared_ptr<bool> enableVoiceInterrupt{};
  shared_ptr<bool> gracefulShutdown{};
  shared_ptr<string> greeting{};
  shared_ptr<vector<string>> interruptWords{};
  shared_ptr<vector<AIAgentTemplateConfigVoiceChatLlmHistory>> llmHistory{};
  shared_ptr<long> llmHistoryLimit{};
  shared_ptr<string> llmSystemPrompt{};
  shared_ptr<long> maxIdleTime{};
  shared_ptr<bool> useVoiceprint{};
  shared_ptr<long> userOfflineTimeout{};
  shared_ptr<long> userOnlineTimeout{};
  shared_ptr<long> vadLevel{};
  shared_ptr<string> voiceId{};
  shared_ptr<vector<string>> voiceIdList{};
  shared_ptr<string> voiceprintId{};
  shared_ptr<long> volume{};
  shared_ptr<string> wakeUpQuery{};
  shared_ptr<string> workflowOverrideParams{};

  AIAgentTemplateConfigVoiceChat() {}

  explicit AIAgentTemplateConfigVoiceChat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asrHotWords) {
      res["AsrHotWords"] = boost::any(*asrHotWords);
    }
    if (asrLanguageId) {
      res["AsrLanguageId"] = boost::any(*asrLanguageId);
    }
    if (asrMaxSilence) {
      res["AsrMaxSilence"] = boost::any(*asrMaxSilence);
    }
    if (avatarUrl) {
      res["AvatarUrl"] = boost::any(*avatarUrl);
    }
    if (avatarUrlType) {
      res["AvatarUrlType"] = boost::any(*avatarUrlType);
    }
    if (bailianAppParams) {
      res["BailianAppParams"] = boost::any(*bailianAppParams);
    }
    if (charBreak) {
      res["CharBreak"] = boost::any(*charBreak);
    }
    if (enableIntelligentSegment) {
      res["EnableIntelligentSegment"] = boost::any(*enableIntelligentSegment);
    }
    if (enablePushToTalk) {
      res["EnablePushToTalk"] = boost::any(*enablePushToTalk);
    }
    if (enableVoiceInterrupt) {
      res["EnableVoiceInterrupt"] = boost::any(*enableVoiceInterrupt);
    }
    if (gracefulShutdown) {
      res["GracefulShutdown"] = boost::any(*gracefulShutdown);
    }
    if (greeting) {
      res["Greeting"] = boost::any(*greeting);
    }
    if (interruptWords) {
      res["InterruptWords"] = boost::any(*interruptWords);
    }
    if (llmHistory) {
      vector<boost::any> temp1;
      for(auto item1:*llmHistory){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LlmHistory"] = boost::any(temp1);
    }
    if (llmHistoryLimit) {
      res["LlmHistoryLimit"] = boost::any(*llmHistoryLimit);
    }
    if (llmSystemPrompt) {
      res["LlmSystemPrompt"] = boost::any(*llmSystemPrompt);
    }
    if (maxIdleTime) {
      res["MaxIdleTime"] = boost::any(*maxIdleTime);
    }
    if (useVoiceprint) {
      res["UseVoiceprint"] = boost::any(*useVoiceprint);
    }
    if (userOfflineTimeout) {
      res["UserOfflineTimeout"] = boost::any(*userOfflineTimeout);
    }
    if (userOnlineTimeout) {
      res["UserOnlineTimeout"] = boost::any(*userOnlineTimeout);
    }
    if (vadLevel) {
      res["VadLevel"] = boost::any(*vadLevel);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    if (voiceIdList) {
      res["VoiceIdList"] = boost::any(*voiceIdList);
    }
    if (voiceprintId) {
      res["VoiceprintId"] = boost::any(*voiceprintId);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    if (wakeUpQuery) {
      res["WakeUpQuery"] = boost::any(*wakeUpQuery);
    }
    if (workflowOverrideParams) {
      res["WorkflowOverrideParams"] = boost::any(*workflowOverrideParams);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsrHotWords") != m.end() && !m["AsrHotWords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AsrHotWords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AsrHotWords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      asrHotWords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AsrLanguageId") != m.end() && !m["AsrLanguageId"].empty()) {
      asrLanguageId = make_shared<string>(boost::any_cast<string>(m["AsrLanguageId"]));
    }
    if (m.find("AsrMaxSilence") != m.end() && !m["AsrMaxSilence"].empty()) {
      asrMaxSilence = make_shared<long>(boost::any_cast<long>(m["AsrMaxSilence"]));
    }
    if (m.find("AvatarUrl") != m.end() && !m["AvatarUrl"].empty()) {
      avatarUrl = make_shared<string>(boost::any_cast<string>(m["AvatarUrl"]));
    }
    if (m.find("AvatarUrlType") != m.end() && !m["AvatarUrlType"].empty()) {
      avatarUrlType = make_shared<string>(boost::any_cast<string>(m["AvatarUrlType"]));
    }
    if (m.find("BailianAppParams") != m.end() && !m["BailianAppParams"].empty()) {
      bailianAppParams = make_shared<string>(boost::any_cast<string>(m["BailianAppParams"]));
    }
    if (m.find("CharBreak") != m.end() && !m["CharBreak"].empty()) {
      charBreak = make_shared<bool>(boost::any_cast<bool>(m["CharBreak"]));
    }
    if (m.find("EnableIntelligentSegment") != m.end() && !m["EnableIntelligentSegment"].empty()) {
      enableIntelligentSegment = make_shared<bool>(boost::any_cast<bool>(m["EnableIntelligentSegment"]));
    }
    if (m.find("EnablePushToTalk") != m.end() && !m["EnablePushToTalk"].empty()) {
      enablePushToTalk = make_shared<bool>(boost::any_cast<bool>(m["EnablePushToTalk"]));
    }
    if (m.find("EnableVoiceInterrupt") != m.end() && !m["EnableVoiceInterrupt"].empty()) {
      enableVoiceInterrupt = make_shared<bool>(boost::any_cast<bool>(m["EnableVoiceInterrupt"]));
    }
    if (m.find("GracefulShutdown") != m.end() && !m["GracefulShutdown"].empty()) {
      gracefulShutdown = make_shared<bool>(boost::any_cast<bool>(m["GracefulShutdown"]));
    }
    if (m.find("Greeting") != m.end() && !m["Greeting"].empty()) {
      greeting = make_shared<string>(boost::any_cast<string>(m["Greeting"]));
    }
    if (m.find("InterruptWords") != m.end() && !m["InterruptWords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InterruptWords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InterruptWords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      interruptWords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LlmHistory") != m.end() && !m["LlmHistory"].empty()) {
      if (typeid(vector<boost::any>) == m["LlmHistory"].type()) {
        vector<AIAgentTemplateConfigVoiceChatLlmHistory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LlmHistory"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AIAgentTemplateConfigVoiceChatLlmHistory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        llmHistory = make_shared<vector<AIAgentTemplateConfigVoiceChatLlmHistory>>(expect1);
      }
    }
    if (m.find("LlmHistoryLimit") != m.end() && !m["LlmHistoryLimit"].empty()) {
      llmHistoryLimit = make_shared<long>(boost::any_cast<long>(m["LlmHistoryLimit"]));
    }
    if (m.find("LlmSystemPrompt") != m.end() && !m["LlmSystemPrompt"].empty()) {
      llmSystemPrompt = make_shared<string>(boost::any_cast<string>(m["LlmSystemPrompt"]));
    }
    if (m.find("MaxIdleTime") != m.end() && !m["MaxIdleTime"].empty()) {
      maxIdleTime = make_shared<long>(boost::any_cast<long>(m["MaxIdleTime"]));
    }
    if (m.find("UseVoiceprint") != m.end() && !m["UseVoiceprint"].empty()) {
      useVoiceprint = make_shared<bool>(boost::any_cast<bool>(m["UseVoiceprint"]));
    }
    if (m.find("UserOfflineTimeout") != m.end() && !m["UserOfflineTimeout"].empty()) {
      userOfflineTimeout = make_shared<long>(boost::any_cast<long>(m["UserOfflineTimeout"]));
    }
    if (m.find("UserOnlineTimeout") != m.end() && !m["UserOnlineTimeout"].empty()) {
      userOnlineTimeout = make_shared<long>(boost::any_cast<long>(m["UserOnlineTimeout"]));
    }
    if (m.find("VadLevel") != m.end() && !m["VadLevel"].empty()) {
      vadLevel = make_shared<long>(boost::any_cast<long>(m["VadLevel"]));
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
    if (m.find("VoiceIdList") != m.end() && !m["VoiceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VoiceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VoiceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      voiceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VoiceprintId") != m.end() && !m["VoiceprintId"].empty()) {
      voiceprintId = make_shared<string>(boost::any_cast<string>(m["VoiceprintId"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
    if (m.find("WakeUpQuery") != m.end() && !m["WakeUpQuery"].empty()) {
      wakeUpQuery = make_shared<string>(boost::any_cast<string>(m["WakeUpQuery"]));
    }
    if (m.find("WorkflowOverrideParams") != m.end() && !m["WorkflowOverrideParams"].empty()) {
      workflowOverrideParams = make_shared<string>(boost::any_cast<string>(m["WorkflowOverrideParams"]));
    }
  }


  virtual ~AIAgentTemplateConfigVoiceChat() = default;
};
class AIAgentTemplateConfig : public Darabonba::Model {
public:
  shared_ptr<AIAgentTemplateConfigAvatarChat3D> avatarChat3D{};
  shared_ptr<AIAgentTemplateConfigVisionChat> visionChat{};
  shared_ptr<AIAgentTemplateConfigVoiceChat> voiceChat{};

  AIAgentTemplateConfig() {}

  explicit AIAgentTemplateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarChat3D) {
      res["AvatarChat3D"] = avatarChat3D ? boost::any(avatarChat3D->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visionChat) {
      res["VisionChat"] = visionChat ? boost::any(visionChat->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (voiceChat) {
      res["VoiceChat"] = voiceChat ? boost::any(voiceChat->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarChat3D") != m.end() && !m["AvatarChat3D"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvatarChat3D"].type()) {
        AIAgentTemplateConfigAvatarChat3D model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvatarChat3D"]));
        avatarChat3D = make_shared<AIAgentTemplateConfigAvatarChat3D>(model1);
      }
    }
    if (m.find("VisionChat") != m.end() && !m["VisionChat"].empty()) {
      if (typeid(map<string, boost::any>) == m["VisionChat"].type()) {
        AIAgentTemplateConfigVisionChat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VisionChat"]));
        visionChat = make_shared<AIAgentTemplateConfigVisionChat>(model1);
      }
    }
    if (m.find("VoiceChat") != m.end() && !m["VoiceChat"].empty()) {
      if (typeid(map<string, boost::any>) == m["VoiceChat"].type()) {
        AIAgentTemplateConfigVoiceChat model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VoiceChat"]));
        voiceChat = make_shared<AIAgentTemplateConfigVoiceChat>(model1);
      }
    }
  }


  virtual ~AIAgentTemplateConfig() = default;
};
class AppInfoDTOPlatforms : public Darabonba::Model {
public:
  shared_ptr<string> itemId{};
  shared_ptr<vector<string>> licenseItemIds{};
  shared_ptr<string> pkgName{};
  shared_ptr<string> pkgSignature{};
  shared_ptr<long> platformType{};
  shared_ptr<long> type{};

  AppInfoDTOPlatforms() {}

  explicit AppInfoDTOPlatforms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (licenseItemIds) {
      res["LicenseItemIds"] = boost::any(*licenseItemIds);
    }
    if (pkgName) {
      res["PkgName"] = boost::any(*pkgName);
    }
    if (pkgSignature) {
      res["PkgSignature"] = boost::any(*pkgSignature);
    }
    if (platformType) {
      res["PlatformType"] = boost::any(*platformType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("LicenseItemIds") != m.end() && !m["LicenseItemIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LicenseItemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LicenseItemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      licenseItemIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PkgName") != m.end() && !m["PkgName"].empty()) {
      pkgName = make_shared<string>(boost::any_cast<string>(m["PkgName"]));
    }
    if (m.find("PkgSignature") != m.end() && !m["PkgSignature"].empty()) {
      pkgSignature = make_shared<string>(boost::any_cast<string>(m["PkgSignature"]));
    }
    if (m.find("PlatformType") != m.end() && !m["PlatformType"].empty()) {
      platformType = make_shared<long>(boost::any_cast<long>(m["PlatformType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~AppInfoDTOPlatforms() = default;
};
class AppInfoDTO : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<long> appType{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> itemId{};
  shared_ptr<string> modificationTime{};
  shared_ptr<vector<AppInfoDTOPlatforms>> platforms{};
  shared_ptr<long> userId{};

  AppInfoDTO() {}

  explicit AppInfoDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (platforms) {
      vector<boost::any> temp1;
      for(auto item1:*platforms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Platforms"] = boost::any(temp1);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<long>(boost::any_cast<long>(m["AppType"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("Platforms") != m.end() && !m["Platforms"].empty()) {
      if (typeid(vector<boost::any>) == m["Platforms"].type()) {
        vector<AppInfoDTOPlatforms> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Platforms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AppInfoDTOPlatforms model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        platforms = make_shared<vector<AppInfoDTOPlatforms>>(expect1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~AppInfoDTO() = default;
};
class ChannelOutPutConfigList : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> format{};
  shared_ptr<string> manifestName{};
  shared_ptr<string> manifestSettings{};
  shared_ptr<string> playbackUrl{};
  shared_ptr<string> sourceGroupName{};

  ChannelOutPutConfigList() {}

  explicit ChannelOutPutConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (manifestName) {
      res["ManifestName"] = boost::any(*manifestName);
    }
    if (manifestSettings) {
      res["ManifestSettings"] = boost::any(*manifestSettings);
    }
    if (playbackUrl) {
      res["PlaybackUrl"] = boost::any(*playbackUrl);
    }
    if (sourceGroupName) {
      res["SourceGroupName"] = boost::any(*sourceGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("ManifestName") != m.end() && !m["ManifestName"].empty()) {
      manifestName = make_shared<string>(boost::any_cast<string>(m["ManifestName"]));
    }
    if (m.find("ManifestSettings") != m.end() && !m["ManifestSettings"].empty()) {
      manifestSettings = make_shared<string>(boost::any_cast<string>(m["ManifestSettings"]));
    }
    if (m.find("PlaybackUrl") != m.end() && !m["PlaybackUrl"].empty()) {
      playbackUrl = make_shared<string>(boost::any_cast<string>(m["PlaybackUrl"]));
    }
    if (m.find("SourceGroupName") != m.end() && !m["SourceGroupName"].empty()) {
      sourceGroupName = make_shared<string>(boost::any_cast<string>(m["SourceGroupName"]));
    }
  }


  virtual ~ChannelOutPutConfigList() = default;
};
class Channel : public Darabonba::Model {
public:
  shared_ptr<bool> accessPolicy{};
  shared_ptr<string> accessToken{};
  shared_ptr<string> arn{};
  shared_ptr<string> channelName{};
  shared_ptr<string> channelTier{};
  shared_ptr<string> fillerSourceLocationName{};
  shared_ptr<string> fillerSourceName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<vector<ChannelOutPutConfigList>> outPutConfigList{};
  shared_ptr<string> playbackMode{};
  shared_ptr<long> state{};

  Channel() {}

  explicit Channel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPolicy) {
      res["AccessPolicy"] = boost::any(*accessPolicy);
    }
    if (accessToken) {
      res["AccessToken"] = boost::any(*accessToken);
    }
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (channelTier) {
      res["ChannelTier"] = boost::any(*channelTier);
    }
    if (fillerSourceLocationName) {
      res["FillerSourceLocationName"] = boost::any(*fillerSourceLocationName);
    }
    if (fillerSourceName) {
      res["FillerSourceName"] = boost::any(*fillerSourceName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (outPutConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*outPutConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutPutConfigList"] = boost::any(temp1);
    }
    if (playbackMode) {
      res["PlaybackMode"] = boost::any(*playbackMode);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPolicy") != m.end() && !m["AccessPolicy"].empty()) {
      accessPolicy = make_shared<bool>(boost::any_cast<bool>(m["AccessPolicy"]));
    }
    if (m.find("AccessToken") != m.end() && !m["AccessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["AccessToken"]));
    }
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ChannelTier") != m.end() && !m["ChannelTier"].empty()) {
      channelTier = make_shared<string>(boost::any_cast<string>(m["ChannelTier"]));
    }
    if (m.find("FillerSourceLocationName") != m.end() && !m["FillerSourceLocationName"].empty()) {
      fillerSourceLocationName = make_shared<string>(boost::any_cast<string>(m["FillerSourceLocationName"]));
    }
    if (m.find("FillerSourceName") != m.end() && !m["FillerSourceName"].empty()) {
      fillerSourceName = make_shared<string>(boost::any_cast<string>(m["FillerSourceName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("OutPutConfigList") != m.end() && !m["OutPutConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["OutPutConfigList"].type()) {
        vector<ChannelOutPutConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutPutConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ChannelOutPutConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outPutConfigList = make_shared<vector<ChannelOutPutConfigList>>(expect1);
      }
    }
    if (m.find("PlaybackMode") != m.end() && !m["PlaybackMode"].empty()) {
      playbackMode = make_shared<string>(boost::any_cast<string>(m["PlaybackMode"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
  }


  virtual ~Channel() = default;
};
class ChannelAssemblyChannelOutPutConfigList : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> format{};
  shared_ptr<string> manifestName{};
  shared_ptr<string> manifestSettings{};
  shared_ptr<string> playbackUrl{};
  shared_ptr<string> sourceGroupName{};

  ChannelAssemblyChannelOutPutConfigList() {}

  explicit ChannelAssemblyChannelOutPutConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (manifestName) {
      res["ManifestName"] = boost::any(*manifestName);
    }
    if (manifestSettings) {
      res["ManifestSettings"] = boost::any(*manifestSettings);
    }
    if (playbackUrl) {
      res["PlaybackUrl"] = boost::any(*playbackUrl);
    }
    if (sourceGroupName) {
      res["SourceGroupName"] = boost::any(*sourceGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("ManifestName") != m.end() && !m["ManifestName"].empty()) {
      manifestName = make_shared<string>(boost::any_cast<string>(m["ManifestName"]));
    }
    if (m.find("ManifestSettings") != m.end() && !m["ManifestSettings"].empty()) {
      manifestSettings = make_shared<string>(boost::any_cast<string>(m["ManifestSettings"]));
    }
    if (m.find("PlaybackUrl") != m.end() && !m["PlaybackUrl"].empty()) {
      playbackUrl = make_shared<string>(boost::any_cast<string>(m["PlaybackUrl"]));
    }
    if (m.find("SourceGroupName") != m.end() && !m["SourceGroupName"].empty()) {
      sourceGroupName = make_shared<string>(boost::any_cast<string>(m["SourceGroupName"]));
    }
  }


  virtual ~ChannelAssemblyChannelOutPutConfigList() = default;
};
class ChannelAssemblyChannel : public Darabonba::Model {
public:
  shared_ptr<bool> accessPolicy{};
  shared_ptr<string> accessToken{};
  shared_ptr<string> arn{};
  shared_ptr<string> channelName{};
  shared_ptr<string> channelTier{};
  shared_ptr<string> fillerSourceLocationName{};
  shared_ptr<string> fillerSourceName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<vector<ChannelAssemblyChannelOutPutConfigList>> outPutConfigList{};
  shared_ptr<string> playbackMode{};
  shared_ptr<long> state{};

  ChannelAssemblyChannel() {}

  explicit ChannelAssemblyChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPolicy) {
      res["AccessPolicy"] = boost::any(*accessPolicy);
    }
    if (accessToken) {
      res["AccessToken"] = boost::any(*accessToken);
    }
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (channelTier) {
      res["ChannelTier"] = boost::any(*channelTier);
    }
    if (fillerSourceLocationName) {
      res["FillerSourceLocationName"] = boost::any(*fillerSourceLocationName);
    }
    if (fillerSourceName) {
      res["FillerSourceName"] = boost::any(*fillerSourceName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (outPutConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*outPutConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutPutConfigList"] = boost::any(temp1);
    }
    if (playbackMode) {
      res["PlaybackMode"] = boost::any(*playbackMode);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPolicy") != m.end() && !m["AccessPolicy"].empty()) {
      accessPolicy = make_shared<bool>(boost::any_cast<bool>(m["AccessPolicy"]));
    }
    if (m.find("AccessToken") != m.end() && !m["AccessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["AccessToken"]));
    }
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ChannelTier") != m.end() && !m["ChannelTier"].empty()) {
      channelTier = make_shared<string>(boost::any_cast<string>(m["ChannelTier"]));
    }
    if (m.find("FillerSourceLocationName") != m.end() && !m["FillerSourceLocationName"].empty()) {
      fillerSourceLocationName = make_shared<string>(boost::any_cast<string>(m["FillerSourceLocationName"]));
    }
    if (m.find("FillerSourceName") != m.end() && !m["FillerSourceName"].empty()) {
      fillerSourceName = make_shared<string>(boost::any_cast<string>(m["FillerSourceName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("OutPutConfigList") != m.end() && !m["OutPutConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["OutPutConfigList"].type()) {
        vector<ChannelAssemblyChannelOutPutConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutPutConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ChannelAssemblyChannelOutPutConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outPutConfigList = make_shared<vector<ChannelAssemblyChannelOutPutConfigList>>(expect1);
      }
    }
    if (m.find("PlaybackMode") != m.end() && !m["PlaybackMode"].empty()) {
      playbackMode = make_shared<string>(boost::any_cast<string>(m["PlaybackMode"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
  }


  virtual ~ChannelAssemblyChannel() = default;
};
class ChannelAssemblyProgramAdBreaks : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> messageType{};
  shared_ptr<long> offsetMillis{};
  shared_ptr<string> programName{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> spliceInsertSettings{};
  shared_ptr<string> timeSignalSettings{};

  ChannelAssemblyProgramAdBreaks() {}

  explicit ChannelAssemblyProgramAdBreaks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (messageType) {
      res["MessageType"] = boost::any(*messageType);
    }
    if (offsetMillis) {
      res["OffsetMillis"] = boost::any(*offsetMillis);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (spliceInsertSettings) {
      res["SpliceInsertSettings"] = boost::any(*spliceInsertSettings);
    }
    if (timeSignalSettings) {
      res["TimeSignalSettings"] = boost::any(*timeSignalSettings);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("MessageType") != m.end() && !m["MessageType"].empty()) {
      messageType = make_shared<string>(boost::any_cast<string>(m["MessageType"]));
    }
    if (m.find("OffsetMillis") != m.end() && !m["OffsetMillis"].empty()) {
      offsetMillis = make_shared<long>(boost::any_cast<long>(m["OffsetMillis"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SpliceInsertSettings") != m.end() && !m["SpliceInsertSettings"].empty()) {
      spliceInsertSettings = make_shared<string>(boost::any_cast<string>(m["SpliceInsertSettings"]));
    }
    if (m.find("TimeSignalSettings") != m.end() && !m["TimeSignalSettings"].empty()) {
      timeSignalSettings = make_shared<string>(boost::any_cast<string>(m["TimeSignalSettings"]));
    }
  }


  virtual ~ChannelAssemblyProgramAdBreaks() = default;
};
class ChannelAssemblyProgram : public Darabonba::Model {
public:
  shared_ptr<vector<ChannelAssemblyProgramAdBreaks>> adBreaks{};
  shared_ptr<string> arn{};
  shared_ptr<string> channelName{};
  shared_ptr<string> clipRange{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> programName{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> transition{};

  ChannelAssemblyProgram() {}

  explicit ChannelAssemblyProgram(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adBreaks) {
      vector<boost::any> temp1;
      for(auto item1:*adBreaks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdBreaks"] = boost::any(temp1);
    }
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (clipRange) {
      res["ClipRange"] = boost::any(*clipRange);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (transition) {
      res["Transition"] = boost::any(*transition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdBreaks") != m.end() && !m["AdBreaks"].empty()) {
      if (typeid(vector<boost::any>) == m["AdBreaks"].type()) {
        vector<ChannelAssemblyProgramAdBreaks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdBreaks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ChannelAssemblyProgramAdBreaks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adBreaks = make_shared<vector<ChannelAssemblyProgramAdBreaks>>(expect1);
      }
    }
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ClipRange") != m.end() && !m["ClipRange"].empty()) {
      clipRange = make_shared<string>(boost::any_cast<string>(m["ClipRange"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Transition") != m.end() && !m["Transition"].empty()) {
      transition = make_shared<string>(boost::any_cast<string>(m["Transition"]));
    }
  }


  virtual ~ChannelAssemblyProgram() = default;
};
class ChannelAssemblyScheduleDataAdBreaks : public Darabonba::Model {
public:
  shared_ptr<string> messageType{};
  shared_ptr<string> offsetMillis{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> spliceInsertSettings{};
  shared_ptr<string> timeSignalSettings{};

  ChannelAssemblyScheduleDataAdBreaks() {}

  explicit ChannelAssemblyScheduleDataAdBreaks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageType) {
      res["MessageType"] = boost::any(*messageType);
    }
    if (offsetMillis) {
      res["OffsetMillis"] = boost::any(*offsetMillis);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (spliceInsertSettings) {
      res["SpliceInsertSettings"] = boost::any(*spliceInsertSettings);
    }
    if (timeSignalSettings) {
      res["TimeSignalSettings"] = boost::any(*timeSignalSettings);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageType") != m.end() && !m["MessageType"].empty()) {
      messageType = make_shared<string>(boost::any_cast<string>(m["MessageType"]));
    }
    if (m.find("OffsetMillis") != m.end() && !m["OffsetMillis"].empty()) {
      offsetMillis = make_shared<string>(boost::any_cast<string>(m["OffsetMillis"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SpliceInsertSettings") != m.end() && !m["SpliceInsertSettings"].empty()) {
      spliceInsertSettings = make_shared<string>(boost::any_cast<string>(m["SpliceInsertSettings"]));
    }
    if (m.find("TimeSignalSettings") != m.end() && !m["TimeSignalSettings"].empty()) {
      timeSignalSettings = make_shared<string>(boost::any_cast<string>(m["TimeSignalSettings"]));
    }
  }


  virtual ~ChannelAssemblyScheduleDataAdBreaks() = default;
};
class ChannelAssemblyScheduleData : public Darabonba::Model {
public:
  shared_ptr<vector<ChannelAssemblyScheduleDataAdBreaks>> adBreaks{};
  shared_ptr<long> approximateDurationSeconds{};
  shared_ptr<string> approximateStartTime{};
  shared_ptr<string> entryType{};
  shared_ptr<string> programName{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceType{};

  ChannelAssemblyScheduleData() {}

  explicit ChannelAssemblyScheduleData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adBreaks) {
      vector<boost::any> temp1;
      for(auto item1:*adBreaks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdBreaks"] = boost::any(temp1);
    }
    if (approximateDurationSeconds) {
      res["ApproximateDurationSeconds"] = boost::any(*approximateDurationSeconds);
    }
    if (approximateStartTime) {
      res["ApproximateStartTime"] = boost::any(*approximateStartTime);
    }
    if (entryType) {
      res["EntryType"] = boost::any(*entryType);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdBreaks") != m.end() && !m["AdBreaks"].empty()) {
      if (typeid(vector<boost::any>) == m["AdBreaks"].type()) {
        vector<ChannelAssemblyScheduleDataAdBreaks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdBreaks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ChannelAssemblyScheduleDataAdBreaks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adBreaks = make_shared<vector<ChannelAssemblyScheduleDataAdBreaks>>(expect1);
      }
    }
    if (m.find("ApproximateDurationSeconds") != m.end() && !m["ApproximateDurationSeconds"].empty()) {
      approximateDurationSeconds = make_shared<long>(boost::any_cast<long>(m["ApproximateDurationSeconds"]));
    }
    if (m.find("ApproximateStartTime") != m.end() && !m["ApproximateStartTime"].empty()) {
      approximateStartTime = make_shared<string>(boost::any_cast<string>(m["ApproximateStartTime"]));
    }
    if (m.find("EntryType") != m.end() && !m["EntryType"].empty()) {
      entryType = make_shared<string>(boost::any_cast<string>(m["EntryType"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~ChannelAssemblyScheduleData() = default;
};
class ChannelAssemblySource : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> httpPackageConfigurations{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceType{};
  shared_ptr<long> state{};

  ChannelAssemblySource() {}

  explicit ChannelAssemblySource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (httpPackageConfigurations) {
      res["HttpPackageConfigurations"] = boost::any(*httpPackageConfigurations);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("HttpPackageConfigurations") != m.end() && !m["HttpPackageConfigurations"].empty()) {
      httpPackageConfigurations = make_shared<string>(boost::any_cast<string>(m["HttpPackageConfigurations"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
  }


  virtual ~ChannelAssemblySource() = default;
};
class ChannelAssemblySourceLocation : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> baseUrl{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> segmentDeliveryConfigurations{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<long> state{};

  ChannelAssemblySourceLocation() {}

  explicit ChannelAssemblySourceLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (baseUrl) {
      res["BaseUrl"] = boost::any(*baseUrl);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (segmentDeliveryConfigurations) {
      res["SegmentDeliveryConfigurations"] = boost::any(*segmentDeliveryConfigurations);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("BaseUrl") != m.end() && !m["BaseUrl"].empty()) {
      baseUrl = make_shared<string>(boost::any_cast<string>(m["BaseUrl"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("SegmentDeliveryConfigurations") != m.end() && !m["SegmentDeliveryConfigurations"].empty()) {
      segmentDeliveryConfigurations = make_shared<string>(boost::any_cast<string>(m["SegmentDeliveryConfigurations"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
  }


  virtual ~ChannelAssemblySourceLocation() = default;
};
class TranspositionResult : public Darabonba::Model {
public:
  shared_ptr<string> targetLanguage{};
  shared_ptr<string> translatedText{};

  TranspositionResult() {}

  explicit TranspositionResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (targetLanguage) {
      res["TargetLanguage"] = boost::any(*targetLanguage);
    }
    if (translatedText) {
      res["TranslatedText"] = boost::any(*translatedText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TargetLanguage") != m.end() && !m["TargetLanguage"].empty()) {
      targetLanguage = make_shared<string>(boost::any_cast<string>(m["TargetLanguage"]));
    }
    if (m.find("TranslatedText") != m.end() && !m["TranslatedText"].empty()) {
      translatedText = make_shared<string>(boost::any_cast<string>(m["TranslatedText"]));
    }
  }


  virtual ~TranspositionResult() = default;
};
class Hotword : public Darabonba::Model {
public:
  shared_ptr<string> language{};
  shared_ptr<string> text{};
  shared_ptr<vector<TranspositionResult>> transpositionResultList{};
  shared_ptr<long> weight{};

  Hotword() {}

  explicit Hotword(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (transpositionResultList) {
      vector<boost::any> temp1;
      for(auto item1:*transpositionResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranspositionResultList"] = boost::any(temp1);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("TranspositionResultList") != m.end() && !m["TranspositionResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["TranspositionResultList"].type()) {
        vector<TranspositionResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranspositionResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TranspositionResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transpositionResultList = make_shared<vector<TranspositionResult>>(expect1);
      }
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~Hotword() = default;
};
class LicenseInstanceAppDTOLicenseConfigs : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> featureIds{};
  shared_ptr<bool> isTrial{};
  shared_ptr<long> sdkId{};
  shared_ptr<string> sdkName{};
  shared_ptr<string> subscription{};
  shared_ptr<string> subscriptionImp{};
  shared_ptr<string> subscriptionPkg{};

  LicenseInstanceAppDTOLicenseConfigs() {}

  explicit LicenseInstanceAppDTOLicenseConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (featureIds) {
      res["FeatureIds"] = boost::any(*featureIds);
    }
    if (isTrial) {
      res["IsTrial"] = boost::any(*isTrial);
    }
    if (sdkId) {
      res["SdkId"] = boost::any(*sdkId);
    }
    if (sdkName) {
      res["SdkName"] = boost::any(*sdkName);
    }
    if (subscription) {
      res["Subscription"] = boost::any(*subscription);
    }
    if (subscriptionImp) {
      res["SubscriptionImp"] = boost::any(*subscriptionImp);
    }
    if (subscriptionPkg) {
      res["SubscriptionPkg"] = boost::any(*subscriptionPkg);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("FeatureIds") != m.end() && !m["FeatureIds"].empty()) {
      featureIds = make_shared<string>(boost::any_cast<string>(m["FeatureIds"]));
    }
    if (m.find("IsTrial") != m.end() && !m["IsTrial"].empty()) {
      isTrial = make_shared<bool>(boost::any_cast<bool>(m["IsTrial"]));
    }
    if (m.find("SdkId") != m.end() && !m["SdkId"].empty()) {
      sdkId = make_shared<long>(boost::any_cast<long>(m["SdkId"]));
    }
    if (m.find("SdkName") != m.end() && !m["SdkName"].empty()) {
      sdkName = make_shared<string>(boost::any_cast<string>(m["SdkName"]));
    }
    if (m.find("Subscription") != m.end() && !m["Subscription"].empty()) {
      subscription = make_shared<string>(boost::any_cast<string>(m["Subscription"]));
    }
    if (m.find("SubscriptionImp") != m.end() && !m["SubscriptionImp"].empty()) {
      subscriptionImp = make_shared<string>(boost::any_cast<string>(m["SubscriptionImp"]));
    }
    if (m.find("SubscriptionPkg") != m.end() && !m["SubscriptionPkg"].empty()) {
      subscriptionPkg = make_shared<string>(boost::any_cast<string>(m["SubscriptionPkg"]));
    }
  }


  virtual ~LicenseInstanceAppDTOLicenseConfigs() = default;
};
class LicenseInstanceAppDTO : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> beginOn{};
  shared_ptr<string> contractNo{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> expiredOn{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> itemId{};
  shared_ptr<vector<LicenseInstanceAppDTOLicenseConfigs>> licenseConfigs{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> status{};
  shared_ptr<long> userId{};

  LicenseInstanceAppDTO() {}

  explicit LicenseInstanceAppDTO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (beginOn) {
      res["BeginOn"] = boost::any(*beginOn);
    }
    if (contractNo) {
      res["ContractNo"] = boost::any(*contractNo);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (expiredOn) {
      res["ExpiredOn"] = boost::any(*expiredOn);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (itemId) {
      res["ItemId"] = boost::any(*itemId);
    }
    if (licenseConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*licenseConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LicenseConfigs"] = boost::any(temp1);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("BeginOn") != m.end() && !m["BeginOn"].empty()) {
      beginOn = make_shared<string>(boost::any_cast<string>(m["BeginOn"]));
    }
    if (m.find("ContractNo") != m.end() && !m["ContractNo"].empty()) {
      contractNo = make_shared<string>(boost::any_cast<string>(m["ContractNo"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ExpiredOn") != m.end() && !m["ExpiredOn"].empty()) {
      expiredOn = make_shared<string>(boost::any_cast<string>(m["ExpiredOn"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ItemId") != m.end() && !m["ItemId"].empty()) {
      itemId = make_shared<string>(boost::any_cast<string>(m["ItemId"]));
    }
    if (m.find("LicenseConfigs") != m.end() && !m["LicenseConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["LicenseConfigs"].type()) {
        vector<LicenseInstanceAppDTOLicenseConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LicenseConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LicenseInstanceAppDTOLicenseConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        licenseConfigs = make_shared<vector<LicenseInstanceAppDTOLicenseConfigs>>(expect1);
      }
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~LicenseInstanceAppDTO() = default;
};
class LiveManifestConfig : public Darabonba::Model {
public:
  shared_ptr<string> adMarkers{};
  shared_ptr<long> dateTimeInterval{};
  shared_ptr<long> manifestDuration{};
  shared_ptr<long> maxVideoBitrate{};
  shared_ptr<long> minBufferTime{};
  shared_ptr<long> minUpdatePeriod{};
  shared_ptr<long> minVideoBitrate{};
  shared_ptr<long> presentationDelay{};
  shared_ptr<long> segmentCount{};
  shared_ptr<string> segmentTemplateFormat{};
  shared_ptr<string> streamOrder{};

  LiveManifestConfig() {}

  explicit LiveManifestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adMarkers) {
      res["AdMarkers"] = boost::any(*adMarkers);
    }
    if (dateTimeInterval) {
      res["DateTimeInterval"] = boost::any(*dateTimeInterval);
    }
    if (manifestDuration) {
      res["ManifestDuration"] = boost::any(*manifestDuration);
    }
    if (maxVideoBitrate) {
      res["MaxVideoBitrate"] = boost::any(*maxVideoBitrate);
    }
    if (minBufferTime) {
      res["MinBufferTime"] = boost::any(*minBufferTime);
    }
    if (minUpdatePeriod) {
      res["MinUpdatePeriod"] = boost::any(*minUpdatePeriod);
    }
    if (minVideoBitrate) {
      res["MinVideoBitrate"] = boost::any(*minVideoBitrate);
    }
    if (presentationDelay) {
      res["PresentationDelay"] = boost::any(*presentationDelay);
    }
    if (segmentCount) {
      res["SegmentCount"] = boost::any(*segmentCount);
    }
    if (segmentTemplateFormat) {
      res["SegmentTemplateFormat"] = boost::any(*segmentTemplateFormat);
    }
    if (streamOrder) {
      res["StreamOrder"] = boost::any(*streamOrder);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdMarkers") != m.end() && !m["AdMarkers"].empty()) {
      adMarkers = make_shared<string>(boost::any_cast<string>(m["AdMarkers"]));
    }
    if (m.find("DateTimeInterval") != m.end() && !m["DateTimeInterval"].empty()) {
      dateTimeInterval = make_shared<long>(boost::any_cast<long>(m["DateTimeInterval"]));
    }
    if (m.find("ManifestDuration") != m.end() && !m["ManifestDuration"].empty()) {
      manifestDuration = make_shared<long>(boost::any_cast<long>(m["ManifestDuration"]));
    }
    if (m.find("MaxVideoBitrate") != m.end() && !m["MaxVideoBitrate"].empty()) {
      maxVideoBitrate = make_shared<long>(boost::any_cast<long>(m["MaxVideoBitrate"]));
    }
    if (m.find("MinBufferTime") != m.end() && !m["MinBufferTime"].empty()) {
      minBufferTime = make_shared<long>(boost::any_cast<long>(m["MinBufferTime"]));
    }
    if (m.find("MinUpdatePeriod") != m.end() && !m["MinUpdatePeriod"].empty()) {
      minUpdatePeriod = make_shared<long>(boost::any_cast<long>(m["MinUpdatePeriod"]));
    }
    if (m.find("MinVideoBitrate") != m.end() && !m["MinVideoBitrate"].empty()) {
      minVideoBitrate = make_shared<long>(boost::any_cast<long>(m["MinVideoBitrate"]));
    }
    if (m.find("PresentationDelay") != m.end() && !m["PresentationDelay"].empty()) {
      presentationDelay = make_shared<long>(boost::any_cast<long>(m["PresentationDelay"]));
    }
    if (m.find("SegmentCount") != m.end() && !m["SegmentCount"].empty()) {
      segmentCount = make_shared<long>(boost::any_cast<long>(m["SegmentCount"]));
    }
    if (m.find("SegmentTemplateFormat") != m.end() && !m["SegmentTemplateFormat"].empty()) {
      segmentTemplateFormat = make_shared<string>(boost::any_cast<string>(m["SegmentTemplateFormat"]));
    }
    if (m.find("StreamOrder") != m.end() && !m["StreamOrder"].empty()) {
      streamOrder = make_shared<string>(boost::any_cast<string>(m["StreamOrder"]));
    }
  }


  virtual ~LiveManifestConfig() = default;
};
class LivePackagingConfigDrmConfig : public Darabonba::Model {
public:
  shared_ptr<string> contentId{};
  shared_ptr<string> encryptionMethod{};
  shared_ptr<string> IV{};
  shared_ptr<long> rotatePeriod{};
  shared_ptr<vector<string>> systemIds{};
  shared_ptr<string> url{};

  LivePackagingConfigDrmConfig() {}

  explicit LivePackagingConfigDrmConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentId) {
      res["ContentId"] = boost::any(*contentId);
    }
    if (encryptionMethod) {
      res["EncryptionMethod"] = boost::any(*encryptionMethod);
    }
    if (IV) {
      res["IV"] = boost::any(*IV);
    }
    if (rotatePeriod) {
      res["RotatePeriod"] = boost::any(*rotatePeriod);
    }
    if (systemIds) {
      res["SystemIds"] = boost::any(*systemIds);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentId") != m.end() && !m["ContentId"].empty()) {
      contentId = make_shared<string>(boost::any_cast<string>(m["ContentId"]));
    }
    if (m.find("EncryptionMethod") != m.end() && !m["EncryptionMethod"].empty()) {
      encryptionMethod = make_shared<string>(boost::any_cast<string>(m["EncryptionMethod"]));
    }
    if (m.find("IV") != m.end() && !m["IV"].empty()) {
      IV = make_shared<string>(boost::any_cast<string>(m["IV"]));
    }
    if (m.find("RotatePeriod") != m.end() && !m["RotatePeriod"].empty()) {
      rotatePeriod = make_shared<long>(boost::any_cast<long>(m["RotatePeriod"]));
    }
    if (m.find("SystemIds") != m.end() && !m["SystemIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SystemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SystemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      systemIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~LivePackagingConfigDrmConfig() = default;
};
class LivePackagingConfig : public Darabonba::Model {
public:
  shared_ptr<LivePackagingConfigDrmConfig> drmConfig{};
  shared_ptr<vector<LiveManifestConfig>> liveManifestConfigs{};
  shared_ptr<long> segmentDuration{};
  shared_ptr<bool> useAudioRenditionGroups{};

  LivePackagingConfig() {}

  explicit LivePackagingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (drmConfig) {
      res["DrmConfig"] = drmConfig ? boost::any(drmConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (liveManifestConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*liveManifestConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveManifestConfigs"] = boost::any(temp1);
    }
    if (segmentDuration) {
      res["SegmentDuration"] = boost::any(*segmentDuration);
    }
    if (useAudioRenditionGroups) {
      res["UseAudioRenditionGroups"] = boost::any(*useAudioRenditionGroups);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DrmConfig") != m.end() && !m["DrmConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DrmConfig"].type()) {
        LivePackagingConfigDrmConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DrmConfig"]));
        drmConfig = make_shared<LivePackagingConfigDrmConfig>(model1);
      }
    }
    if (m.find("LiveManifestConfigs") != m.end() && !m["LiveManifestConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveManifestConfigs"].type()) {
        vector<LiveManifestConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveManifestConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LiveManifestConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveManifestConfigs = make_shared<vector<LiveManifestConfig>>(expect1);
      }
    }
    if (m.find("SegmentDuration") != m.end() && !m["SegmentDuration"].empty()) {
      segmentDuration = make_shared<long>(boost::any_cast<long>(m["SegmentDuration"]));
    }
    if (m.find("UseAudioRenditionGroups") != m.end() && !m["UseAudioRenditionGroups"].empty()) {
      useAudioRenditionGroups = make_shared<bool>(boost::any_cast<bool>(m["UseAudioRenditionGroups"]));
    }
  }


  virtual ~LivePackagingConfig() = default;
};
class MediaConvertAudio : public Darabonba::Model {
public:
  shared_ptr<long> bitrate{};
  shared_ptr<long> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<bool> remove{};
  shared_ptr<string> samplerate{};

  MediaConvertAudio() {}

  explicit MediaConvertAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<long>(boost::any_cast<long>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<bool>(boost::any_cast<bool>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~MediaConvertAudio() = default;
};
class MediaObject : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  MediaObject() {}

  explicit MediaObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~MediaObject() = default;
};
class MediaConvertInput : public Darabonba::Model {
public:
  shared_ptr<MediaObject> inputFile{};
  shared_ptr<string> name{};

  MediaConvertInput() {}

  explicit MediaConvertInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        MediaObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<MediaObject>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~MediaConvertInput() = default;
};
class MediaConvertOutputGroupConfig : public Darabonba::Model {
public:
  shared_ptr<string> manifestName{};
  shared_ptr<MediaObject> outputFileBase{};
  shared_ptr<string> type{};

  MediaConvertOutputGroupConfig() {}

  explicit MediaConvertOutputGroupConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (manifestName) {
      res["ManifestName"] = boost::any(*manifestName);
    }
    if (outputFileBase) {
      res["OutputFileBase"] = outputFileBase ? boost::any(outputFileBase->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ManifestName") != m.end() && !m["ManifestName"].empty()) {
      manifestName = make_shared<string>(boost::any_cast<string>(m["ManifestName"]));
    }
    if (m.find("OutputFileBase") != m.end() && !m["OutputFileBase"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFileBase"].type()) {
        MediaObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFileBase"]));
        outputFileBase = make_shared<MediaObject>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~MediaConvertOutputGroupConfig() = default;
};
class MediaConvertOutputGroupOutput : public Darabonba::Model {
public:
  shared_ptr<string> features{};
  shared_ptr<string> name{};
  shared_ptr<string> outputFileName{};
  shared_ptr<string> overrideParams{};
  shared_ptr<long> priority{};
  shared_ptr<string> templateId{};

  MediaConvertOutputGroupOutput() {}

  explicit MediaConvertOutputGroupOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (features) {
      res["Features"] = boost::any(*features);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputFileName) {
      res["OutputFileName"] = boost::any(*outputFileName);
    }
    if (overrideParams) {
      res["OverrideParams"] = boost::any(*overrideParams);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Features") != m.end() && !m["Features"].empty()) {
      features = make_shared<string>(boost::any_cast<string>(m["Features"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputFileName") != m.end() && !m["OutputFileName"].empty()) {
      outputFileName = make_shared<string>(boost::any_cast<string>(m["OutputFileName"]));
    }
    if (m.find("OverrideParams") != m.end() && !m["OverrideParams"].empty()) {
      overrideParams = make_shared<string>(boost::any_cast<string>(m["OverrideParams"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~MediaConvertOutputGroupOutput() = default;
};
class MediaConvertOutputGroup : public Darabonba::Model {
public:
  shared_ptr<MediaConvertOutputGroupConfig> groupConfig{};
  shared_ptr<string> name{};
  shared_ptr<vector<MediaConvertOutputGroupOutput>> outputs{};

  MediaConvertOutputGroup() {}

  explicit MediaConvertOutputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupConfig) {
      res["GroupConfig"] = groupConfig ? boost::any(groupConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      vector<boost::any> temp1;
      for(auto item1:*outputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outputs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupConfig") != m.end() && !m["GroupConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupConfig"].type()) {
        MediaConvertOutputGroupConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupConfig"]));
        groupConfig = make_shared<MediaConvertOutputGroupConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Outputs"].type()) {
        vector<MediaConvertOutputGroupOutput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutputGroupOutput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputs = make_shared<vector<MediaConvertOutputGroupOutput>>(expect1);
      }
    }
  }


  virtual ~MediaConvertOutputGroup() = default;
};
class MediaConvertOutput : public Darabonba::Model {
public:
  shared_ptr<string> features{};
  shared_ptr<string> name{};
  shared_ptr<MediaObject> outputFile{};
  shared_ptr<string> overrideParams{};
  shared_ptr<long> priority{};
  shared_ptr<string> templateId{};

  MediaConvertOutput() {}

  explicit MediaConvertOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (features) {
      res["Features"] = boost::any(*features);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overrideParams) {
      res["OverrideParams"] = boost::any(*overrideParams);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Features") != m.end() && !m["Features"].empty()) {
      features = make_shared<string>(boost::any_cast<string>(m["Features"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        MediaObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<MediaObject>(model1);
      }
    }
    if (m.find("OverrideParams") != m.end() && !m["OverrideParams"].empty()) {
      overrideParams = make_shared<string>(boost::any_cast<string>(m["OverrideParams"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~MediaConvertOutput() = default;
};
class MediaConvertJobConfig : public Darabonba::Model {
public:
  shared_ptr<vector<MediaConvertInput>> inputs{};
  shared_ptr<string> jobName{};
  shared_ptr<vector<MediaConvertOutputGroup>> outputGroups{};
  shared_ptr<vector<MediaConvertOutput>> outputs{};

  MediaConvertJobConfig() {}

  explicit MediaConvertJobConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputs) {
      vector<boost::any> temp1;
      for(auto item1:*inputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Inputs"] = boost::any(temp1);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (outputGroups) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroups"] = boost::any(temp1);
    }
    if (outputs) {
      vector<boost::any> temp1;
      for(auto item1:*outputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outputs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Inputs"].type()) {
        vector<MediaConvertInput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Inputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertInput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputs = make_shared<vector<MediaConvertInput>>(expect1);
      }
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("OutputGroups") != m.end() && !m["OutputGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroups"].type()) {
        vector<MediaConvertOutputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroups = make_shared<vector<MediaConvertOutputGroup>>(expect1);
      }
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Outputs"].type()) {
        vector<MediaConvertOutput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputs = make_shared<vector<MediaConvertOutput>>(expect1);
      }
    }
  }


  virtual ~MediaConvertJobConfig() = default;
};
class MediaConvertOutputDetailResultOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  MediaConvertOutputDetailResultOutputFile() {}

  explicit MediaConvertOutputDetailResultOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~MediaConvertOutputDetailResultOutputFile() = default;
};
class MediaConvertOutputDetailFileMetaAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  MediaConvertOutputDetailFileMetaAudioStreamInfoList() {}

  explicit MediaConvertOutputDetailFileMetaAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~MediaConvertOutputDetailFileMetaAudioStreamInfoList() = default;
};
class MediaConvertOutputDetailFileMetaFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  MediaConvertOutputDetailFileMetaFileBasicInfo() {}

  explicit MediaConvertOutputDetailFileMetaFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~MediaConvertOutputDetailFileMetaFileBasicInfo() = default;
};
class MediaConvertOutputDetailFileMetaVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFps{};
  shared_ptr<string> bitRate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeBase{};
  shared_ptr<string> width{};

  MediaConvertOutputDetailFileMetaVideoStreamInfoList() {}

  explicit MediaConvertOutputDetailFileMetaVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFps) {
      res["Avg_fps"] = boost::any(*avgFps);
    }
    if (bitRate) {
      res["Bit_rate"] = boost::any(*bitRate);
    }
    if (codecLongName) {
      res["Codec_long_name"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["Codec_name"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["Codec_tag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["Codec_tag_string"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["Codec_time_base"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["Has_b_frames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["Start_time"] = boost::any(*startTime);
    }
    if (timeBase) {
      res["Time_base"] = boost::any(*timeBase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avg_fps") != m.end() && !m["Avg_fps"].empty()) {
      avgFps = make_shared<string>(boost::any_cast<string>(m["Avg_fps"]));
    }
    if (m.find("Bit_rate") != m.end() && !m["Bit_rate"].empty()) {
      bitRate = make_shared<string>(boost::any_cast<string>(m["Bit_rate"]));
    }
    if (m.find("Codec_long_name") != m.end() && !m["Codec_long_name"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["Codec_long_name"]));
    }
    if (m.find("Codec_name") != m.end() && !m["Codec_name"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["Codec_name"]));
    }
    if (m.find("Codec_tag") != m.end() && !m["Codec_tag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["Codec_tag"]));
    }
    if (m.find("Codec_tag_string") != m.end() && !m["Codec_tag_string"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["Codec_tag_string"]));
    }
    if (m.find("Codec_time_base") != m.end() && !m["Codec_time_base"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["Codec_time_base"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Has_b_frames") != m.end() && !m["Has_b_frames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["Has_b_frames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Start_time") != m.end() && !m["Start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["Start_time"]));
    }
    if (m.find("Time_base") != m.end() && !m["Time_base"].empty()) {
      timeBase = make_shared<string>(boost::any_cast<string>(m["Time_base"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~MediaConvertOutputDetailFileMetaVideoStreamInfoList() = default;
};
class MediaConvertOutputDetailFileMeta : public Darabonba::Model {
public:
  shared_ptr<vector<MediaConvertOutputDetailFileMetaAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<MediaConvertOutputDetailFileMetaFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<MediaConvertOutputDetailFileMetaVideoStreamInfoList>> videoStreamInfoList{};

  MediaConvertOutputDetailFileMeta() {}

  explicit MediaConvertOutputDetailFileMeta(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<MediaConvertOutputDetailFileMetaAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutputDetailFileMetaAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<MediaConvertOutputDetailFileMetaAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        MediaConvertOutputDetailFileMetaFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<MediaConvertOutputDetailFileMetaFileBasicInfo>(model1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<MediaConvertOutputDetailFileMetaVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutputDetailFileMetaVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<MediaConvertOutputDetailFileMetaVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~MediaConvertOutputDetailFileMeta() = default;
};
class MediaConvertOutputDetailResult : public Darabonba::Model {
public:
  shared_ptr<MediaConvertOutputDetailFileMeta> outFileMeta{};
  shared_ptr<MediaConvertOutputDetailResultOutputFile> outputFile{};

  MediaConvertOutputDetailResult() {}

  explicit MediaConvertOutputDetailResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outFileMeta) {
      res["OutFileMeta"] = outFileMeta ? boost::any(outFileMeta->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutFileMeta") != m.end() && !m["OutFileMeta"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutFileMeta"].type()) {
        MediaConvertOutputDetailFileMeta model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutFileMeta"]));
        outFileMeta = make_shared<MediaConvertOutputDetailFileMeta>(model1);
      }
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        MediaConvertOutputDetailResultOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<MediaConvertOutputDetailResultOutputFile>(model1);
      }
    }
  }


  virtual ~MediaConvertOutputDetailResult() = default;
};
class MediaConvertOutputDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<MediaConvertOutputDetailResult> result{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  MediaConvertOutputDetail() {}

  explicit MediaConvertOutputDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        MediaConvertOutputDetailResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<MediaConvertOutputDetailResult>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~MediaConvertOutputDetail() = default;
};
class MediaConvertOutputGroupDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<vector<MediaConvertOutputDetail>> outputs{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  MediaConvertOutputGroupDetail() {}

  explicit MediaConvertOutputGroupDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      vector<boost::any> temp1;
      for(auto item1:*outputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outputs"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Outputs"].type()) {
        vector<MediaConvertOutputDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutputDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputs = make_shared<vector<MediaConvertOutputDetail>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~MediaConvertOutputGroupDetail() = default;
};
class MediaConvertJob : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> code{};
  shared_ptr<MediaConvertJobConfig> config{};
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<vector<MediaConvertOutputDetail>> outputDetails{};
  shared_ptr<vector<MediaConvertOutputGroupDetail>> outputGroupDetails{};
  shared_ptr<long> percent{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};

  MediaConvertJob() {}

  explicit MediaConvertJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (outputDetails) {
      vector<boost::any> temp1;
      for(auto item1:*outputDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputDetails"] = boost::any(temp1);
    }
    if (outputGroupDetails) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroupDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroupDetails"] = boost::any(temp1);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        MediaConvertJobConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<MediaConvertJobConfig>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OutputDetails") != m.end() && !m["OutputDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputDetails"].type()) {
        vector<MediaConvertOutputDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutputDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputDetails = make_shared<vector<MediaConvertOutputDetail>>(expect1);
      }
    }
    if (m.find("OutputGroupDetails") != m.end() && !m["OutputGroupDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroupDetails"].type()) {
        vector<MediaConvertOutputGroupDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroupDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutputGroupDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroupDetails = make_shared<vector<MediaConvertOutputGroupDetail>>(expect1);
      }
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~MediaConvertJob() = default;
};
class MediaConvertJobWithoutDetailConfig : public Darabonba::Model {
public:
  shared_ptr<vector<MediaConvertInput>> inputs{};
  shared_ptr<string> jobName{};
  shared_ptr<vector<MediaConvertOutputGroup>> outputGroups{};
  shared_ptr<vector<MediaConvertOutput>> outputs{};

  MediaConvertJobWithoutDetailConfig() {}

  explicit MediaConvertJobWithoutDetailConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputs) {
      vector<boost::any> temp1;
      for(auto item1:*inputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Inputs"] = boost::any(temp1);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (outputGroups) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroups"] = boost::any(temp1);
    }
    if (outputs) {
      vector<boost::any> temp1;
      for(auto item1:*outputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outputs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Inputs"].type()) {
        vector<MediaConvertInput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Inputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertInput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputs = make_shared<vector<MediaConvertInput>>(expect1);
      }
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("OutputGroups") != m.end() && !m["OutputGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroups"].type()) {
        vector<MediaConvertOutputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroups = make_shared<vector<MediaConvertOutputGroup>>(expect1);
      }
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Outputs"].type()) {
        vector<MediaConvertOutput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputs = make_shared<vector<MediaConvertOutput>>(expect1);
      }
    }
  }


  virtual ~MediaConvertJobWithoutDetailConfig() = default;
};
class MediaConvertJobWithoutDetail : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> code{};
  shared_ptr<MediaConvertJobWithoutDetailConfig> config{};
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};

  MediaConvertJobWithoutDetail() {}

  explicit MediaConvertJobWithoutDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        MediaConvertJobWithoutDetailConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<MediaConvertJobWithoutDetailConfig>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~MediaConvertJobWithoutDetail() = default;
};
class MediaConvertSegment : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> forceSegTime{};

  MediaConvertSegment() {}

  explicit MediaConvertSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (forceSegTime) {
      res["ForceSegTime"] = boost::any(*forceSegTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("ForceSegTime") != m.end() && !m["ForceSegTime"].empty()) {
      forceSegTime = make_shared<string>(boost::any_cast<string>(m["ForceSegTime"]));
    }
  }


  virtual ~MediaConvertSegment() = default;
};
class MediaConvertMuxConfig : public Darabonba::Model {
public:
  shared_ptr<MediaConvertSegment> segment{};

  MediaConvertMuxConfig() {}

  explicit MediaConvertMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        MediaConvertSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<MediaConvertSegment>(model1);
      }
    }
  }


  virtual ~MediaConvertMuxConfig() = default;
};
class MediaConvertTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<bool> isCheckAudioBitrate{};
  shared_ptr<bool> isCheckAudioBitrateFail{};
  shared_ptr<bool> isCheckReso{};
  shared_ptr<bool> isCheckResoFail{};
  shared_ptr<bool> isCheckVideoBitrate{};
  shared_ptr<bool> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  MediaConvertTransConfig() {}

  explicit MediaConvertTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<bool>(boost::any_cast<bool>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<bool>(boost::any_cast<bool>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<bool>(boost::any_cast<bool>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<bool>(boost::any_cast<bool>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<bool>(boost::any_cast<bool>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<bool>(boost::any_cast<bool>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~MediaConvertTransConfig() = default;
};
class MediaConvertVideo : public Darabonba::Model {
public:
  shared_ptr<long> bitrate{};
  shared_ptr<long> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<boost::any> crf{};
  shared_ptr<string> crop{};
  shared_ptr<boost::any> fps{};
  shared_ptr<boost::any> gop{};
  shared_ptr<long> height{};
  shared_ptr<bool> longShortMode{};
  shared_ptr<boost::any> maxFps{};
  shared_ptr<long> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> profile{};
  shared_ptr<long> qscale{};
  shared_ptr<bool> remove{};
  shared_ptr<string> scanMode{};
  shared_ptr<long> width{};

  MediaConvertVideo() {}

  explicit MediaConvertVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxFps) {
      res["MaxFps"] = boost::any(*maxFps);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (qscale) {
      res["Qscale"] = boost::any(*qscale);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<long>(boost::any_cast<long>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<boost::any>(boost::any_cast<boost::any>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<boost::any>(boost::any_cast<boost::any>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<boost::any>(boost::any_cast<boost::any>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<bool>(boost::any_cast<bool>(m["LongShortMode"]));
    }
    if (m.find("MaxFps") != m.end() && !m["MaxFps"].empty()) {
      maxFps = make_shared<boost::any>(boost::any_cast<boost::any>(m["MaxFps"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<long>(boost::any_cast<long>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Qscale") != m.end() && !m["Qscale"].empty()) {
      qscale = make_shared<long>(boost::any_cast<long>(m["Qscale"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<bool>(boost::any_cast<bool>(m["Remove"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~MediaConvertVideo() = default;
};
class MediaConvertVolume : public Darabonba::Model {
public:
  shared_ptr<long> integratedLoudnessTarget{};
  shared_ptr<long> level{};
  shared_ptr<long> loudnessRangeTarget{};
  shared_ptr<string> method{};
  shared_ptr<long> truePeak{};

  MediaConvertVolume() {}

  explicit MediaConvertVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedLoudnessTarget) {
      res["IntegratedLoudnessTarget"] = boost::any(*integratedLoudnessTarget);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (loudnessRangeTarget) {
      res["LoudnessRangeTarget"] = boost::any(*loudnessRangeTarget);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (truePeak) {
      res["TruePeak"] = boost::any(*truePeak);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedLoudnessTarget") != m.end() && !m["IntegratedLoudnessTarget"].empty()) {
      integratedLoudnessTarget = make_shared<long>(boost::any_cast<long>(m["IntegratedLoudnessTarget"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("LoudnessRangeTarget") != m.end() && !m["LoudnessRangeTarget"].empty()) {
      loudnessRangeTarget = make_shared<long>(boost::any_cast<long>(m["LoudnessRangeTarget"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("TruePeak") != m.end() && !m["TruePeak"].empty()) {
      truePeak = make_shared<long>(boost::any_cast<long>(m["TruePeak"]));
    }
  }


  virtual ~MediaConvertVolume() = default;
};
class ProgramAdBreaks : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> messageType{};
  shared_ptr<long> offsetMillis{};
  shared_ptr<string> programName{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> spliceInsertSettings{};
  shared_ptr<string> timeSignalSettings{};

  ProgramAdBreaks() {}

  explicit ProgramAdBreaks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (messageType) {
      res["MessageType"] = boost::any(*messageType);
    }
    if (offsetMillis) {
      res["OffsetMillis"] = boost::any(*offsetMillis);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (spliceInsertSettings) {
      res["SpliceInsertSettings"] = boost::any(*spliceInsertSettings);
    }
    if (timeSignalSettings) {
      res["TimeSignalSettings"] = boost::any(*timeSignalSettings);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("MessageType") != m.end() && !m["MessageType"].empty()) {
      messageType = make_shared<string>(boost::any_cast<string>(m["MessageType"]));
    }
    if (m.find("OffsetMillis") != m.end() && !m["OffsetMillis"].empty()) {
      offsetMillis = make_shared<long>(boost::any_cast<long>(m["OffsetMillis"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SpliceInsertSettings") != m.end() && !m["SpliceInsertSettings"].empty()) {
      spliceInsertSettings = make_shared<string>(boost::any_cast<string>(m["SpliceInsertSettings"]));
    }
    if (m.find("TimeSignalSettings") != m.end() && !m["TimeSignalSettings"].empty()) {
      timeSignalSettings = make_shared<string>(boost::any_cast<string>(m["TimeSignalSettings"]));
    }
  }


  virtual ~ProgramAdBreaks() = default;
};
class Program : public Darabonba::Model {
public:
  shared_ptr<vector<ProgramAdBreaks>> adBreaks{};
  shared_ptr<string> arn{};
  shared_ptr<string> channelName{};
  shared_ptr<string> clipRange{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> programName{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> transition{};

  Program() {}

  explicit Program(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adBreaks) {
      vector<boost::any> temp1;
      for(auto item1:*adBreaks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdBreaks"] = boost::any(temp1);
    }
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (clipRange) {
      res["ClipRange"] = boost::any(*clipRange);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (transition) {
      res["Transition"] = boost::any(*transition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdBreaks") != m.end() && !m["AdBreaks"].empty()) {
      if (typeid(vector<boost::any>) == m["AdBreaks"].type()) {
        vector<ProgramAdBreaks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdBreaks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ProgramAdBreaks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adBreaks = make_shared<vector<ProgramAdBreaks>>(expect1);
      }
    }
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ClipRange") != m.end() && !m["ClipRange"].empty()) {
      clipRange = make_shared<string>(boost::any_cast<string>(m["ClipRange"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Transition") != m.end() && !m["Transition"].empty()) {
      transition = make_shared<string>(boost::any_cast<string>(m["Transition"]));
    }
  }


  virtual ~Program() = default;
};
class ScheduleDataAdBreaks : public Darabonba::Model {
public:
  shared_ptr<string> messageType{};
  shared_ptr<string> offsetMillis{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> spliceInsertSettings{};
  shared_ptr<string> timeSignalSettings{};

  ScheduleDataAdBreaks() {}

  explicit ScheduleDataAdBreaks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageType) {
      res["MessageType"] = boost::any(*messageType);
    }
    if (offsetMillis) {
      res["OffsetMillis"] = boost::any(*offsetMillis);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (spliceInsertSettings) {
      res["SpliceInsertSettings"] = boost::any(*spliceInsertSettings);
    }
    if (timeSignalSettings) {
      res["TimeSignalSettings"] = boost::any(*timeSignalSettings);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageType") != m.end() && !m["MessageType"].empty()) {
      messageType = make_shared<string>(boost::any_cast<string>(m["MessageType"]));
    }
    if (m.find("OffsetMillis") != m.end() && !m["OffsetMillis"].empty()) {
      offsetMillis = make_shared<string>(boost::any_cast<string>(m["OffsetMillis"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SpliceInsertSettings") != m.end() && !m["SpliceInsertSettings"].empty()) {
      spliceInsertSettings = make_shared<string>(boost::any_cast<string>(m["SpliceInsertSettings"]));
    }
    if (m.find("TimeSignalSettings") != m.end() && !m["TimeSignalSettings"].empty()) {
      timeSignalSettings = make_shared<string>(boost::any_cast<string>(m["TimeSignalSettings"]));
    }
  }


  virtual ~ScheduleDataAdBreaks() = default;
};
class ScheduleData : public Darabonba::Model {
public:
  shared_ptr<vector<ScheduleDataAdBreaks>> adBreaks{};
  shared_ptr<long> approximateDurationSeconds{};
  shared_ptr<string> approximateStartTime{};
  shared_ptr<string> entryType{};
  shared_ptr<string> programName{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceType{};

  ScheduleData() {}

  explicit ScheduleData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adBreaks) {
      vector<boost::any> temp1;
      for(auto item1:*adBreaks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdBreaks"] = boost::any(temp1);
    }
    if (approximateDurationSeconds) {
      res["ApproximateDurationSeconds"] = boost::any(*approximateDurationSeconds);
    }
    if (approximateStartTime) {
      res["ApproximateStartTime"] = boost::any(*approximateStartTime);
    }
    if (entryType) {
      res["EntryType"] = boost::any(*entryType);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdBreaks") != m.end() && !m["AdBreaks"].empty()) {
      if (typeid(vector<boost::any>) == m["AdBreaks"].type()) {
        vector<ScheduleDataAdBreaks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdBreaks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ScheduleDataAdBreaks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adBreaks = make_shared<vector<ScheduleDataAdBreaks>>(expect1);
      }
    }
    if (m.find("ApproximateDurationSeconds") != m.end() && !m["ApproximateDurationSeconds"].empty()) {
      approximateDurationSeconds = make_shared<long>(boost::any_cast<long>(m["ApproximateDurationSeconds"]));
    }
    if (m.find("ApproximateStartTime") != m.end() && !m["ApproximateStartTime"].empty()) {
      approximateStartTime = make_shared<string>(boost::any_cast<string>(m["ApproximateStartTime"]));
    }
    if (m.find("EntryType") != m.end() && !m["EntryType"].empty()) {
      entryType = make_shared<string>(boost::any_cast<string>(m["EntryType"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~ScheduleData() = default;
};
class Source : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> httpPackageConfigurations{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceType{};
  shared_ptr<long> state{};

  Source() {}

  explicit Source(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (httpPackageConfigurations) {
      res["HttpPackageConfigurations"] = boost::any(*httpPackageConfigurations);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("HttpPackageConfigurations") != m.end() && !m["HttpPackageConfigurations"].empty()) {
      httpPackageConfigurations = make_shared<string>(boost::any_cast<string>(m["HttpPackageConfigurations"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
  }


  virtual ~Source() = default;
};
class SourceLocation : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> baseUrl{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> segmentDeliveryConfigurations{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<long> state{};

  SourceLocation() {}

  explicit SourceLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (baseUrl) {
      res["BaseUrl"] = boost::any(*baseUrl);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (segmentDeliveryConfigurations) {
      res["SegmentDeliveryConfigurations"] = boost::any(*segmentDeliveryConfigurations);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("BaseUrl") != m.end() && !m["BaseUrl"].empty()) {
      baseUrl = make_shared<string>(boost::any_cast<string>(m["BaseUrl"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("SegmentDeliveryConfigurations") != m.end() && !m["SegmentDeliveryConfigurations"].empty()) {
      segmentDeliveryConfigurations = make_shared<string>(boost::any_cast<string>(m["SegmentDeliveryConfigurations"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
  }


  virtual ~SourceLocation() = default;
};
class VodPackagingAssetInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  VodPackagingAssetInput() {}

  explicit VodPackagingAssetInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~VodPackagingAssetInput() = default;
};
class VodPackagingAsset : public Darabonba::Model {
public:
  shared_ptr<string> assetName{};
  shared_ptr<string> contentId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> groupName{};
  shared_ptr<VodPackagingAssetInput> input{};

  VodPackagingAsset() {}

  explicit VodPackagingAsset(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetName) {
      res["AssetName"] = boost::any(*assetName);
    }
    if (contentId) {
      res["ContentId"] = boost::any(*contentId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetName") != m.end() && !m["AssetName"].empty()) {
      assetName = make_shared<string>(boost::any_cast<string>(m["AssetName"]));
    }
    if (m.find("ContentId") != m.end() && !m["ContentId"].empty()) {
      contentId = make_shared<string>(boost::any_cast<string>(m["ContentId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        VodPackagingAssetInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<VodPackagingAssetInput>(model1);
      }
    }
  }


  virtual ~VodPackagingAsset() = default;
};
class VodPackagingConfigDrmProvider : public Darabonba::Model {
public:
  shared_ptr<string> encryptionMethod{};
  shared_ptr<string> IV{};
  shared_ptr<vector<string>> systemIds{};
  shared_ptr<string> url{};

  VodPackagingConfigDrmProvider() {}

  explicit VodPackagingConfigDrmProvider(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (encryptionMethod) {
      res["EncryptionMethod"] = boost::any(*encryptionMethod);
    }
    if (IV) {
      res["IV"] = boost::any(*IV);
    }
    if (systemIds) {
      res["SystemIds"] = boost::any(*systemIds);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EncryptionMethod") != m.end() && !m["EncryptionMethod"].empty()) {
      encryptionMethod = make_shared<string>(boost::any_cast<string>(m["EncryptionMethod"]));
    }
    if (m.find("IV") != m.end() && !m["IV"].empty()) {
      IV = make_shared<string>(boost::any_cast<string>(m["IV"]));
    }
    if (m.find("SystemIds") != m.end() && !m["SystemIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SystemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SystemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      systemIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~VodPackagingConfigDrmProvider() = default;
};
class VodPackagingConfigStreamSelection : public Darabonba::Model {
public:
  shared_ptr<long> maxVideoBitsPerSecond{};
  shared_ptr<long> minVideoBitsPerSecond{};
  shared_ptr<string> streamOrder{};

  VodPackagingConfigStreamSelection() {}

  explicit VodPackagingConfigStreamSelection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxVideoBitsPerSecond) {
      res["MaxVideoBitsPerSecond"] = boost::any(*maxVideoBitsPerSecond);
    }
    if (minVideoBitsPerSecond) {
      res["MinVideoBitsPerSecond"] = boost::any(*minVideoBitsPerSecond);
    }
    if (streamOrder) {
      res["StreamOrder"] = boost::any(*streamOrder);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxVideoBitsPerSecond") != m.end() && !m["MaxVideoBitsPerSecond"].empty()) {
      maxVideoBitsPerSecond = make_shared<long>(boost::any_cast<long>(m["MaxVideoBitsPerSecond"]));
    }
    if (m.find("MinVideoBitsPerSecond") != m.end() && !m["MinVideoBitsPerSecond"].empty()) {
      minVideoBitsPerSecond = make_shared<long>(boost::any_cast<long>(m["MinVideoBitsPerSecond"]));
    }
    if (m.find("StreamOrder") != m.end() && !m["StreamOrder"].empty()) {
      streamOrder = make_shared<string>(boost::any_cast<string>(m["StreamOrder"]));
    }
  }


  virtual ~VodPackagingConfigStreamSelection() = default;
};
class VodPackagingConfig : public Darabonba::Model {
public:
  shared_ptr<VodPackagingConfigDrmProvider> drmProvider{};
  shared_ptr<string> manifestName{};
  shared_ptr<long> segmentDuration{};
  shared_ptr<VodPackagingConfigStreamSelection> streamSelection{};

  VodPackagingConfig() {}

  explicit VodPackagingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (drmProvider) {
      res["DrmProvider"] = drmProvider ? boost::any(drmProvider->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (manifestName) {
      res["ManifestName"] = boost::any(*manifestName);
    }
    if (segmentDuration) {
      res["SegmentDuration"] = boost::any(*segmentDuration);
    }
    if (streamSelection) {
      res["StreamSelection"] = streamSelection ? boost::any(streamSelection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DrmProvider") != m.end() && !m["DrmProvider"].empty()) {
      if (typeid(map<string, boost::any>) == m["DrmProvider"].type()) {
        VodPackagingConfigDrmProvider model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DrmProvider"]));
        drmProvider = make_shared<VodPackagingConfigDrmProvider>(model1);
      }
    }
    if (m.find("ManifestName") != m.end() && !m["ManifestName"].empty()) {
      manifestName = make_shared<string>(boost::any_cast<string>(m["ManifestName"]));
    }
    if (m.find("SegmentDuration") != m.end() && !m["SegmentDuration"].empty()) {
      segmentDuration = make_shared<long>(boost::any_cast<long>(m["SegmentDuration"]));
    }
    if (m.find("StreamSelection") != m.end() && !m["StreamSelection"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamSelection"].type()) {
        VodPackagingConfigStreamSelection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamSelection"]));
        streamSelection = make_shared<VodPackagingConfigStreamSelection>(model1);
      }
    }
  }


  virtual ~VodPackagingConfig() = default;
};
class VodPackagingConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> configurationName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<VodPackagingConfig> packageConfig{};
  shared_ptr<string> protocol{};

  VodPackagingConfiguration() {}

  explicit VodPackagingConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationName) {
      res["ConfigurationName"] = boost::any(*configurationName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (packageConfig) {
      res["PackageConfig"] = packageConfig ? boost::any(packageConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationName") != m.end() && !m["ConfigurationName"].empty()) {
      configurationName = make_shared<string>(boost::any_cast<string>(m["ConfigurationName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("PackageConfig") != m.end() && !m["PackageConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["PackageConfig"].type()) {
        VodPackagingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PackageConfig"]));
        packageConfig = make_shared<VodPackagingConfig>(model1);
      }
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~VodPackagingConfiguration() = default;
};
class VodPackagingGroup : public Darabonba::Model {
public:
  shared_ptr<long> approximateAssetCount{};
  shared_ptr<long> configurationCount{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupName{};

  VodPackagingGroup() {}

  explicit VodPackagingGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approximateAssetCount) {
      res["ApproximateAssetCount"] = boost::any(*approximateAssetCount);
    }
    if (configurationCount) {
      res["ConfigurationCount"] = boost::any(*configurationCount);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApproximateAssetCount") != m.end() && !m["ApproximateAssetCount"].empty()) {
      approximateAssetCount = make_shared<long>(boost::any_cast<long>(m["ApproximateAssetCount"]));
    }
    if (m.find("ConfigurationCount") != m.end() && !m["ConfigurationCount"].empty()) {
      configurationCount = make_shared<long>(boost::any_cast<long>(m["ConfigurationCount"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~VodPackagingGroup() = default;
};
class AddAdInsertionRequest : public Darabonba::Model {
public:
  shared_ptr<string> adMarkerPassthrough{};
  shared_ptr<string> adsUrl{};
  shared_ptr<string> cdnAdSegmentUrlPrefix{};
  shared_ptr<string> cdnContentSegmentUrlPrefix{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> configAliases{};
  shared_ptr<string> contentUrlPrefix{};
  shared_ptr<string> name{};
  shared_ptr<long> personalizationThreshold{};
  shared_ptr<string> slateAdUrl{};

  AddAdInsertionRequest() {}

  explicit AddAdInsertionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adMarkerPassthrough) {
      res["AdMarkerPassthrough"] = boost::any(*adMarkerPassthrough);
    }
    if (adsUrl) {
      res["AdsUrl"] = boost::any(*adsUrl);
    }
    if (cdnAdSegmentUrlPrefix) {
      res["CdnAdSegmentUrlPrefix"] = boost::any(*cdnAdSegmentUrlPrefix);
    }
    if (cdnContentSegmentUrlPrefix) {
      res["CdnContentSegmentUrlPrefix"] = boost::any(*cdnContentSegmentUrlPrefix);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (configAliases) {
      res["ConfigAliases"] = boost::any(*configAliases);
    }
    if (contentUrlPrefix) {
      res["ContentUrlPrefix"] = boost::any(*contentUrlPrefix);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (personalizationThreshold) {
      res["PersonalizationThreshold"] = boost::any(*personalizationThreshold);
    }
    if (slateAdUrl) {
      res["SlateAdUrl"] = boost::any(*slateAdUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdMarkerPassthrough") != m.end() && !m["AdMarkerPassthrough"].empty()) {
      adMarkerPassthrough = make_shared<string>(boost::any_cast<string>(m["AdMarkerPassthrough"]));
    }
    if (m.find("AdsUrl") != m.end() && !m["AdsUrl"].empty()) {
      adsUrl = make_shared<string>(boost::any_cast<string>(m["AdsUrl"]));
    }
    if (m.find("CdnAdSegmentUrlPrefix") != m.end() && !m["CdnAdSegmentUrlPrefix"].empty()) {
      cdnAdSegmentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["CdnAdSegmentUrlPrefix"]));
    }
    if (m.find("CdnContentSegmentUrlPrefix") != m.end() && !m["CdnContentSegmentUrlPrefix"].empty()) {
      cdnContentSegmentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["CdnContentSegmentUrlPrefix"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConfigAliases") != m.end() && !m["ConfigAliases"].empty()) {
      configAliases = make_shared<string>(boost::any_cast<string>(m["ConfigAliases"]));
    }
    if (m.find("ContentUrlPrefix") != m.end() && !m["ContentUrlPrefix"].empty()) {
      contentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["ContentUrlPrefix"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PersonalizationThreshold") != m.end() && !m["PersonalizationThreshold"].empty()) {
      personalizationThreshold = make_shared<long>(boost::any_cast<long>(m["PersonalizationThreshold"]));
    }
    if (m.find("SlateAdUrl") != m.end() && !m["SlateAdUrl"].empty()) {
      slateAdUrl = make_shared<string>(boost::any_cast<string>(m["SlateAdUrl"]));
    }
  }


  virtual ~AddAdInsertionRequest() = default;
};
class AddAdInsertionResponseBodyConfigCdnConfig : public Darabonba::Model {
public:
  shared_ptr<string> adSegmentUrlPrefix{};
  shared_ptr<string> contentSegmentUrlPrefix{};

  AddAdInsertionResponseBodyConfigCdnConfig() {}

  explicit AddAdInsertionResponseBodyConfigCdnConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adSegmentUrlPrefix) {
      res["AdSegmentUrlPrefix"] = boost::any(*adSegmentUrlPrefix);
    }
    if (contentSegmentUrlPrefix) {
      res["ContentSegmentUrlPrefix"] = boost::any(*contentSegmentUrlPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdSegmentUrlPrefix") != m.end() && !m["AdSegmentUrlPrefix"].empty()) {
      adSegmentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["AdSegmentUrlPrefix"]));
    }
    if (m.find("ContentSegmentUrlPrefix") != m.end() && !m["ContentSegmentUrlPrefix"].empty()) {
      contentSegmentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["ContentSegmentUrlPrefix"]));
    }
  }


  virtual ~AddAdInsertionResponseBodyConfigCdnConfig() = default;
};
class AddAdInsertionResponseBodyConfigManifestEndpointConfig : public Darabonba::Model {
public:
  shared_ptr<string> dashPrefix{};
  shared_ptr<string> hlsPrefix{};

  AddAdInsertionResponseBodyConfigManifestEndpointConfig() {}

  explicit AddAdInsertionResponseBodyConfigManifestEndpointConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dashPrefix) {
      res["DashPrefix"] = boost::any(*dashPrefix);
    }
    if (hlsPrefix) {
      res["HlsPrefix"] = boost::any(*hlsPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DashPrefix") != m.end() && !m["DashPrefix"].empty()) {
      dashPrefix = make_shared<string>(boost::any_cast<string>(m["DashPrefix"]));
    }
    if (m.find("HlsPrefix") != m.end() && !m["HlsPrefix"].empty()) {
      hlsPrefix = make_shared<string>(boost::any_cast<string>(m["HlsPrefix"]));
    }
  }


  virtual ~AddAdInsertionResponseBodyConfigManifestEndpointConfig() = default;
};
class AddAdInsertionResponseBodyConfig : public Darabonba::Model {
public:
  shared_ptr<string> adMarkerPassthrough{};
  shared_ptr<string> adsUrl{};
  shared_ptr<AddAdInsertionResponseBodyConfigCdnConfig> cdnConfig{};
  shared_ptr<string> configAliases{};
  shared_ptr<string> contentUrlPrefix{};
  shared_ptr<string> createTime{};
  shared_ptr<string> lastModified{};
  shared_ptr<AddAdInsertionResponseBodyConfigManifestEndpointConfig> manifestEndpointConfig{};
  shared_ptr<string> name{};
  shared_ptr<long> personalizationThreshold{};
  shared_ptr<string> slateAdUrl{};

  AddAdInsertionResponseBodyConfig() {}

  explicit AddAdInsertionResponseBodyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adMarkerPassthrough) {
      res["AdMarkerPassthrough"] = boost::any(*adMarkerPassthrough);
    }
    if (adsUrl) {
      res["AdsUrl"] = boost::any(*adsUrl);
    }
    if (cdnConfig) {
      res["CdnConfig"] = cdnConfig ? boost::any(cdnConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configAliases) {
      res["ConfigAliases"] = boost::any(*configAliases);
    }
    if (contentUrlPrefix) {
      res["ContentUrlPrefix"] = boost::any(*contentUrlPrefix);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (manifestEndpointConfig) {
      res["ManifestEndpointConfig"] = manifestEndpointConfig ? boost::any(manifestEndpointConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (personalizationThreshold) {
      res["PersonalizationThreshold"] = boost::any(*personalizationThreshold);
    }
    if (slateAdUrl) {
      res["SlateAdUrl"] = boost::any(*slateAdUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdMarkerPassthrough") != m.end() && !m["AdMarkerPassthrough"].empty()) {
      adMarkerPassthrough = make_shared<string>(boost::any_cast<string>(m["AdMarkerPassthrough"]));
    }
    if (m.find("AdsUrl") != m.end() && !m["AdsUrl"].empty()) {
      adsUrl = make_shared<string>(boost::any_cast<string>(m["AdsUrl"]));
    }
    if (m.find("CdnConfig") != m.end() && !m["CdnConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CdnConfig"].type()) {
        AddAdInsertionResponseBodyConfigCdnConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CdnConfig"]));
        cdnConfig = make_shared<AddAdInsertionResponseBodyConfigCdnConfig>(model1);
      }
    }
    if (m.find("ConfigAliases") != m.end() && !m["ConfigAliases"].empty()) {
      configAliases = make_shared<string>(boost::any_cast<string>(m["ConfigAliases"]));
    }
    if (m.find("ContentUrlPrefix") != m.end() && !m["ContentUrlPrefix"].empty()) {
      contentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["ContentUrlPrefix"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("ManifestEndpointConfig") != m.end() && !m["ManifestEndpointConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ManifestEndpointConfig"].type()) {
        AddAdInsertionResponseBodyConfigManifestEndpointConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ManifestEndpointConfig"]));
        manifestEndpointConfig = make_shared<AddAdInsertionResponseBodyConfigManifestEndpointConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PersonalizationThreshold") != m.end() && !m["PersonalizationThreshold"].empty()) {
      personalizationThreshold = make_shared<long>(boost::any_cast<long>(m["PersonalizationThreshold"]));
    }
    if (m.find("SlateAdUrl") != m.end() && !m["SlateAdUrl"].empty()) {
      slateAdUrl = make_shared<string>(boost::any_cast<string>(m["SlateAdUrl"]));
    }
  }


  virtual ~AddAdInsertionResponseBodyConfig() = default;
};
class AddAdInsertionResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddAdInsertionResponseBodyConfig> config{};
  shared_ptr<string> requestId{};

  AddAdInsertionResponseBody() {}

  explicit AddAdInsertionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        AddAdInsertionResponseBodyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<AddAdInsertionResponseBodyConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddAdInsertionResponseBody() = default;
};
class AddAdInsertionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddAdInsertionResponseBody> body{};

  AddAdInsertionResponse() {}

  explicit AddAdInsertionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddAdInsertionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddAdInsertionResponseBody>(model1);
      }
    }
  }


  virtual ~AddAdInsertionResponse() = default;
};
class AddCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> cateName{};
  shared_ptr<long> parentId{};
  shared_ptr<string> type{};

  AddCategoryRequest() {}

  explicit AddCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddCategoryRequest() = default;
};
class AddCategoryResponseBodyCategory : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<long> level{};
  shared_ptr<long> parentId{};
  shared_ptr<string> type{};

  AddCategoryResponseBodyCategory() {}

  explicit AddCategoryResponseBodyCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddCategoryResponseBodyCategory() = default;
};
class AddCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddCategoryResponseBodyCategory> category{};
  shared_ptr<string> requestId{};

  AddCategoryResponseBody() {}

  explicit AddCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = category ? boost::any(category->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(map<string, boost::any>) == m["Category"].type()) {
        AddCategoryResponseBodyCategory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Category"]));
        category = make_shared<AddCategoryResponseBodyCategory>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCategoryResponseBody() = default;
};
class AddCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCategoryResponseBody> body{};

  AddCategoryResponse() {}

  explicit AddCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~AddCategoryResponse() = default;
};
class AddEditingProjectMaterialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> materialMaps{};
  shared_ptr<string> projectId{};

  AddEditingProjectMaterialsRequest() {}

  explicit AddEditingProjectMaterialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (materialMaps) {
      res["MaterialMaps"] = boost::any(*materialMaps);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaterialMaps") != m.end() && !m["MaterialMaps"].empty()) {
      materialMaps = make_shared<string>(boost::any_cast<string>(m["MaterialMaps"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~AddEditingProjectMaterialsRequest() = default;
};
class AddEditingProjectMaterialsResponseBodyLiveMaterials : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> liveUrl{};
  shared_ptr<string> streamName{};

  AddEditingProjectMaterialsResponseBodyLiveMaterials() {}

  explicit AddEditingProjectMaterialsResponseBodyLiveMaterials(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (liveUrl) {
      res["LiveUrl"] = boost::any(*liveUrl);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LiveUrl") != m.end() && !m["LiveUrl"].empty()) {
      liveUrl = make_shared<string>(boost::any_cast<string>(m["LiveUrl"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~AddEditingProjectMaterialsResponseBodyLiveMaterials() = default;
};
class AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo() {}

  explicit AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo() = default;
};
class AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList : public Darabonba::Model {
public:
  shared_ptr<AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo> fileBasicInfo{};

  AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList() {}

  explicit AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo>(model1);
      }
    }
  }


  virtual ~AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList() = default;
};
class AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> snapshots{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteImages{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> transcodeStatus{};
  shared_ptr<string> userData{};

  AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo() {}

  explicit AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteImages) {
      res["SpriteImages"] = boost::any(*spriteImages);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (transcodeStatus) {
      res["TranscodeStatus"] = boost::any(*transcodeStatus);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      snapshots = make_shared<string>(boost::any_cast<string>(m["Snapshots"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteImages") != m.end() && !m["SpriteImages"].empty()) {
      spriteImages = make_shared<string>(boost::any_cast<string>(m["SpriteImages"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TranscodeStatus") != m.end() && !m["TranscodeStatus"].empty()) {
      transcodeStatus = make_shared<string>(boost::any_cast<string>(m["TranscodeStatus"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo() = default;
};
class AddEditingProjectMaterialsResponseBodyMediaInfos : public Darabonba::Model {
public:
  shared_ptr<vector<AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList>> fileInfoList{};
  shared_ptr<AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  AddEditingProjectMaterialsResponseBodyMediaInfos() {}

  explicit AddEditingProjectMaterialsResponseBodyMediaInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList>>(expect1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~AddEditingProjectMaterialsResponseBodyMediaInfos() = default;
};
class AddEditingProjectMaterialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<AddEditingProjectMaterialsResponseBodyLiveMaterials>> liveMaterials{};
  shared_ptr<vector<AddEditingProjectMaterialsResponseBodyMediaInfos>> mediaInfos{};
  shared_ptr<string> projectId{};
  shared_ptr<vector<string>> projectMaterials{};
  shared_ptr<string> requestId{};

  AddEditingProjectMaterialsResponseBody() {}

  explicit AddEditingProjectMaterialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveMaterials) {
      vector<boost::any> temp1;
      for(auto item1:*liveMaterials){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveMaterials"] = boost::any(temp1);
    }
    if (mediaInfos) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInfos"] = boost::any(temp1);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectMaterials) {
      res["ProjectMaterials"] = boost::any(*projectMaterials);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveMaterials") != m.end() && !m["LiveMaterials"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveMaterials"].type()) {
        vector<AddEditingProjectMaterialsResponseBodyLiveMaterials> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveMaterials"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddEditingProjectMaterialsResponseBodyLiveMaterials model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveMaterials = make_shared<vector<AddEditingProjectMaterialsResponseBodyLiveMaterials>>(expect1);
      }
    }
    if (m.find("MediaInfos") != m.end() && !m["MediaInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInfos"].type()) {
        vector<AddEditingProjectMaterialsResponseBodyMediaInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddEditingProjectMaterialsResponseBodyMediaInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInfos = make_shared<vector<AddEditingProjectMaterialsResponseBodyMediaInfos>>(expect1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectMaterials") != m.end() && !m["ProjectMaterials"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProjectMaterials"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProjectMaterials"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      projectMaterials = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddEditingProjectMaterialsResponseBody() = default;
};
class AddEditingProjectMaterialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddEditingProjectMaterialsResponseBody> body{};

  AddEditingProjectMaterialsResponse() {}

  explicit AddEditingProjectMaterialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddEditingProjectMaterialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddEditingProjectMaterialsResponseBody>(model1);
      }
    }
  }


  virtual ~AddEditingProjectMaterialsResponse() = default;
};
class AddFavoritePublicMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaIds{};

  AddFavoritePublicMediaRequest() {}

  explicit AddFavoritePublicMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
  }


  virtual ~AddFavoritePublicMediaRequest() = default;
};
class AddFavoritePublicMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ignoredList{};
  shared_ptr<string> requestId{};

  AddFavoritePublicMediaResponseBody() {}

  explicit AddFavoritePublicMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoredList) {
      res["IgnoredList"] = boost::any(*ignoredList);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoredList") != m.end() && !m["IgnoredList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IgnoredList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IgnoredList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ignoredList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddFavoritePublicMediaResponseBody() = default;
};
class AddFavoritePublicMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddFavoritePublicMediaResponseBody> body{};

  AddFavoritePublicMediaResponse() {}

  explicit AddFavoritePublicMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddFavoritePublicMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddFavoritePublicMediaResponseBody>(model1);
      }
    }
  }


  virtual ~AddFavoritePublicMediaResponse() = default;
};
class AddMediaConnectFlowInputRequest : public Darabonba::Model {
public:
  shared_ptr<string> cidrs{};
  shared_ptr<string> flowId{};
  shared_ptr<string> inputFromUrl{};
  shared_ptr<string> inputName{};
  shared_ptr<string> inputProtocol{};
  shared_ptr<long> maxBitrate{};
  shared_ptr<string> pairFlowId{};
  shared_ptr<string> pairOutputName{};
  shared_ptr<long> srtLatency{};
  shared_ptr<string> srtPassphrase{};
  shared_ptr<string> srtPbkeyLen{};

  AddMediaConnectFlowInputRequest() {}

  explicit AddMediaConnectFlowInputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrs) {
      res["Cidrs"] = boost::any(*cidrs);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (inputFromUrl) {
      res["InputFromUrl"] = boost::any(*inputFromUrl);
    }
    if (inputName) {
      res["InputName"] = boost::any(*inputName);
    }
    if (inputProtocol) {
      res["InputProtocol"] = boost::any(*inputProtocol);
    }
    if (maxBitrate) {
      res["MaxBitrate"] = boost::any(*maxBitrate);
    }
    if (pairFlowId) {
      res["PairFlowId"] = boost::any(*pairFlowId);
    }
    if (pairOutputName) {
      res["PairOutputName"] = boost::any(*pairOutputName);
    }
    if (srtLatency) {
      res["SrtLatency"] = boost::any(*srtLatency);
    }
    if (srtPassphrase) {
      res["SrtPassphrase"] = boost::any(*srtPassphrase);
    }
    if (srtPbkeyLen) {
      res["SrtPbkeyLen"] = boost::any(*srtPbkeyLen);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cidrs") != m.end() && !m["Cidrs"].empty()) {
      cidrs = make_shared<string>(boost::any_cast<string>(m["Cidrs"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("InputFromUrl") != m.end() && !m["InputFromUrl"].empty()) {
      inputFromUrl = make_shared<string>(boost::any_cast<string>(m["InputFromUrl"]));
    }
    if (m.find("InputName") != m.end() && !m["InputName"].empty()) {
      inputName = make_shared<string>(boost::any_cast<string>(m["InputName"]));
    }
    if (m.find("InputProtocol") != m.end() && !m["InputProtocol"].empty()) {
      inputProtocol = make_shared<string>(boost::any_cast<string>(m["InputProtocol"]));
    }
    if (m.find("MaxBitrate") != m.end() && !m["MaxBitrate"].empty()) {
      maxBitrate = make_shared<long>(boost::any_cast<long>(m["MaxBitrate"]));
    }
    if (m.find("PairFlowId") != m.end() && !m["PairFlowId"].empty()) {
      pairFlowId = make_shared<string>(boost::any_cast<string>(m["PairFlowId"]));
    }
    if (m.find("PairOutputName") != m.end() && !m["PairOutputName"].empty()) {
      pairOutputName = make_shared<string>(boost::any_cast<string>(m["PairOutputName"]));
    }
    if (m.find("SrtLatency") != m.end() && !m["SrtLatency"].empty()) {
      srtLatency = make_shared<long>(boost::any_cast<long>(m["SrtLatency"]));
    }
    if (m.find("SrtPassphrase") != m.end() && !m["SrtPassphrase"].empty()) {
      srtPassphrase = make_shared<string>(boost::any_cast<string>(m["SrtPassphrase"]));
    }
    if (m.find("SrtPbkeyLen") != m.end() && !m["SrtPbkeyLen"].empty()) {
      srtPbkeyLen = make_shared<string>(boost::any_cast<string>(m["SrtPbkeyLen"]));
    }
  }


  virtual ~AddMediaConnectFlowInputRequest() = default;
};
class AddMediaConnectFlowInputResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> inputUrl{};

  AddMediaConnectFlowInputResponseBodyContent() {}

  explicit AddMediaConnectFlowInputResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputUrl) {
      res["InputUrl"] = boost::any(*inputUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputUrl") != m.end() && !m["InputUrl"].empty()) {
      inputUrl = make_shared<string>(boost::any_cast<string>(m["InputUrl"]));
    }
  }


  virtual ~AddMediaConnectFlowInputResponseBodyContent() = default;
};
class AddMediaConnectFlowInputResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddMediaConnectFlowInputResponseBodyContent> content{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};

  AddMediaConnectFlowInputResponseBody() {}

  explicit AddMediaConnectFlowInputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        AddMediaConnectFlowInputResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<AddMediaConnectFlowInputResponseBodyContent>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
  }


  virtual ~AddMediaConnectFlowInputResponseBody() = default;
};
class AddMediaConnectFlowInputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddMediaConnectFlowInputResponseBody> body{};

  AddMediaConnectFlowInputResponse() {}

  explicit AddMediaConnectFlowInputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMediaConnectFlowInputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMediaConnectFlowInputResponseBody>(model1);
      }
    }
  }


  virtual ~AddMediaConnectFlowInputResponse() = default;
};
class AddMediaConnectFlowOutputRequest : public Darabonba::Model {
public:
  shared_ptr<string> cidrs{};
  shared_ptr<string> flowId{};
  shared_ptr<string> outputName{};
  shared_ptr<string> outputProtocol{};
  shared_ptr<string> outputToUrl{};
  shared_ptr<string> pairFlowId{};
  shared_ptr<string> pairInputName{};
  shared_ptr<long> playerLimit{};
  shared_ptr<long> srtLatency{};
  shared_ptr<string> srtPassphrase{};
  shared_ptr<string> srtPbkeyLen{};

  AddMediaConnectFlowOutputRequest() {}

  explicit AddMediaConnectFlowOutputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrs) {
      res["Cidrs"] = boost::any(*cidrs);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (outputName) {
      res["OutputName"] = boost::any(*outputName);
    }
    if (outputProtocol) {
      res["OutputProtocol"] = boost::any(*outputProtocol);
    }
    if (outputToUrl) {
      res["OutputToUrl"] = boost::any(*outputToUrl);
    }
    if (pairFlowId) {
      res["PairFlowId"] = boost::any(*pairFlowId);
    }
    if (pairInputName) {
      res["PairInputName"] = boost::any(*pairInputName);
    }
    if (playerLimit) {
      res["PlayerLimit"] = boost::any(*playerLimit);
    }
    if (srtLatency) {
      res["SrtLatency"] = boost::any(*srtLatency);
    }
    if (srtPassphrase) {
      res["SrtPassphrase"] = boost::any(*srtPassphrase);
    }
    if (srtPbkeyLen) {
      res["SrtPbkeyLen"] = boost::any(*srtPbkeyLen);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cidrs") != m.end() && !m["Cidrs"].empty()) {
      cidrs = make_shared<string>(boost::any_cast<string>(m["Cidrs"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("OutputName") != m.end() && !m["OutputName"].empty()) {
      outputName = make_shared<string>(boost::any_cast<string>(m["OutputName"]));
    }
    if (m.find("OutputProtocol") != m.end() && !m["OutputProtocol"].empty()) {
      outputProtocol = make_shared<string>(boost::any_cast<string>(m["OutputProtocol"]));
    }
    if (m.find("OutputToUrl") != m.end() && !m["OutputToUrl"].empty()) {
      outputToUrl = make_shared<string>(boost::any_cast<string>(m["OutputToUrl"]));
    }
    if (m.find("PairFlowId") != m.end() && !m["PairFlowId"].empty()) {
      pairFlowId = make_shared<string>(boost::any_cast<string>(m["PairFlowId"]));
    }
    if (m.find("PairInputName") != m.end() && !m["PairInputName"].empty()) {
      pairInputName = make_shared<string>(boost::any_cast<string>(m["PairInputName"]));
    }
    if (m.find("PlayerLimit") != m.end() && !m["PlayerLimit"].empty()) {
      playerLimit = make_shared<long>(boost::any_cast<long>(m["PlayerLimit"]));
    }
    if (m.find("SrtLatency") != m.end() && !m["SrtLatency"].empty()) {
      srtLatency = make_shared<long>(boost::any_cast<long>(m["SrtLatency"]));
    }
    if (m.find("SrtPassphrase") != m.end() && !m["SrtPassphrase"].empty()) {
      srtPassphrase = make_shared<string>(boost::any_cast<string>(m["SrtPassphrase"]));
    }
    if (m.find("SrtPbkeyLen") != m.end() && !m["SrtPbkeyLen"].empty()) {
      srtPbkeyLen = make_shared<string>(boost::any_cast<string>(m["SrtPbkeyLen"]));
    }
  }


  virtual ~AddMediaConnectFlowOutputRequest() = default;
};
class AddMediaConnectFlowOutputResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> outputUrl{};

  AddMediaConnectFlowOutputResponseBodyContent() {}

  explicit AddMediaConnectFlowOutputResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputUrl) {
      res["OutputUrl"] = boost::any(*outputUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputUrl") != m.end() && !m["OutputUrl"].empty()) {
      outputUrl = make_shared<string>(boost::any_cast<string>(m["OutputUrl"]));
    }
  }


  virtual ~AddMediaConnectFlowOutputResponseBodyContent() = default;
};
class AddMediaConnectFlowOutputResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddMediaConnectFlowOutputResponseBodyContent> content{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};

  AddMediaConnectFlowOutputResponseBody() {}

  explicit AddMediaConnectFlowOutputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        AddMediaConnectFlowOutputResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<AddMediaConnectFlowOutputResponseBodyContent>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
  }


  virtual ~AddMediaConnectFlowOutputResponseBody() = default;
};
class AddMediaConnectFlowOutputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddMediaConnectFlowOutputResponseBody> body{};

  AddMediaConnectFlowOutputResponse() {}

  explicit AddMediaConnectFlowOutputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMediaConnectFlowOutputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMediaConnectFlowOutputResponseBody>(model1);
      }
    }
  }


  virtual ~AddMediaConnectFlowOutputResponse() = default;
};
class AddMediaMarksRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaMarks{};

  AddMediaMarksRequest() {}

  explicit AddMediaMarksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaMarks) {
      res["MediaMarks"] = boost::any(*mediaMarks);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaMarks") != m.end() && !m["MediaMarks"].empty()) {
      mediaMarks = make_shared<string>(boost::any_cast<string>(m["MediaMarks"]));
    }
  }


  virtual ~AddMediaMarksRequest() = default;
};
class AddMediaMarksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaMarkIds{};
  shared_ptr<string> requestId{};

  AddMediaMarksResponseBody() {}

  explicit AddMediaMarksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaMarkIds) {
      res["MediaMarkIds"] = boost::any(*mediaMarkIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaMarkIds") != m.end() && !m["MediaMarkIds"].empty()) {
      mediaMarkIds = make_shared<string>(boost::any_cast<string>(m["MediaMarkIds"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddMediaMarksResponseBody() = default;
};
class AddMediaMarksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddMediaMarksResponseBody> body{};

  AddMediaMarksResponse() {}

  explicit AddMediaMarksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddMediaMarksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddMediaMarksResponseBody>(model1);
      }
    }
  }


  virtual ~AddMediaMarksResponse() = default;
};
class AddTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> coverUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> previewMedia{};
  shared_ptr<string> relatedMediaids{};
  shared_ptr<string> source{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  AddTemplateRequest() {}

  explicit AddTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (previewMedia) {
      res["PreviewMedia"] = boost::any(*previewMedia);
    }
    if (relatedMediaids) {
      res["RelatedMediaids"] = boost::any(*relatedMediaids);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PreviewMedia") != m.end() && !m["PreviewMedia"].empty()) {
      previewMedia = make_shared<string>(boost::any_cast<string>(m["PreviewMedia"]));
    }
    if (m.find("RelatedMediaids") != m.end() && !m["RelatedMediaids"].empty()) {
      relatedMediaids = make_shared<string>(boost::any_cast<string>(m["RelatedMediaids"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddTemplateRequest() = default;
};
class AddTemplateResponseBodyTemplate : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> coverUrl{};
  shared_ptr<string> createSource{};
  shared_ptr<string> modifiedSource{};
  shared_ptr<string> name{};
  shared_ptr<string> previewMedia{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  AddTemplateResponseBodyTemplate() {}

  explicit AddTemplateResponseBodyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (modifiedSource) {
      res["ModifiedSource"] = boost::any(*modifiedSource);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (previewMedia) {
      res["PreviewMedia"] = boost::any(*previewMedia);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("ModifiedSource") != m.end() && !m["ModifiedSource"].empty()) {
      modifiedSource = make_shared<string>(boost::any_cast<string>(m["ModifiedSource"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PreviewMedia") != m.end() && !m["PreviewMedia"].empty()) {
      previewMedia = make_shared<string>(boost::any_cast<string>(m["PreviewMedia"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddTemplateResponseBodyTemplate() = default;
};
class AddTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<AddTemplateResponseBodyTemplate> template_{};

  AddTemplateResponseBody() {}

  explicit AddTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (template_) {
      res["Template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(map<string, boost::any>) == m["Template"].type()) {
        AddTemplateResponseBodyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Template"]));
        template_ = make_shared<AddTemplateResponseBodyTemplate>(model1);
      }
    }
  }


  virtual ~AddTemplateResponseBody() = default;
};
class AddTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTemplateResponseBody> body{};

  AddTemplateResponse() {}

  explicit AddTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~AddTemplateResponse() = default;
};
class AlterSearchIndexRequest : public Darabonba::Model {
public:
  shared_ptr<string> indexConfig{};
  shared_ptr<string> indexStatus{};
  shared_ptr<string> indexType{};
  shared_ptr<string> searchLibName{};

  AlterSearchIndexRequest() {}

  explicit AlterSearchIndexRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (indexConfig) {
      res["IndexConfig"] = boost::any(*indexConfig);
    }
    if (indexStatus) {
      res["IndexStatus"] = boost::any(*indexStatus);
    }
    if (indexType) {
      res["IndexType"] = boost::any(*indexType);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IndexConfig") != m.end() && !m["IndexConfig"].empty()) {
      indexConfig = make_shared<string>(boost::any_cast<string>(m["IndexConfig"]));
    }
    if (m.find("IndexStatus") != m.end() && !m["IndexStatus"].empty()) {
      indexStatus = make_shared<string>(boost::any_cast<string>(m["IndexStatus"]));
    }
    if (m.find("IndexType") != m.end() && !m["IndexType"].empty()) {
      indexType = make_shared<string>(boost::any_cast<string>(m["IndexType"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
  }


  virtual ~AlterSearchIndexRequest() = default;
};
class AlterSearchIndexResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  AlterSearchIndexResponseBody() {}

  explicit AlterSearchIndexResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~AlterSearchIndexResponseBody() = default;
};
class AlterSearchIndexResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AlterSearchIndexResponseBody> body{};

  AlterSearchIndexResponse() {}

  explicit AlterSearchIndexResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AlterSearchIndexResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AlterSearchIndexResponseBody>(model1);
      }
    }
  }


  virtual ~AlterSearchIndexResponse() = default;
};
class BatchCreateVodPackagingAssetRequestAssetsInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  BatchCreateVodPackagingAssetRequestAssetsInput() {}

  explicit BatchCreateVodPackagingAssetRequestAssetsInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~BatchCreateVodPackagingAssetRequestAssetsInput() = default;
};
class BatchCreateVodPackagingAssetRequestAssets : public Darabonba::Model {
public:
  shared_ptr<string> assetName{};
  shared_ptr<string> contentId{};
  shared_ptr<BatchCreateVodPackagingAssetRequestAssetsInput> input{};

  BatchCreateVodPackagingAssetRequestAssets() {}

  explicit BatchCreateVodPackagingAssetRequestAssets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetName) {
      res["AssetName"] = boost::any(*assetName);
    }
    if (contentId) {
      res["ContentId"] = boost::any(*contentId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetName") != m.end() && !m["AssetName"].empty()) {
      assetName = make_shared<string>(boost::any_cast<string>(m["AssetName"]));
    }
    if (m.find("ContentId") != m.end() && !m["ContentId"].empty()) {
      contentId = make_shared<string>(boost::any_cast<string>(m["ContentId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        BatchCreateVodPackagingAssetRequestAssetsInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<BatchCreateVodPackagingAssetRequestAssetsInput>(model1);
      }
    }
  }


  virtual ~BatchCreateVodPackagingAssetRequestAssets() = default;
};
class BatchCreateVodPackagingAssetRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchCreateVodPackagingAssetRequestAssets>> assets{};
  shared_ptr<string> groupName{};

  BatchCreateVodPackagingAssetRequest() {}

  explicit BatchCreateVodPackagingAssetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assets) {
      vector<boost::any> temp1;
      for(auto item1:*assets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Assets"] = boost::any(temp1);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Assets") != m.end() && !m["Assets"].empty()) {
      if (typeid(vector<boost::any>) == m["Assets"].type()) {
        vector<BatchCreateVodPackagingAssetRequestAssets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Assets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchCreateVodPackagingAssetRequestAssets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        assets = make_shared<vector<BatchCreateVodPackagingAssetRequestAssets>>(expect1);
      }
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~BatchCreateVodPackagingAssetRequest() = default;
};
class BatchCreateVodPackagingAssetShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> assetsShrink{};
  shared_ptr<string> groupName{};

  BatchCreateVodPackagingAssetShrinkRequest() {}

  explicit BatchCreateVodPackagingAssetShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetsShrink) {
      res["Assets"] = boost::any(*assetsShrink);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Assets") != m.end() && !m["Assets"].empty()) {
      assetsShrink = make_shared<string>(boost::any_cast<string>(m["Assets"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~BatchCreateVodPackagingAssetShrinkRequest() = default;
};
class BatchCreateVodPackagingAssetResponseBodyResultList : public Darabonba::Model {
public:
  shared_ptr<VodPackagingAsset> asset{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};

  BatchCreateVodPackagingAssetResponseBodyResultList() {}

  explicit BatchCreateVodPackagingAssetResponseBodyResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asset) {
      res["Asset"] = asset ? boost::any(asset->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asset") != m.end() && !m["Asset"].empty()) {
      if (typeid(map<string, boost::any>) == m["Asset"].type()) {
        VodPackagingAsset model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Asset"]));
        asset = make_shared<VodPackagingAsset>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~BatchCreateVodPackagingAssetResponseBodyResultList() = default;
};
class BatchCreateVodPackagingAssetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<BatchCreateVodPackagingAssetResponseBodyResultList>> resultList{};

  BatchCreateVodPackagingAssetResponseBody() {}

  explicit BatchCreateVodPackagingAssetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resultList) {
      vector<boost::any> temp1;
      for(auto item1:*resultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResultList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResultList") != m.end() && !m["ResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResultList"].type()) {
        vector<BatchCreateVodPackagingAssetResponseBodyResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchCreateVodPackagingAssetResponseBodyResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultList = make_shared<vector<BatchCreateVodPackagingAssetResponseBodyResultList>>(expect1);
      }
    }
  }


  virtual ~BatchCreateVodPackagingAssetResponseBody() = default;
};
class BatchCreateVodPackagingAssetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchCreateVodPackagingAssetResponseBody> body{};

  BatchCreateVodPackagingAssetResponse() {}

  explicit BatchCreateVodPackagingAssetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchCreateVodPackagingAssetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchCreateVodPackagingAssetResponseBody>(model1);
      }
    }
  }


  virtual ~BatchCreateVodPackagingAssetResponse() = default;
};
class BatchGetMediaInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> additionType{};
  shared_ptr<long> authTimeout{};
  shared_ptr<string> mediaIds{};

  BatchGetMediaInfosRequest() {}

  explicit BatchGetMediaInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionType) {
      res["AdditionType"] = boost::any(*additionType);
    }
    if (authTimeout) {
      res["AuthTimeout"] = boost::any(*authTimeout);
    }
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionType") != m.end() && !m["AdditionType"].empty()) {
      additionType = make_shared<string>(boost::any_cast<string>(m["AdditionType"]));
    }
    if (m.find("AuthTimeout") != m.end() && !m["AuthTimeout"].empty()) {
      authTimeout = make_shared<long>(boost::any_cast<long>(m["AuthTimeout"]));
    }
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
  }


  virtual ~BatchGetMediaInfosRequest() = default;
};
class BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo() {}

  explicit BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo() = default;
};
class BatchGetMediaInfosResponseBodyMediaInfosFileInfoList : public Darabonba::Model {
public:
  shared_ptr<BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo> fileBasicInfo{};

  BatchGetMediaInfosResponseBodyMediaInfosFileInfoList() {}

  explicit BatchGetMediaInfosResponseBodyMediaInfosFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo>(model1);
      }
    }
  }


  virtual ~BatchGetMediaInfosResponseBodyMediaInfosFileInfoList() = default;
};
class BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> biz{};
  shared_ptr<string> businessType{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> snapshots{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteImages{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> transcodeStatus{};
  shared_ptr<string> userData{};

  BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo() {}

  explicit BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (biz) {
      res["Biz"] = boost::any(*biz);
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteImages) {
      res["SpriteImages"] = boost::any(*spriteImages);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (transcodeStatus) {
      res["TranscodeStatus"] = boost::any(*transcodeStatus);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Biz") != m.end() && !m["Biz"].empty()) {
      biz = make_shared<string>(boost::any_cast<string>(m["Biz"]));
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      snapshots = make_shared<string>(boost::any_cast<string>(m["Snapshots"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteImages") != m.end() && !m["SpriteImages"].empty()) {
      spriteImages = make_shared<string>(boost::any_cast<string>(m["SpriteImages"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TranscodeStatus") != m.end() && !m["TranscodeStatus"].empty()) {
      transcodeStatus = make_shared<string>(boost::any_cast<string>(m["TranscodeStatus"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo() = default;
};
class BatchGetMediaInfosResponseBodyMediaInfos : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetMediaInfosResponseBodyMediaInfosFileInfoList>> fileInfoList{};
  shared_ptr<BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  BatchGetMediaInfosResponseBodyMediaInfos() {}

  explicit BatchGetMediaInfosResponseBodyMediaInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<BatchGetMediaInfosResponseBodyMediaInfosFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetMediaInfosResponseBodyMediaInfosFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<BatchGetMediaInfosResponseBodyMediaInfosFileInfoList>>(expect1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~BatchGetMediaInfosResponseBodyMediaInfos() = default;
};
class BatchGetMediaInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<BatchGetMediaInfosResponseBodyMediaInfos>> mediaInfos{};
  shared_ptr<string> requestId{};

  BatchGetMediaInfosResponseBody() {}

  explicit BatchGetMediaInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfos) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfos") != m.end() && !m["MediaInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInfos"].type()) {
        vector<BatchGetMediaInfosResponseBodyMediaInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchGetMediaInfosResponseBodyMediaInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInfos = make_shared<vector<BatchGetMediaInfosResponseBodyMediaInfos>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchGetMediaInfosResponseBody() = default;
};
class BatchGetMediaInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchGetMediaInfosResponseBody> body{};

  BatchGetMediaInfosResponse() {}

  explicit BatchGetMediaInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetMediaInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetMediaInfosResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetMediaInfosResponse() = default;
};
class CancelDNAJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CancelDNAJobRequest() {}

  explicit CancelDNAJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CancelDNAJobRequest() = default;
};
class CancelDNAJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  CancelDNAJobResponseBody() {}

  explicit CancelDNAJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelDNAJobResponseBody() = default;
};
class CancelDNAJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelDNAJobResponseBody> body{};

  CancelDNAJobResponse() {}

  explicit CancelDNAJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelDNAJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelDNAJobResponseBody>(model1);
      }
    }
  }


  virtual ~CancelDNAJobResponse() = default;
};
class CancelFavoritePublicMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaIds{};

  CancelFavoritePublicMediaRequest() {}

  explicit CancelFavoritePublicMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
  }


  virtual ~CancelFavoritePublicMediaRequest() = default;
};
class CancelFavoritePublicMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ignoredList{};
  shared_ptr<string> requestId{};

  CancelFavoritePublicMediaResponseBody() {}

  explicit CancelFavoritePublicMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ignoredList) {
      res["IgnoredList"] = boost::any(*ignoredList);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IgnoredList") != m.end() && !m["IgnoredList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IgnoredList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IgnoredList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ignoredList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelFavoritePublicMediaResponseBody() = default;
};
class CancelFavoritePublicMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelFavoritePublicMediaResponseBody> body{};

  CancelFavoritePublicMediaResponse() {}

  explicit CancelFavoritePublicMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelFavoritePublicMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelFavoritePublicMediaResponseBody>(model1);
      }
    }
  }


  virtual ~CancelFavoritePublicMediaResponse() = default;
};
class CreateAuditRequest : public Darabonba::Model {
public:
  shared_ptr<string> auditContent{};

  CreateAuditRequest() {}

  explicit CreateAuditRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auditContent) {
      res["AuditContent"] = boost::any(*auditContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuditContent") != m.end() && !m["AuditContent"].empty()) {
      auditContent = make_shared<string>(boost::any_cast<string>(m["AuditContent"]));
    }
  }


  virtual ~CreateAuditRequest() = default;
};
class CreateAuditResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateAuditResponseBody() {}

  explicit CreateAuditResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAuditResponseBody() = default;
};
class CreateAuditResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAuditResponseBody> body{};

  CreateAuditResponse() {}

  explicit CreateAuditResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAuditResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAuditResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAuditResponse() = default;
};
class CreateAvatarTrainingJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> avatarDescription{};
  shared_ptr<string> avatarName{};
  shared_ptr<string> avatarType{};
  shared_ptr<string> portrait{};
  shared_ptr<string> thumbnail{};
  shared_ptr<bool> transparent{};
  shared_ptr<string> video{};

  CreateAvatarTrainingJobRequest() {}

  explicit CreateAvatarTrainingJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarDescription) {
      res["AvatarDescription"] = boost::any(*avatarDescription);
    }
    if (avatarName) {
      res["AvatarName"] = boost::any(*avatarName);
    }
    if (avatarType) {
      res["AvatarType"] = boost::any(*avatarType);
    }
    if (portrait) {
      res["Portrait"] = boost::any(*portrait);
    }
    if (thumbnail) {
      res["Thumbnail"] = boost::any(*thumbnail);
    }
    if (transparent) {
      res["Transparent"] = boost::any(*transparent);
    }
    if (video) {
      res["Video"] = boost::any(*video);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarDescription") != m.end() && !m["AvatarDescription"].empty()) {
      avatarDescription = make_shared<string>(boost::any_cast<string>(m["AvatarDescription"]));
    }
    if (m.find("AvatarName") != m.end() && !m["AvatarName"].empty()) {
      avatarName = make_shared<string>(boost::any_cast<string>(m["AvatarName"]));
    }
    if (m.find("AvatarType") != m.end() && !m["AvatarType"].empty()) {
      avatarType = make_shared<string>(boost::any_cast<string>(m["AvatarType"]));
    }
    if (m.find("Portrait") != m.end() && !m["Portrait"].empty()) {
      portrait = make_shared<string>(boost::any_cast<string>(m["Portrait"]));
    }
    if (m.find("Thumbnail") != m.end() && !m["Thumbnail"].empty()) {
      thumbnail = make_shared<string>(boost::any_cast<string>(m["Thumbnail"]));
    }
    if (m.find("Transparent") != m.end() && !m["Transparent"].empty()) {
      transparent = make_shared<bool>(boost::any_cast<bool>(m["Transparent"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      video = make_shared<string>(boost::any_cast<string>(m["Video"]));
    }
  }


  virtual ~CreateAvatarTrainingJobRequest() = default;
};
class CreateAvatarTrainingJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  CreateAvatarTrainingJobResponseBodyData() {}

  explicit CreateAvatarTrainingJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CreateAvatarTrainingJobResponseBodyData() = default;
};
class CreateAvatarTrainingJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateAvatarTrainingJobResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateAvatarTrainingJobResponseBody() {}

  explicit CreateAvatarTrainingJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateAvatarTrainingJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateAvatarTrainingJobResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateAvatarTrainingJobResponseBody() = default;
};
class CreateAvatarTrainingJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAvatarTrainingJobResponseBody> body{};

  CreateAvatarTrainingJobResponse() {}

  explicit CreateAvatarTrainingJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAvatarTrainingJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAvatarTrainingJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAvatarTrainingJobResponse() = default;
};
class CreateChannelRequest : public Darabonba::Model {
public:
  shared_ptr<bool> accessPolicy{};
  shared_ptr<string> accessToken{};
  shared_ptr<string> channelName{};
  shared_ptr<string> channelTier{};
  shared_ptr<string> fillerSourceLocationName{};
  shared_ptr<string> fillerSourceName{};
  shared_ptr<string> outPutConfigList{};
  shared_ptr<string> playbackMode{};

  CreateChannelRequest() {}

  explicit CreateChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPolicy) {
      res["AccessPolicy"] = boost::any(*accessPolicy);
    }
    if (accessToken) {
      res["AccessToken"] = boost::any(*accessToken);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (channelTier) {
      res["ChannelTier"] = boost::any(*channelTier);
    }
    if (fillerSourceLocationName) {
      res["FillerSourceLocationName"] = boost::any(*fillerSourceLocationName);
    }
    if (fillerSourceName) {
      res["FillerSourceName"] = boost::any(*fillerSourceName);
    }
    if (outPutConfigList) {
      res["OutPutConfigList"] = boost::any(*outPutConfigList);
    }
    if (playbackMode) {
      res["PlaybackMode"] = boost::any(*playbackMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPolicy") != m.end() && !m["AccessPolicy"].empty()) {
      accessPolicy = make_shared<bool>(boost::any_cast<bool>(m["AccessPolicy"]));
    }
    if (m.find("AccessToken") != m.end() && !m["AccessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["AccessToken"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ChannelTier") != m.end() && !m["ChannelTier"].empty()) {
      channelTier = make_shared<string>(boost::any_cast<string>(m["ChannelTier"]));
    }
    if (m.find("FillerSourceLocationName") != m.end() && !m["FillerSourceLocationName"].empty()) {
      fillerSourceLocationName = make_shared<string>(boost::any_cast<string>(m["FillerSourceLocationName"]));
    }
    if (m.find("FillerSourceName") != m.end() && !m["FillerSourceName"].empty()) {
      fillerSourceName = make_shared<string>(boost::any_cast<string>(m["FillerSourceName"]));
    }
    if (m.find("OutPutConfigList") != m.end() && !m["OutPutConfigList"].empty()) {
      outPutConfigList = make_shared<string>(boost::any_cast<string>(m["OutPutConfigList"]));
    }
    if (m.find("PlaybackMode") != m.end() && !m["PlaybackMode"].empty()) {
      playbackMode = make_shared<string>(boost::any_cast<string>(m["PlaybackMode"]));
    }
  }


  virtual ~CreateChannelRequest() = default;
};
class CreateChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<ChannelAssemblyChannel> channel{};
  shared_ptr<string> requestId{};

  CreateChannelResponseBody() {}

  explicit CreateChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["Channel"] = channel ? boost::any(channel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      if (typeid(map<string, boost::any>) == m["Channel"].type()) {
        ChannelAssemblyChannel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Channel"]));
        channel = make_shared<ChannelAssemblyChannel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateChannelResponseBody() = default;
};
class CreateChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateChannelResponseBody> body{};

  CreateChannelResponse() {}

  explicit CreateChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateChannelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateChannelResponse() = default;
};
class CreateCustomTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> subtype{};
  shared_ptr<string> templateConfig{};
  shared_ptr<long> type{};

  CreateCustomTemplateRequest() {}

  explicit CreateCustomTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<long>(boost::any_cast<long>(m["Subtype"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~CreateCustomTemplateRequest() = default;
};
class CreateCustomTemplateResponseBodyCustomTemplate : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> status{};
  shared_ptr<string> subtype{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> type{};
  shared_ptr<string> typeName_{};

  CreateCustomTemplateResponseBodyCustomTemplate() {}

  explicit CreateCustomTemplateResponseBodyCustomTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<string>(boost::any_cast<string>(m["Subtype"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~CreateCustomTemplateResponseBodyCustomTemplate() = default;
};
class CreateCustomTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateCustomTemplateResponseBodyCustomTemplate> customTemplate{};
  shared_ptr<string> requestId{};

  CreateCustomTemplateResponseBody() {}

  explicit CreateCustomTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTemplate) {
      res["CustomTemplate"] = customTemplate ? boost::any(customTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTemplate") != m.end() && !m["CustomTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomTemplate"].type()) {
        CreateCustomTemplateResponseBodyCustomTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomTemplate"]));
        customTemplate = make_shared<CreateCustomTemplateResponseBodyCustomTemplate>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomTemplateResponseBody() = default;
};
class CreateCustomTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomTemplateResponseBody> body{};

  CreateCustomTemplateResponse() {}

  explicit CreateCustomTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomTemplateResponse() = default;
};
class CreateCustomizedVoiceJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> gender{};
  shared_ptr<string> scenario{};
  shared_ptr<string> voiceDesc{};
  shared_ptr<string> voiceId{};
  shared_ptr<string> voiceName{};

  CreateCustomizedVoiceJobRequest() {}

  explicit CreateCustomizedVoiceJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gender) {
      res["Gender"] = boost::any(*gender);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (voiceDesc) {
      res["VoiceDesc"] = boost::any(*voiceDesc);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    if (voiceName) {
      res["VoiceName"] = boost::any(*voiceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gender") != m.end() && !m["Gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["Gender"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("VoiceDesc") != m.end() && !m["VoiceDesc"].empty()) {
      voiceDesc = make_shared<string>(boost::any_cast<string>(m["VoiceDesc"]));
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
    if (m.find("VoiceName") != m.end() && !m["VoiceName"].empty()) {
      voiceName = make_shared<string>(boost::any_cast<string>(m["VoiceName"]));
    }
  }


  virtual ~CreateCustomizedVoiceJobRequest() = default;
};
class CreateCustomizedVoiceJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> voiceId{};

  CreateCustomizedVoiceJobResponseBodyData() {}

  explicit CreateCustomizedVoiceJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
  }


  virtual ~CreateCustomizedVoiceJobResponseBodyData() = default;
};
class CreateCustomizedVoiceJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateCustomizedVoiceJobResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateCustomizedVoiceJobResponseBody() {}

  explicit CreateCustomizedVoiceJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateCustomizedVoiceJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateCustomizedVoiceJobResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateCustomizedVoiceJobResponseBody() = default;
};
class CreateCustomizedVoiceJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomizedVoiceJobResponseBody> body{};

  CreateCustomizedVoiceJobResponse() {}

  explicit CreateCustomizedVoiceJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomizedVoiceJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomizedVoiceJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomizedVoiceJobResponse() = default;
};
class CreateDNADBRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> model{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateDNADBRequest() {}

  explicit CreateDNADBRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateDNADBRequest() = default;
};
class CreateDNADBResponseBodyDBInfo : public Darabonba::Model {
public:
  shared_ptr<string> DBId{};
  shared_ptr<string> description{};
  shared_ptr<string> model{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};

  CreateDNADBResponseBodyDBInfo() {}

  explicit CreateDNADBResponseBodyDBInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBId) {
      res["DBId"] = boost::any(*DBId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBId") != m.end() && !m["DBId"].empty()) {
      DBId = make_shared<string>(boost::any_cast<string>(m["DBId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreateDNADBResponseBodyDBInfo() = default;
};
class CreateDNADBResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateDNADBResponseBodyDBInfo> DBInfo{};
  shared_ptr<string> requestId{};

  CreateDNADBResponseBody() {}

  explicit CreateDNADBResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBInfo) {
      res["DBInfo"] = DBInfo ? boost::any(DBInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBInfo") != m.end() && !m["DBInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DBInfo"].type()) {
        CreateDNADBResponseBodyDBInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DBInfo"]));
        DBInfo = make_shared<CreateDNADBResponseBodyDBInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDNADBResponseBody() = default;
};
class CreateDNADBResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDNADBResponseBody> body{};

  CreateDNADBResponse() {}

  explicit CreateDNADBResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDNADBResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDNADBResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDNADBResponse() = default;
};
class CreateEditingProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessConfig{};
  shared_ptr<string> clipsParam{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> materialMaps{};
  shared_ptr<string> projectType{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};
  shared_ptr<string> timeline{};
  shared_ptr<string> title{};

  CreateEditingProjectRequest() {}

  explicit CreateEditingProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessConfig) {
      res["BusinessConfig"] = boost::any(*businessConfig);
    }
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (materialMaps) {
      res["MaterialMaps"] = boost::any(*materialMaps);
    }
    if (projectType) {
      res["ProjectType"] = boost::any(*projectType);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessConfig") != m.end() && !m["BusinessConfig"].empty()) {
      businessConfig = make_shared<string>(boost::any_cast<string>(m["BusinessConfig"]));
    }
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MaterialMaps") != m.end() && !m["MaterialMaps"].empty()) {
      materialMaps = make_shared<string>(boost::any_cast<string>(m["MaterialMaps"]));
    }
    if (m.find("ProjectType") != m.end() && !m["ProjectType"].empty()) {
      projectType = make_shared<string>(boost::any_cast<string>(m["ProjectType"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateEditingProjectRequest() = default;
};
class CreateEditingProjectResponseBodyProject : public Darabonba::Model {
public:
  shared_ptr<string> businessConfig{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> clipsParam{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createSource{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<double> duration{};
  shared_ptr<string> modifiedSource{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectType{};
  shared_ptr<long> status{};
  shared_ptr<string> statusName{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};
  shared_ptr<string> timeline{};
  shared_ptr<string> title{};

  CreateEditingProjectResponseBodyProject() {}

  explicit CreateEditingProjectResponseBodyProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessConfig) {
      res["BusinessConfig"] = boost::any(*businessConfig);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (modifiedSource) {
      res["ModifiedSource"] = boost::any(*modifiedSource);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectType) {
      res["ProjectType"] = boost::any(*projectType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusName) {
      res["StatusName"] = boost::any(*statusName);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessConfig") != m.end() && !m["BusinessConfig"].empty()) {
      businessConfig = make_shared<string>(boost::any_cast<string>(m["BusinessConfig"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("ModifiedSource") != m.end() && !m["ModifiedSource"].empty()) {
      modifiedSource = make_shared<string>(boost::any_cast<string>(m["ModifiedSource"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectType") != m.end() && !m["ProjectType"].empty()) {
      projectType = make_shared<string>(boost::any_cast<string>(m["ProjectType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StatusName") != m.end() && !m["StatusName"].empty()) {
      statusName = make_shared<string>(boost::any_cast<string>(m["StatusName"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateEditingProjectResponseBodyProject() = default;
};
class CreateEditingProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateEditingProjectResponseBodyProject> project{};
  shared_ptr<string> requestId{};

  CreateEditingProjectResponseBody() {}

  explicit CreateEditingProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (project) {
      res["Project"] = project ? boost::any(project->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      if (typeid(map<string, boost::any>) == m["Project"].type()) {
        CreateEditingProjectResponseBodyProject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Project"]));
        project = make_shared<CreateEditingProjectResponseBodyProject>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEditingProjectResponseBody() = default;
};
class CreateEditingProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEditingProjectResponseBody> body{};

  CreateEditingProjectResponse() {}

  explicit CreateEditingProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEditingProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEditingProjectResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEditingProjectResponse() = default;
};
class CreateHotwordLibraryRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<Hotword>> hotwords{};
  shared_ptr<string> name{};
  shared_ptr<string> usageScenario{};

  CreateHotwordLibraryRequest() {}

  explicit CreateHotwordLibraryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hotwords) {
      vector<boost::any> temp1;
      for(auto item1:*hotwords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hotwords"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (usageScenario) {
      res["UsageScenario"] = boost::any(*usageScenario);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hotwords") != m.end() && !m["Hotwords"].empty()) {
      if (typeid(vector<boost::any>) == m["Hotwords"].type()) {
        vector<Hotword> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hotwords"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Hotword model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotwords = make_shared<vector<Hotword>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UsageScenario") != m.end() && !m["UsageScenario"].empty()) {
      usageScenario = make_shared<string>(boost::any_cast<string>(m["UsageScenario"]));
    }
  }


  virtual ~CreateHotwordLibraryRequest() = default;
};
class CreateHotwordLibraryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> hotwordsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> usageScenario{};

  CreateHotwordLibraryShrinkRequest() {}

  explicit CreateHotwordLibraryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hotwordsShrink) {
      res["Hotwords"] = boost::any(*hotwordsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (usageScenario) {
      res["UsageScenario"] = boost::any(*usageScenario);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Hotwords") != m.end() && !m["Hotwords"].empty()) {
      hotwordsShrink = make_shared<string>(boost::any_cast<string>(m["Hotwords"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UsageScenario") != m.end() && !m["UsageScenario"].empty()) {
      usageScenario = make_shared<string>(boost::any_cast<string>(m["UsageScenario"]));
    }
  }


  virtual ~CreateHotwordLibraryShrinkRequest() = default;
};
class CreateHotwordLibraryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> hotwordLibraryId{};
  shared_ptr<string> requestId{};

  CreateHotwordLibraryResponseBody() {}

  explicit CreateHotwordLibraryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotwordLibraryId) {
      res["HotwordLibraryId"] = boost::any(*hotwordLibraryId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HotwordLibraryId") != m.end() && !m["HotwordLibraryId"].empty()) {
      hotwordLibraryId = make_shared<string>(boost::any_cast<string>(m["HotwordLibraryId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateHotwordLibraryResponseBody() = default;
};
class CreateHotwordLibraryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHotwordLibraryResponseBody> body{};

  CreateHotwordLibraryResponse() {}

  explicit CreateHotwordLibraryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHotwordLibraryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHotwordLibraryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHotwordLibraryResponse() = default;
};
class CreateLivePackageChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<string> protocol{};
  shared_ptr<long> segmentCount{};
  shared_ptr<long> segmentDuration{};

  CreateLivePackageChannelRequest() {}

  explicit CreateLivePackageChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (segmentCount) {
      res["SegmentCount"] = boost::any(*segmentCount);
    }
    if (segmentDuration) {
      res["SegmentDuration"] = boost::any(*segmentDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SegmentCount") != m.end() && !m["SegmentCount"].empty()) {
      segmentCount = make_shared<long>(boost::any_cast<long>(m["SegmentCount"]));
    }
    if (m.find("SegmentDuration") != m.end() && !m["SegmentDuration"].empty()) {
      segmentDuration = make_shared<long>(boost::any_cast<long>(m["SegmentDuration"]));
    }
  }


  virtual ~CreateLivePackageChannelRequest() = default;
};
class CreateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> password{};
  shared_ptr<string> url{};
  shared_ptr<string> username{};

  CreateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints() {}

  explicit CreateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~CreateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints() = default;
};
class CreateLivePackageChannelResponseBodyLivePackageChannel : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<vector<CreateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints>> ingestEndpoints{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> protocol{};
  shared_ptr<long> segmentCount{};
  shared_ptr<long> segmentDuration{};

  CreateLivePackageChannelResponseBodyLivePackageChannel() {}

  explicit CreateLivePackageChannelResponseBodyLivePackageChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (ingestEndpoints) {
      vector<boost::any> temp1;
      for(auto item1:*ingestEndpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngestEndpoints"] = boost::any(temp1);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (segmentCount) {
      res["SegmentCount"] = boost::any(*segmentCount);
    }
    if (segmentDuration) {
      res["SegmentDuration"] = boost::any(*segmentDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IngestEndpoints") != m.end() && !m["IngestEndpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["IngestEndpoints"].type()) {
        vector<CreateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngestEndpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingestEndpoints = make_shared<vector<CreateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints>>(expect1);
      }
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SegmentCount") != m.end() && !m["SegmentCount"].empty()) {
      segmentCount = make_shared<long>(boost::any_cast<long>(m["SegmentCount"]));
    }
    if (m.find("SegmentDuration") != m.end() && !m["SegmentDuration"].empty()) {
      segmentDuration = make_shared<long>(boost::any_cast<long>(m["SegmentDuration"]));
    }
  }


  virtual ~CreateLivePackageChannelResponseBodyLivePackageChannel() = default;
};
class CreateLivePackageChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateLivePackageChannelResponseBodyLivePackageChannel> livePackageChannel{};
  shared_ptr<string> requestId{};

  CreateLivePackageChannelResponseBody() {}

  explicit CreateLivePackageChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livePackageChannel) {
      res["LivePackageChannel"] = livePackageChannel ? boost::any(livePackageChannel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivePackageChannel") != m.end() && !m["LivePackageChannel"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivePackageChannel"].type()) {
        CreateLivePackageChannelResponseBodyLivePackageChannel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivePackageChannel"]));
        livePackageChannel = make_shared<CreateLivePackageChannelResponseBodyLivePackageChannel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLivePackageChannelResponseBody() = default;
};
class CreateLivePackageChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLivePackageChannelResponseBody> body{};

  CreateLivePackageChannelResponse() {}

  explicit CreateLivePackageChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLivePackageChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLivePackageChannelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLivePackageChannelResponse() = default;
};
class CreateLivePackageChannelGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};

  CreateLivePackageChannelGroupRequest() {}

  explicit CreateLivePackageChannelGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~CreateLivePackageChannelGroupRequest() = default;
};
class CreateLivePackageChannelGroupResponseBodyLivePackageChannelGroup : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> originDomain{};

  CreateLivePackageChannelGroupResponseBodyLivePackageChannelGroup() {}

  explicit CreateLivePackageChannelGroupResponseBodyLivePackageChannelGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (originDomain) {
      res["OriginDomain"] = boost::any(*originDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("OriginDomain") != m.end() && !m["OriginDomain"].empty()) {
      originDomain = make_shared<string>(boost::any_cast<string>(m["OriginDomain"]));
    }
  }


  virtual ~CreateLivePackageChannelGroupResponseBodyLivePackageChannelGroup() = default;
};
class CreateLivePackageChannelGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateLivePackageChannelGroupResponseBodyLivePackageChannelGroup> livePackageChannelGroup{};
  shared_ptr<string> requestId{};

  CreateLivePackageChannelGroupResponseBody() {}

  explicit CreateLivePackageChannelGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livePackageChannelGroup) {
      res["LivePackageChannelGroup"] = livePackageChannelGroup ? boost::any(livePackageChannelGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivePackageChannelGroup") != m.end() && !m["LivePackageChannelGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivePackageChannelGroup"].type()) {
        CreateLivePackageChannelGroupResponseBodyLivePackageChannelGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivePackageChannelGroup"]));
        livePackageChannelGroup = make_shared<CreateLivePackageChannelGroupResponseBodyLivePackageChannelGroup>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLivePackageChannelGroupResponseBody() = default;
};
class CreateLivePackageChannelGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLivePackageChannelGroupResponseBody> body{};

  CreateLivePackageChannelGroupResponse() {}

  explicit CreateLivePackageChannelGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLivePackageChannelGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLivePackageChannelGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLivePackageChannelGroupResponse() = default;
};
class CreateLivePackageOriginEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> authorizationCode{};
  shared_ptr<string> channelName{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> groupName{};
  shared_ptr<string> ipBlacklist{};
  shared_ptr<string> ipWhitelist{};
  shared_ptr<LivePackagingConfig> livePackagingConfig{};
  shared_ptr<string> manifestName{};
  shared_ptr<string> protocol{};
  shared_ptr<long> timeshiftVision{};

  CreateLivePackageOriginEndpointRequest() {}

  explicit CreateLivePackageOriginEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizationCode) {
      res["AuthorizationCode"] = boost::any(*authorizationCode);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (ipBlacklist) {
      res["IpBlacklist"] = boost::any(*ipBlacklist);
    }
    if (ipWhitelist) {
      res["IpWhitelist"] = boost::any(*ipWhitelist);
    }
    if (livePackagingConfig) {
      res["LivePackagingConfig"] = livePackagingConfig ? boost::any(livePackagingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (manifestName) {
      res["ManifestName"] = boost::any(*manifestName);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (timeshiftVision) {
      res["TimeshiftVision"] = boost::any(*timeshiftVision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizationCode") != m.end() && !m["AuthorizationCode"].empty()) {
      authorizationCode = make_shared<string>(boost::any_cast<string>(m["AuthorizationCode"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IpBlacklist") != m.end() && !m["IpBlacklist"].empty()) {
      ipBlacklist = make_shared<string>(boost::any_cast<string>(m["IpBlacklist"]));
    }
    if (m.find("IpWhitelist") != m.end() && !m["IpWhitelist"].empty()) {
      ipWhitelist = make_shared<string>(boost::any_cast<string>(m["IpWhitelist"]));
    }
    if (m.find("LivePackagingConfig") != m.end() && !m["LivePackagingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivePackagingConfig"].type()) {
        LivePackagingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivePackagingConfig"]));
        livePackagingConfig = make_shared<LivePackagingConfig>(model1);
      }
    }
    if (m.find("ManifestName") != m.end() && !m["ManifestName"].empty()) {
      manifestName = make_shared<string>(boost::any_cast<string>(m["ManifestName"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("TimeshiftVision") != m.end() && !m["TimeshiftVision"].empty()) {
      timeshiftVision = make_shared<long>(boost::any_cast<long>(m["TimeshiftVision"]));
    }
  }


  virtual ~CreateLivePackageOriginEndpointRequest() = default;
};
class CreateLivePackageOriginEndpointShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> authorizationCode{};
  shared_ptr<string> channelName{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> groupName{};
  shared_ptr<string> ipBlacklist{};
  shared_ptr<string> ipWhitelist{};
  shared_ptr<string> livePackagingConfigShrink{};
  shared_ptr<string> manifestName{};
  shared_ptr<string> protocol{};
  shared_ptr<long> timeshiftVision{};

  CreateLivePackageOriginEndpointShrinkRequest() {}

  explicit CreateLivePackageOriginEndpointShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizationCode) {
      res["AuthorizationCode"] = boost::any(*authorizationCode);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (ipBlacklist) {
      res["IpBlacklist"] = boost::any(*ipBlacklist);
    }
    if (ipWhitelist) {
      res["IpWhitelist"] = boost::any(*ipWhitelist);
    }
    if (livePackagingConfigShrink) {
      res["LivePackagingConfig"] = boost::any(*livePackagingConfigShrink);
    }
    if (manifestName) {
      res["ManifestName"] = boost::any(*manifestName);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (timeshiftVision) {
      res["TimeshiftVision"] = boost::any(*timeshiftVision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizationCode") != m.end() && !m["AuthorizationCode"].empty()) {
      authorizationCode = make_shared<string>(boost::any_cast<string>(m["AuthorizationCode"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IpBlacklist") != m.end() && !m["IpBlacklist"].empty()) {
      ipBlacklist = make_shared<string>(boost::any_cast<string>(m["IpBlacklist"]));
    }
    if (m.find("IpWhitelist") != m.end() && !m["IpWhitelist"].empty()) {
      ipWhitelist = make_shared<string>(boost::any_cast<string>(m["IpWhitelist"]));
    }
    if (m.find("LivePackagingConfig") != m.end() && !m["LivePackagingConfig"].empty()) {
      livePackagingConfigShrink = make_shared<string>(boost::any_cast<string>(m["LivePackagingConfig"]));
    }
    if (m.find("ManifestName") != m.end() && !m["ManifestName"].empty()) {
      manifestName = make_shared<string>(boost::any_cast<string>(m["ManifestName"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("TimeshiftVision") != m.end() && !m["TimeshiftVision"].empty()) {
      timeshiftVision = make_shared<long>(boost::any_cast<long>(m["TimeshiftVision"]));
    }
  }


  virtual ~CreateLivePackageOriginEndpointShrinkRequest() = default;
};
class CreateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> authorizationCode{};
  shared_ptr<string> channelName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> endpointUrl{};
  shared_ptr<string> groupName{};
  shared_ptr<string> ipBlacklist{};
  shared_ptr<string> ipWhitelist{};
  shared_ptr<string> lastModified{};
  shared_ptr<LivePackagingConfig> livePackagingConfig{};
  shared_ptr<string> manifestName{};
  shared_ptr<string> protocol{};
  shared_ptr<long> timeshiftVision{};

  CreateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint() {}

  explicit CreateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizationCode) {
      res["AuthorizationCode"] = boost::any(*authorizationCode);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (endpointUrl) {
      res["EndpointUrl"] = boost::any(*endpointUrl);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (ipBlacklist) {
      res["IpBlacklist"] = boost::any(*ipBlacklist);
    }
    if (ipWhitelist) {
      res["IpWhitelist"] = boost::any(*ipWhitelist);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (livePackagingConfig) {
      res["LivePackagingConfig"] = livePackagingConfig ? boost::any(livePackagingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (manifestName) {
      res["ManifestName"] = boost::any(*manifestName);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (timeshiftVision) {
      res["TimeshiftVision"] = boost::any(*timeshiftVision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizationCode") != m.end() && !m["AuthorizationCode"].empty()) {
      authorizationCode = make_shared<string>(boost::any_cast<string>(m["AuthorizationCode"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("EndpointUrl") != m.end() && !m["EndpointUrl"].empty()) {
      endpointUrl = make_shared<string>(boost::any_cast<string>(m["EndpointUrl"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IpBlacklist") != m.end() && !m["IpBlacklist"].empty()) {
      ipBlacklist = make_shared<string>(boost::any_cast<string>(m["IpBlacklist"]));
    }
    if (m.find("IpWhitelist") != m.end() && !m["IpWhitelist"].empty()) {
      ipWhitelist = make_shared<string>(boost::any_cast<string>(m["IpWhitelist"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("LivePackagingConfig") != m.end() && !m["LivePackagingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivePackagingConfig"].type()) {
        LivePackagingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivePackagingConfig"]));
        livePackagingConfig = make_shared<LivePackagingConfig>(model1);
      }
    }
    if (m.find("ManifestName") != m.end() && !m["ManifestName"].empty()) {
      manifestName = make_shared<string>(boost::any_cast<string>(m["ManifestName"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("TimeshiftVision") != m.end() && !m["TimeshiftVision"].empty()) {
      timeshiftVision = make_shared<long>(boost::any_cast<long>(m["TimeshiftVision"]));
    }
  }


  virtual ~CreateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint() = default;
};
class CreateLivePackageOriginEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint> livePackageOriginEndpoint{};
  shared_ptr<string> requestId{};

  CreateLivePackageOriginEndpointResponseBody() {}

  explicit CreateLivePackageOriginEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livePackageOriginEndpoint) {
      res["LivePackageOriginEndpoint"] = livePackageOriginEndpoint ? boost::any(livePackageOriginEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivePackageOriginEndpoint") != m.end() && !m["LivePackageOriginEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivePackageOriginEndpoint"].type()) {
        CreateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivePackageOriginEndpoint"]));
        livePackageOriginEndpoint = make_shared<CreateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLivePackageOriginEndpointResponseBody() = default;
};
class CreateLivePackageOriginEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLivePackageOriginEndpointResponseBody> body{};

  CreateLivePackageOriginEndpointResponse() {}

  explicit CreateLivePackageOriginEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLivePackageOriginEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLivePackageOriginEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLivePackageOriginEndpointResponse() = default;
};
class CreateLiveRecordTemplateRequestRecordFormat : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<long> sliceDuration{};
  shared_ptr<string> sliceOssObjectPrefix{};

  CreateLiveRecordTemplateRequestRecordFormat() {}

  explicit CreateLiveRecordTemplateRequestRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~CreateLiveRecordTemplateRequestRecordFormat() = default;
};
class CreateLiveRecordTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<vector<CreateLiveRecordTemplateRequestRecordFormat>> recordFormat{};

  CreateLiveRecordTemplateRequest() {}

  explicit CreateLiveRecordTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordFormat) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormat"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormat"].type()) {
        vector<CreateLiveRecordTemplateRequestRecordFormat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateLiveRecordTemplateRequestRecordFormat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormat = make_shared<vector<CreateLiveRecordTemplateRequestRecordFormat>>(expect1);
      }
    }
  }


  virtual ~CreateLiveRecordTemplateRequest() = default;
};
class CreateLiveRecordTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> recordFormatShrink{};

  CreateLiveRecordTemplateShrinkRequest() {}

  explicit CreateLiveRecordTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordFormatShrink) {
      res["RecordFormat"] = boost::any(*recordFormatShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      recordFormatShrink = make_shared<string>(boost::any_cast<string>(m["RecordFormat"]));
    }
  }


  virtual ~CreateLiveRecordTemplateShrinkRequest() = default;
};
class CreateLiveRecordTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  CreateLiveRecordTemplateResponseBody() {}

  explicit CreateLiveRecordTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateLiveRecordTemplateResponseBody() = default;
};
class CreateLiveRecordTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveRecordTemplateResponseBody> body{};

  CreateLiveRecordTemplateResponse() {}

  explicit CreateLiveRecordTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveRecordTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveRecordTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveRecordTemplateResponse() = default;
};
class CreateLiveSnapshotTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> overwriteFormat{};
  shared_ptr<string> sequenceFormat{};
  shared_ptr<string> templateName{};
  shared_ptr<long> timeInterval{};

  CreateLiveSnapshotTemplateRequest() {}

  explicit CreateLiveSnapshotTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteFormat) {
      res["OverwriteFormat"] = boost::any(*overwriteFormat);
    }
    if (sequenceFormat) {
      res["SequenceFormat"] = boost::any(*sequenceFormat);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteFormat") != m.end() && !m["OverwriteFormat"].empty()) {
      overwriteFormat = make_shared<string>(boost::any_cast<string>(m["OverwriteFormat"]));
    }
    if (m.find("SequenceFormat") != m.end() && !m["SequenceFormat"].empty()) {
      sequenceFormat = make_shared<string>(boost::any_cast<string>(m["SequenceFormat"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
  }


  virtual ~CreateLiveSnapshotTemplateRequest() = default;
};
class CreateLiveSnapshotTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  CreateLiveSnapshotTemplateResponseBody() {}

  explicit CreateLiveSnapshotTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateLiveSnapshotTemplateResponseBody() = default;
};
class CreateLiveSnapshotTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveSnapshotTemplateResponseBody> body{};

  CreateLiveSnapshotTemplateResponse() {}

  explicit CreateLiveSnapshotTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveSnapshotTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveSnapshotTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveSnapshotTemplateResponse() = default;
};
class CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> samplerate{};

  CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams() {}

  explicit CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams() = default;
};
class CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> codec{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> profile{};
  shared_ptr<string> width{};

  CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams() {}

  explicit CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams() = default;
};
class CreateLiveTranscodeTemplateRequestTemplateConfig : public Darabonba::Model {
public:
  shared_ptr<CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams> audioParams{};
  shared_ptr<CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams> videoParams{};

  CreateLiveTranscodeTemplateRequestTemplateConfig() {}

  explicit CreateLiveTranscodeTemplateRequestTemplateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioParams) {
      res["AudioParams"] = audioParams ? boost::any(audioParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoParams) {
      res["VideoParams"] = videoParams ? boost::any(videoParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioParams") != m.end() && !m["AudioParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioParams"].type()) {
        CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioParams"]));
        audioParams = make_shared<CreateLiveTranscodeTemplateRequestTemplateConfigAudioParams>(model1);
      }
    }
    if (m.find("VideoParams") != m.end() && !m["VideoParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoParams"].type()) {
        CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoParams"]));
        videoParams = make_shared<CreateLiveTranscodeTemplateRequestTemplateConfigVideoParams>(model1);
      }
    }
  }


  virtual ~CreateLiveTranscodeTemplateRequestTemplateConfig() = default;
};
class CreateLiveTranscodeTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<CreateLiveTranscodeTemplateRequestTemplateConfig> templateConfig{};
  shared_ptr<string> type{};

  CreateLiveTranscodeTemplateRequest() {}

  explicit CreateLiveTranscodeTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        CreateLiveTranscodeTemplateRequestTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<CreateLiveTranscodeTemplateRequestTemplateConfig>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateLiveTranscodeTemplateRequest() = default;
};
class CreateLiveTranscodeTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> templateConfigShrink{};
  shared_ptr<string> type{};

  CreateLiveTranscodeTemplateShrinkRequest() {}

  explicit CreateLiveTranscodeTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfigShrink) {
      res["TemplateConfig"] = boost::any(*templateConfigShrink);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfigShrink = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateLiveTranscodeTemplateShrinkRequest() = default;
};
class CreateLiveTranscodeTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  CreateLiveTranscodeTemplateResponseBody() {}

  explicit CreateLiveTranscodeTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateLiveTranscodeTemplateResponseBody() = default;
};
class CreateLiveTranscodeTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLiveTranscodeTemplateResponseBody> body{};

  CreateLiveTranscodeTemplateResponse() {}

  explicit CreateLiveTranscodeTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLiveTranscodeTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLiveTranscodeTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLiveTranscodeTemplateResponse() = default;
};
class CreateMediaConnectFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowName{};
  shared_ptr<string> flowRegion{};

  CreateMediaConnectFlowRequest() {}

  explicit CreateMediaConnectFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowName) {
      res["FlowName"] = boost::any(*flowName);
    }
    if (flowRegion) {
      res["FlowRegion"] = boost::any(*flowRegion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowName") != m.end() && !m["FlowName"].empty()) {
      flowName = make_shared<string>(boost::any_cast<string>(m["FlowName"]));
    }
    if (m.find("FlowRegion") != m.end() && !m["FlowRegion"].empty()) {
      flowRegion = make_shared<string>(boost::any_cast<string>(m["FlowRegion"]));
    }
  }


  virtual ~CreateMediaConnectFlowRequest() = default;
};
class CreateMediaConnectFlowResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};

  CreateMediaConnectFlowResponseBodyContent() {}

  explicit CreateMediaConnectFlowResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
  }


  virtual ~CreateMediaConnectFlowResponseBodyContent() = default;
};
class CreateMediaConnectFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateMediaConnectFlowResponseBodyContent> content{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};

  CreateMediaConnectFlowResponseBody() {}

  explicit CreateMediaConnectFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        CreateMediaConnectFlowResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<CreateMediaConnectFlowResponseBodyContent>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
  }


  virtual ~CreateMediaConnectFlowResponseBody() = default;
};
class CreateMediaConnectFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMediaConnectFlowResponseBody> body{};

  CreateMediaConnectFlowResponse() {}

  explicit CreateMediaConnectFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMediaConnectFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMediaConnectFlowResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMediaConnectFlowResponse() = default;
};
class CreateMediaLiveChannelRequestAudioSettingsAudioCodecSetting : public Darabonba::Model {
public:
  shared_ptr<long> bitrate{};
  shared_ptr<string> profile{};
  shared_ptr<long> sampleRate{};

  CreateMediaLiveChannelRequestAudioSettingsAudioCodecSetting() {}

  explicit CreateMediaLiveChannelRequestAudioSettingsAudioCodecSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<long>(boost::any_cast<long>(m["SampleRate"]));
    }
  }


  virtual ~CreateMediaLiveChannelRequestAudioSettingsAudioCodecSetting() = default;
};
class CreateMediaLiveChannelRequestAudioSettings : public Darabonba::Model {
public:
  shared_ptr<string> audioCodec{};
  shared_ptr<CreateMediaLiveChannelRequestAudioSettingsAudioCodecSetting> audioCodecSetting{};
  shared_ptr<string> audioSelectorName{};
  shared_ptr<string> languageCode{};
  shared_ptr<string> languageName{};
  shared_ptr<string> name{};

  CreateMediaLiveChannelRequestAudioSettings() {}

  explicit CreateMediaLiveChannelRequestAudioSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioCodec) {
      res["AudioCodec"] = boost::any(*audioCodec);
    }
    if (audioCodecSetting) {
      res["AudioCodecSetting"] = audioCodecSetting ? boost::any(audioCodecSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioSelectorName) {
      res["AudioSelectorName"] = boost::any(*audioSelectorName);
    }
    if (languageCode) {
      res["LanguageCode"] = boost::any(*languageCode);
    }
    if (languageName) {
      res["LanguageName"] = boost::any(*languageName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioCodec") != m.end() && !m["AudioCodec"].empty()) {
      audioCodec = make_shared<string>(boost::any_cast<string>(m["AudioCodec"]));
    }
    if (m.find("AudioCodecSetting") != m.end() && !m["AudioCodecSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioCodecSetting"].type()) {
        CreateMediaLiveChannelRequestAudioSettingsAudioCodecSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioCodecSetting"]));
        audioCodecSetting = make_shared<CreateMediaLiveChannelRequestAudioSettingsAudioCodecSetting>(model1);
      }
    }
    if (m.find("AudioSelectorName") != m.end() && !m["AudioSelectorName"].empty()) {
      audioSelectorName = make_shared<string>(boost::any_cast<string>(m["AudioSelectorName"]));
    }
    if (m.find("LanguageCode") != m.end() && !m["LanguageCode"].empty()) {
      languageCode = make_shared<string>(boost::any_cast<string>(m["LanguageCode"]));
    }
    if (m.find("LanguageName") != m.end() && !m["LanguageName"].empty()) {
      languageName = make_shared<string>(boost::any_cast<string>(m["LanguageName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateMediaLiveChannelRequestAudioSettings() = default;
};
class CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection : public Darabonba::Model {
public:
  shared_ptr<string> languageCode{};

  CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection() {}

  explicit CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (languageCode) {
      res["LanguageCode"] = boost::any(*languageCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LanguageCode") != m.end() && !m["LanguageCode"].empty()) {
      languageCode = make_shared<string>(boost::any_cast<string>(m["LanguageCode"]));
    }
  }


  virtual ~CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection() = default;
};
class CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection : public Darabonba::Model {
public:
  shared_ptr<long> pid{};

  CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection() {}

  explicit CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<long>(boost::any_cast<long>(m["Pid"]));
    }
  }


  virtual ~CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection() = default;
};
class CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection : public Darabonba::Model {
public:
  shared_ptr<long> trackId{};

  CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection() {}

  explicit CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trackId) {
      res["TrackId"] = boost::any(*trackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrackId") != m.end() && !m["TrackId"].empty()) {
      trackId = make_shared<long>(boost::any_cast<long>(m["TrackId"]));
    }
  }


  virtual ~CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection() = default;
};
class CreateMediaLiveChannelRequestInputAttachmentsAudioSelectors : public Darabonba::Model {
public:
  shared_ptr<CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection> audioLanguageSelection{};
  shared_ptr<CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection> audioPidSelection{};
  shared_ptr<vector<CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection>> audioTrackSelection{};
  shared_ptr<string> name{};

  CreateMediaLiveChannelRequestInputAttachmentsAudioSelectors() {}

  explicit CreateMediaLiveChannelRequestInputAttachmentsAudioSelectors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLanguageSelection) {
      res["AudioLanguageSelection"] = audioLanguageSelection ? boost::any(audioLanguageSelection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioPidSelection) {
      res["AudioPidSelection"] = audioPidSelection ? boost::any(audioPidSelection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioTrackSelection) {
      vector<boost::any> temp1;
      for(auto item1:*audioTrackSelection){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioTrackSelection"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLanguageSelection") != m.end() && !m["AudioLanguageSelection"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioLanguageSelection"].type()) {
        CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioLanguageSelection"]));
        audioLanguageSelection = make_shared<CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection>(model1);
      }
    }
    if (m.find("AudioPidSelection") != m.end() && !m["AudioPidSelection"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioPidSelection"].type()) {
        CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioPidSelection"]));
        audioPidSelection = make_shared<CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection>(model1);
      }
    }
    if (m.find("AudioTrackSelection") != m.end() && !m["AudioTrackSelection"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioTrackSelection"].type()) {
        vector<CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioTrackSelection"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioTrackSelection = make_shared<vector<CreateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateMediaLiveChannelRequestInputAttachmentsAudioSelectors() = default;
};
class CreateMediaLiveChannelRequestInputAttachments : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMediaLiveChannelRequestInputAttachmentsAudioSelectors>> audioSelectors{};
  shared_ptr<string> inputId{};
  shared_ptr<string> languageName{};

  CreateMediaLiveChannelRequestInputAttachments() {}

  explicit CreateMediaLiveChannelRequestInputAttachments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSelectors) {
      vector<boost::any> temp1;
      for(auto item1:*audioSelectors){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioSelectors"] = boost::any(temp1);
    }
    if (inputId) {
      res["InputId"] = boost::any(*inputId);
    }
    if (languageName) {
      res["LanguageName"] = boost::any(*languageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSelectors") != m.end() && !m["AudioSelectors"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioSelectors"].type()) {
        vector<CreateMediaLiveChannelRequestInputAttachmentsAudioSelectors> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioSelectors"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMediaLiveChannelRequestInputAttachmentsAudioSelectors model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioSelectors = make_shared<vector<CreateMediaLiveChannelRequestInputAttachmentsAudioSelectors>>(expect1);
      }
    }
    if (m.find("InputId") != m.end() && !m["InputId"].empty()) {
      inputId = make_shared<string>(boost::any_cast<string>(m["InputId"]));
    }
    if (m.find("LanguageName") != m.end() && !m["LanguageName"].empty()) {
      languageName = make_shared<string>(boost::any_cast<string>(m["LanguageName"]));
    }
  }


  virtual ~CreateMediaLiveChannelRequestInputAttachments() = default;
};
class CreateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> groupName{};

  CreateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting() {}

  explicit CreateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~CreateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting() = default;
};
class CreateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting : public Darabonba::Model {
public:
  shared_ptr<string> audioGroupId{};
  shared_ptr<string> nameModifier{};

  CreateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting() {}

  explicit CreateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioGroupId) {
      res["AudioGroupId"] = boost::any(*audioGroupId);
    }
    if (nameModifier) {
      res["NameModifier"] = boost::any(*nameModifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioGroupId") != m.end() && !m["AudioGroupId"].empty()) {
      audioGroupId = make_shared<string>(boost::any_cast<string>(m["AudioGroupId"]));
    }
    if (m.find("NameModifier") != m.end() && !m["NameModifier"].empty()) {
      nameModifier = make_shared<string>(boost::any_cast<string>(m["NameModifier"]));
    }
  }


  virtual ~CreateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting() = default;
};
class CreateMediaLiveChannelRequestOutputGroupsOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> audioSettingNames{};
  shared_ptr<CreateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting> mediaPackageOutputSetting{};
  shared_ptr<long> mediaType{};
  shared_ptr<string> name{};
  shared_ptr<string> videoSettingName{};

  CreateMediaLiveChannelRequestOutputGroupsOutputs() {}

  explicit CreateMediaLiveChannelRequestOutputGroupsOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSettingNames) {
      res["AudioSettingNames"] = boost::any(*audioSettingNames);
    }
    if (mediaPackageOutputSetting) {
      res["MediaPackageOutputSetting"] = mediaPackageOutputSetting ? boost::any(mediaPackageOutputSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (videoSettingName) {
      res["VideoSettingName"] = boost::any(*videoSettingName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSettingNames") != m.end() && !m["AudioSettingNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AudioSettingNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AudioSettingNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      audioSettingNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MediaPackageOutputSetting") != m.end() && !m["MediaPackageOutputSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaPackageOutputSetting"].type()) {
        CreateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaPackageOutputSetting"]));
        mediaPackageOutputSetting = make_shared<CreateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting>(model1);
      }
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<long>(boost::any_cast<long>(m["MediaType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("VideoSettingName") != m.end() && !m["VideoSettingName"].empty()) {
      videoSettingName = make_shared<string>(boost::any_cast<string>(m["VideoSettingName"]));
    }
  }


  virtual ~CreateMediaLiveChannelRequestOutputGroupsOutputs() = default;
};
class CreateMediaLiveChannelRequestOutputGroups : public Darabonba::Model {
public:
  shared_ptr<CreateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting> mediaPackageGroupSetting{};
  shared_ptr<string> name{};
  shared_ptr<vector<CreateMediaLiveChannelRequestOutputGroupsOutputs>> outputs{};
  shared_ptr<string> type{};

  CreateMediaLiveChannelRequestOutputGroups() {}

  explicit CreateMediaLiveChannelRequestOutputGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaPackageGroupSetting) {
      res["MediaPackageGroupSetting"] = mediaPackageGroupSetting ? boost::any(mediaPackageGroupSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      vector<boost::any> temp1;
      for(auto item1:*outputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outputs"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaPackageGroupSetting") != m.end() && !m["MediaPackageGroupSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaPackageGroupSetting"].type()) {
        CreateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaPackageGroupSetting"]));
        mediaPackageGroupSetting = make_shared<CreateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Outputs"].type()) {
        vector<CreateMediaLiveChannelRequestOutputGroupsOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMediaLiveChannelRequestOutputGroupsOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputs = make_shared<vector<CreateMediaLiveChannelRequestOutputGroupsOutputs>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateMediaLiveChannelRequestOutputGroups() = default;
};
class CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> profile{};

  CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail() {}

  explicit CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
  }


  virtual ~CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail() = default;
};
class CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate : public Darabonba::Model {
public:
  shared_ptr<string> framerateControl{};
  shared_ptr<long> framerateDenominator{};
  shared_ptr<long> framerateNumerator{};

  CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate() {}

  explicit CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (framerateControl) {
      res["FramerateControl"] = boost::any(*framerateControl);
    }
    if (framerateDenominator) {
      res["FramerateDenominator"] = boost::any(*framerateDenominator);
    }
    if (framerateNumerator) {
      res["FramerateNumerator"] = boost::any(*framerateNumerator);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FramerateControl") != m.end() && !m["FramerateControl"].empty()) {
      framerateControl = make_shared<string>(boost::any_cast<string>(m["FramerateControl"]));
    }
    if (m.find("FramerateDenominator") != m.end() && !m["FramerateDenominator"].empty()) {
      framerateDenominator = make_shared<long>(boost::any_cast<long>(m["FramerateDenominator"]));
    }
    if (m.find("FramerateNumerator") != m.end() && !m["FramerateNumerator"].empty()) {
      framerateNumerator = make_shared<long>(boost::any_cast<long>(m["FramerateNumerator"]));
    }
  }


  virtual ~CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate() = default;
};
class CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop : public Darabonba::Model {
public:
  shared_ptr<long> bframesNum{};
  shared_ptr<long> gopSize{};
  shared_ptr<string> gopSizeUnits{};

  CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop() {}

  explicit CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bframesNum) {
      res["BframesNum"] = boost::any(*bframesNum);
    }
    if (gopSize) {
      res["GopSize"] = boost::any(*gopSize);
    }
    if (gopSizeUnits) {
      res["GopSizeUnits"] = boost::any(*gopSizeUnits);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BframesNum") != m.end() && !m["BframesNum"].empty()) {
      bframesNum = make_shared<long>(boost::any_cast<long>(m["BframesNum"]));
    }
    if (m.find("GopSize") != m.end() && !m["GopSize"].empty()) {
      gopSize = make_shared<long>(boost::any_cast<long>(m["GopSize"]));
    }
    if (m.find("GopSizeUnits") != m.end() && !m["GopSizeUnits"].empty()) {
      gopSizeUnits = make_shared<string>(boost::any_cast<string>(m["GopSizeUnits"]));
    }
  }


  virtual ~CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop() = default;
};
class CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate : public Darabonba::Model {
public:
  shared_ptr<long> bitrate{};
  shared_ptr<long> bufferSize{};
  shared_ptr<long> maxBitrate{};
  shared_ptr<string> rateControlMode{};

  CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate() {}

  explicit CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufferSize) {
      res["BufferSize"] = boost::any(*bufferSize);
    }
    if (maxBitrate) {
      res["MaxBitrate"] = boost::any(*maxBitrate);
    }
    if (rateControlMode) {
      res["RateControlMode"] = boost::any(*rateControlMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("BufferSize") != m.end() && !m["BufferSize"].empty()) {
      bufferSize = make_shared<long>(boost::any_cast<long>(m["BufferSize"]));
    }
    if (m.find("MaxBitrate") != m.end() && !m["MaxBitrate"].empty()) {
      maxBitrate = make_shared<long>(boost::any_cast<long>(m["MaxBitrate"]));
    }
    if (m.find("RateControlMode") != m.end() && !m["RateControlMode"].empty()) {
      rateControlMode = make_shared<string>(boost::any_cast<string>(m["RateControlMode"]));
    }
  }


  virtual ~CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate() = default;
};
class CreateMediaLiveChannelRequestVideoSettingsVideoCodecSetting : public Darabonba::Model {
public:
  shared_ptr<CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail> codecDetail{};
  shared_ptr<CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate> framerate{};
  shared_ptr<CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop> gop{};
  shared_ptr<CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate> rate{};

  CreateMediaLiveChannelRequestVideoSettingsVideoCodecSetting() {}

  explicit CreateMediaLiveChannelRequestVideoSettingsVideoCodecSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codecDetail) {
      res["CodecDetail"] = codecDetail ? boost::any(codecDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (framerate) {
      res["Framerate"] = framerate ? boost::any(framerate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gop) {
      res["Gop"] = gop ? boost::any(gop->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rate) {
      res["Rate"] = rate ? boost::any(rate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodecDetail") != m.end() && !m["CodecDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["CodecDetail"].type()) {
        CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CodecDetail"]));
        codecDetail = make_shared<CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail>(model1);
      }
    }
    if (m.find("Framerate") != m.end() && !m["Framerate"].empty()) {
      if (typeid(map<string, boost::any>) == m["Framerate"].type()) {
        CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Framerate"]));
        framerate = make_shared<CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate>(model1);
      }
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gop"].type()) {
        CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gop"]));
        gop = make_shared<CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop>(model1);
      }
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rate"].type()) {
        CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rate"]));
        rate = make_shared<CreateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate>(model1);
      }
    }
  }


  virtual ~CreateMediaLiveChannelRequestVideoSettingsVideoCodecSetting() = default;
};
class CreateMediaLiveChannelRequestVideoSettings : public Darabonba::Model {
public:
  shared_ptr<long> height{};
  shared_ptr<string> name{};
  shared_ptr<string> videoCodec{};
  shared_ptr<CreateMediaLiveChannelRequestVideoSettingsVideoCodecSetting> videoCodecSetting{};
  shared_ptr<string> videoCodecType{};
  shared_ptr<long> width{};

  CreateMediaLiveChannelRequestVideoSettings() {}

  explicit CreateMediaLiveChannelRequestVideoSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (videoCodec) {
      res["VideoCodec"] = boost::any(*videoCodec);
    }
    if (videoCodecSetting) {
      res["VideoCodecSetting"] = videoCodecSetting ? boost::any(videoCodecSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCodecType) {
      res["VideoCodecType"] = boost::any(*videoCodecType);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("VideoCodec") != m.end() && !m["VideoCodec"].empty()) {
      videoCodec = make_shared<string>(boost::any_cast<string>(m["VideoCodec"]));
    }
    if (m.find("VideoCodecSetting") != m.end() && !m["VideoCodecSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoCodecSetting"].type()) {
        CreateMediaLiveChannelRequestVideoSettingsVideoCodecSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoCodecSetting"]));
        videoCodecSetting = make_shared<CreateMediaLiveChannelRequestVideoSettingsVideoCodecSetting>(model1);
      }
    }
    if (m.find("VideoCodecType") != m.end() && !m["VideoCodecType"].empty()) {
      videoCodecType = make_shared<string>(boost::any_cast<string>(m["VideoCodecType"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~CreateMediaLiveChannelRequestVideoSettings() = default;
};
class CreateMediaLiveChannelRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMediaLiveChannelRequestAudioSettings>> audioSettings{};
  shared_ptr<vector<CreateMediaLiveChannelRequestInputAttachments>> inputAttachments{};
  shared_ptr<string> name{};
  shared_ptr<vector<CreateMediaLiveChannelRequestOutputGroups>> outputGroups{};
  shared_ptr<vector<CreateMediaLiveChannelRequestVideoSettings>> videoSettings{};

  CreateMediaLiveChannelRequest() {}

  explicit CreateMediaLiveChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSettings) {
      vector<boost::any> temp1;
      for(auto item1:*audioSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioSettings"] = boost::any(temp1);
    }
    if (inputAttachments) {
      vector<boost::any> temp1;
      for(auto item1:*inputAttachments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputAttachments"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputGroups) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroups"] = boost::any(temp1);
    }
    if (videoSettings) {
      vector<boost::any> temp1;
      for(auto item1:*videoSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoSettings"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSettings") != m.end() && !m["AudioSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioSettings"].type()) {
        vector<CreateMediaLiveChannelRequestAudioSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMediaLiveChannelRequestAudioSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioSettings = make_shared<vector<CreateMediaLiveChannelRequestAudioSettings>>(expect1);
      }
    }
    if (m.find("InputAttachments") != m.end() && !m["InputAttachments"].empty()) {
      if (typeid(vector<boost::any>) == m["InputAttachments"].type()) {
        vector<CreateMediaLiveChannelRequestInputAttachments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputAttachments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMediaLiveChannelRequestInputAttachments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputAttachments = make_shared<vector<CreateMediaLiveChannelRequestInputAttachments>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputGroups") != m.end() && !m["OutputGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroups"].type()) {
        vector<CreateMediaLiveChannelRequestOutputGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMediaLiveChannelRequestOutputGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroups = make_shared<vector<CreateMediaLiveChannelRequestOutputGroups>>(expect1);
      }
    }
    if (m.find("VideoSettings") != m.end() && !m["VideoSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoSettings"].type()) {
        vector<CreateMediaLiveChannelRequestVideoSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMediaLiveChannelRequestVideoSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoSettings = make_shared<vector<CreateMediaLiveChannelRequestVideoSettings>>(expect1);
      }
    }
  }


  virtual ~CreateMediaLiveChannelRequest() = default;
};
class CreateMediaLiveChannelShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioSettingsShrink{};
  shared_ptr<string> inputAttachmentsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> outputGroupsShrink{};
  shared_ptr<string> videoSettingsShrink{};

  CreateMediaLiveChannelShrinkRequest() {}

  explicit CreateMediaLiveChannelShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSettingsShrink) {
      res["AudioSettings"] = boost::any(*audioSettingsShrink);
    }
    if (inputAttachmentsShrink) {
      res["InputAttachments"] = boost::any(*inputAttachmentsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputGroupsShrink) {
      res["OutputGroups"] = boost::any(*outputGroupsShrink);
    }
    if (videoSettingsShrink) {
      res["VideoSettings"] = boost::any(*videoSettingsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSettings") != m.end() && !m["AudioSettings"].empty()) {
      audioSettingsShrink = make_shared<string>(boost::any_cast<string>(m["AudioSettings"]));
    }
    if (m.find("InputAttachments") != m.end() && !m["InputAttachments"].empty()) {
      inputAttachmentsShrink = make_shared<string>(boost::any_cast<string>(m["InputAttachments"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputGroups") != m.end() && !m["OutputGroups"].empty()) {
      outputGroupsShrink = make_shared<string>(boost::any_cast<string>(m["OutputGroups"]));
    }
    if (m.find("VideoSettings") != m.end() && !m["VideoSettings"].empty()) {
      videoSettingsShrink = make_shared<string>(boost::any_cast<string>(m["VideoSettings"]));
    }
  }


  virtual ~CreateMediaLiveChannelShrinkRequest() = default;
};
class CreateMediaLiveChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> requestId{};

  CreateMediaLiveChannelResponseBody() {}

  explicit CreateMediaLiveChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateMediaLiveChannelResponseBody() = default;
};
class CreateMediaLiveChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMediaLiveChannelResponseBody> body{};

  CreateMediaLiveChannelResponse() {}

  explicit CreateMediaLiveChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMediaLiveChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMediaLiveChannelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMediaLiveChannelResponse() = default;
};
class CreateMediaLiveInputRequestInputSettings : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};
  shared_ptr<string> flowOutputName{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<string> streamName{};

  CreateMediaLiveInputRequestInputSettings() {}

  explicit CreateMediaLiveInputRequestInputSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowOutputName) {
      res["FlowOutputName"] = boost::any(*flowOutputName);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowOutputName") != m.end() && !m["FlowOutputName"].empty()) {
      flowOutputName = make_shared<string>(boost::any_cast<string>(m["FlowOutputName"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~CreateMediaLiveInputRequestInputSettings() = default;
};
class CreateMediaLiveInputRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateMediaLiveInputRequestInputSettings>> inputSettings{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<string> type{};

  CreateMediaLiveInputRequest() {}

  explicit CreateMediaLiveInputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputSettings) {
      vector<boost::any> temp1;
      for(auto item1:*inputSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputSettings"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputSettings") != m.end() && !m["InputSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["InputSettings"].type()) {
        vector<CreateMediaLiveInputRequestInputSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMediaLiveInputRequestInputSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputSettings = make_shared<vector<CreateMediaLiveInputRequestInputSettings>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateMediaLiveInputRequest() = default;
};
class CreateMediaLiveInputShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputSettingsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> securityGroupIdsShrink{};
  shared_ptr<string> type{};

  CreateMediaLiveInputShrinkRequest() {}

  explicit CreateMediaLiveInputShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputSettingsShrink) {
      res["InputSettings"] = boost::any(*inputSettingsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (securityGroupIdsShrink) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIdsShrink);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputSettings") != m.end() && !m["InputSettings"].empty()) {
      inputSettingsShrink = make_shared<string>(boost::any_cast<string>(m["InputSettings"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      securityGroupIdsShrink = make_shared<string>(boost::any_cast<string>(m["SecurityGroupIds"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateMediaLiveInputShrinkRequest() = default;
};
class CreateMediaLiveInputResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> inputId{};
  shared_ptr<string> requestId{};

  CreateMediaLiveInputResponseBody() {}

  explicit CreateMediaLiveInputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputId) {
      res["InputId"] = boost::any(*inputId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputId") != m.end() && !m["InputId"].empty()) {
      inputId = make_shared<string>(boost::any_cast<string>(m["InputId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateMediaLiveInputResponseBody() = default;
};
class CreateMediaLiveInputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMediaLiveInputResponseBody> body{};

  CreateMediaLiveInputResponse() {}

  explicit CreateMediaLiveInputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMediaLiveInputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMediaLiveInputResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMediaLiveInputResponse() = default;
};
class CreateMediaLiveInputSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<vector<string>> whitelistRules{};

  CreateMediaLiveInputSecurityGroupRequest() {}

  explicit CreateMediaLiveInputSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (whitelistRules) {
      res["WhitelistRules"] = boost::any(*whitelistRules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("WhitelistRules") != m.end() && !m["WhitelistRules"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WhitelistRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WhitelistRules"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      whitelistRules = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateMediaLiveInputSecurityGroupRequest() = default;
};
class CreateMediaLiveInputSecurityGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> whitelistRulesShrink{};

  CreateMediaLiveInputSecurityGroupShrinkRequest() {}

  explicit CreateMediaLiveInputSecurityGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (whitelistRulesShrink) {
      res["WhitelistRules"] = boost::any(*whitelistRulesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("WhitelistRules") != m.end() && !m["WhitelistRules"].empty()) {
      whitelistRulesShrink = make_shared<string>(boost::any_cast<string>(m["WhitelistRules"]));
    }
  }


  virtual ~CreateMediaLiveInputSecurityGroupShrinkRequest() = default;
};
class CreateMediaLiveInputSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> securityGroupId{};

  CreateMediaLiveInputSecurityGroupResponseBody() {}

  explicit CreateMediaLiveInputSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~CreateMediaLiveInputSecurityGroupResponseBody() = default;
};
class CreateMediaLiveInputSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMediaLiveInputSecurityGroupResponseBody> body{};

  CreateMediaLiveInputSecurityGroupResponse() {}

  explicit CreateMediaLiveInputSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMediaLiveInputSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMediaLiveInputSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMediaLiveInputSecurityGroupResponse() = default;
};
class CreatePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> priority{};
  shared_ptr<string> speed{};

  CreatePipelineRequest() {}

  explicit CreatePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
  }


  virtual ~CreatePipelineRequest() = default;
};
class CreatePipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};
  shared_ptr<string> speed{};
  shared_ptr<string> status{};

  CreatePipelineResponseBodyPipeline() {}

  explicit CreatePipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~CreatePipelineResponseBodyPipeline() = default;
};
class CreatePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreatePipelineResponseBodyPipeline> pipeline{};
  shared_ptr<string> requestId{};

  CreatePipelineResponseBody() {}

  explicit CreatePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        CreatePipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<CreatePipelineResponseBodyPipeline>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePipelineResponseBody() = default;
};
class CreatePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePipelineResponseBody> body{};

  CreatePipelineResponse() {}

  explicit CreatePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePipelineResponse() = default;
};
class CreateProgramRequest : public Darabonba::Model {
public:
  shared_ptr<string> adBreaks{};
  shared_ptr<string> channelName{};
  shared_ptr<string> clipRange{};
  shared_ptr<string> programName{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> transition{};

  CreateProgramRequest() {}

  explicit CreateProgramRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adBreaks) {
      res["AdBreaks"] = boost::any(*adBreaks);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (clipRange) {
      res["ClipRange"] = boost::any(*clipRange);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (transition) {
      res["Transition"] = boost::any(*transition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdBreaks") != m.end() && !m["AdBreaks"].empty()) {
      adBreaks = make_shared<string>(boost::any_cast<string>(m["AdBreaks"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ClipRange") != m.end() && !m["ClipRange"].empty()) {
      clipRange = make_shared<string>(boost::any_cast<string>(m["ClipRange"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Transition") != m.end() && !m["Transition"].empty()) {
      transition = make_shared<string>(boost::any_cast<string>(m["Transition"]));
    }
  }


  virtual ~CreateProgramRequest() = default;
};
class CreateProgramResponseBody : public Darabonba::Model {
public:
  shared_ptr<ChannelAssemblyProgram> program{};
  shared_ptr<string> requestId{};

  CreateProgramResponseBody() {}

  explicit CreateProgramResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (program) {
      res["Program"] = program ? boost::any(program->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Program") != m.end() && !m["Program"].empty()) {
      if (typeid(map<string, boost::any>) == m["Program"].type()) {
        ChannelAssemblyProgram model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Program"]));
        program = make_shared<ChannelAssemblyProgram>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateProgramResponseBody() = default;
};
class CreateProgramResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProgramResponseBody> body{};

  CreateProgramResponse() {}

  explicit CreateProgramResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProgramResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProgramResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProgramResponse() = default;
};
class CreateRecognitionEntityRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> entityInfo{};
  shared_ptr<string> entityName{};
  shared_ptr<string> libId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateRecognitionEntityRequest() {}

  explicit CreateRecognitionEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (entityInfo) {
      res["EntityInfo"] = boost::any(*entityInfo);
    }
    if (entityName) {
      res["EntityName"] = boost::any(*entityName);
    }
    if (libId) {
      res["LibId"] = boost::any(*libId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("EntityInfo") != m.end() && !m["EntityInfo"].empty()) {
      entityInfo = make_shared<string>(boost::any_cast<string>(m["EntityInfo"]));
    }
    if (m.find("EntityName") != m.end() && !m["EntityName"].empty()) {
      entityName = make_shared<string>(boost::any_cast<string>(m["EntityName"]));
    }
    if (m.find("LibId") != m.end() && !m["LibId"].empty()) {
      libId = make_shared<string>(boost::any_cast<string>(m["LibId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateRecognitionEntityRequest() = default;
};
class CreateRecognitionEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<string> requestId{};

  CreateRecognitionEntityResponseBody() {}

  explicit CreateRecognitionEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateRecognitionEntityResponseBody() = default;
};
class CreateRecognitionEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRecognitionEntityResponseBody> body{};

  CreateRecognitionEntityResponse() {}

  explicit CreateRecognitionEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRecognitionEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRecognitionEntityResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRecognitionEntityResponse() = default;
};
class CreateRecognitionLibRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> libDescription{};
  shared_ptr<string> libName{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateRecognitionLibRequest() {}

  explicit CreateRecognitionLibRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (libDescription) {
      res["LibDescription"] = boost::any(*libDescription);
    }
    if (libName) {
      res["LibName"] = boost::any(*libName);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("LibDescription") != m.end() && !m["LibDescription"].empty()) {
      libDescription = make_shared<string>(boost::any_cast<string>(m["LibDescription"]));
    }
    if (m.find("LibName") != m.end() && !m["LibName"].empty()) {
      libName = make_shared<string>(boost::any_cast<string>(m["LibName"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateRecognitionLibRequest() = default;
};
class CreateRecognitionLibResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> libId{};
  shared_ptr<string> requestId{};

  CreateRecognitionLibResponseBody() {}

  explicit CreateRecognitionLibResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (libId) {
      res["LibId"] = boost::any(*libId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LibId") != m.end() && !m["LibId"].empty()) {
      libId = make_shared<string>(boost::any_cast<string>(m["LibId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateRecognitionLibResponseBody() = default;
};
class CreateRecognitionLibResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRecognitionLibResponseBody> body{};

  CreateRecognitionLibResponse() {}

  explicit CreateRecognitionLibResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRecognitionLibResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRecognitionLibResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRecognitionLibResponse() = default;
};
class CreateRecognitionSampleRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> entityId{};
  shared_ptr<string> imageUrl{};
  shared_ptr<string> labelPrompt{};
  shared_ptr<string> libId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  CreateRecognitionSampleRequest() {}

  explicit CreateRecognitionSampleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (labelPrompt) {
      res["LabelPrompt"] = boost::any(*labelPrompt);
    }
    if (libId) {
      res["LibId"] = boost::any(*libId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("LabelPrompt") != m.end() && !m["LabelPrompt"].empty()) {
      labelPrompt = make_shared<string>(boost::any_cast<string>(m["LabelPrompt"]));
    }
    if (m.find("LibId") != m.end() && !m["LibId"].empty()) {
      libId = make_shared<string>(boost::any_cast<string>(m["LibId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~CreateRecognitionSampleRequest() = default;
};
class CreateRecognitionSampleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> sampleId{};

  CreateRecognitionSampleResponseBody() {}

  explicit CreateRecognitionSampleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sampleId) {
      res["SampleId"] = boost::any(*sampleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SampleId") != m.end() && !m["SampleId"].empty()) {
      sampleId = make_shared<string>(boost::any_cast<string>(m["SampleId"]));
    }
  }


  virtual ~CreateRecognitionSampleResponseBody() = default;
};
class CreateRecognitionSampleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRecognitionSampleResponseBody> body{};

  CreateRecognitionSampleResponse() {}

  explicit CreateRecognitionSampleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRecognitionSampleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRecognitionSampleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRecognitionSampleResponse() = default;
};
class CreateSearchIndexRequest : public Darabonba::Model {
public:
  shared_ptr<string> indexConfig{};
  shared_ptr<string> indexStatus{};
  shared_ptr<string> indexType{};
  shared_ptr<string> searchLibName{};

  CreateSearchIndexRequest() {}

  explicit CreateSearchIndexRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (indexConfig) {
      res["IndexConfig"] = boost::any(*indexConfig);
    }
    if (indexStatus) {
      res["IndexStatus"] = boost::any(*indexStatus);
    }
    if (indexType) {
      res["IndexType"] = boost::any(*indexType);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IndexConfig") != m.end() && !m["IndexConfig"].empty()) {
      indexConfig = make_shared<string>(boost::any_cast<string>(m["IndexConfig"]));
    }
    if (m.find("IndexStatus") != m.end() && !m["IndexStatus"].empty()) {
      indexStatus = make_shared<string>(boost::any_cast<string>(m["IndexStatus"]));
    }
    if (m.find("IndexType") != m.end() && !m["IndexType"].empty()) {
      indexType = make_shared<string>(boost::any_cast<string>(m["IndexType"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
  }


  virtual ~CreateSearchIndexRequest() = default;
};
class CreateSearchIndexResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  CreateSearchIndexResponseBody() {}

  explicit CreateSearchIndexResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateSearchIndexResponseBody() = default;
};
class CreateSearchIndexResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSearchIndexResponseBody> body{};

  CreateSearchIndexResponse() {}

  explicit CreateSearchIndexResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSearchIndexResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSearchIndexResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSearchIndexResponse() = default;
};
class CreateSearchLibRequest : public Darabonba::Model {
public:
  shared_ptr<string> searchLibName{};

  CreateSearchLibRequest() {}

  explicit CreateSearchLibRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
  }


  virtual ~CreateSearchLibRequest() = default;
};
class CreateSearchLibResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};
  shared_ptr<string> searchLibName{};
  shared_ptr<string> success{};

  CreateSearchLibResponseBody() {}

  explicit CreateSearchLibResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~CreateSearchLibResponseBody() = default;
};
class CreateSearchLibResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSearchLibResponseBody> body{};

  CreateSearchLibResponse() {}

  explicit CreateSearchLibResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSearchLibResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSearchLibResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSearchLibResponse() = default;
};
class CreateSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> httpPackageConfigurations{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceType{};

  CreateSourceRequest() {}

  explicit CreateSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpPackageConfigurations) {
      res["HttpPackageConfigurations"] = boost::any(*httpPackageConfigurations);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpPackageConfigurations") != m.end() && !m["HttpPackageConfigurations"].empty()) {
      httpPackageConfigurations = make_shared<string>(boost::any_cast<string>(m["HttpPackageConfigurations"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~CreateSourceRequest() = default;
};
class CreateSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ChannelAssemblySource> source{};

  CreateSourceResponseBody() {}

  explicit CreateSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (source) {
      res["Source"] = source ? boost::any(source->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(map<string, boost::any>) == m["Source"].type()) {
        ChannelAssemblySource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Source"]));
        source = make_shared<ChannelAssemblySource>(model1);
      }
    }
  }


  virtual ~CreateSourceResponseBody() = default;
};
class CreateSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSourceResponseBody> body{};

  CreateSourceResponse() {}

  explicit CreateSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSourceResponse() = default;
};
class CreateSourceLocationRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseUrl{};
  shared_ptr<bool> enableSegmentDelivery{};
  shared_ptr<string> segmentDeliveryUrl{};
  shared_ptr<string> sourceLocationName{};

  CreateSourceLocationRequest() {}

  explicit CreateSourceLocationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseUrl) {
      res["BaseUrl"] = boost::any(*baseUrl);
    }
    if (enableSegmentDelivery) {
      res["EnableSegmentDelivery"] = boost::any(*enableSegmentDelivery);
    }
    if (segmentDeliveryUrl) {
      res["SegmentDeliveryUrl"] = boost::any(*segmentDeliveryUrl);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseUrl") != m.end() && !m["BaseUrl"].empty()) {
      baseUrl = make_shared<string>(boost::any_cast<string>(m["BaseUrl"]));
    }
    if (m.find("EnableSegmentDelivery") != m.end() && !m["EnableSegmentDelivery"].empty()) {
      enableSegmentDelivery = make_shared<bool>(boost::any_cast<bool>(m["EnableSegmentDelivery"]));
    }
    if (m.find("SegmentDeliveryUrl") != m.end() && !m["SegmentDeliveryUrl"].empty()) {
      segmentDeliveryUrl = make_shared<string>(boost::any_cast<string>(m["SegmentDeliveryUrl"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
  }


  virtual ~CreateSourceLocationRequest() = default;
};
class CreateSourceLocationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ChannelAssemblySourceLocation> sourceLocation{};

  CreateSourceLocationResponseBody() {}

  explicit CreateSourceLocationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceLocation) {
      res["SourceLocation"] = sourceLocation ? boost::any(sourceLocation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceLocation") != m.end() && !m["SourceLocation"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceLocation"].type()) {
        ChannelAssemblySourceLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceLocation"]));
        sourceLocation = make_shared<ChannelAssemblySourceLocation>(model1);
      }
    }
  }


  virtual ~CreateSourceLocationResponseBody() = default;
};
class CreateSourceLocationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSourceLocationResponseBody> body{};

  CreateSourceLocationResponse() {}

  explicit CreateSourceLocationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSourceLocationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSourceLocationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSourceLocationResponse() = default;
};
class CreateUploadMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> entityId{};
  shared_ptr<string> fileInfo{};
  shared_ptr<string> mediaMetaData{};
  shared_ptr<string> postProcessConfig{};
  shared_ptr<string> uploadTargetConfig{};
  shared_ptr<string> userData{};

  CreateUploadMediaRequest() {}

  explicit CreateUploadMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (fileInfo) {
      res["FileInfo"] = boost::any(*fileInfo);
    }
    if (mediaMetaData) {
      res["MediaMetaData"] = boost::any(*mediaMetaData);
    }
    if (postProcessConfig) {
      res["PostProcessConfig"] = boost::any(*postProcessConfig);
    }
    if (uploadTargetConfig) {
      res["UploadTargetConfig"] = boost::any(*uploadTargetConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("FileInfo") != m.end() && !m["FileInfo"].empty()) {
      fileInfo = make_shared<string>(boost::any_cast<string>(m["FileInfo"]));
    }
    if (m.find("MediaMetaData") != m.end() && !m["MediaMetaData"].empty()) {
      mediaMetaData = make_shared<string>(boost::any_cast<string>(m["MediaMetaData"]));
    }
    if (m.find("PostProcessConfig") != m.end() && !m["PostProcessConfig"].empty()) {
      postProcessConfig = make_shared<string>(boost::any_cast<string>(m["PostProcessConfig"]));
    }
    if (m.find("UploadTargetConfig") != m.end() && !m["UploadTargetConfig"].empty()) {
      uploadTargetConfig = make_shared<string>(boost::any_cast<string>(m["UploadTargetConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateUploadMediaRequest() = default;
};
class CreateUploadMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fileURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaURL{};
  shared_ptr<string> requestId{};
  shared_ptr<string> uploadAddress{};
  shared_ptr<string> uploadAuth{};

  CreateUploadMediaResponseBody() {}

  explicit CreateUploadMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaURL) {
      res["MediaURL"] = boost::any(*mediaURL);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadAddress) {
      res["UploadAddress"] = boost::any(*uploadAddress);
    }
    if (uploadAuth) {
      res["UploadAuth"] = boost::any(*uploadAuth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaURL") != m.end() && !m["MediaURL"].empty()) {
      mediaURL = make_shared<string>(boost::any_cast<string>(m["MediaURL"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadAddress") != m.end() && !m["UploadAddress"].empty()) {
      uploadAddress = make_shared<string>(boost::any_cast<string>(m["UploadAddress"]));
    }
    if (m.find("UploadAuth") != m.end() && !m["UploadAuth"].empty()) {
      uploadAuth = make_shared<string>(boost::any_cast<string>(m["UploadAuth"]));
    }
  }


  virtual ~CreateUploadMediaResponseBody() = default;
};
class CreateUploadMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUploadMediaResponseBody> body{};

  CreateUploadMediaResponse() {}

  explicit CreateUploadMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUploadMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUploadMediaResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUploadMediaResponse() = default;
};
class CreateUploadStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> definition{};
  shared_ptr<string> fileExtension{};
  shared_ptr<string> HDRType{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> userData{};

  CreateUploadStreamRequest() {}

  explicit CreateUploadStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (fileExtension) {
      res["FileExtension"] = boost::any(*fileExtension);
    }
    if (HDRType) {
      res["HDRType"] = boost::any(*HDRType);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("FileExtension") != m.end() && !m["FileExtension"].empty()) {
      fileExtension = make_shared<string>(boost::any_cast<string>(m["FileExtension"]));
    }
    if (m.find("HDRType") != m.end() && !m["HDRType"].empty()) {
      HDRType = make_shared<string>(boost::any_cast<string>(m["HDRType"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateUploadStreamRequest() = default;
};
class CreateUploadStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fileURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> uploadAddress{};
  shared_ptr<string> uploadAuth{};

  CreateUploadStreamResponseBody() {}

  explicit CreateUploadStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadAddress) {
      res["UploadAddress"] = boost::any(*uploadAddress);
    }
    if (uploadAuth) {
      res["UploadAuth"] = boost::any(*uploadAuth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadAddress") != m.end() && !m["UploadAddress"].empty()) {
      uploadAddress = make_shared<string>(boost::any_cast<string>(m["UploadAddress"]));
    }
    if (m.find("UploadAuth") != m.end() && !m["UploadAuth"].empty()) {
      uploadAuth = make_shared<string>(boost::any_cast<string>(m["UploadAuth"]));
    }
  }


  virtual ~CreateUploadStreamResponseBody() = default;
};
class CreateUploadStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUploadStreamResponseBody> body{};

  CreateUploadStreamResponse() {}

  explicit CreateUploadStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUploadStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUploadStreamResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUploadStreamResponse() = default;
};
class CreateVodPackagingAssetRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  CreateVodPackagingAssetRequestInput() {}

  explicit CreateVodPackagingAssetRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateVodPackagingAssetRequestInput() = default;
};
class CreateVodPackagingAssetRequest : public Darabonba::Model {
public:
  shared_ptr<string> assetName{};
  shared_ptr<string> contentId{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<CreateVodPackagingAssetRequestInput> input{};

  CreateVodPackagingAssetRequest() {}

  explicit CreateVodPackagingAssetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetName) {
      res["AssetName"] = boost::any(*assetName);
    }
    if (contentId) {
      res["ContentId"] = boost::any(*contentId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetName") != m.end() && !m["AssetName"].empty()) {
      assetName = make_shared<string>(boost::any_cast<string>(m["AssetName"]));
    }
    if (m.find("ContentId") != m.end() && !m["ContentId"].empty()) {
      contentId = make_shared<string>(boost::any_cast<string>(m["ContentId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        CreateVodPackagingAssetRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<CreateVodPackagingAssetRequestInput>(model1);
      }
    }
  }


  virtual ~CreateVodPackagingAssetRequest() = default;
};
class CreateVodPackagingAssetShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> assetName{};
  shared_ptr<string> contentId{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<string> inputShrink{};

  CreateVodPackagingAssetShrinkRequest() {}

  explicit CreateVodPackagingAssetShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetName) {
      res["AssetName"] = boost::any(*assetName);
    }
    if (contentId) {
      res["ContentId"] = boost::any(*contentId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetName") != m.end() && !m["AssetName"].empty()) {
      assetName = make_shared<string>(boost::any_cast<string>(m["AssetName"]));
    }
    if (m.find("ContentId") != m.end() && !m["ContentId"].empty()) {
      contentId = make_shared<string>(boost::any_cast<string>(m["ContentId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
  }


  virtual ~CreateVodPackagingAssetShrinkRequest() = default;
};
class CreateVodPackagingAssetResponseBody : public Darabonba::Model {
public:
  shared_ptr<VodPackagingAsset> asset{};
  shared_ptr<string> requestId{};

  CreateVodPackagingAssetResponseBody() {}

  explicit CreateVodPackagingAssetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asset) {
      res["Asset"] = asset ? boost::any(asset->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asset") != m.end() && !m["Asset"].empty()) {
      if (typeid(map<string, boost::any>) == m["Asset"].type()) {
        VodPackagingAsset model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Asset"]));
        asset = make_shared<VodPackagingAsset>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateVodPackagingAssetResponseBody() = default;
};
class CreateVodPackagingAssetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVodPackagingAssetResponseBody> body{};

  CreateVodPackagingAssetResponse() {}

  explicit CreateVodPackagingAssetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVodPackagingAssetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVodPackagingAssetResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVodPackagingAssetResponse() = default;
};
class CreateVodPackagingConfigurationRequestPackageConfigDrmProvider : public Darabonba::Model {
public:
  shared_ptr<string> encryptionMethod{};
  shared_ptr<string> IV{};
  shared_ptr<vector<string>> systemIds{};
  shared_ptr<string> url{};

  CreateVodPackagingConfigurationRequestPackageConfigDrmProvider() {}

  explicit CreateVodPackagingConfigurationRequestPackageConfigDrmProvider(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (encryptionMethod) {
      res["EncryptionMethod"] = boost::any(*encryptionMethod);
    }
    if (IV) {
      res["IV"] = boost::any(*IV);
    }
    if (systemIds) {
      res["SystemIds"] = boost::any(*systemIds);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EncryptionMethod") != m.end() && !m["EncryptionMethod"].empty()) {
      encryptionMethod = make_shared<string>(boost::any_cast<string>(m["EncryptionMethod"]));
    }
    if (m.find("IV") != m.end() && !m["IV"].empty()) {
      IV = make_shared<string>(boost::any_cast<string>(m["IV"]));
    }
    if (m.find("SystemIds") != m.end() && !m["SystemIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SystemIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SystemIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      systemIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~CreateVodPackagingConfigurationRequestPackageConfigDrmProvider() = default;
};
class CreateVodPackagingConfigurationRequestPackageConfigStreamSelection : public Darabonba::Model {
public:
  shared_ptr<long> maxVideoBitsPerSecond{};
  shared_ptr<long> minVideoBitsPerSecond{};
  shared_ptr<string> streamOrder{};

  CreateVodPackagingConfigurationRequestPackageConfigStreamSelection() {}

  explicit CreateVodPackagingConfigurationRequestPackageConfigStreamSelection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxVideoBitsPerSecond) {
      res["MaxVideoBitsPerSecond"] = boost::any(*maxVideoBitsPerSecond);
    }
    if (minVideoBitsPerSecond) {
      res["MinVideoBitsPerSecond"] = boost::any(*minVideoBitsPerSecond);
    }
    if (streamOrder) {
      res["StreamOrder"] = boost::any(*streamOrder);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxVideoBitsPerSecond") != m.end() && !m["MaxVideoBitsPerSecond"].empty()) {
      maxVideoBitsPerSecond = make_shared<long>(boost::any_cast<long>(m["MaxVideoBitsPerSecond"]));
    }
    if (m.find("MinVideoBitsPerSecond") != m.end() && !m["MinVideoBitsPerSecond"].empty()) {
      minVideoBitsPerSecond = make_shared<long>(boost::any_cast<long>(m["MinVideoBitsPerSecond"]));
    }
    if (m.find("StreamOrder") != m.end() && !m["StreamOrder"].empty()) {
      streamOrder = make_shared<string>(boost::any_cast<string>(m["StreamOrder"]));
    }
  }


  virtual ~CreateVodPackagingConfigurationRequestPackageConfigStreamSelection() = default;
};
class CreateVodPackagingConfigurationRequestPackageConfig : public Darabonba::Model {
public:
  shared_ptr<CreateVodPackagingConfigurationRequestPackageConfigDrmProvider> drmProvider{};
  shared_ptr<string> manifestName{};
  shared_ptr<long> segmentDuration{};
  shared_ptr<CreateVodPackagingConfigurationRequestPackageConfigStreamSelection> streamSelection{};

  CreateVodPackagingConfigurationRequestPackageConfig() {}

  explicit CreateVodPackagingConfigurationRequestPackageConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (drmProvider) {
      res["DrmProvider"] = drmProvider ? boost::any(drmProvider->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (manifestName) {
      res["ManifestName"] = boost::any(*manifestName);
    }
    if (segmentDuration) {
      res["SegmentDuration"] = boost::any(*segmentDuration);
    }
    if (streamSelection) {
      res["StreamSelection"] = streamSelection ? boost::any(streamSelection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DrmProvider") != m.end() && !m["DrmProvider"].empty()) {
      if (typeid(map<string, boost::any>) == m["DrmProvider"].type()) {
        CreateVodPackagingConfigurationRequestPackageConfigDrmProvider model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DrmProvider"]));
        drmProvider = make_shared<CreateVodPackagingConfigurationRequestPackageConfigDrmProvider>(model1);
      }
    }
    if (m.find("ManifestName") != m.end() && !m["ManifestName"].empty()) {
      manifestName = make_shared<string>(boost::any_cast<string>(m["ManifestName"]));
    }
    if (m.find("SegmentDuration") != m.end() && !m["SegmentDuration"].empty()) {
      segmentDuration = make_shared<long>(boost::any_cast<long>(m["SegmentDuration"]));
    }
    if (m.find("StreamSelection") != m.end() && !m["StreamSelection"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamSelection"].type()) {
        CreateVodPackagingConfigurationRequestPackageConfigStreamSelection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamSelection"]));
        streamSelection = make_shared<CreateVodPackagingConfigurationRequestPackageConfigStreamSelection>(model1);
      }
    }
  }


  virtual ~CreateVodPackagingConfigurationRequestPackageConfig() = default;
};
class CreateVodPackagingConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> configurationName{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<CreateVodPackagingConfigurationRequestPackageConfig> packageConfig{};
  shared_ptr<string> protocol{};

  CreateVodPackagingConfigurationRequest() {}

  explicit CreateVodPackagingConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationName) {
      res["ConfigurationName"] = boost::any(*configurationName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (packageConfig) {
      res["PackageConfig"] = packageConfig ? boost::any(packageConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationName") != m.end() && !m["ConfigurationName"].empty()) {
      configurationName = make_shared<string>(boost::any_cast<string>(m["ConfigurationName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("PackageConfig") != m.end() && !m["PackageConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["PackageConfig"].type()) {
        CreateVodPackagingConfigurationRequestPackageConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PackageConfig"]));
        packageConfig = make_shared<CreateVodPackagingConfigurationRequestPackageConfig>(model1);
      }
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~CreateVodPackagingConfigurationRequest() = default;
};
class CreateVodPackagingConfigurationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> configurationName{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<string> packageConfigShrink{};
  shared_ptr<string> protocol{};

  CreateVodPackagingConfigurationShrinkRequest() {}

  explicit CreateVodPackagingConfigurationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationName) {
      res["ConfigurationName"] = boost::any(*configurationName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (packageConfigShrink) {
      res["PackageConfig"] = boost::any(*packageConfigShrink);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationName") != m.end() && !m["ConfigurationName"].empty()) {
      configurationName = make_shared<string>(boost::any_cast<string>(m["ConfigurationName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("PackageConfig") != m.end() && !m["PackageConfig"].empty()) {
      packageConfigShrink = make_shared<string>(boost::any_cast<string>(m["PackageConfig"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~CreateVodPackagingConfigurationShrinkRequest() = default;
};
class CreateVodPackagingConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<VodPackagingConfiguration> packagingConfiguration{};
  shared_ptr<string> requestId{};

  CreateVodPackagingConfigurationResponseBody() {}

  explicit CreateVodPackagingConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packagingConfiguration) {
      res["PackagingConfiguration"] = packagingConfiguration ? boost::any(packagingConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackagingConfiguration") != m.end() && !m["PackagingConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["PackagingConfiguration"].type()) {
        VodPackagingConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PackagingConfiguration"]));
        packagingConfiguration = make_shared<VodPackagingConfiguration>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateVodPackagingConfigurationResponseBody() = default;
};
class CreateVodPackagingConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVodPackagingConfigurationResponseBody> body{};

  CreateVodPackagingConfigurationResponse() {}

  explicit CreateVodPackagingConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVodPackagingConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVodPackagingConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVodPackagingConfigurationResponse() = default;
};
class CreateVodPackagingGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};

  CreateVodPackagingGroupRequest() {}

  explicit CreateVodPackagingGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~CreateVodPackagingGroupRequest() = default;
};
class CreateVodPackagingGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<VodPackagingGroup> packagingGroup{};
  shared_ptr<string> requestId{};

  CreateVodPackagingGroupResponseBody() {}

  explicit CreateVodPackagingGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packagingGroup) {
      res["PackagingGroup"] = packagingGroup ? boost::any(packagingGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackagingGroup") != m.end() && !m["PackagingGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["PackagingGroup"].type()) {
        VodPackagingGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PackagingGroup"]));
        packagingGroup = make_shared<VodPackagingGroup>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateVodPackagingGroupResponseBody() = default;
};
class CreateVodPackagingGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVodPackagingGroupResponseBody> body{};

  CreateVodPackagingGroupResponse() {}

  explicit CreateVodPackagingGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVodPackagingGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVodPackagingGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVodPackagingGroupResponse() = default;
};
class DecryptKMSDataKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> ciphertextBlob{};

  DecryptKMSDataKeyRequest() {}

  explicit DecryptKMSDataKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ciphertextBlob) {
      res["CiphertextBlob"] = boost::any(*ciphertextBlob);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CiphertextBlob") != m.end() && !m["CiphertextBlob"].empty()) {
      ciphertextBlob = make_shared<string>(boost::any_cast<string>(m["CiphertextBlob"]));
    }
  }


  virtual ~DecryptKMSDataKeyRequest() = default;
};
class DecryptKMSDataKeyResponseBodyDataKey : public Darabonba::Model {
public:
  shared_ptr<string> keyId{};
  shared_ptr<string> plaintext{};

  DecryptKMSDataKeyResponseBodyDataKey() {}

  explicit DecryptKMSDataKeyResponseBodyDataKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyId) {
      res["KeyId"] = boost::any(*keyId);
    }
    if (plaintext) {
      res["Plaintext"] = boost::any(*plaintext);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyId") != m.end() && !m["KeyId"].empty()) {
      keyId = make_shared<string>(boost::any_cast<string>(m["KeyId"]));
    }
    if (m.find("Plaintext") != m.end() && !m["Plaintext"].empty()) {
      plaintext = make_shared<string>(boost::any_cast<string>(m["Plaintext"]));
    }
  }


  virtual ~DecryptKMSDataKeyResponseBodyDataKey() = default;
};
class DecryptKMSDataKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<DecryptKMSDataKeyResponseBodyDataKey> dataKey{};
  shared_ptr<string> requestId{};

  DecryptKMSDataKeyResponseBody() {}

  explicit DecryptKMSDataKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataKey) {
      res["DataKey"] = dataKey ? boost::any(dataKey->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataKey") != m.end() && !m["DataKey"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataKey"].type()) {
        DecryptKMSDataKeyResponseBodyDataKey model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataKey"]));
        dataKey = make_shared<DecryptKMSDataKeyResponseBodyDataKey>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DecryptKMSDataKeyResponseBody() = default;
};
class DecryptKMSDataKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DecryptKMSDataKeyResponseBody> body{};

  DecryptKMSDataKeyResponse() {}

  explicit DecryptKMSDataKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DecryptKMSDataKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DecryptKMSDataKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DecryptKMSDataKeyResponse() = default;
};
class DeleteAIAgentDialogueRequest : public Darabonba::Model {
public:
  shared_ptr<string> dialogueId{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> sessionId{};

  DeleteAIAgentDialogueRequest() {}

  explicit DeleteAIAgentDialogueRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dialogueId) {
      res["DialogueId"] = boost::any(*dialogueId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DialogueId") != m.end() && !m["DialogueId"].empty()) {
      dialogueId = make_shared<string>(boost::any_cast<string>(m["DialogueId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
  }


  virtual ~DeleteAIAgentDialogueRequest() = default;
};
class DeleteAIAgentDialogueResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAIAgentDialogueResponseBody() {}

  explicit DeleteAIAgentDialogueResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAIAgentDialogueResponseBody() = default;
};
class DeleteAIAgentDialogueResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAIAgentDialogueResponseBody> body{};

  DeleteAIAgentDialogueResponse() {}

  explicit DeleteAIAgentDialogueResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAIAgentDialogueResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAIAgentDialogueResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAIAgentDialogueResponse() = default;
};
class DeleteAdInsertionRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  DeleteAdInsertionRequest() {}

  explicit DeleteAdInsertionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DeleteAdInsertionRequest() = default;
};
class DeleteAdInsertionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAdInsertionResponseBody() {}

  explicit DeleteAdInsertionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAdInsertionResponseBody() = default;
};
class DeleteAdInsertionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAdInsertionResponseBody> body{};

  DeleteAdInsertionResponse() {}

  explicit DeleteAdInsertionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAdInsertionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAdInsertionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAdInsertionResponse() = default;
};
class DeleteAvatarTrainingJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  DeleteAvatarTrainingJobRequest() {}

  explicit DeleteAvatarTrainingJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteAvatarTrainingJobRequest() = default;
};
class DeleteAvatarTrainingJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  DeleteAvatarTrainingJobResponseBodyData() {}

  explicit DeleteAvatarTrainingJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteAvatarTrainingJobResponseBodyData() = default;
};
class DeleteAvatarTrainingJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteAvatarTrainingJobResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteAvatarTrainingJobResponseBody() {}

  explicit DeleteAvatarTrainingJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteAvatarTrainingJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteAvatarTrainingJobResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteAvatarTrainingJobResponseBody() = default;
};
class DeleteAvatarTrainingJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAvatarTrainingJobResponseBody> body{};

  DeleteAvatarTrainingJobResponse() {}

  explicit DeleteAvatarTrainingJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAvatarTrainingJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAvatarTrainingJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAvatarTrainingJobResponse() = default;
};
class DeleteCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};

  DeleteCategoryRequest() {}

  explicit DeleteCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
  }


  virtual ~DeleteCategoryRequest() = default;
};
class DeleteCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCategoryResponseBody() {}

  explicit DeleteCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCategoryResponseBody() = default;
};
class DeleteCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCategoryResponseBody> body{};

  DeleteCategoryResponse() {}

  explicit DeleteCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCategoryResponse() = default;
};
class DeleteChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};

  DeleteChannelRequest() {}

  explicit DeleteChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
  }


  virtual ~DeleteChannelRequest() = default;
};
class DeleteChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteChannelResponseBody() {}

  explicit DeleteChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteChannelResponseBody() = default;
};
class DeleteChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteChannelResponseBody> body{};

  DeleteChannelResponse() {}

  explicit DeleteChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteChannelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteChannelResponse() = default;
};
class DeleteCustomTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  DeleteCustomTemplateRequest() {}

  explicit DeleteCustomTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteCustomTemplateRequest() = default;
};
class DeleteCustomTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteCustomTemplateResponseBody() {}

  explicit DeleteCustomTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteCustomTemplateResponseBody() = default;
};
class DeleteCustomTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomTemplateResponseBody> body{};

  DeleteCustomTemplateResponse() {}

  explicit DeleteCustomTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomTemplateResponse() = default;
};
class DeleteCustomizedVoiceJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  DeleteCustomizedVoiceJobRequest() {}

  explicit DeleteCustomizedVoiceJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteCustomizedVoiceJobRequest() = default;
};
class DeleteCustomizedVoiceJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteCustomizedVoiceJobResponseBody() {}

  explicit DeleteCustomizedVoiceJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteCustomizedVoiceJobResponseBody() = default;
};
class DeleteCustomizedVoiceJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomizedVoiceJobResponseBody> body{};

  DeleteCustomizedVoiceJobResponse() {}

  explicit DeleteCustomizedVoiceJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomizedVoiceJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomizedVoiceJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomizedVoiceJobResponse() = default;
};
class DeleteDNADBRequest : public Darabonba::Model {
public:
  shared_ptr<string> DBId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteDNADBRequest() {}

  explicit DeleteDNADBRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBId) {
      res["DBId"] = boost::any(*DBId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBId") != m.end() && !m["DBId"].empty()) {
      DBId = make_shared<string>(boost::any_cast<string>(m["DBId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteDNADBRequest() = default;
};
class DeleteDNADBResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDNADBResponseBody() {}

  explicit DeleteDNADBResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDNADBResponseBody() = default;
};
class DeleteDNADBResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDNADBResponseBody> body{};

  DeleteDNADBResponse() {}

  explicit DeleteDNADBResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDNADBResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDNADBResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDNADBResponse() = default;
};
class DeleteDNAFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> DBId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> primaryKeys{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteDNAFilesRequest() {}

  explicit DeleteDNAFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBId) {
      res["DBId"] = boost::any(*DBId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBId") != m.end() && !m["DBId"].empty()) {
      DBId = make_shared<string>(boost::any_cast<string>(m["DBId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      primaryKeys = make_shared<string>(boost::any_cast<string>(m["PrimaryKeys"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteDNAFilesRequest() = default;
};
class DeleteDNAFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDNAFilesResponseBody() {}

  explicit DeleteDNAFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDNAFilesResponseBody() = default;
};
class DeleteDNAFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDNAFilesResponseBody> body{};

  DeleteDNAFilesResponse() {}

  explicit DeleteDNAFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDNAFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDNAFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDNAFilesResponse() = default;
};
class DeleteEditingProjectMaterialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> materialIds{};
  shared_ptr<string> materialType{};
  shared_ptr<string> projectId{};

  DeleteEditingProjectMaterialsRequest() {}

  explicit DeleteEditingProjectMaterialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (materialIds) {
      res["MaterialIds"] = boost::any(*materialIds);
    }
    if (materialType) {
      res["MaterialType"] = boost::any(*materialType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaterialIds") != m.end() && !m["MaterialIds"].empty()) {
      materialIds = make_shared<string>(boost::any_cast<string>(m["MaterialIds"]));
    }
    if (m.find("MaterialType") != m.end() && !m["MaterialType"].empty()) {
      materialType = make_shared<string>(boost::any_cast<string>(m["MaterialType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DeleteEditingProjectMaterialsRequest() = default;
};
class DeleteEditingProjectMaterialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEditingProjectMaterialsResponseBody() {}

  explicit DeleteEditingProjectMaterialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEditingProjectMaterialsResponseBody() = default;
};
class DeleteEditingProjectMaterialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEditingProjectMaterialsResponseBody> body{};

  DeleteEditingProjectMaterialsResponse() {}

  explicit DeleteEditingProjectMaterialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEditingProjectMaterialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEditingProjectMaterialsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEditingProjectMaterialsResponse() = default;
};
class DeleteEditingProjectsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectIds{};

  DeleteEditingProjectsRequest() {}

  explicit DeleteEditingProjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectIds) {
      res["ProjectIds"] = boost::any(*projectIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectIds") != m.end() && !m["ProjectIds"].empty()) {
      projectIds = make_shared<string>(boost::any_cast<string>(m["ProjectIds"]));
    }
  }


  virtual ~DeleteEditingProjectsRequest() = default;
};
class DeleteEditingProjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEditingProjectsResponseBody() {}

  explicit DeleteEditingProjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEditingProjectsResponseBody() = default;
};
class DeleteEditingProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEditingProjectsResponseBody> body{};

  DeleteEditingProjectsResponse() {}

  explicit DeleteEditingProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEditingProjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEditingProjectsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEditingProjectsResponse() = default;
};
class DeleteHotwordLibraryRequest : public Darabonba::Model {
public:
  shared_ptr<string> hotwordLibraryId{};

  DeleteHotwordLibraryRequest() {}

  explicit DeleteHotwordLibraryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotwordLibraryId) {
      res["HotwordLibraryId"] = boost::any(*hotwordLibraryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HotwordLibraryId") != m.end() && !m["HotwordLibraryId"].empty()) {
      hotwordLibraryId = make_shared<string>(boost::any_cast<string>(m["HotwordLibraryId"]));
    }
  }


  virtual ~DeleteHotwordLibraryRequest() = default;
};
class DeleteHotwordLibraryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteHotwordLibraryResponseBody() {}

  explicit DeleteHotwordLibraryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteHotwordLibraryResponseBody() = default;
};
class DeleteHotwordLibraryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteHotwordLibraryResponseBody> body{};

  DeleteHotwordLibraryResponse() {}

  explicit DeleteHotwordLibraryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHotwordLibraryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHotwordLibraryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHotwordLibraryResponse() = default;
};
class DeleteLivePackageChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> groupName{};

  DeleteLivePackageChannelRequest() {}

  explicit DeleteLivePackageChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~DeleteLivePackageChannelRequest() = default;
};
class DeleteLivePackageChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLivePackageChannelResponseBody() {}

  explicit DeleteLivePackageChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLivePackageChannelResponseBody() = default;
};
class DeleteLivePackageChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLivePackageChannelResponseBody> body{};

  DeleteLivePackageChannelResponse() {}

  explicit DeleteLivePackageChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLivePackageChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLivePackageChannelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLivePackageChannelResponse() = default;
};
class DeleteLivePackageChannelGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};

  DeleteLivePackageChannelGroupRequest() {}

  explicit DeleteLivePackageChannelGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~DeleteLivePackageChannelGroupRequest() = default;
};
class DeleteLivePackageChannelGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLivePackageChannelGroupResponseBody() {}

  explicit DeleteLivePackageChannelGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLivePackageChannelGroupResponseBody() = default;
};
class DeleteLivePackageChannelGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLivePackageChannelGroupResponseBody> body{};

  DeleteLivePackageChannelGroupResponse() {}

  explicit DeleteLivePackageChannelGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLivePackageChannelGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLivePackageChannelGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLivePackageChannelGroupResponse() = default;
};
class DeleteLivePackageOriginEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> groupName{};

  DeleteLivePackageOriginEndpointRequest() {}

  explicit DeleteLivePackageOriginEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~DeleteLivePackageOriginEndpointRequest() = default;
};
class DeleteLivePackageOriginEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLivePackageOriginEndpointResponseBody() {}

  explicit DeleteLivePackageOriginEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLivePackageOriginEndpointResponseBody() = default;
};
class DeleteLivePackageOriginEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLivePackageOriginEndpointResponseBody> body{};

  DeleteLivePackageOriginEndpointResponse() {}

  explicit DeleteLivePackageOriginEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLivePackageOriginEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLivePackageOriginEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLivePackageOriginEndpointResponse() = default;
};
class DeleteLiveRecordFilesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> recordIds{};
  shared_ptr<bool> removeFile{};

  DeleteLiveRecordFilesRequest() {}

  explicit DeleteLiveRecordFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordIds) {
      res["RecordIds"] = boost::any(*recordIds);
    }
    if (removeFile) {
      res["RemoveFile"] = boost::any(*removeFile);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordIds") != m.end() && !m["RecordIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RemoveFile") != m.end() && !m["RemoveFile"].empty()) {
      removeFile = make_shared<bool>(boost::any_cast<bool>(m["RemoveFile"]));
    }
  }


  virtual ~DeleteLiveRecordFilesRequest() = default;
};
class DeleteLiveRecordFilesResponseBodyDeleteFileInfoList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> recordId{};

  DeleteLiveRecordFilesResponseBodyDeleteFileInfoList() {}

  explicit DeleteLiveRecordFilesResponseBodyDeleteFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
  }


  virtual ~DeleteLiveRecordFilesResponseBodyDeleteFileInfoList() = default;
};
class DeleteLiveRecordFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteLiveRecordFilesResponseBodyDeleteFileInfoList>> deleteFileInfoList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteLiveRecordFilesResponseBody() {}

  explicit DeleteLiveRecordFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteFileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*deleteFileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeleteFileInfoList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteFileInfoList") != m.end() && !m["DeleteFileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeleteFileInfoList"].type()) {
        vector<DeleteLiveRecordFilesResponseBodyDeleteFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeleteFileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteLiveRecordFilesResponseBodyDeleteFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deleteFileInfoList = make_shared<vector<DeleteLiveRecordFilesResponseBodyDeleteFileInfoList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveRecordFilesResponseBody() = default;
};
class DeleteLiveRecordFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveRecordFilesResponseBody> body{};

  DeleteLiveRecordFilesResponse() {}

  explicit DeleteLiveRecordFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveRecordFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveRecordFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveRecordFilesResponse() = default;
};
class DeleteLiveRecordTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  DeleteLiveRecordTemplateRequest() {}

  explicit DeleteLiveRecordTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteLiveRecordTemplateRequest() = default;
};
class DeleteLiveRecordTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveRecordTemplateResponseBody() {}

  explicit DeleteLiveRecordTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveRecordTemplateResponseBody() = default;
};
class DeleteLiveRecordTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveRecordTemplateResponseBody> body{};

  DeleteLiveRecordTemplateResponse() {}

  explicit DeleteLiveRecordTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveRecordTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveRecordTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveRecordTemplateResponse() = default;
};
class DeleteLiveSnapshotFilesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> createTimestampList{};
  shared_ptr<bool> deleteOriginalFile{};
  shared_ptr<string> jobId{};

  DeleteLiveSnapshotFilesRequest() {}

  explicit DeleteLiveSnapshotFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimestampList) {
      res["CreateTimestampList"] = boost::any(*createTimestampList);
    }
    if (deleteOriginalFile) {
      res["DeleteOriginalFile"] = boost::any(*deleteOriginalFile);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimestampList") != m.end() && !m["CreateTimestampList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CreateTimestampList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CreateTimestampList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      createTimestampList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("DeleteOriginalFile") != m.end() && !m["DeleteOriginalFile"].empty()) {
      deleteOriginalFile = make_shared<bool>(boost::any_cast<bool>(m["DeleteOriginalFile"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteLiveSnapshotFilesRequest() = default;
};
class DeleteLiveSnapshotFilesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> createTimestampListShrink{};
  shared_ptr<bool> deleteOriginalFile{};
  shared_ptr<string> jobId{};

  DeleteLiveSnapshotFilesShrinkRequest() {}

  explicit DeleteLiveSnapshotFilesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimestampListShrink) {
      res["CreateTimestampList"] = boost::any(*createTimestampListShrink);
    }
    if (deleteOriginalFile) {
      res["DeleteOriginalFile"] = boost::any(*deleteOriginalFile);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimestampList") != m.end() && !m["CreateTimestampList"].empty()) {
      createTimestampListShrink = make_shared<string>(boost::any_cast<string>(m["CreateTimestampList"]));
    }
    if (m.find("DeleteOriginalFile") != m.end() && !m["DeleteOriginalFile"].empty()) {
      deleteOriginalFile = make_shared<bool>(boost::any_cast<bool>(m["DeleteOriginalFile"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteLiveSnapshotFilesShrinkRequest() = default;
};
class DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList : public Darabonba::Model {
public:
  shared_ptr<long> createTimestamp{};
  shared_ptr<string> result{};

  DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList() {}

  explicit DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList() = default;
};
class DeleteLiveSnapshotFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList>> deleteFileResultList{};
  shared_ptr<string> requestId{};

  DeleteLiveSnapshotFilesResponseBody() {}

  explicit DeleteLiveSnapshotFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteFileResultList) {
      vector<boost::any> temp1;
      for(auto item1:*deleteFileResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeleteFileResultList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteFileResultList") != m.end() && !m["DeleteFileResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeleteFileResultList"].type()) {
        vector<DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeleteFileResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deleteFileResultList = make_shared<vector<DeleteLiveSnapshotFilesResponseBodyDeleteFileResultList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveSnapshotFilesResponseBody() = default;
};
class DeleteLiveSnapshotFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveSnapshotFilesResponseBody> body{};

  DeleteLiveSnapshotFilesResponse() {}

  explicit DeleteLiveSnapshotFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveSnapshotFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveSnapshotFilesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveSnapshotFilesResponse() = default;
};
class DeleteLiveSnapshotTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  DeleteLiveSnapshotTemplateRequest() {}

  explicit DeleteLiveSnapshotTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteLiveSnapshotTemplateRequest() = default;
};
class DeleteLiveSnapshotTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveSnapshotTemplateResponseBody() {}

  explicit DeleteLiveSnapshotTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveSnapshotTemplateResponseBody() = default;
};
class DeleteLiveSnapshotTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveSnapshotTemplateResponseBody> body{};

  DeleteLiveSnapshotTemplateResponse() {}

  explicit DeleteLiveSnapshotTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveSnapshotTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveSnapshotTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveSnapshotTemplateResponse() = default;
};
class DeleteLiveTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  DeleteLiveTranscodeJobRequest() {}

  explicit DeleteLiveTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteLiveTranscodeJobRequest() = default;
};
class DeleteLiveTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveTranscodeJobResponseBody() {}

  explicit DeleteLiveTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveTranscodeJobResponseBody() = default;
};
class DeleteLiveTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveTranscodeJobResponseBody> body{};

  DeleteLiveTranscodeJobResponse() {}

  explicit DeleteLiveTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveTranscodeJobResponse() = default;
};
class DeleteLiveTranscodeTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  DeleteLiveTranscodeTemplateRequest() {}

  explicit DeleteLiveTranscodeTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~DeleteLiveTranscodeTemplateRequest() = default;
};
class DeleteLiveTranscodeTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLiveTranscodeTemplateResponseBody() {}

  explicit DeleteLiveTranscodeTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLiveTranscodeTemplateResponseBody() = default;
};
class DeleteLiveTranscodeTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLiveTranscodeTemplateResponseBody> body{};

  DeleteLiveTranscodeTemplateResponse() {}

  explicit DeleteLiveTranscodeTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLiveTranscodeTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLiveTranscodeTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLiveTranscodeTemplateResponse() = default;
};
class DeleteMediaConnectFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};

  DeleteMediaConnectFlowRequest() {}

  explicit DeleteMediaConnectFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
  }


  virtual ~DeleteMediaConnectFlowRequest() = default;
};
class DeleteMediaConnectFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};

  DeleteMediaConnectFlowResponseBody() {}

  explicit DeleteMediaConnectFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
  }


  virtual ~DeleteMediaConnectFlowResponseBody() = default;
};
class DeleteMediaConnectFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMediaConnectFlowResponseBody> body{};

  DeleteMediaConnectFlowResponse() {}

  explicit DeleteMediaConnectFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaConnectFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaConnectFlowResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaConnectFlowResponse() = default;
};
class DeleteMediaConnectFlowInputRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};
  shared_ptr<string> inputName{};

  DeleteMediaConnectFlowInputRequest() {}

  explicit DeleteMediaConnectFlowInputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (inputName) {
      res["InputName"] = boost::any(*inputName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("InputName") != m.end() && !m["InputName"].empty()) {
      inputName = make_shared<string>(boost::any_cast<string>(m["InputName"]));
    }
  }


  virtual ~DeleteMediaConnectFlowInputRequest() = default;
};
class DeleteMediaConnectFlowInputResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};

  DeleteMediaConnectFlowInputResponseBody() {}

  explicit DeleteMediaConnectFlowInputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
  }


  virtual ~DeleteMediaConnectFlowInputResponseBody() = default;
};
class DeleteMediaConnectFlowInputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMediaConnectFlowInputResponseBody> body{};

  DeleteMediaConnectFlowInputResponse() {}

  explicit DeleteMediaConnectFlowInputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaConnectFlowInputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaConnectFlowInputResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaConnectFlowInputResponse() = default;
};
class DeleteMediaConnectFlowOutputRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};
  shared_ptr<string> outputName{};

  DeleteMediaConnectFlowOutputRequest() {}

  explicit DeleteMediaConnectFlowOutputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (outputName) {
      res["OutputName"] = boost::any(*outputName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("OutputName") != m.end() && !m["OutputName"].empty()) {
      outputName = make_shared<string>(boost::any_cast<string>(m["OutputName"]));
    }
  }


  virtual ~DeleteMediaConnectFlowOutputRequest() = default;
};
class DeleteMediaConnectFlowOutputResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};

  DeleteMediaConnectFlowOutputResponseBody() {}

  explicit DeleteMediaConnectFlowOutputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
  }


  virtual ~DeleteMediaConnectFlowOutputResponseBody() = default;
};
class DeleteMediaConnectFlowOutputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMediaConnectFlowOutputResponseBody> body{};

  DeleteMediaConnectFlowOutputResponse() {}

  explicit DeleteMediaConnectFlowOutputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaConnectFlowOutputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaConnectFlowOutputResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaConnectFlowOutputResponse() = default;
};
class DeleteMediaFromSearchLibRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> msgBody{};
  shared_ptr<string> searchLibName{};

  DeleteMediaFromSearchLibRequest() {}

  explicit DeleteMediaFromSearchLibRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (msgBody) {
      res["MsgBody"] = boost::any(*msgBody);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MsgBody") != m.end() && !m["MsgBody"].empty()) {
      msgBody = make_shared<string>(boost::any_cast<string>(m["MsgBody"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
  }


  virtual ~DeleteMediaFromSearchLibRequest() = default;
};
class DeleteMediaFromSearchLibResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DeleteMediaFromSearchLibResponseBody() {}

  explicit DeleteMediaFromSearchLibResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DeleteMediaFromSearchLibResponseBody() = default;
};
class DeleteMediaFromSearchLibResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMediaFromSearchLibResponseBody> body{};

  DeleteMediaFromSearchLibResponse() {}

  explicit DeleteMediaFromSearchLibResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaFromSearchLibResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaFromSearchLibResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaFromSearchLibResponse() = default;
};
class DeleteMediaInfosRequest : public Darabonba::Model {
public:
  shared_ptr<bool> deletePhysicalFiles{};
  shared_ptr<string> inputURLs{};
  shared_ptr<string> mediaIds{};

  DeleteMediaInfosRequest() {}

  explicit DeleteMediaInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deletePhysicalFiles) {
      res["DeletePhysicalFiles"] = boost::any(*deletePhysicalFiles);
    }
    if (inputURLs) {
      res["InputURLs"] = boost::any(*inputURLs);
    }
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeletePhysicalFiles") != m.end() && !m["DeletePhysicalFiles"].empty()) {
      deletePhysicalFiles = make_shared<bool>(boost::any_cast<bool>(m["DeletePhysicalFiles"]));
    }
    if (m.find("InputURLs") != m.end() && !m["InputURLs"].empty()) {
      inputURLs = make_shared<string>(boost::any_cast<string>(m["InputURLs"]));
    }
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
  }


  virtual ~DeleteMediaInfosRequest() = default;
};
class DeleteMediaInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> forbiddenList{};
  shared_ptr<vector<string>> ignoredList{};
  shared_ptr<string> requestId{};

  DeleteMediaInfosResponseBody() {}

  explicit DeleteMediaInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forbiddenList) {
      res["ForbiddenList"] = boost::any(*forbiddenList);
    }
    if (ignoredList) {
      res["IgnoredList"] = boost::any(*ignoredList);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForbiddenList") != m.end() && !m["ForbiddenList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ForbiddenList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ForbiddenList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      forbiddenList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IgnoredList") != m.end() && !m["IgnoredList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IgnoredList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IgnoredList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ignoredList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMediaInfosResponseBody() = default;
};
class DeleteMediaInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMediaInfosResponseBody> body{};

  DeleteMediaInfosResponse() {}

  explicit DeleteMediaInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaInfosResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaInfosResponse() = default;
};
class DeleteMediaLiveChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};

  DeleteMediaLiveChannelRequest() {}

  explicit DeleteMediaLiveChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
  }


  virtual ~DeleteMediaLiveChannelRequest() = default;
};
class DeleteMediaLiveChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMediaLiveChannelResponseBody() {}

  explicit DeleteMediaLiveChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMediaLiveChannelResponseBody() = default;
};
class DeleteMediaLiveChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMediaLiveChannelResponseBody> body{};

  DeleteMediaLiveChannelResponse() {}

  explicit DeleteMediaLiveChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaLiveChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaLiveChannelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaLiveChannelResponse() = default;
};
class DeleteMediaLiveInputRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputId{};

  DeleteMediaLiveInputRequest() {}

  explicit DeleteMediaLiveInputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputId) {
      res["InputId"] = boost::any(*inputId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputId") != m.end() && !m["InputId"].empty()) {
      inputId = make_shared<string>(boost::any_cast<string>(m["InputId"]));
    }
  }


  virtual ~DeleteMediaLiveInputRequest() = default;
};
class DeleteMediaLiveInputResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMediaLiveInputResponseBody() {}

  explicit DeleteMediaLiveInputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMediaLiveInputResponseBody() = default;
};
class DeleteMediaLiveInputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMediaLiveInputResponseBody> body{};

  DeleteMediaLiveInputResponse() {}

  explicit DeleteMediaLiveInputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaLiveInputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaLiveInputResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaLiveInputResponse() = default;
};
class DeleteMediaLiveInputSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityGroupId{};

  DeleteMediaLiveInputSecurityGroupRequest() {}

  explicit DeleteMediaLiveInputSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~DeleteMediaLiveInputSecurityGroupRequest() = default;
};
class DeleteMediaLiveInputSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMediaLiveInputSecurityGroupResponseBody() {}

  explicit DeleteMediaLiveInputSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMediaLiveInputSecurityGroupResponseBody() = default;
};
class DeleteMediaLiveInputSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMediaLiveInputSecurityGroupResponseBody> body{};

  DeleteMediaLiveInputSecurityGroupResponse() {}

  explicit DeleteMediaLiveInputSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaLiveInputSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaLiveInputSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaLiveInputSecurityGroupResponse() = default;
};
class DeleteMediaMarksRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaMarkIds{};

  DeleteMediaMarksRequest() {}

  explicit DeleteMediaMarksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaMarkIds) {
      res["MediaMarkIds"] = boost::any(*mediaMarkIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaMarkIds") != m.end() && !m["MediaMarkIds"].empty()) {
      mediaMarkIds = make_shared<string>(boost::any_cast<string>(m["MediaMarkIds"]));
    }
  }


  virtual ~DeleteMediaMarksRequest() = default;
};
class DeleteMediaMarksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaMarkIds{};
  shared_ptr<string> requestId{};

  DeleteMediaMarksResponseBody() {}

  explicit DeleteMediaMarksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaMarkIds) {
      res["MediaMarkIds"] = boost::any(*mediaMarkIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaMarkIds") != m.end() && !m["MediaMarkIds"].empty()) {
      mediaMarkIds = make_shared<string>(boost::any_cast<string>(m["MediaMarkIds"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMediaMarksResponseBody() = default;
};
class DeleteMediaMarksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMediaMarksResponseBody> body{};

  DeleteMediaMarksResponse() {}

  explicit DeleteMediaMarksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaMarksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaMarksResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaMarksResponse() = default;
};
class DeletePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};

  DeletePipelineRequest() {}

  explicit DeletePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~DeletePipelineRequest() = default;
};
class DeletePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeletePipelineResponseBody() {}

  explicit DeletePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeletePipelineResponseBody() = default;
};
class DeletePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePipelineResponseBody> body{};

  DeletePipelineResponse() {}

  explicit DeletePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePipelineResponse() = default;
};
class DeletePlayInfoRequest : public Darabonba::Model {
public:
  shared_ptr<bool> deletePhysicalFiles{};
  shared_ptr<string> fileURLs{};
  shared_ptr<string> mediaId{};

  DeletePlayInfoRequest() {}

  explicit DeletePlayInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deletePhysicalFiles) {
      res["DeletePhysicalFiles"] = boost::any(*deletePhysicalFiles);
    }
    if (fileURLs) {
      res["FileURLs"] = boost::any(*fileURLs);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeletePhysicalFiles") != m.end() && !m["DeletePhysicalFiles"].empty()) {
      deletePhysicalFiles = make_shared<bool>(boost::any_cast<bool>(m["DeletePhysicalFiles"]));
    }
    if (m.find("FileURLs") != m.end() && !m["FileURLs"].empty()) {
      fileURLs = make_shared<string>(boost::any_cast<string>(m["FileURLs"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~DeletePlayInfoRequest() = default;
};
class DeletePlayInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> forbiddenList{};
  shared_ptr<vector<string>> ignoredList{};
  shared_ptr<string> requestId{};

  DeletePlayInfoResponseBody() {}

  explicit DeletePlayInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forbiddenList) {
      res["ForbiddenList"] = boost::any(*forbiddenList);
    }
    if (ignoredList) {
      res["IgnoredList"] = boost::any(*ignoredList);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForbiddenList") != m.end() && !m["ForbiddenList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ForbiddenList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ForbiddenList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      forbiddenList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IgnoredList") != m.end() && !m["IgnoredList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IgnoredList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IgnoredList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ignoredList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePlayInfoResponseBody() = default;
};
class DeletePlayInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePlayInfoResponseBody> body{};

  DeletePlayInfoResponse() {}

  explicit DeletePlayInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePlayInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePlayInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePlayInfoResponse() = default;
};
class DeleteProgramRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> programName{};

  DeleteProgramRequest() {}

  explicit DeleteProgramRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
  }


  virtual ~DeleteProgramRequest() = default;
};
class DeleteProgramResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteProgramResponseBody() {}

  explicit DeleteProgramResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteProgramResponseBody() = default;
};
class DeleteProgramResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProgramResponseBody> body{};

  DeleteProgramResponse() {}

  explicit DeleteProgramResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProgramResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProgramResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProgramResponse() = default;
};
class DeleteRecognitionEntityRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> entityId{};
  shared_ptr<string> libId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteRecognitionEntityRequest() {}

  explicit DeleteRecognitionEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (libId) {
      res["LibId"] = boost::any(*libId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("LibId") != m.end() && !m["LibId"].empty()) {
      libId = make_shared<string>(boost::any_cast<string>(m["LibId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteRecognitionEntityRequest() = default;
};
class DeleteRecognitionEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRecognitionEntityResponseBody() {}

  explicit DeleteRecognitionEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRecognitionEntityResponseBody() = default;
};
class DeleteRecognitionEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRecognitionEntityResponseBody> body{};

  DeleteRecognitionEntityResponse() {}

  explicit DeleteRecognitionEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRecognitionEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRecognitionEntityResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRecognitionEntityResponse() = default;
};
class DeleteRecognitionLibRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> libId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DeleteRecognitionLibRequest() {}

  explicit DeleteRecognitionLibRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (libId) {
      res["LibId"] = boost::any(*libId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("LibId") != m.end() && !m["LibId"].empty()) {
      libId = make_shared<string>(boost::any_cast<string>(m["LibId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteRecognitionLibRequest() = default;
};
class DeleteRecognitionLibResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRecognitionLibResponseBody() {}

  explicit DeleteRecognitionLibResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRecognitionLibResponseBody() = default;
};
class DeleteRecognitionLibResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRecognitionLibResponseBody> body{};

  DeleteRecognitionLibResponse() {}

  explicit DeleteRecognitionLibResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRecognitionLibResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRecognitionLibResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRecognitionLibResponse() = default;
};
class DeleteRecognitionSampleRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> entityId{};
  shared_ptr<string> libId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> sampleId{};

  DeleteRecognitionSampleRequest() {}

  explicit DeleteRecognitionSampleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (libId) {
      res["LibId"] = boost::any(*libId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (sampleId) {
      res["SampleId"] = boost::any(*sampleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("LibId") != m.end() && !m["LibId"].empty()) {
      libId = make_shared<string>(boost::any_cast<string>(m["LibId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SampleId") != m.end() && !m["SampleId"].empty()) {
      sampleId = make_shared<string>(boost::any_cast<string>(m["SampleId"]));
    }
  }


  virtual ~DeleteRecognitionSampleRequest() = default;
};
class DeleteRecognitionSampleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRecognitionSampleResponseBody() {}

  explicit DeleteRecognitionSampleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRecognitionSampleResponseBody() = default;
};
class DeleteRecognitionSampleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRecognitionSampleResponseBody> body{};

  DeleteRecognitionSampleResponse() {}

  explicit DeleteRecognitionSampleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRecognitionSampleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRecognitionSampleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRecognitionSampleResponse() = default;
};
class DeleteSmartJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  DeleteSmartJobRequest() {}

  explicit DeleteSmartJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DeleteSmartJobRequest() = default;
};
class DeleteSmartJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSmartJobResponseBody() {}

  explicit DeleteSmartJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSmartJobResponseBody() = default;
};
class DeleteSmartJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSmartJobResponseBody> body{};

  DeleteSmartJobResponse() {}

  explicit DeleteSmartJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSmartJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSmartJobResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSmartJobResponse() = default;
};
class DeleteSourceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> softDelete{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceType{};

  DeleteSourceRequest() {}

  explicit DeleteSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (softDelete) {
      res["SoftDelete"] = boost::any(*softDelete);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SoftDelete") != m.end() && !m["SoftDelete"].empty()) {
      softDelete = make_shared<bool>(boost::any_cast<bool>(m["SoftDelete"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~DeleteSourceRequest() = default;
};
class DeleteSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteSourceResponseBody() {}

  explicit DeleteSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSourceResponseBody() = default;
};
class DeleteSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSourceResponseBody> body{};

  DeleteSourceResponse() {}

  explicit DeleteSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSourceResponse() = default;
};
class DeleteSourceLocationRequest : public Darabonba::Model {
public:
  shared_ptr<bool> softDelete{};
  shared_ptr<string> sourceLocationName{};

  DeleteSourceLocationRequest() {}

  explicit DeleteSourceLocationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (softDelete) {
      res["SoftDelete"] = boost::any(*softDelete);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SoftDelete") != m.end() && !m["SoftDelete"].empty()) {
      softDelete = make_shared<bool>(boost::any_cast<bool>(m["SoftDelete"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
  }


  virtual ~DeleteSourceLocationRequest() = default;
};
class DeleteSourceLocationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteSourceLocationResponseBody() {}

  explicit DeleteSourceLocationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSourceLocationResponseBody() = default;
};
class DeleteSourceLocationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSourceLocationResponseBody> body{};

  DeleteSourceLocationResponse() {}

  explicit DeleteSourceLocationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSourceLocationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSourceLocationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSourceLocationResponse() = default;
};
class DeleteTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateIds{};

  DeleteTemplateRequest() {}

  explicit DeleteTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateIds) {
      res["TemplateIds"] = boost::any(*templateIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateIds") != m.end() && !m["TemplateIds"].empty()) {
      templateIds = make_shared<string>(boost::any_cast<string>(m["TemplateIds"]));
    }
  }


  virtual ~DeleteTemplateRequest() = default;
};
class DeleteTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTemplateResponseBody() {}

  explicit DeleteTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTemplateResponseBody() = default;
};
class DeleteTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTemplateResponseBody> body{};

  DeleteTemplateResponse() {}

  explicit DeleteTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTemplateResponse() = default;
};
class DeleteVodPackagingAssetRequest : public Darabonba::Model {
public:
  shared_ptr<string> assetName{};

  DeleteVodPackagingAssetRequest() {}

  explicit DeleteVodPackagingAssetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetName) {
      res["AssetName"] = boost::any(*assetName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetName") != m.end() && !m["AssetName"].empty()) {
      assetName = make_shared<string>(boost::any_cast<string>(m["AssetName"]));
    }
  }


  virtual ~DeleteVodPackagingAssetRequest() = default;
};
class DeleteVodPackagingAssetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVodPackagingAssetResponseBody() {}

  explicit DeleteVodPackagingAssetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVodPackagingAssetResponseBody() = default;
};
class DeleteVodPackagingAssetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVodPackagingAssetResponseBody> body{};

  DeleteVodPackagingAssetResponse() {}

  explicit DeleteVodPackagingAssetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVodPackagingAssetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVodPackagingAssetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVodPackagingAssetResponse() = default;
};
class DeleteVodPackagingConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> configurationName{};

  DeleteVodPackagingConfigurationRequest() {}

  explicit DeleteVodPackagingConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationName) {
      res["ConfigurationName"] = boost::any(*configurationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationName") != m.end() && !m["ConfigurationName"].empty()) {
      configurationName = make_shared<string>(boost::any_cast<string>(m["ConfigurationName"]));
    }
  }


  virtual ~DeleteVodPackagingConfigurationRequest() = default;
};
class DeleteVodPackagingConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVodPackagingConfigurationResponseBody() {}

  explicit DeleteVodPackagingConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVodPackagingConfigurationResponseBody() = default;
};
class DeleteVodPackagingConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVodPackagingConfigurationResponseBody> body{};

  DeleteVodPackagingConfigurationResponse() {}

  explicit DeleteVodPackagingConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVodPackagingConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVodPackagingConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVodPackagingConfigurationResponse() = default;
};
class DeleteVodPackagingGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};

  DeleteVodPackagingGroupRequest() {}

  explicit DeleteVodPackagingGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~DeleteVodPackagingGroupRequest() = default;
};
class DeleteVodPackagingGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVodPackagingGroupResponseBody() {}

  explicit DeleteVodPackagingGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVodPackagingGroupResponseBody() = default;
};
class DeleteVodPackagingGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVodPackagingGroupResponseBody> body{};

  DeleteVodPackagingGroupResponse() {}

  explicit DeleteVodPackagingGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVodPackagingGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVodPackagingGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVodPackagingGroupResponse() = default;
};
class DescribeAIAgentInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeAIAgentInstanceRequest() {}

  explicit DescribeAIAgentInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeAIAgentInstanceRequest() = default;
};
class DescribeAIAgentInstanceResponseBodyInstance : public Darabonba::Model {
public:
  shared_ptr<AIAgentConfig> agentConfig{};
  shared_ptr<string> callLogUrl{};
  shared_ptr<AIAgentRuntimeConfig> runtimeConfig{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> status{};
  shared_ptr<AIAgentTemplateConfig> templateConfig{};
  shared_ptr<string> userData{};

  DescribeAIAgentInstanceResponseBodyInstance() {}

  explicit DescribeAIAgentInstanceResponseBodyInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentConfig) {
      res["AgentConfig"] = agentConfig ? boost::any(agentConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (callLogUrl) {
      res["CallLogUrl"] = boost::any(*callLogUrl);
    }
    if (runtimeConfig) {
      res["RuntimeConfig"] = runtimeConfig ? boost::any(runtimeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentConfig") != m.end() && !m["AgentConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AgentConfig"].type()) {
        AIAgentConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AgentConfig"]));
        agentConfig = make_shared<AIAgentConfig>(model1);
      }
    }
    if (m.find("CallLogUrl") != m.end() && !m["CallLogUrl"].empty()) {
      callLogUrl = make_shared<string>(boost::any_cast<string>(m["CallLogUrl"]));
    }
    if (m.find("RuntimeConfig") != m.end() && !m["RuntimeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeConfig"].type()) {
        AIAgentRuntimeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeConfig"]));
        runtimeConfig = make_shared<AIAgentRuntimeConfig>(model1);
      }
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        AIAgentTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<AIAgentTemplateConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~DescribeAIAgentInstanceResponseBodyInstance() = default;
};
class DescribeAIAgentInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAIAgentInstanceResponseBodyInstance> instance{};
  shared_ptr<string> requestId{};

  DescribeAIAgentInstanceResponseBody() {}

  explicit DescribeAIAgentInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      res["Instance"] = instance ? boost::any(instance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instance"].type()) {
        DescribeAIAgentInstanceResponseBodyInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instance"]));
        instance = make_shared<DescribeAIAgentInstanceResponseBodyInstance>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAIAgentInstanceResponseBody() = default;
};
class DescribeAIAgentInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAIAgentInstanceResponseBody> body{};

  DescribeAIAgentInstanceResponse() {}

  explicit DescribeAIAgentInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAIAgentInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAIAgentInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAIAgentInstanceResponse() = default;
};
class DescribeMeterImsEditUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<long> interval{};
  shared_ptr<string> region{};
  shared_ptr<long> startTs{};

  DescribeMeterImsEditUsageRequest() {}

  explicit DescribeMeterImsEditUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterImsEditUsageRequest() = default;
};
class DescribeMeterImsEditUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> profile{};
  shared_ptr<long> time{};

  DescribeMeterImsEditUsageResponseBodyData() {}

  explicit DescribeMeterImsEditUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeMeterImsEditUsageResponseBodyData() = default;
};
class DescribeMeterImsEditUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterImsEditUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterImsEditUsageResponseBody() {}

  explicit DescribeMeterImsEditUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterImsEditUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterImsEditUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterImsEditUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterImsEditUsageResponseBody() = default;
};
class DescribeMeterImsEditUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterImsEditUsageResponseBody> body{};

  DescribeMeterImsEditUsageResponse() {}

  explicit DescribeMeterImsEditUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterImsEditUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterImsEditUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterImsEditUsageResponse() = default;
};
class DescribeMeterImsMediaConvertUHDUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<string> interval{};
  shared_ptr<string> regionId{};
  shared_ptr<long> startTs{};

  DescribeMeterImsMediaConvertUHDUsageRequest() {}

  explicit DescribeMeterImsMediaConvertUHDUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterImsMediaConvertUHDUsageRequest() = default;
};
class DescribeMeterImsMediaConvertUHDUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> specification{};
  shared_ptr<long> time{};

  DescribeMeterImsMediaConvertUHDUsageResponseBodyData() {}

  explicit DescribeMeterImsMediaConvertUHDUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeMeterImsMediaConvertUHDUsageResponseBodyData() = default;
};
class DescribeMeterImsMediaConvertUHDUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterImsMediaConvertUHDUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterImsMediaConvertUHDUsageResponseBody() {}

  explicit DescribeMeterImsMediaConvertUHDUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterImsMediaConvertUHDUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterImsMediaConvertUHDUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterImsMediaConvertUHDUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterImsMediaConvertUHDUsageResponseBody() = default;
};
class DescribeMeterImsMediaConvertUHDUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterImsMediaConvertUHDUsageResponseBody> body{};

  DescribeMeterImsMediaConvertUHDUsageResponse() {}

  explicit DescribeMeterImsMediaConvertUHDUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterImsMediaConvertUHDUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterImsMediaConvertUHDUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterImsMediaConvertUHDUsageResponse() = default;
};
class DescribeMeterImsMediaConvertUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<long> interval{};
  shared_ptr<string> region{};
  shared_ptr<long> startTs{};

  DescribeMeterImsMediaConvertUsageRequest() {}

  explicit DescribeMeterImsMediaConvertUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterImsMediaConvertUsageRequest() = default;
};
class DescribeMeterImsMediaConvertUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> specification{};
  shared_ptr<long> time{};

  DescribeMeterImsMediaConvertUsageResponseBodyData() {}

  explicit DescribeMeterImsMediaConvertUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (specification) {
      res["Specification"] = boost::any(*specification);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      specification = make_shared<string>(boost::any_cast<string>(m["Specification"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~DescribeMeterImsMediaConvertUsageResponseBodyData() = default;
};
class DescribeMeterImsMediaConvertUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterImsMediaConvertUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterImsMediaConvertUsageResponseBody() {}

  explicit DescribeMeterImsMediaConvertUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterImsMediaConvertUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterImsMediaConvertUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterImsMediaConvertUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterImsMediaConvertUsageResponseBody() = default;
};
class DescribeMeterImsMediaConvertUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterImsMediaConvertUsageResponseBody> body{};

  DescribeMeterImsMediaConvertUsageResponse() {}

  explicit DescribeMeterImsMediaConvertUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterImsMediaConvertUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterImsMediaConvertUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterImsMediaConvertUsageResponse() = default;
};
class DescribeMeterImsMpsAiUsageRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<long> interval{};
  shared_ptr<string> region{};
  shared_ptr<long> startTs{};

  DescribeMeterImsMpsAiUsageRequest() {}

  explicit DescribeMeterImsMpsAiUsageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterImsMpsAiUsageRequest() = default;
};
class DescribeMeterImsMpsAiUsageResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<long> time{};
  shared_ptr<string> type{};

  DescribeMeterImsMpsAiUsageResponseBodyData() {}

  explicit DescribeMeterImsMpsAiUsageResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeMeterImsMpsAiUsageResponseBodyData() = default;
};
class DescribeMeterImsMpsAiUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterImsMpsAiUsageResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterImsMpsAiUsageResponseBody() {}

  explicit DescribeMeterImsMpsAiUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterImsMpsAiUsageResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterImsMpsAiUsageResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterImsMpsAiUsageResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterImsMpsAiUsageResponseBody() = default;
};
class DescribeMeterImsMpsAiUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterImsMpsAiUsageResponseBody> body{};

  DescribeMeterImsMpsAiUsageResponse() {}

  explicit DescribeMeterImsMpsAiUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterImsMpsAiUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterImsMpsAiUsageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterImsMpsAiUsageResponse() = default;
};
class DescribeMeterImsSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTs{};
  shared_ptr<string> region{};
  shared_ptr<long> startTs{};

  DescribeMeterImsSummaryRequest() {}

  explicit DescribeMeterImsSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
  }


  virtual ~DescribeMeterImsSummaryRequest() = default;
};
class DescribeMeterImsSummaryResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> editingDuration{};
  shared_ptr<string> liveEditDuration{};
  shared_ptr<string> liveRecordDuration{};
  shared_ptr<string> liveSnapshotCount{};
  shared_ptr<long> liveTranscodeDuration{};
  shared_ptr<long> mpsAiDuration{};
  shared_ptr<long> mpsTranscodeDuration{};
  shared_ptr<long> mpsTranscodeUHDDuration{};

  DescribeMeterImsSummaryResponseBodyData() {}

  explicit DescribeMeterImsSummaryResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editingDuration) {
      res["EditingDuration"] = boost::any(*editingDuration);
    }
    if (liveEditDuration) {
      res["LiveEditDuration"] = boost::any(*liveEditDuration);
    }
    if (liveRecordDuration) {
      res["LiveRecordDuration"] = boost::any(*liveRecordDuration);
    }
    if (liveSnapshotCount) {
      res["LiveSnapshotCount"] = boost::any(*liveSnapshotCount);
    }
    if (liveTranscodeDuration) {
      res["LiveTranscodeDuration"] = boost::any(*liveTranscodeDuration);
    }
    if (mpsAiDuration) {
      res["MpsAiDuration"] = boost::any(*mpsAiDuration);
    }
    if (mpsTranscodeDuration) {
      res["MpsTranscodeDuration"] = boost::any(*mpsTranscodeDuration);
    }
    if (mpsTranscodeUHDDuration) {
      res["MpsTranscodeUHDDuration"] = boost::any(*mpsTranscodeUHDDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditingDuration") != m.end() && !m["EditingDuration"].empty()) {
      editingDuration = make_shared<string>(boost::any_cast<string>(m["EditingDuration"]));
    }
    if (m.find("LiveEditDuration") != m.end() && !m["LiveEditDuration"].empty()) {
      liveEditDuration = make_shared<string>(boost::any_cast<string>(m["LiveEditDuration"]));
    }
    if (m.find("LiveRecordDuration") != m.end() && !m["LiveRecordDuration"].empty()) {
      liveRecordDuration = make_shared<string>(boost::any_cast<string>(m["LiveRecordDuration"]));
    }
    if (m.find("LiveSnapshotCount") != m.end() && !m["LiveSnapshotCount"].empty()) {
      liveSnapshotCount = make_shared<string>(boost::any_cast<string>(m["LiveSnapshotCount"]));
    }
    if (m.find("LiveTranscodeDuration") != m.end() && !m["LiveTranscodeDuration"].empty()) {
      liveTranscodeDuration = make_shared<long>(boost::any_cast<long>(m["LiveTranscodeDuration"]));
    }
    if (m.find("MpsAiDuration") != m.end() && !m["MpsAiDuration"].empty()) {
      mpsAiDuration = make_shared<long>(boost::any_cast<long>(m["MpsAiDuration"]));
    }
    if (m.find("MpsTranscodeDuration") != m.end() && !m["MpsTranscodeDuration"].empty()) {
      mpsTranscodeDuration = make_shared<long>(boost::any_cast<long>(m["MpsTranscodeDuration"]));
    }
    if (m.find("MpsTranscodeUHDDuration") != m.end() && !m["MpsTranscodeUHDDuration"].empty()) {
      mpsTranscodeUHDDuration = make_shared<long>(boost::any_cast<long>(m["MpsTranscodeUHDDuration"]));
    }
  }


  virtual ~DescribeMeterImsSummaryResponseBodyData() = default;
};
class DescribeMeterImsSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMeterImsSummaryResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeMeterImsSummaryResponseBody() {}

  explicit DescribeMeterImsSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeMeterImsSummaryResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMeterImsSummaryResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeMeterImsSummaryResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMeterImsSummaryResponseBody() = default;
};
class DescribeMeterImsSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMeterImsSummaryResponseBody> body{};

  DescribeMeterImsSummaryResponse() {}

  explicit DescribeMeterImsSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMeterImsSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMeterImsSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMeterImsSummaryResponse() = default;
};
class DescribeNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> AIAgentId{};

  DescribeNotifyConfigRequest() {}

  explicit DescribeNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIAgentId) {
      res["AIAgentId"] = boost::any(*AIAgentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIAgentId") != m.end() && !m["AIAgentId"].empty()) {
      AIAgentId = make_shared<string>(boost::any_cast<string>(m["AIAgentId"]));
    }
  }


  virtual ~DescribeNotifyConfigRequest() = default;
};
class DescribeNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> audioOssPath{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<bool> enableAudioRecording{};
  shared_ptr<bool> enableNotify{};
  shared_ptr<string> eventTypes{};
  shared_ptr<string> requestId{};
  shared_ptr<string> token{};

  DescribeNotifyConfigResponseBody() {}

  explicit DescribeNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioOssPath) {
      res["AudioOssPath"] = boost::any(*audioOssPath);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (enableAudioRecording) {
      res["EnableAudioRecording"] = boost::any(*enableAudioRecording);
    }
    if (enableNotify) {
      res["EnableNotify"] = boost::any(*enableNotify);
    }
    if (eventTypes) {
      res["EventTypes"] = boost::any(*eventTypes);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioOssPath") != m.end() && !m["AudioOssPath"].empty()) {
      audioOssPath = make_shared<string>(boost::any_cast<string>(m["AudioOssPath"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("EnableAudioRecording") != m.end() && !m["EnableAudioRecording"].empty()) {
      enableAudioRecording = make_shared<bool>(boost::any_cast<bool>(m["EnableAudioRecording"]));
    }
    if (m.find("EnableNotify") != m.end() && !m["EnableNotify"].empty()) {
      enableNotify = make_shared<bool>(boost::any_cast<bool>(m["EnableNotify"]));
    }
    if (m.find("EventTypes") != m.end() && !m["EventTypes"].empty()) {
      eventTypes = make_shared<string>(boost::any_cast<string>(m["EventTypes"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~DescribeNotifyConfigResponseBody() = default;
};
class DescribeNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNotifyConfigResponseBody> body{};

  DescribeNotifyConfigResponse() {}

  explicit DescribeNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNotifyConfigResponse() = default;
};
class DescribePlayListRequest : public Darabonba::Model {
public:
  shared_ptr<string> beginTs{};
  shared_ptr<string> endTs{};
  shared_ptr<string> orderName{};
  shared_ptr<string> orderType{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> playType{};
  shared_ptr<string> status{};
  shared_ptr<string> traceId{};

  DescribePlayListRequest() {}

  explicit DescribePlayListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTs) {
      res["BeginTs"] = boost::any(*beginTs);
    }
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (orderName) {
      res["OrderName"] = boost::any(*orderName);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (playType) {
      res["PlayType"] = boost::any(*playType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTs") != m.end() && !m["BeginTs"].empty()) {
      beginTs = make_shared<string>(boost::any_cast<string>(m["BeginTs"]));
    }
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<string>(boost::any_cast<string>(m["EndTs"]));
    }
    if (m.find("OrderName") != m.end() && !m["OrderName"].empty()) {
      orderName = make_shared<string>(boost::any_cast<string>(m["OrderName"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PlayType") != m.end() && !m["PlayType"].empty()) {
      playType = make_shared<string>(boost::any_cast<string>(m["PlayType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribePlayListRequest() = default;
};
class DescribePlayListResponseBodyPlayList : public Darabonba::Model {
public:
  shared_ptr<string> firstFrameDuration{};
  shared_ptr<string> playDuration{};
  shared_ptr<string> playTs{};
  shared_ptr<string> playType{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> status{};
  shared_ptr<string> stuckDuration{};
  shared_ptr<string> traceId{};
  shared_ptr<string> videoDuration{};
  shared_ptr<string> videoId{};

  DescribePlayListResponseBodyPlayList() {}

  explicit DescribePlayListResponseBodyPlayList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firstFrameDuration) {
      res["FirstFrameDuration"] = boost::any(*firstFrameDuration);
    }
    if (playDuration) {
      res["PlayDuration"] = boost::any(*playDuration);
    }
    if (playTs) {
      res["PlayTs"] = boost::any(*playTs);
    }
    if (playType) {
      res["PlayType"] = boost::any(*playType);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stuckDuration) {
      res["StuckDuration"] = boost::any(*stuckDuration);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    if (videoDuration) {
      res["VideoDuration"] = boost::any(*videoDuration);
    }
    if (videoId) {
      res["VideoId"] = boost::any(*videoId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirstFrameDuration") != m.end() && !m["FirstFrameDuration"].empty()) {
      firstFrameDuration = make_shared<string>(boost::any_cast<string>(m["FirstFrameDuration"]));
    }
    if (m.find("PlayDuration") != m.end() && !m["PlayDuration"].empty()) {
      playDuration = make_shared<string>(boost::any_cast<string>(m["PlayDuration"]));
    }
    if (m.find("PlayTs") != m.end() && !m["PlayTs"].empty()) {
      playTs = make_shared<string>(boost::any_cast<string>(m["PlayTs"]));
    }
    if (m.find("PlayType") != m.end() && !m["PlayType"].empty()) {
      playType = make_shared<string>(boost::any_cast<string>(m["PlayType"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StuckDuration") != m.end() && !m["StuckDuration"].empty()) {
      stuckDuration = make_shared<string>(boost::any_cast<string>(m["StuckDuration"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
    if (m.find("VideoDuration") != m.end() && !m["VideoDuration"].empty()) {
      videoDuration = make_shared<string>(boost::any_cast<string>(m["VideoDuration"]));
    }
    if (m.find("VideoId") != m.end() && !m["VideoId"].empty()) {
      videoId = make_shared<string>(boost::any_cast<string>(m["VideoId"]));
    }
  }


  virtual ~DescribePlayListResponseBodyPlayList() = default;
};
class DescribePlayListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribePlayListResponseBodyPlayList>> playList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNum{};

  DescribePlayListResponseBody() {}

  explicit DescribePlayListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (playList) {
      vector<boost::any> temp1;
      for(auto item1:*playList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PlayList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNum) {
      res["TotalNum"] = boost::any(*totalNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PlayList") != m.end() && !m["PlayList"].empty()) {
      if (typeid(vector<boost::any>) == m["PlayList"].type()) {
        vector<DescribePlayListResponseBodyPlayList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PlayList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePlayListResponseBodyPlayList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        playList = make_shared<vector<DescribePlayListResponseBodyPlayList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNum") != m.end() && !m["TotalNum"].empty()) {
      totalNum = make_shared<long>(boost::any_cast<long>(m["TotalNum"]));
    }
  }


  virtual ~DescribePlayListResponseBody() = default;
};
class DescribePlayListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePlayListResponseBody> body{};

  DescribePlayListResponse() {}

  explicit DescribePlayListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePlayListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePlayListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePlayListResponse() = default;
};
class DescribeRtcRobotInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeRtcRobotInstanceRequest() {}

  explicit DescribeRtcRobotInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeRtcRobotInstanceRequest() = default;
};
class DescribeRtcRobotInstanceResponseBodyConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableVoiceInterrupt{};
  shared_ptr<string> greeting{};
  shared_ptr<string> voiceId{};

  DescribeRtcRobotInstanceResponseBodyConfig() {}

  explicit DescribeRtcRobotInstanceResponseBodyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableVoiceInterrupt) {
      res["EnableVoiceInterrupt"] = boost::any(*enableVoiceInterrupt);
    }
    if (greeting) {
      res["Greeting"] = boost::any(*greeting);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableVoiceInterrupt") != m.end() && !m["EnableVoiceInterrupt"].empty()) {
      enableVoiceInterrupt = make_shared<bool>(boost::any_cast<bool>(m["EnableVoiceInterrupt"]));
    }
    if (m.find("Greeting") != m.end() && !m["Greeting"].empty()) {
      greeting = make_shared<string>(boost::any_cast<string>(m["Greeting"]));
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
  }


  virtual ~DescribeRtcRobotInstanceResponseBodyConfig() = default;
};
class DescribeRtcRobotInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> authToken{};
  shared_ptr<string> channelId{};
  shared_ptr<DescribeRtcRobotInstanceResponseBodyConfig> config{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<string> userData{};
  shared_ptr<string> userId{};

  DescribeRtcRobotInstanceResponseBody() {}

  explicit DescribeRtcRobotInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authToken) {
      res["AuthToken"] = boost::any(*authToken);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthToken") != m.end() && !m["AuthToken"].empty()) {
      authToken = make_shared<string>(boost::any_cast<string>(m["AuthToken"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        DescribeRtcRobotInstanceResponseBodyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<DescribeRtcRobotInstanceResponseBodyConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DescribeRtcRobotInstanceResponseBody() = default;
};
class DescribeRtcRobotInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRtcRobotInstanceResponseBody> body{};

  DescribeRtcRobotInstanceResponse() {}

  explicit DescribeRtcRobotInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRtcRobotInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRtcRobotInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRtcRobotInstanceResponse() = default;
};
class DetectAudioForCustomizedVoiceJobRequest : public Darabonba::Model {
public:
  shared_ptr<long> audioRecordId{};
  shared_ptr<string> recordUrl{};
  shared_ptr<string> voiceId{};

  DetectAudioForCustomizedVoiceJobRequest() {}

  explicit DetectAudioForCustomizedVoiceJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioRecordId) {
      res["AudioRecordId"] = boost::any(*audioRecordId);
    }
    if (recordUrl) {
      res["RecordUrl"] = boost::any(*recordUrl);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioRecordId") != m.end() && !m["AudioRecordId"].empty()) {
      audioRecordId = make_shared<long>(boost::any_cast<long>(m["AudioRecordId"]));
    }
    if (m.find("RecordUrl") != m.end() && !m["RecordUrl"].empty()) {
      recordUrl = make_shared<string>(boost::any_cast<string>(m["RecordUrl"]));
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
  }


  virtual ~DetectAudioForCustomizedVoiceJobRequest() = default;
};
class DetectAudioForCustomizedVoiceJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> pass{};
  shared_ptr<string> reason{};

  DetectAudioForCustomizedVoiceJobResponseBodyData() {}

  explicit DetectAudioForCustomizedVoiceJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pass) {
      res["Pass"] = boost::any(*pass);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pass") != m.end() && !m["Pass"].empty()) {
      pass = make_shared<bool>(boost::any_cast<bool>(m["Pass"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~DetectAudioForCustomizedVoiceJobResponseBodyData() = default;
};
class DetectAudioForCustomizedVoiceJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<DetectAudioForCustomizedVoiceJobResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DetectAudioForCustomizedVoiceJobResponseBody() {}

  explicit DetectAudioForCustomizedVoiceJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DetectAudioForCustomizedVoiceJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DetectAudioForCustomizedVoiceJobResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DetectAudioForCustomizedVoiceJobResponseBody() = default;
};
class DetectAudioForCustomizedVoiceJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetectAudioForCustomizedVoiceJobResponseBody> body{};

  DetectAudioForCustomizedVoiceJobResponse() {}

  explicit DetectAudioForCustomizedVoiceJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetectAudioForCustomizedVoiceJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetectAudioForCustomizedVoiceJobResponseBody>(model1);
      }
    }
  }


  virtual ~DetectAudioForCustomizedVoiceJobResponse() = default;
};
class DropSearchIndexRequest : public Darabonba::Model {
public:
  shared_ptr<string> indexType{};
  shared_ptr<string> searchLibName{};

  DropSearchIndexRequest() {}

  explicit DropSearchIndexRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (indexType) {
      res["IndexType"] = boost::any(*indexType);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IndexType") != m.end() && !m["IndexType"].empty()) {
      indexType = make_shared<string>(boost::any_cast<string>(m["IndexType"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
  }


  virtual ~DropSearchIndexRequest() = default;
};
class DropSearchIndexResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DropSearchIndexResponseBody() {}

  explicit DropSearchIndexResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DropSearchIndexResponseBody() = default;
};
class DropSearchIndexResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DropSearchIndexResponseBody> body{};

  DropSearchIndexResponse() {}

  explicit DropSearchIndexResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DropSearchIndexResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DropSearchIndexResponseBody>(model1);
      }
    }
  }


  virtual ~DropSearchIndexResponse() = default;
};
class DropSearchLibRequest : public Darabonba::Model {
public:
  shared_ptr<string> searchLibName{};

  DropSearchLibRequest() {}

  explicit DropSearchLibRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
  }


  virtual ~DropSearchLibRequest() = default;
};
class DropSearchLibResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  DropSearchLibResponseBody() {}

  explicit DropSearchLibResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~DropSearchLibResponseBody() = default;
};
class DropSearchLibResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DropSearchLibResponseBody> body{};

  DropSearchLibResponse() {}

  explicit DropSearchLibResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DropSearchLibResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DropSearchLibResponseBody>(model1);
      }
    }
  }


  virtual ~DropSearchLibResponse() = default;
};
class GenerateAIAgentCallRequestChatSyncConfig : public Darabonba::Model {
public:
  shared_ptr<string> IMAIAgentId{};
  shared_ptr<string> receiverId{};

  GenerateAIAgentCallRequestChatSyncConfig() {}

  explicit GenerateAIAgentCallRequestChatSyncConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IMAIAgentId) {
      res["IMAIAgentId"] = boost::any(*IMAIAgentId);
    }
    if (receiverId) {
      res["ReceiverId"] = boost::any(*receiverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IMAIAgentId") != m.end() && !m["IMAIAgentId"].empty()) {
      IMAIAgentId = make_shared<string>(boost::any_cast<string>(m["IMAIAgentId"]));
    }
    if (m.find("ReceiverId") != m.end() && !m["ReceiverId"].empty()) {
      receiverId = make_shared<string>(boost::any_cast<string>(m["ReceiverId"]));
    }
  }


  virtual ~GenerateAIAgentCallRequestChatSyncConfig() = default;
};
class GenerateAIAgentCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> AIAgentId{};
  shared_ptr<AIAgentConfig> agentConfig{};
  shared_ptr<GenerateAIAgentCallRequestChatSyncConfig> chatSyncConfig{};
  shared_ptr<long> expire{};
  shared_ptr<string> sessionId{};
  shared_ptr<AIAgentTemplateConfig> templateConfig{};
  shared_ptr<string> userData{};
  shared_ptr<string> userId{};

  GenerateAIAgentCallRequest() {}

  explicit GenerateAIAgentCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIAgentId) {
      res["AIAgentId"] = boost::any(*AIAgentId);
    }
    if (agentConfig) {
      res["AgentConfig"] = agentConfig ? boost::any(agentConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (chatSyncConfig) {
      res["ChatSyncConfig"] = chatSyncConfig ? boost::any(chatSyncConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIAgentId") != m.end() && !m["AIAgentId"].empty()) {
      AIAgentId = make_shared<string>(boost::any_cast<string>(m["AIAgentId"]));
    }
    if (m.find("AgentConfig") != m.end() && !m["AgentConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AgentConfig"].type()) {
        AIAgentConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AgentConfig"]));
        agentConfig = make_shared<AIAgentConfig>(model1);
      }
    }
    if (m.find("ChatSyncConfig") != m.end() && !m["ChatSyncConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChatSyncConfig"].type()) {
        GenerateAIAgentCallRequestChatSyncConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChatSyncConfig"]));
        chatSyncConfig = make_shared<GenerateAIAgentCallRequestChatSyncConfig>(model1);
      }
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["Expire"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        AIAgentTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<AIAgentTemplateConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GenerateAIAgentCallRequest() = default;
};
class GenerateAIAgentCallShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> AIAgentId{};
  shared_ptr<string> agentConfigShrink{};
  shared_ptr<string> chatSyncConfigShrink{};
  shared_ptr<long> expire{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> templateConfigShrink{};
  shared_ptr<string> userData{};
  shared_ptr<string> userId{};

  GenerateAIAgentCallShrinkRequest() {}

  explicit GenerateAIAgentCallShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIAgentId) {
      res["AIAgentId"] = boost::any(*AIAgentId);
    }
    if (agentConfigShrink) {
      res["AgentConfig"] = boost::any(*agentConfigShrink);
    }
    if (chatSyncConfigShrink) {
      res["ChatSyncConfig"] = boost::any(*chatSyncConfigShrink);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (templateConfigShrink) {
      res["TemplateConfig"] = boost::any(*templateConfigShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIAgentId") != m.end() && !m["AIAgentId"].empty()) {
      AIAgentId = make_shared<string>(boost::any_cast<string>(m["AIAgentId"]));
    }
    if (m.find("AgentConfig") != m.end() && !m["AgentConfig"].empty()) {
      agentConfigShrink = make_shared<string>(boost::any_cast<string>(m["AgentConfig"]));
    }
    if (m.find("ChatSyncConfig") != m.end() && !m["ChatSyncConfig"].empty()) {
      chatSyncConfigShrink = make_shared<string>(boost::any_cast<string>(m["ChatSyncConfig"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["Expire"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfigShrink = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GenerateAIAgentCallShrinkRequest() = default;
};
class GenerateAIAgentCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> AIAgentUserId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> token{};
  shared_ptr<string> userId{};

  GenerateAIAgentCallResponseBody() {}

  explicit GenerateAIAgentCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIAgentUserId) {
      res["AIAgentUserId"] = boost::any(*AIAgentUserId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIAgentUserId") != m.end() && !m["AIAgentUserId"].empty()) {
      AIAgentUserId = make_shared<string>(boost::any_cast<string>(m["AIAgentUserId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GenerateAIAgentCallResponseBody() = default;
};
class GenerateAIAgentCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateAIAgentCallResponseBody> body{};

  GenerateAIAgentCallResponse() {}

  explicit GenerateAIAgentCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateAIAgentCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateAIAgentCallResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateAIAgentCallResponse() = default;
};
class GenerateKMSDataKeyResponseBodyDataKey : public Darabonba::Model {
public:
  shared_ptr<string> ciphertextBlob{};
  shared_ptr<string> keyId{};
  shared_ptr<string> plaintext{};

  GenerateKMSDataKeyResponseBodyDataKey() {}

  explicit GenerateKMSDataKeyResponseBodyDataKey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ciphertextBlob) {
      res["CiphertextBlob"] = boost::any(*ciphertextBlob);
    }
    if (keyId) {
      res["KeyId"] = boost::any(*keyId);
    }
    if (plaintext) {
      res["Plaintext"] = boost::any(*plaintext);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CiphertextBlob") != m.end() && !m["CiphertextBlob"].empty()) {
      ciphertextBlob = make_shared<string>(boost::any_cast<string>(m["CiphertextBlob"]));
    }
    if (m.find("KeyId") != m.end() && !m["KeyId"].empty()) {
      keyId = make_shared<string>(boost::any_cast<string>(m["KeyId"]));
    }
    if (m.find("Plaintext") != m.end() && !m["Plaintext"].empty()) {
      plaintext = make_shared<string>(boost::any_cast<string>(m["Plaintext"]));
    }
  }


  virtual ~GenerateKMSDataKeyResponseBodyDataKey() = default;
};
class GenerateKMSDataKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<GenerateKMSDataKeyResponseBodyDataKey> dataKey{};
  shared_ptr<string> requestId{};

  GenerateKMSDataKeyResponseBody() {}

  explicit GenerateKMSDataKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataKey) {
      res["DataKey"] = dataKey ? boost::any(dataKey->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataKey") != m.end() && !m["DataKey"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataKey"].type()) {
        GenerateKMSDataKeyResponseBodyDataKey model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataKey"]));
        dataKey = make_shared<GenerateKMSDataKeyResponseBodyDataKey>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GenerateKMSDataKeyResponseBody() = default;
};
class GenerateKMSDataKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateKMSDataKeyResponseBody> body{};

  GenerateKMSDataKeyResponse() {}

  explicit GenerateKMSDataKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateKMSDataKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateKMSDataKeyResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateKMSDataKeyResponse() = default;
};
class GenerateMessageChatTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> AIAgentId{};
  shared_ptr<long> expire{};
  shared_ptr<string> role{};
  shared_ptr<string> userId{};

  GenerateMessageChatTokenRequest() {}

  explicit GenerateMessageChatTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIAgentId) {
      res["AIAgentId"] = boost::any(*AIAgentId);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIAgentId") != m.end() && !m["AIAgentId"].empty()) {
      AIAgentId = make_shared<string>(boost::any_cast<string>(m["AIAgentId"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["Expire"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GenerateMessageChatTokenRequest() = default;
};
class GenerateMessageChatTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appSign{};
  shared_ptr<string> nonce{};
  shared_ptr<string> requestId{};
  shared_ptr<string> role{};
  shared_ptr<long> timeStamp{};
  shared_ptr<string> token{};
  shared_ptr<string> userId{};

  GenerateMessageChatTokenResponseBody() {}

  explicit GenerateMessageChatTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appSign) {
      res["AppSign"] = boost::any(*appSign);
    }
    if (nonce) {
      res["Nonce"] = boost::any(*nonce);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppSign") != m.end() && !m["AppSign"].empty()) {
      appSign = make_shared<string>(boost::any_cast<string>(m["AppSign"]));
    }
    if (m.find("Nonce") != m.end() && !m["Nonce"].empty()) {
      nonce = make_shared<string>(boost::any_cast<string>(m["Nonce"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["TimeStamp"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GenerateMessageChatTokenResponseBody() = default;
};
class GenerateMessageChatTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateMessageChatTokenResponseBody> body{};

  GenerateMessageChatTokenResponse() {}

  explicit GenerateMessageChatTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateMessageChatTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateMessageChatTokenResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateMessageChatTokenResponse() = default;
};
class GetAdInsertionRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  GetAdInsertionRequest() {}

  explicit GetAdInsertionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetAdInsertionRequest() = default;
};
class GetAdInsertionResponseBodyConfigCdnConfig : public Darabonba::Model {
public:
  shared_ptr<string> adSegmentUrlPrefix{};
  shared_ptr<string> contentSegmentUrlPrefix{};

  GetAdInsertionResponseBodyConfigCdnConfig() {}

  explicit GetAdInsertionResponseBodyConfigCdnConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adSegmentUrlPrefix) {
      res["AdSegmentUrlPrefix"] = boost::any(*adSegmentUrlPrefix);
    }
    if (contentSegmentUrlPrefix) {
      res["ContentSegmentUrlPrefix"] = boost::any(*contentSegmentUrlPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdSegmentUrlPrefix") != m.end() && !m["AdSegmentUrlPrefix"].empty()) {
      adSegmentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["AdSegmentUrlPrefix"]));
    }
    if (m.find("ContentSegmentUrlPrefix") != m.end() && !m["ContentSegmentUrlPrefix"].empty()) {
      contentSegmentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["ContentSegmentUrlPrefix"]));
    }
  }


  virtual ~GetAdInsertionResponseBodyConfigCdnConfig() = default;
};
class GetAdInsertionResponseBodyConfigManifestEndpointConfig : public Darabonba::Model {
public:
  shared_ptr<string> dashPrefix{};
  shared_ptr<string> hlsPrefix{};

  GetAdInsertionResponseBodyConfigManifestEndpointConfig() {}

  explicit GetAdInsertionResponseBodyConfigManifestEndpointConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dashPrefix) {
      res["DashPrefix"] = boost::any(*dashPrefix);
    }
    if (hlsPrefix) {
      res["HlsPrefix"] = boost::any(*hlsPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DashPrefix") != m.end() && !m["DashPrefix"].empty()) {
      dashPrefix = make_shared<string>(boost::any_cast<string>(m["DashPrefix"]));
    }
    if (m.find("HlsPrefix") != m.end() && !m["HlsPrefix"].empty()) {
      hlsPrefix = make_shared<string>(boost::any_cast<string>(m["HlsPrefix"]));
    }
  }


  virtual ~GetAdInsertionResponseBodyConfigManifestEndpointConfig() = default;
};
class GetAdInsertionResponseBodyConfig : public Darabonba::Model {
public:
  shared_ptr<string> adMarkerPassthrough{};
  shared_ptr<string> adsUrl{};
  shared_ptr<GetAdInsertionResponseBodyConfigCdnConfig> cdnConfig{};
  shared_ptr<string> configAliases{};
  shared_ptr<string> contentUrlPrefix{};
  shared_ptr<string> createTime{};
  shared_ptr<string> lastModified{};
  shared_ptr<GetAdInsertionResponseBodyConfigManifestEndpointConfig> manifestEndpointConfig{};
  shared_ptr<string> name{};
  shared_ptr<long> personalizationThreshold{};
  shared_ptr<string> slateAdUrl{};

  GetAdInsertionResponseBodyConfig() {}

  explicit GetAdInsertionResponseBodyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adMarkerPassthrough) {
      res["AdMarkerPassthrough"] = boost::any(*adMarkerPassthrough);
    }
    if (adsUrl) {
      res["AdsUrl"] = boost::any(*adsUrl);
    }
    if (cdnConfig) {
      res["CdnConfig"] = cdnConfig ? boost::any(cdnConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configAliases) {
      res["ConfigAliases"] = boost::any(*configAliases);
    }
    if (contentUrlPrefix) {
      res["ContentUrlPrefix"] = boost::any(*contentUrlPrefix);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (manifestEndpointConfig) {
      res["ManifestEndpointConfig"] = manifestEndpointConfig ? boost::any(manifestEndpointConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (personalizationThreshold) {
      res["PersonalizationThreshold"] = boost::any(*personalizationThreshold);
    }
    if (slateAdUrl) {
      res["SlateAdUrl"] = boost::any(*slateAdUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdMarkerPassthrough") != m.end() && !m["AdMarkerPassthrough"].empty()) {
      adMarkerPassthrough = make_shared<string>(boost::any_cast<string>(m["AdMarkerPassthrough"]));
    }
    if (m.find("AdsUrl") != m.end() && !m["AdsUrl"].empty()) {
      adsUrl = make_shared<string>(boost::any_cast<string>(m["AdsUrl"]));
    }
    if (m.find("CdnConfig") != m.end() && !m["CdnConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CdnConfig"].type()) {
        GetAdInsertionResponseBodyConfigCdnConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CdnConfig"]));
        cdnConfig = make_shared<GetAdInsertionResponseBodyConfigCdnConfig>(model1);
      }
    }
    if (m.find("ConfigAliases") != m.end() && !m["ConfigAliases"].empty()) {
      configAliases = make_shared<string>(boost::any_cast<string>(m["ConfigAliases"]));
    }
    if (m.find("ContentUrlPrefix") != m.end() && !m["ContentUrlPrefix"].empty()) {
      contentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["ContentUrlPrefix"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("ManifestEndpointConfig") != m.end() && !m["ManifestEndpointConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ManifestEndpointConfig"].type()) {
        GetAdInsertionResponseBodyConfigManifestEndpointConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ManifestEndpointConfig"]));
        manifestEndpointConfig = make_shared<GetAdInsertionResponseBodyConfigManifestEndpointConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PersonalizationThreshold") != m.end() && !m["PersonalizationThreshold"].empty()) {
      personalizationThreshold = make_shared<long>(boost::any_cast<long>(m["PersonalizationThreshold"]));
    }
    if (m.find("SlateAdUrl") != m.end() && !m["SlateAdUrl"].empty()) {
      slateAdUrl = make_shared<string>(boost::any_cast<string>(m["SlateAdUrl"]));
    }
  }


  virtual ~GetAdInsertionResponseBodyConfig() = default;
};
class GetAdInsertionResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAdInsertionResponseBodyConfig> config{};
  shared_ptr<string> requestId{};

  GetAdInsertionResponseBody() {}

  explicit GetAdInsertionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        GetAdInsertionResponseBodyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<GetAdInsertionResponseBodyConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAdInsertionResponseBody() = default;
};
class GetAdInsertionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAdInsertionResponseBody> body{};

  GetAdInsertionResponse() {}

  explicit GetAdInsertionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAdInsertionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAdInsertionResponseBody>(model1);
      }
    }
  }


  virtual ~GetAdInsertionResponse() = default;
};
class GetAvatarRequest : public Darabonba::Model {
public:
  shared_ptr<string> avatarId{};

  GetAvatarRequest() {}

  explicit GetAvatarRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarId) {
      res["AvatarId"] = boost::any(*avatarId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarId") != m.end() && !m["AvatarId"].empty()) {
      avatarId = make_shared<string>(boost::any_cast<string>(m["AvatarId"]));
    }
  }


  virtual ~GetAvatarRequest() = default;
};
class GetAvatarResponseBodyDataAvatar : public Darabonba::Model {
public:
  shared_ptr<string> avatarDescription{};
  shared_ptr<string> avatarId{};
  shared_ptr<string> avatarName{};
  shared_ptr<string> avatarType{};
  shared_ptr<long> height{};
  shared_ptr<string> portrait{};
  shared_ptr<string> thumbnail{};
  shared_ptr<bool> transparent{};
  shared_ptr<long> width{};

  GetAvatarResponseBodyDataAvatar() {}

  explicit GetAvatarResponseBodyDataAvatar(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarDescription) {
      res["AvatarDescription"] = boost::any(*avatarDescription);
    }
    if (avatarId) {
      res["AvatarId"] = boost::any(*avatarId);
    }
    if (avatarName) {
      res["AvatarName"] = boost::any(*avatarName);
    }
    if (avatarType) {
      res["AvatarType"] = boost::any(*avatarType);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (portrait) {
      res["Portrait"] = boost::any(*portrait);
    }
    if (thumbnail) {
      res["Thumbnail"] = boost::any(*thumbnail);
    }
    if (transparent) {
      res["Transparent"] = boost::any(*transparent);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarDescription") != m.end() && !m["AvatarDescription"].empty()) {
      avatarDescription = make_shared<string>(boost::any_cast<string>(m["AvatarDescription"]));
    }
    if (m.find("AvatarId") != m.end() && !m["AvatarId"].empty()) {
      avatarId = make_shared<string>(boost::any_cast<string>(m["AvatarId"]));
    }
    if (m.find("AvatarName") != m.end() && !m["AvatarName"].empty()) {
      avatarName = make_shared<string>(boost::any_cast<string>(m["AvatarName"]));
    }
    if (m.find("AvatarType") != m.end() && !m["AvatarType"].empty()) {
      avatarType = make_shared<string>(boost::any_cast<string>(m["AvatarType"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Portrait") != m.end() && !m["Portrait"].empty()) {
      portrait = make_shared<string>(boost::any_cast<string>(m["Portrait"]));
    }
    if (m.find("Thumbnail") != m.end() && !m["Thumbnail"].empty()) {
      thumbnail = make_shared<string>(boost::any_cast<string>(m["Thumbnail"]));
    }
    if (m.find("Transparent") != m.end() && !m["Transparent"].empty()) {
      transparent = make_shared<bool>(boost::any_cast<bool>(m["Transparent"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~GetAvatarResponseBodyDataAvatar() = default;
};
class GetAvatarResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetAvatarResponseBodyDataAvatar> avatar{};

  GetAvatarResponseBodyData() {}

  explicit GetAvatarResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatar) {
      res["Avatar"] = avatar ? boost::any(avatar->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avatar") != m.end() && !m["Avatar"].empty()) {
      if (typeid(map<string, boost::any>) == m["Avatar"].type()) {
        GetAvatarResponseBodyDataAvatar model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Avatar"]));
        avatar = make_shared<GetAvatarResponseBodyDataAvatar>(model1);
      }
    }
  }


  virtual ~GetAvatarResponseBodyData() = default;
};
class GetAvatarResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAvatarResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAvatarResponseBody() {}

  explicit GetAvatarResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAvatarResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAvatarResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAvatarResponseBody() = default;
};
class GetAvatarResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAvatarResponseBody> body{};

  GetAvatarResponse() {}

  explicit GetAvatarResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAvatarResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAvatarResponseBody>(model1);
      }
    }
  }


  virtual ~GetAvatarResponse() = default;
};
class GetAvatarTrainingJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetAvatarTrainingJobRequest() {}

  explicit GetAvatarTrainingJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetAvatarTrainingJobRequest() = default;
};
class GetAvatarTrainingJobResponseBodyDataAvatarTrainingJob : public Darabonba::Model {
public:
  shared_ptr<string> avatarDescription{};
  shared_ptr<string> avatarId{};
  shared_ptr<string> avatarName{};
  shared_ptr<string> avatarType{};
  shared_ptr<string> firstTrainingTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> lastTrainingTime{};
  shared_ptr<string> message{};
  shared_ptr<string> portrait{};
  shared_ptr<string> status{};
  shared_ptr<string> thumbnail{};
  shared_ptr<bool> transparent{};
  shared_ptr<string> video{};

  GetAvatarTrainingJobResponseBodyDataAvatarTrainingJob() {}

  explicit GetAvatarTrainingJobResponseBodyDataAvatarTrainingJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarDescription) {
      res["AvatarDescription"] = boost::any(*avatarDescription);
    }
    if (avatarId) {
      res["AvatarId"] = boost::any(*avatarId);
    }
    if (avatarName) {
      res["AvatarName"] = boost::any(*avatarName);
    }
    if (avatarType) {
      res["AvatarType"] = boost::any(*avatarType);
    }
    if (firstTrainingTime) {
      res["FirstTrainingTime"] = boost::any(*firstTrainingTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (lastTrainingTime) {
      res["LastTrainingTime"] = boost::any(*lastTrainingTime);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (portrait) {
      res["Portrait"] = boost::any(*portrait);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (thumbnail) {
      res["Thumbnail"] = boost::any(*thumbnail);
    }
    if (transparent) {
      res["Transparent"] = boost::any(*transparent);
    }
    if (video) {
      res["Video"] = boost::any(*video);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarDescription") != m.end() && !m["AvatarDescription"].empty()) {
      avatarDescription = make_shared<string>(boost::any_cast<string>(m["AvatarDescription"]));
    }
    if (m.find("AvatarId") != m.end() && !m["AvatarId"].empty()) {
      avatarId = make_shared<string>(boost::any_cast<string>(m["AvatarId"]));
    }
    if (m.find("AvatarName") != m.end() && !m["AvatarName"].empty()) {
      avatarName = make_shared<string>(boost::any_cast<string>(m["AvatarName"]));
    }
    if (m.find("AvatarType") != m.end() && !m["AvatarType"].empty()) {
      avatarType = make_shared<string>(boost::any_cast<string>(m["AvatarType"]));
    }
    if (m.find("FirstTrainingTime") != m.end() && !m["FirstTrainingTime"].empty()) {
      firstTrainingTime = make_shared<string>(boost::any_cast<string>(m["FirstTrainingTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("LastTrainingTime") != m.end() && !m["LastTrainingTime"].empty()) {
      lastTrainingTime = make_shared<string>(boost::any_cast<string>(m["LastTrainingTime"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Portrait") != m.end() && !m["Portrait"].empty()) {
      portrait = make_shared<string>(boost::any_cast<string>(m["Portrait"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Thumbnail") != m.end() && !m["Thumbnail"].empty()) {
      thumbnail = make_shared<string>(boost::any_cast<string>(m["Thumbnail"]));
    }
    if (m.find("Transparent") != m.end() && !m["Transparent"].empty()) {
      transparent = make_shared<bool>(boost::any_cast<bool>(m["Transparent"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      video = make_shared<string>(boost::any_cast<string>(m["Video"]));
    }
  }


  virtual ~GetAvatarTrainingJobResponseBodyDataAvatarTrainingJob() = default;
};
class GetAvatarTrainingJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetAvatarTrainingJobResponseBodyDataAvatarTrainingJob> avatarTrainingJob{};

  GetAvatarTrainingJobResponseBodyData() {}

  explicit GetAvatarTrainingJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarTrainingJob) {
      res["AvatarTrainingJob"] = avatarTrainingJob ? boost::any(avatarTrainingJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarTrainingJob") != m.end() && !m["AvatarTrainingJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["AvatarTrainingJob"].type()) {
        GetAvatarTrainingJobResponseBodyDataAvatarTrainingJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AvatarTrainingJob"]));
        avatarTrainingJob = make_shared<GetAvatarTrainingJobResponseBodyDataAvatarTrainingJob>(model1);
      }
    }
  }


  virtual ~GetAvatarTrainingJobResponseBodyData() = default;
};
class GetAvatarTrainingJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAvatarTrainingJobResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAvatarTrainingJobResponseBody() {}

  explicit GetAvatarTrainingJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAvatarTrainingJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAvatarTrainingJobResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAvatarTrainingJobResponseBody() = default;
};
class GetAvatarTrainingJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAvatarTrainingJobResponseBody> body{};

  GetAvatarTrainingJobResponse() {}

  explicit GetAvatarTrainingJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAvatarTrainingJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAvatarTrainingJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetAvatarTrainingJobResponse() = default;
};
class GetBatchMediaProducingJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetBatchMediaProducingJobRequest() {}

  explicit GetBatchMediaProducingJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetBatchMediaProducingJobRequest() = default;
};
class GetBatchMediaProducingJobResponseBodyEditingBatchJobSubJobList : public Darabonba::Model {
public:
  shared_ptr<double> duration{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaURL{};
  shared_ptr<string> projectId{};
  shared_ptr<string> status{};

  GetBatchMediaProducingJobResponseBodyEditingBatchJobSubJobList() {}

  explicit GetBatchMediaProducingJobResponseBodyEditingBatchJobSubJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaURL) {
      res["MediaURL"] = boost::any(*mediaURL);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaURL") != m.end() && !m["MediaURL"].empty()) {
      mediaURL = make_shared<string>(boost::any_cast<string>(m["MediaURL"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetBatchMediaProducingJobResponseBodyEditingBatchJobSubJobList() = default;
};
class GetBatchMediaProducingJobResponseBodyEditingBatchJob : public Darabonba::Model {
public:
  shared_ptr<string> completeTime{};
  shared_ptr<string> createTime{};
  shared_ptr<string> editingConfig{};
  shared_ptr<string> extend{};
  shared_ptr<string> inputConfig{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> outputConfig{};
  shared_ptr<string> status{};
  shared_ptr<vector<GetBatchMediaProducingJobResponseBodyEditingBatchJobSubJobList>> subJobList{};
  shared_ptr<string> userData{};

  GetBatchMediaProducingJobResponseBodyEditingBatchJob() {}

  explicit GetBatchMediaProducingJobResponseBodyEditingBatchJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (editingConfig) {
      res["EditingConfig"] = boost::any(*editingConfig);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (inputConfig) {
      res["InputConfig"] = boost::any(*inputConfig);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subJobList) {
      vector<boost::any> temp1;
      for(auto item1:*subJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubJobList"] = boost::any(temp1);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      editingConfig = make_shared<string>(boost::any_cast<string>(m["EditingConfig"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      inputConfig = make_shared<string>(boost::any_cast<string>(m["InputConfig"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubJobList") != m.end() && !m["SubJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["SubJobList"].type()) {
        vector<GetBatchMediaProducingJobResponseBodyEditingBatchJobSubJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBatchMediaProducingJobResponseBodyEditingBatchJobSubJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subJobList = make_shared<vector<GetBatchMediaProducingJobResponseBodyEditingBatchJobSubJobList>>(expect1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetBatchMediaProducingJobResponseBodyEditingBatchJob() = default;
};
class GetBatchMediaProducingJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetBatchMediaProducingJobResponseBodyEditingBatchJob> editingBatchJob{};
  shared_ptr<string> requestId{};

  GetBatchMediaProducingJobResponseBody() {}

  explicit GetBatchMediaProducingJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editingBatchJob) {
      res["EditingBatchJob"] = editingBatchJob ? boost::any(editingBatchJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditingBatchJob") != m.end() && !m["EditingBatchJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["EditingBatchJob"].type()) {
        GetBatchMediaProducingJobResponseBodyEditingBatchJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EditingBatchJob"]));
        editingBatchJob = make_shared<GetBatchMediaProducingJobResponseBodyEditingBatchJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetBatchMediaProducingJobResponseBody() = default;
};
class GetBatchMediaProducingJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBatchMediaProducingJobResponseBody> body{};

  GetBatchMediaProducingJobResponse() {}

  explicit GetBatchMediaProducingJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBatchMediaProducingJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBatchMediaProducingJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetBatchMediaProducingJobResponse() = default;
};
class GetCategoriesRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> type{};

  GetCategoriesRequest() {}

  explicit GetCategoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetCategoriesRequest() = default;
};
class GetCategoriesResponseBodyCategory : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<long> level{};
  shared_ptr<long> parentId{};
  shared_ptr<string> type{};

  GetCategoriesResponseBodyCategory() {}

  explicit GetCategoriesResponseBodyCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetCategoriesResponseBodyCategory() = default;
};
class GetCategoriesResponseBodySubCategoriesCategory : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<long> level{};
  shared_ptr<long> parentId{};
  shared_ptr<long> subTotal{};
  shared_ptr<string> type{};

  GetCategoriesResponseBodySubCategoriesCategory() {}

  explicit GetCategoriesResponseBodySubCategoriesCategory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (subTotal) {
      res["SubTotal"] = boost::any(*subTotal);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("SubTotal") != m.end() && !m["SubTotal"].empty()) {
      subTotal = make_shared<long>(boost::any_cast<long>(m["SubTotal"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetCategoriesResponseBodySubCategoriesCategory() = default;
};
class GetCategoriesResponseBodySubCategories : public Darabonba::Model {
public:
  shared_ptr<vector<GetCategoriesResponseBodySubCategoriesCategory>> category{};

  GetCategoriesResponseBodySubCategories() {}

  explicit GetCategoriesResponseBodySubCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      vector<boost::any> temp1;
      for(auto item1:*category){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Category"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(vector<boost::any>) == m["Category"].type()) {
        vector<GetCategoriesResponseBodySubCategoriesCategory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Category"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCategoriesResponseBodySubCategoriesCategory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        category = make_shared<vector<GetCategoriesResponseBodySubCategoriesCategory>>(expect1);
      }
    }
  }


  virtual ~GetCategoriesResponseBodySubCategories() = default;
};
class GetCategoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetCategoriesResponseBodyCategory> category{};
  shared_ptr<string> requestId{};
  shared_ptr<GetCategoriesResponseBodySubCategories> subCategories{};
  shared_ptr<long> subTotal{};

  GetCategoriesResponseBody() {}

  explicit GetCategoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = category ? boost::any(category->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subCategories) {
      res["SubCategories"] = subCategories ? boost::any(subCategories->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subTotal) {
      res["SubTotal"] = boost::any(*subTotal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      if (typeid(map<string, boost::any>) == m["Category"].type()) {
        GetCategoriesResponseBodyCategory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Category"]));
        category = make_shared<GetCategoriesResponseBodyCategory>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubCategories") != m.end() && !m["SubCategories"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubCategories"].type()) {
        GetCategoriesResponseBodySubCategories model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubCategories"]));
        subCategories = make_shared<GetCategoriesResponseBodySubCategories>(model1);
      }
    }
    if (m.find("SubTotal") != m.end() && !m["SubTotal"].empty()) {
      subTotal = make_shared<long>(boost::any_cast<long>(m["SubTotal"]));
    }
  }


  virtual ~GetCategoriesResponseBody() = default;
};
class GetCategoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCategoriesResponseBody> body{};

  GetCategoriesResponse() {}

  explicit GetCategoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCategoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCategoriesResponseBody>(model1);
      }
    }
  }


  virtual ~GetCategoriesResponse() = default;
};
class GetChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};

  GetChannelRequest() {}

  explicit GetChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
  }


  virtual ~GetChannelRequest() = default;
};
class GetChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<ChannelAssemblyChannel> channel{};
  shared_ptr<string> requestId{};

  GetChannelResponseBody() {}

  explicit GetChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["Channel"] = channel ? boost::any(channel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      if (typeid(map<string, boost::any>) == m["Channel"].type()) {
        ChannelAssemblyChannel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Channel"]));
        channel = make_shared<ChannelAssemblyChannel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetChannelResponseBody() = default;
};
class GetChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetChannelResponseBody> body{};

  GetChannelResponse() {}

  explicit GetChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetChannelResponseBody>(model1);
      }
    }
  }


  virtual ~GetChannelResponse() = default;
};
class GetContentAnalyzeConfigResponseBodyContentAnalyzeConfig : public Darabonba::Model {
public:
  shared_ptr<bool> auto_{};
  shared_ptr<string> saveType{};
  shared_ptr<string> templateId{};

  GetContentAnalyzeConfigResponseBodyContentAnalyzeConfig() {}

  explicit GetContentAnalyzeConfigResponseBodyContentAnalyzeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auto_) {
      res["Auto"] = boost::any(*auto_);
    }
    if (saveType) {
      res["SaveType"] = boost::any(*saveType);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Auto") != m.end() && !m["Auto"].empty()) {
      auto_ = make_shared<bool>(boost::any_cast<bool>(m["Auto"]));
    }
    if (m.find("SaveType") != m.end() && !m["SaveType"].empty()) {
      saveType = make_shared<string>(boost::any_cast<string>(m["SaveType"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetContentAnalyzeConfigResponseBodyContentAnalyzeConfig() = default;
};
class GetContentAnalyzeConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetContentAnalyzeConfigResponseBodyContentAnalyzeConfig> contentAnalyzeConfig{};
  shared_ptr<string> requestId{};

  GetContentAnalyzeConfigResponseBody() {}

  explicit GetContentAnalyzeConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentAnalyzeConfig) {
      res["ContentAnalyzeConfig"] = contentAnalyzeConfig ? boost::any(contentAnalyzeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentAnalyzeConfig") != m.end() && !m["ContentAnalyzeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContentAnalyzeConfig"].type()) {
        GetContentAnalyzeConfigResponseBodyContentAnalyzeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContentAnalyzeConfig"]));
        contentAnalyzeConfig = make_shared<GetContentAnalyzeConfigResponseBodyContentAnalyzeConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetContentAnalyzeConfigResponseBody() = default;
};
class GetContentAnalyzeConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetContentAnalyzeConfigResponseBody> body{};

  GetContentAnalyzeConfigResponse() {}

  explicit GetContentAnalyzeConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetContentAnalyzeConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetContentAnalyzeConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetContentAnalyzeConfigResponse() = default;
};
class GetCustomTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<long> subtype{};
  shared_ptr<string> templateId{};
  shared_ptr<long> type{};

  GetCustomTemplateRequest() {}

  explicit GetCustomTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<long>(boost::any_cast<long>(m["Subtype"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~GetCustomTemplateRequest() = default;
};
class GetCustomTemplateResponseBodyCustomTemplateFrontendHintTranscodeTemplateHint : public Darabonba::Model {
public:
  shared_ptr<string> bitrateControlType{};

  GetCustomTemplateResponseBodyCustomTemplateFrontendHintTranscodeTemplateHint() {}

  explicit GetCustomTemplateResponseBodyCustomTemplateFrontendHintTranscodeTemplateHint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrateControlType) {
      res["BitrateControlType"] = boost::any(*bitrateControlType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BitrateControlType") != m.end() && !m["BitrateControlType"].empty()) {
      bitrateControlType = make_shared<string>(boost::any_cast<string>(m["BitrateControlType"]));
    }
  }


  virtual ~GetCustomTemplateResponseBodyCustomTemplateFrontendHintTranscodeTemplateHint() = default;
};
class GetCustomTemplateResponseBodyCustomTemplateFrontendHint : public Darabonba::Model {
public:
  shared_ptr<GetCustomTemplateResponseBodyCustomTemplateFrontendHintTranscodeTemplateHint> transcodeTemplateHint{};

  GetCustomTemplateResponseBodyCustomTemplateFrontendHint() {}

  explicit GetCustomTemplateResponseBodyCustomTemplateFrontendHint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transcodeTemplateHint) {
      res["TranscodeTemplateHint"] = transcodeTemplateHint ? boost::any(transcodeTemplateHint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TranscodeTemplateHint") != m.end() && !m["TranscodeTemplateHint"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeTemplateHint"].type()) {
        GetCustomTemplateResponseBodyCustomTemplateFrontendHintTranscodeTemplateHint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeTemplateHint"]));
        transcodeTemplateHint = make_shared<GetCustomTemplateResponseBodyCustomTemplateFrontendHintTranscodeTemplateHint>(model1);
      }
    }
  }


  virtual ~GetCustomTemplateResponseBodyCustomTemplateFrontendHint() = default;
};
class GetCustomTemplateResponseBodyCustomTemplate : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<GetCustomTemplateResponseBodyCustomTemplateFrontendHint> frontendHint{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> status{};
  shared_ptr<long> subtype{};
  shared_ptr<string> subtypeName{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> type{};
  shared_ptr<string> typeName_{};

  GetCustomTemplateResponseBodyCustomTemplate() {}

  explicit GetCustomTemplateResponseBodyCustomTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (frontendHint) {
      res["FrontendHint"] = frontendHint ? boost::any(frontendHint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (subtypeName) {
      res["SubtypeName"] = boost::any(*subtypeName);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FrontendHint") != m.end() && !m["FrontendHint"].empty()) {
      if (typeid(map<string, boost::any>) == m["FrontendHint"].type()) {
        GetCustomTemplateResponseBodyCustomTemplateFrontendHint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FrontendHint"]));
        frontendHint = make_shared<GetCustomTemplateResponseBodyCustomTemplateFrontendHint>(model1);
      }
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<long>(boost::any_cast<long>(m["Subtype"]));
    }
    if (m.find("SubtypeName") != m.end() && !m["SubtypeName"].empty()) {
      subtypeName = make_shared<string>(boost::any_cast<string>(m["SubtypeName"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~GetCustomTemplateResponseBodyCustomTemplate() = default;
};
class GetCustomTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetCustomTemplateResponseBodyCustomTemplate> customTemplate{};
  shared_ptr<string> requestId{};

  GetCustomTemplateResponseBody() {}

  explicit GetCustomTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTemplate) {
      res["CustomTemplate"] = customTemplate ? boost::any(customTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTemplate") != m.end() && !m["CustomTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomTemplate"].type()) {
        GetCustomTemplateResponseBodyCustomTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomTemplate"]));
        customTemplate = make_shared<GetCustomTemplateResponseBodyCustomTemplate>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCustomTemplateResponseBody() = default;
};
class GetCustomTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCustomTemplateResponseBody> body{};

  GetCustomTemplateResponse() {}

  explicit GetCustomTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCustomTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCustomTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetCustomTemplateResponse() = default;
};
class GetCustomizedVoiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> voiceId{};

  GetCustomizedVoiceRequest() {}

  explicit GetCustomizedVoiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
  }


  virtual ~GetCustomizedVoiceRequest() = default;
};
class GetCustomizedVoiceResponseBodyDataCustomizedVoice : public Darabonba::Model {
public:
  shared_ptr<string> demoAudioMediaId{};
  shared_ptr<string> gender{};
  shared_ptr<string> scenario{};
  shared_ptr<string> voiceDesc{};
  shared_ptr<string> voiceId{};
  shared_ptr<string> voiceName{};

  GetCustomizedVoiceResponseBodyDataCustomizedVoice() {}

  explicit GetCustomizedVoiceResponseBodyDataCustomizedVoice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoAudioMediaId) {
      res["DemoAudioMediaId"] = boost::any(*demoAudioMediaId);
    }
    if (gender) {
      res["Gender"] = boost::any(*gender);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (voiceDesc) {
      res["VoiceDesc"] = boost::any(*voiceDesc);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    if (voiceName) {
      res["VoiceName"] = boost::any(*voiceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoAudioMediaId") != m.end() && !m["DemoAudioMediaId"].empty()) {
      demoAudioMediaId = make_shared<string>(boost::any_cast<string>(m["DemoAudioMediaId"]));
    }
    if (m.find("Gender") != m.end() && !m["Gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["Gender"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("VoiceDesc") != m.end() && !m["VoiceDesc"].empty()) {
      voiceDesc = make_shared<string>(boost::any_cast<string>(m["VoiceDesc"]));
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
    if (m.find("VoiceName") != m.end() && !m["VoiceName"].empty()) {
      voiceName = make_shared<string>(boost::any_cast<string>(m["VoiceName"]));
    }
  }


  virtual ~GetCustomizedVoiceResponseBodyDataCustomizedVoice() = default;
};
class GetCustomizedVoiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetCustomizedVoiceResponseBodyDataCustomizedVoice> customizedVoice{};

  GetCustomizedVoiceResponseBodyData() {}

  explicit GetCustomizedVoiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customizedVoice) {
      res["CustomizedVoice"] = customizedVoice ? boost::any(customizedVoice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomizedVoice") != m.end() && !m["CustomizedVoice"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomizedVoice"].type()) {
        GetCustomizedVoiceResponseBodyDataCustomizedVoice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomizedVoice"]));
        customizedVoice = make_shared<GetCustomizedVoiceResponseBodyDataCustomizedVoice>(model1);
      }
    }
  }


  virtual ~GetCustomizedVoiceResponseBodyData() = default;
};
class GetCustomizedVoiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetCustomizedVoiceResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetCustomizedVoiceResponseBody() {}

  explicit GetCustomizedVoiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetCustomizedVoiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetCustomizedVoiceResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetCustomizedVoiceResponseBody() = default;
};
class GetCustomizedVoiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCustomizedVoiceResponseBody> body{};

  GetCustomizedVoiceResponse() {}

  explicit GetCustomizedVoiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCustomizedVoiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCustomizedVoiceResponseBody>(model1);
      }
    }
  }


  virtual ~GetCustomizedVoiceResponse() = default;
};
class GetCustomizedVoiceJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetCustomizedVoiceJobRequest() {}

  explicit GetCustomizedVoiceJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetCustomizedVoiceJobRequest() = default;
};
class GetCustomizedVoiceJobResponseBodyDataCustomizedVoiceJob : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> gender{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> scenario{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> voiceDesc{};
  shared_ptr<string> voiceId{};
  shared_ptr<string> voiceName{};

  GetCustomizedVoiceJobResponseBodyDataCustomizedVoiceJob() {}

  explicit GetCustomizedVoiceJobResponseBodyDataCustomizedVoiceJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (gender) {
      res["Gender"] = boost::any(*gender);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (voiceDesc) {
      res["VoiceDesc"] = boost::any(*voiceDesc);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    if (voiceName) {
      res["VoiceName"] = boost::any(*voiceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Gender") != m.end() && !m["Gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["Gender"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VoiceDesc") != m.end() && !m["VoiceDesc"].empty()) {
      voiceDesc = make_shared<string>(boost::any_cast<string>(m["VoiceDesc"]));
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
    if (m.find("VoiceName") != m.end() && !m["VoiceName"].empty()) {
      voiceName = make_shared<string>(boost::any_cast<string>(m["VoiceName"]));
    }
  }


  virtual ~GetCustomizedVoiceJobResponseBodyDataCustomizedVoiceJob() = default;
};
class GetCustomizedVoiceJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetCustomizedVoiceJobResponseBodyDataCustomizedVoiceJob> customizedVoiceJob{};

  GetCustomizedVoiceJobResponseBodyData() {}

  explicit GetCustomizedVoiceJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customizedVoiceJob) {
      res["CustomizedVoiceJob"] = customizedVoiceJob ? boost::any(customizedVoiceJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomizedVoiceJob") != m.end() && !m["CustomizedVoiceJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomizedVoiceJob"].type()) {
        GetCustomizedVoiceJobResponseBodyDataCustomizedVoiceJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomizedVoiceJob"]));
        customizedVoiceJob = make_shared<GetCustomizedVoiceJobResponseBodyDataCustomizedVoiceJob>(model1);
      }
    }
  }


  virtual ~GetCustomizedVoiceJobResponseBodyData() = default;
};
class GetCustomizedVoiceJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetCustomizedVoiceJobResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetCustomizedVoiceJobResponseBody() {}

  explicit GetCustomizedVoiceJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetCustomizedVoiceJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetCustomizedVoiceJobResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetCustomizedVoiceJobResponseBody() = default;
};
class GetCustomizedVoiceJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCustomizedVoiceJobResponseBody> body{};

  GetCustomizedVoiceJobResponse() {}

  explicit GetCustomizedVoiceJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCustomizedVoiceJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCustomizedVoiceJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetCustomizedVoiceJobResponse() = default;
};
class GetDefaultStorageLocationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> path{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};
  shared_ptr<string> storageType{};

  GetDefaultStorageLocationResponseBody() {}

  explicit GetDefaultStorageLocationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~GetDefaultStorageLocationResponseBody() = default;
};
class GetDefaultStorageLocationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDefaultStorageLocationResponseBody> body{};

  GetDefaultStorageLocationResponse() {}

  explicit GetDefaultStorageLocationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDefaultStorageLocationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDefaultStorageLocationResponseBody>(model1);
      }
    }
  }


  virtual ~GetDefaultStorageLocationResponse() = default;
};
class GetDemonstrationForCustomizedVoiceJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> scenario{};

  GetDemonstrationForCustomizedVoiceJobRequest() {}

  explicit GetDemonstrationForCustomizedVoiceJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
  }


  virtual ~GetDemonstrationForCustomizedVoiceJobRequest() = default;
};
class GetDemonstrationForCustomizedVoiceJobResponseBodyDataDemonstrationList : public Darabonba::Model {
public:
  shared_ptr<long> audioId{};
  shared_ptr<string> demoAudio{};
  shared_ptr<string> text{};

  GetDemonstrationForCustomizedVoiceJobResponseBodyDataDemonstrationList() {}

  explicit GetDemonstrationForCustomizedVoiceJobResponseBodyDataDemonstrationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioId) {
      res["AudioId"] = boost::any(*audioId);
    }
    if (demoAudio) {
      res["DemoAudio"] = boost::any(*demoAudio);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioId") != m.end() && !m["AudioId"].empty()) {
      audioId = make_shared<long>(boost::any_cast<long>(m["AudioId"]));
    }
    if (m.find("DemoAudio") != m.end() && !m["DemoAudio"].empty()) {
      demoAudio = make_shared<string>(boost::any_cast<string>(m["DemoAudio"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~GetDemonstrationForCustomizedVoiceJobResponseBodyDataDemonstrationList() = default;
};
class GetDemonstrationForCustomizedVoiceJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetDemonstrationForCustomizedVoiceJobResponseBodyDataDemonstrationList>> demonstrationList{};

  GetDemonstrationForCustomizedVoiceJobResponseBodyData() {}

  explicit GetDemonstrationForCustomizedVoiceJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demonstrationList) {
      vector<boost::any> temp1;
      for(auto item1:*demonstrationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DemonstrationList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemonstrationList") != m.end() && !m["DemonstrationList"].empty()) {
      if (typeid(vector<boost::any>) == m["DemonstrationList"].type()) {
        vector<GetDemonstrationForCustomizedVoiceJobResponseBodyDataDemonstrationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DemonstrationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDemonstrationForCustomizedVoiceJobResponseBodyDataDemonstrationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        demonstrationList = make_shared<vector<GetDemonstrationForCustomizedVoiceJobResponseBodyDataDemonstrationList>>(expect1);
      }
    }
  }


  virtual ~GetDemonstrationForCustomizedVoiceJobResponseBodyData() = default;
};
class GetDemonstrationForCustomizedVoiceJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDemonstrationForCustomizedVoiceJobResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDemonstrationForCustomizedVoiceJobResponseBody() {}

  explicit GetDemonstrationForCustomizedVoiceJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDemonstrationForCustomizedVoiceJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDemonstrationForCustomizedVoiceJobResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDemonstrationForCustomizedVoiceJobResponseBody() = default;
};
class GetDemonstrationForCustomizedVoiceJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDemonstrationForCustomizedVoiceJobResponseBody> body{};

  GetDemonstrationForCustomizedVoiceJobResponse() {}

  explicit GetDemonstrationForCustomizedVoiceJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDemonstrationForCustomizedVoiceJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDemonstrationForCustomizedVoiceJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetDemonstrationForCustomizedVoiceJobResponse() = default;
};
class GetDynamicImageJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetDynamicImageJobRequest() {}

  explicit GetDynamicImageJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetDynamicImageJobRequest() = default;
};
class GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile() {}

  explicit GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile() = default;
};
class GetDynamicImageJobResponseBodyDynamicImageJobInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile> ossFile{};
  shared_ptr<string> type{};

  GetDynamicImageJobResponseBodyDynamicImageJobInput() {}

  explicit GetDynamicImageJobResponseBodyDynamicImageJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (ossFile) {
      res["OssFile"] = ossFile ? boost::any(ossFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("OssFile") != m.end() && !m["OssFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssFile"].type()) {
        GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssFile"]));
        ossFile = make_shared<GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDynamicImageJobResponseBodyDynamicImageJobInput() = default;
};
class GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile() {}

  explicit GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile() = default;
};
class GetDynamicImageJobResponseBodyDynamicImageJobOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile> ossFile{};
  shared_ptr<string> type{};

  GetDynamicImageJobResponseBodyDynamicImageJobOutput() {}

  explicit GetDynamicImageJobResponseBodyDynamicImageJobOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (ossFile) {
      res["OssFile"] = ossFile ? boost::any(ossFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("OssFile") != m.end() && !m["OssFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssFile"].type()) {
        GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssFile"]));
        ossFile = make_shared<GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDynamicImageJobResponseBodyDynamicImageJobOutput() = default;
};
class GetDynamicImageJobResponseBodyDynamicImageJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<GetDynamicImageJobResponseBodyDynamicImageJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<GetDynamicImageJobResponseBodyDynamicImageJobOutput> output{};
  shared_ptr<string> outputUrl{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  GetDynamicImageJobResponseBodyDynamicImageJob() {}

  explicit GetDynamicImageJobResponseBodyDynamicImageJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outputUrl) {
      res["OutputUrl"] = boost::any(*outputUrl);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        GetDynamicImageJobResponseBodyDynamicImageJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<GetDynamicImageJobResponseBodyDynamicImageJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        GetDynamicImageJobResponseBodyDynamicImageJobOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<GetDynamicImageJobResponseBodyDynamicImageJobOutput>(model1);
      }
    }
    if (m.find("OutputUrl") != m.end() && !m["OutputUrl"].empty()) {
      outputUrl = make_shared<string>(boost::any_cast<string>(m["OutputUrl"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetDynamicImageJobResponseBodyDynamicImageJob() = default;
};
class GetDynamicImageJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDynamicImageJobResponseBodyDynamicImageJob> dynamicImageJob{};
  shared_ptr<string> requestId{};

  GetDynamicImageJobResponseBody() {}

  explicit GetDynamicImageJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicImageJob) {
      res["DynamicImageJob"] = dynamicImageJob ? boost::any(dynamicImageJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicImageJob") != m.end() && !m["DynamicImageJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["DynamicImageJob"].type()) {
        GetDynamicImageJobResponseBodyDynamicImageJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DynamicImageJob"]));
        dynamicImageJob = make_shared<GetDynamicImageJobResponseBodyDynamicImageJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDynamicImageJobResponseBody() = default;
};
class GetDynamicImageJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDynamicImageJobResponseBody> body{};

  GetDynamicImageJobResponse() {}

  explicit GetDynamicImageJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDynamicImageJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDynamicImageJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetDynamicImageJobResponse() = default;
};
class GetEditingProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> requestSource{};

  GetEditingProjectRequest() {}

  explicit GetEditingProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (requestSource) {
      res["RequestSource"] = boost::any(*requestSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RequestSource") != m.end() && !m["RequestSource"].empty()) {
      requestSource = make_shared<string>(boost::any_cast<string>(m["RequestSource"]));
    }
  }


  virtual ~GetEditingProjectRequest() = default;
};
class GetEditingProjectResponseBodyProject : public Darabonba::Model {
public:
  shared_ptr<string> businessConfig{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> clipsParam{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createSource{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> duration{};
  shared_ptr<string> modifiedSource{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectType{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateType{};
  shared_ptr<string> timeline{};
  shared_ptr<string> timelineConvertErrorMessage{};
  shared_ptr<string> timelineConvertStatus{};
  shared_ptr<string> title{};

  GetEditingProjectResponseBodyProject() {}

  explicit GetEditingProjectResponseBodyProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessConfig) {
      res["BusinessConfig"] = boost::any(*businessConfig);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (modifiedSource) {
      res["ModifiedSource"] = boost::any(*modifiedSource);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectType) {
      res["ProjectType"] = boost::any(*projectType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (timelineConvertErrorMessage) {
      res["TimelineConvertErrorMessage"] = boost::any(*timelineConvertErrorMessage);
    }
    if (timelineConvertStatus) {
      res["TimelineConvertStatus"] = boost::any(*timelineConvertStatus);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessConfig") != m.end() && !m["BusinessConfig"].empty()) {
      businessConfig = make_shared<string>(boost::any_cast<string>(m["BusinessConfig"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("ModifiedSource") != m.end() && !m["ModifiedSource"].empty()) {
      modifiedSource = make_shared<string>(boost::any_cast<string>(m["ModifiedSource"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectType") != m.end() && !m["ProjectType"].empty()) {
      projectType = make_shared<string>(boost::any_cast<string>(m["ProjectType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("TimelineConvertErrorMessage") != m.end() && !m["TimelineConvertErrorMessage"].empty()) {
      timelineConvertErrorMessage = make_shared<string>(boost::any_cast<string>(m["TimelineConvertErrorMessage"]));
    }
    if (m.find("TimelineConvertStatus") != m.end() && !m["TimelineConvertStatus"].empty()) {
      timelineConvertStatus = make_shared<string>(boost::any_cast<string>(m["TimelineConvertStatus"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetEditingProjectResponseBodyProject() = default;
};
class GetEditingProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetEditingProjectResponseBodyProject> project{};
  shared_ptr<string> requestId{};

  GetEditingProjectResponseBody() {}

  explicit GetEditingProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (project) {
      res["Project"] = project ? boost::any(project->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      if (typeid(map<string, boost::any>) == m["Project"].type()) {
        GetEditingProjectResponseBodyProject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Project"]));
        project = make_shared<GetEditingProjectResponseBodyProject>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetEditingProjectResponseBody() = default;
};
class GetEditingProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEditingProjectResponseBody> body{};

  GetEditingProjectResponse() {}

  explicit GetEditingProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEditingProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEditingProjectResponseBody>(model1);
      }
    }
  }


  virtual ~GetEditingProjectResponse() = default;
};
class GetEditingProjectMaterialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};

  GetEditingProjectMaterialsRequest() {}

  explicit GetEditingProjectMaterialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~GetEditingProjectMaterialsRequest() = default;
};
class GetEditingProjectMaterialsResponseBodyLiveMaterials : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> liveUrl{};
  shared_ptr<string> streamName{};

  GetEditingProjectMaterialsResponseBodyLiveMaterials() {}

  explicit GetEditingProjectMaterialsResponseBodyLiveMaterials(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (liveUrl) {
      res["LiveUrl"] = boost::any(*liveUrl);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("LiveUrl") != m.end() && !m["LiveUrl"].empty()) {
      liveUrl = make_shared<string>(boost::any_cast<string>(m["LiveUrl"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBodyLiveMaterials() = default;
};
class GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo() {}

  explicit GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo() = default;
};
class GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList : public Darabonba::Model {
public:
  shared_ptr<GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo> fileBasicInfo{};

  GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList() {}

  explicit GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo>(model1);
      }
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList() = default;
};
class GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> snapshots{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteImages{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> transcodeStatus{};
  shared_ptr<string> userData{};

  GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo() {}

  explicit GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteImages) {
      res["SpriteImages"] = boost::any(*spriteImages);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (transcodeStatus) {
      res["TranscodeStatus"] = boost::any(*transcodeStatus);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      snapshots = make_shared<string>(boost::any_cast<string>(m["Snapshots"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteImages") != m.end() && !m["SpriteImages"].empty()) {
      spriteImages = make_shared<string>(boost::any_cast<string>(m["SpriteImages"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TranscodeStatus") != m.end() && !m["TranscodeStatus"].empty()) {
      transcodeStatus = make_shared<string>(boost::any_cast<string>(m["TranscodeStatus"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo() = default;
};
class GetEditingProjectMaterialsResponseBodyMediaInfos : public Darabonba::Model {
public:
  shared_ptr<vector<GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList>> fileInfoList{};
  shared_ptr<GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  GetEditingProjectMaterialsResponseBodyMediaInfos() {}

  explicit GetEditingProjectMaterialsResponseBodyMediaInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList>>(expect1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBodyMediaInfos() = default;
};
class GetEditingProjectMaterialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetEditingProjectMaterialsResponseBodyLiveMaterials>> liveMaterials{};
  shared_ptr<vector<GetEditingProjectMaterialsResponseBodyMediaInfos>> mediaInfos{};
  shared_ptr<string> projectId{};
  shared_ptr<vector<string>> projectMaterials{};
  shared_ptr<string> requestId{};

  GetEditingProjectMaterialsResponseBody() {}

  explicit GetEditingProjectMaterialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveMaterials) {
      vector<boost::any> temp1;
      for(auto item1:*liveMaterials){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveMaterials"] = boost::any(temp1);
    }
    if (mediaInfos) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInfos"] = boost::any(temp1);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectMaterials) {
      res["ProjectMaterials"] = boost::any(*projectMaterials);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveMaterials") != m.end() && !m["LiveMaterials"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveMaterials"].type()) {
        vector<GetEditingProjectMaterialsResponseBodyLiveMaterials> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveMaterials"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEditingProjectMaterialsResponseBodyLiveMaterials model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveMaterials = make_shared<vector<GetEditingProjectMaterialsResponseBodyLiveMaterials>>(expect1);
      }
    }
    if (m.find("MediaInfos") != m.end() && !m["MediaInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInfos"].type()) {
        vector<GetEditingProjectMaterialsResponseBodyMediaInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEditingProjectMaterialsResponseBodyMediaInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInfos = make_shared<vector<GetEditingProjectMaterialsResponseBodyMediaInfos>>(expect1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectMaterials") != m.end() && !m["ProjectMaterials"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProjectMaterials"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProjectMaterials"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      projectMaterials = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetEditingProjectMaterialsResponseBody() = default;
};
class GetEditingProjectMaterialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEditingProjectMaterialsResponseBody> body{};

  GetEditingProjectMaterialsResponse() {}

  explicit GetEditingProjectMaterialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEditingProjectMaterialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEditingProjectMaterialsResponseBody>(model1);
      }
    }
  }


  virtual ~GetEditingProjectMaterialsResponse() = default;
};
class GetEventCallbackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> authKey{};
  shared_ptr<string> authSwitch{};
  shared_ptr<string> callbackQueueName{};
  shared_ptr<string> callbackType{};
  shared_ptr<string> callbackURL{};
  shared_ptr<string> eventTypeList{};
  shared_ptr<string> requestId{};

  GetEventCallbackResponseBody() {}

  explicit GetEventCallbackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (authSwitch) {
      res["AuthSwitch"] = boost::any(*authSwitch);
    }
    if (callbackQueueName) {
      res["CallbackQueueName"] = boost::any(*callbackQueueName);
    }
    if (callbackType) {
      res["CallbackType"] = boost::any(*callbackType);
    }
    if (callbackURL) {
      res["CallbackURL"] = boost::any(*callbackURL);
    }
    if (eventTypeList) {
      res["EventTypeList"] = boost::any(*eventTypeList);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("AuthSwitch") != m.end() && !m["AuthSwitch"].empty()) {
      authSwitch = make_shared<string>(boost::any_cast<string>(m["AuthSwitch"]));
    }
    if (m.find("CallbackQueueName") != m.end() && !m["CallbackQueueName"].empty()) {
      callbackQueueName = make_shared<string>(boost::any_cast<string>(m["CallbackQueueName"]));
    }
    if (m.find("CallbackType") != m.end() && !m["CallbackType"].empty()) {
      callbackType = make_shared<string>(boost::any_cast<string>(m["CallbackType"]));
    }
    if (m.find("CallbackURL") != m.end() && !m["CallbackURL"].empty()) {
      callbackURL = make_shared<string>(boost::any_cast<string>(m["CallbackURL"]));
    }
    if (m.find("EventTypeList") != m.end() && !m["EventTypeList"].empty()) {
      eventTypeList = make_shared<string>(boost::any_cast<string>(m["EventTypeList"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetEventCallbackResponseBody() = default;
};
class GetEventCallbackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEventCallbackResponseBody> body{};

  GetEventCallbackResponse() {}

  explicit GetEventCallbackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEventCallbackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEventCallbackResponseBody>(model1);
      }
    }
  }


  virtual ~GetEventCallbackResponse() = default;
};
class GetHotwordLibraryRequest : public Darabonba::Model {
public:
  shared_ptr<string> hotwordLibraryId{};

  GetHotwordLibraryRequest() {}

  explicit GetHotwordLibraryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotwordLibraryId) {
      res["HotwordLibraryId"] = boost::any(*hotwordLibraryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HotwordLibraryId") != m.end() && !m["HotwordLibraryId"].empty()) {
      hotwordLibraryId = make_shared<string>(boost::any_cast<string>(m["HotwordLibraryId"]));
    }
  }


  virtual ~GetHotwordLibraryRequest() = default;
};
class GetHotwordLibraryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> hotwordLibraryId{};
  shared_ptr<vector<Hotword>> hotwords{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> usageScenario{};

  GetHotwordLibraryResponseBody() {}

  explicit GetHotwordLibraryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hotwordLibraryId) {
      res["HotwordLibraryId"] = boost::any(*hotwordLibraryId);
    }
    if (hotwords) {
      vector<boost::any> temp1;
      for(auto item1:*hotwords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hotwords"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (usageScenario) {
      res["UsageScenario"] = boost::any(*usageScenario);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HotwordLibraryId") != m.end() && !m["HotwordLibraryId"].empty()) {
      hotwordLibraryId = make_shared<string>(boost::any_cast<string>(m["HotwordLibraryId"]));
    }
    if (m.find("Hotwords") != m.end() && !m["Hotwords"].empty()) {
      if (typeid(vector<boost::any>) == m["Hotwords"].type()) {
        vector<Hotword> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hotwords"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Hotword model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotwords = make_shared<vector<Hotword>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UsageScenario") != m.end() && !m["UsageScenario"].empty()) {
      usageScenario = make_shared<string>(boost::any_cast<string>(m["UsageScenario"]));
    }
  }


  virtual ~GetHotwordLibraryResponseBody() = default;
};
class GetHotwordLibraryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHotwordLibraryResponseBody> body{};

  GetHotwordLibraryResponse() {}

  explicit GetHotwordLibraryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHotwordLibraryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHotwordLibraryResponseBody>(model1);
      }
    }
  }


  virtual ~GetHotwordLibraryResponse() = default;
};
class GetLiveEditingIndexFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> projectId{};
  shared_ptr<string> streamName{};

  GetLiveEditingIndexFileRequest() {}

  explicit GetLiveEditingIndexFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~GetLiveEditingIndexFileRequest() = default;
};
class GetLiveEditingIndexFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> indexFile{};
  shared_ptr<string> requestId{};

  GetLiveEditingIndexFileResponseBody() {}

  explicit GetLiveEditingIndexFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (indexFile) {
      res["IndexFile"] = boost::any(*indexFile);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IndexFile") != m.end() && !m["IndexFile"].empty()) {
      indexFile = make_shared<string>(boost::any_cast<string>(m["IndexFile"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLiveEditingIndexFileResponseBody() = default;
};
class GetLiveEditingIndexFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveEditingIndexFileResponseBody> body{};

  GetLiveEditingIndexFileResponse() {}

  explicit GetLiveEditingIndexFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveEditingIndexFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveEditingIndexFileResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveEditingIndexFileResponse() = default;
};
class GetLiveEditingJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetLiveEditingJobRequest() {}

  explicit GetLiveEditingJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetLiveEditingJobRequest() = default;
};
class GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> streamName{};

  GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig() {}

  explicit GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig() = default;
};
class GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig : public Darabonba::Model {
public:
  shared_ptr<string> mode{};

  GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig() {}

  explicit GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
  }


  virtual ~GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig() = default;
};
class GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig : public Darabonba::Model {
public:
  shared_ptr<long> bitrate{};
  shared_ptr<string> fileName{};
  shared_ptr<long> height{};
  shared_ptr<string> mediaURL{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> vodTemplateGroupId{};
  shared_ptr<long> width{};

  GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig() {}

  explicit GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaURL) {
      res["MediaURL"] = boost::any(*mediaURL);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (vodTemplateGroupId) {
      res["VodTemplateGroupId"] = boost::any(*vodTemplateGroupId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("MediaURL") != m.end() && !m["MediaURL"].empty()) {
      mediaURL = make_shared<string>(boost::any_cast<string>(m["MediaURL"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("VodTemplateGroupId") != m.end() && !m["VodTemplateGroupId"].empty()) {
      vodTemplateGroupId = make_shared<string>(boost::any_cast<string>(m["VodTemplateGroupId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig() = default;
};
class GetLiveEditingJobResponseBodyLiveEditingJob : public Darabonba::Model {
public:
  shared_ptr<string> clips{};
  shared_ptr<string> code{};
  shared_ptr<string> completeTime{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> jobId{};
  shared_ptr<GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig> liveStreamConfig{};
  shared_ptr<string> mediaId{};
  shared_ptr<GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig> mediaProduceConfig{};
  shared_ptr<string> mediaURL{};
  shared_ptr<string> message{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig> outputMediaConfig{};
  shared_ptr<string> projectId{};
  shared_ptr<string> status{};
  shared_ptr<string> userData{};

  GetLiveEditingJobResponseBodyLiveEditingJob() {}

  explicit GetLiveEditingJobResponseBodyLiveEditingJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clips) {
      res["Clips"] = boost::any(*clips);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (liveStreamConfig) {
      res["LiveStreamConfig"] = liveStreamConfig ? boost::any(liveStreamConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaProduceConfig) {
      res["MediaProduceConfig"] = mediaProduceConfig ? boost::any(mediaProduceConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaURL) {
      res["MediaURL"] = boost::any(*mediaURL);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (outputMediaConfig) {
      res["OutputMediaConfig"] = outputMediaConfig ? boost::any(outputMediaConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clips") != m.end() && !m["Clips"].empty()) {
      clips = make_shared<string>(boost::any_cast<string>(m["Clips"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("LiveStreamConfig") != m.end() && !m["LiveStreamConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveStreamConfig"].type()) {
        GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveStreamConfig"]));
        liveStreamConfig = make_shared<GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaProduceConfig") != m.end() && !m["MediaProduceConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaProduceConfig"].type()) {
        GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaProduceConfig"]));
        mediaProduceConfig = make_shared<GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig>(model1);
      }
    }
    if (m.find("MediaURL") != m.end() && !m["MediaURL"].empty()) {
      mediaURL = make_shared<string>(boost::any_cast<string>(m["MediaURL"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OutputMediaConfig") != m.end() && !m["OutputMediaConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputMediaConfig"].type()) {
        GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputMediaConfig"]));
        outputMediaConfig = make_shared<GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig>(model1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetLiveEditingJobResponseBodyLiveEditingJob() = default;
};
class GetLiveEditingJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetLiveEditingJobResponseBodyLiveEditingJob> liveEditingJob{};
  shared_ptr<string> requestId{};

  GetLiveEditingJobResponseBody() {}

  explicit GetLiveEditingJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveEditingJob) {
      res["LiveEditingJob"] = liveEditingJob ? boost::any(liveEditingJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveEditingJob") != m.end() && !m["LiveEditingJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["LiveEditingJob"].type()) {
        GetLiveEditingJobResponseBodyLiveEditingJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LiveEditingJob"]));
        liveEditingJob = make_shared<GetLiveEditingJobResponseBodyLiveEditingJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLiveEditingJobResponseBody() = default;
};
class GetLiveEditingJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveEditingJobResponseBody> body{};

  GetLiveEditingJobResponse() {}

  explicit GetLiveEditingJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveEditingJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveEditingJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveEditingJobResponse() = default;
};
class GetLivePackageChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> groupName{};

  GetLivePackageChannelRequest() {}

  explicit GetLivePackageChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~GetLivePackageChannelRequest() = default;
};
class GetLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> password{};
  shared_ptr<string> url{};
  shared_ptr<string> username{};

  GetLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints() {}

  explicit GetLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~GetLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints() = default;
};
class GetLivePackageChannelResponseBodyLivePackageChannel : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<vector<GetLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints>> ingestEndpoints{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> protocol{};
  shared_ptr<long> segmentCount{};
  shared_ptr<long> segmentDuration{};

  GetLivePackageChannelResponseBodyLivePackageChannel() {}

  explicit GetLivePackageChannelResponseBodyLivePackageChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (ingestEndpoints) {
      vector<boost::any> temp1;
      for(auto item1:*ingestEndpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngestEndpoints"] = boost::any(temp1);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (segmentCount) {
      res["SegmentCount"] = boost::any(*segmentCount);
    }
    if (segmentDuration) {
      res["SegmentDuration"] = boost::any(*segmentDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IngestEndpoints") != m.end() && !m["IngestEndpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["IngestEndpoints"].type()) {
        vector<GetLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngestEndpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingestEndpoints = make_shared<vector<GetLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints>>(expect1);
      }
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SegmentCount") != m.end() && !m["SegmentCount"].empty()) {
      segmentCount = make_shared<long>(boost::any_cast<long>(m["SegmentCount"]));
    }
    if (m.find("SegmentDuration") != m.end() && !m["SegmentDuration"].empty()) {
      segmentDuration = make_shared<long>(boost::any_cast<long>(m["SegmentDuration"]));
    }
  }


  virtual ~GetLivePackageChannelResponseBodyLivePackageChannel() = default;
};
class GetLivePackageChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetLivePackageChannelResponseBodyLivePackageChannel> livePackageChannel{};
  shared_ptr<string> requestId{};

  GetLivePackageChannelResponseBody() {}

  explicit GetLivePackageChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livePackageChannel) {
      res["LivePackageChannel"] = livePackageChannel ? boost::any(livePackageChannel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivePackageChannel") != m.end() && !m["LivePackageChannel"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivePackageChannel"].type()) {
        GetLivePackageChannelResponseBodyLivePackageChannel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivePackageChannel"]));
        livePackageChannel = make_shared<GetLivePackageChannelResponseBodyLivePackageChannel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLivePackageChannelResponseBody() = default;
};
class GetLivePackageChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLivePackageChannelResponseBody> body{};

  GetLivePackageChannelResponse() {}

  explicit GetLivePackageChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLivePackageChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLivePackageChannelResponseBody>(model1);
      }
    }
  }


  virtual ~GetLivePackageChannelResponse() = default;
};
class GetLivePackageChannelGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};

  GetLivePackageChannelGroupRequest() {}

  explicit GetLivePackageChannelGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~GetLivePackageChannelGroupRequest() = default;
};
class GetLivePackageChannelGroupResponseBodyLivePackageChannelGroup : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> originDomain{};

  GetLivePackageChannelGroupResponseBodyLivePackageChannelGroup() {}

  explicit GetLivePackageChannelGroupResponseBodyLivePackageChannelGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (originDomain) {
      res["OriginDomain"] = boost::any(*originDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("OriginDomain") != m.end() && !m["OriginDomain"].empty()) {
      originDomain = make_shared<string>(boost::any_cast<string>(m["OriginDomain"]));
    }
  }


  virtual ~GetLivePackageChannelGroupResponseBodyLivePackageChannelGroup() = default;
};
class GetLivePackageChannelGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetLivePackageChannelGroupResponseBodyLivePackageChannelGroup> livePackageChannelGroup{};
  shared_ptr<string> requestId{};

  GetLivePackageChannelGroupResponseBody() {}

  explicit GetLivePackageChannelGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livePackageChannelGroup) {
      res["LivePackageChannelGroup"] = livePackageChannelGroup ? boost::any(livePackageChannelGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivePackageChannelGroup") != m.end() && !m["LivePackageChannelGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivePackageChannelGroup"].type()) {
        GetLivePackageChannelGroupResponseBodyLivePackageChannelGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivePackageChannelGroup"]));
        livePackageChannelGroup = make_shared<GetLivePackageChannelGroupResponseBodyLivePackageChannelGroup>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLivePackageChannelGroupResponseBody() = default;
};
class GetLivePackageChannelGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLivePackageChannelGroupResponseBody> body{};

  GetLivePackageChannelGroupResponse() {}

  explicit GetLivePackageChannelGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLivePackageChannelGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLivePackageChannelGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetLivePackageChannelGroupResponse() = default;
};
class GetLivePackageOriginEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> groupName{};

  GetLivePackageOriginEndpointRequest() {}

  explicit GetLivePackageOriginEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~GetLivePackageOriginEndpointRequest() = default;
};
class GetLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> authorizationCode{};
  shared_ptr<string> channelName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> endpointUrl{};
  shared_ptr<string> groupName{};
  shared_ptr<string> ipBlacklist{};
  shared_ptr<string> ipWhitelist{};
  shared_ptr<string> lastModified{};
  shared_ptr<LivePackagingConfig> livePackagingConfig{};
  shared_ptr<string> manifestName{};
  shared_ptr<string> protocol{};
  shared_ptr<long> timeshiftVision{};

  GetLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint() {}

  explicit GetLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizationCode) {
      res["AuthorizationCode"] = boost::any(*authorizationCode);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (endpointUrl) {
      res["EndpointUrl"] = boost::any(*endpointUrl);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (ipBlacklist) {
      res["IpBlacklist"] = boost::any(*ipBlacklist);
    }
    if (ipWhitelist) {
      res["IpWhitelist"] = boost::any(*ipWhitelist);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (livePackagingConfig) {
      res["LivePackagingConfig"] = livePackagingConfig ? boost::any(livePackagingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (manifestName) {
      res["ManifestName"] = boost::any(*manifestName);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (timeshiftVision) {
      res["TimeshiftVision"] = boost::any(*timeshiftVision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizationCode") != m.end() && !m["AuthorizationCode"].empty()) {
      authorizationCode = make_shared<string>(boost::any_cast<string>(m["AuthorizationCode"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("EndpointUrl") != m.end() && !m["EndpointUrl"].empty()) {
      endpointUrl = make_shared<string>(boost::any_cast<string>(m["EndpointUrl"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IpBlacklist") != m.end() && !m["IpBlacklist"].empty()) {
      ipBlacklist = make_shared<string>(boost::any_cast<string>(m["IpBlacklist"]));
    }
    if (m.find("IpWhitelist") != m.end() && !m["IpWhitelist"].empty()) {
      ipWhitelist = make_shared<string>(boost::any_cast<string>(m["IpWhitelist"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("LivePackagingConfig") != m.end() && !m["LivePackagingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivePackagingConfig"].type()) {
        LivePackagingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivePackagingConfig"]));
        livePackagingConfig = make_shared<LivePackagingConfig>(model1);
      }
    }
    if (m.find("ManifestName") != m.end() && !m["ManifestName"].empty()) {
      manifestName = make_shared<string>(boost::any_cast<string>(m["ManifestName"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("TimeshiftVision") != m.end() && !m["TimeshiftVision"].empty()) {
      timeshiftVision = make_shared<long>(boost::any_cast<long>(m["TimeshiftVision"]));
    }
  }


  virtual ~GetLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint() = default;
};
class GetLivePackageOriginEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint> livePackageOriginEndpoint{};
  shared_ptr<string> requestId{};

  GetLivePackageOriginEndpointResponseBody() {}

  explicit GetLivePackageOriginEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livePackageOriginEndpoint) {
      res["LivePackageOriginEndpoint"] = livePackageOriginEndpoint ? boost::any(livePackageOriginEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivePackageOriginEndpoint") != m.end() && !m["LivePackageOriginEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivePackageOriginEndpoint"].type()) {
        GetLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivePackageOriginEndpoint"]));
        livePackageOriginEndpoint = make_shared<GetLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLivePackageOriginEndpointResponseBody() = default;
};
class GetLivePackageOriginEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLivePackageOriginEndpointResponseBody> body{};

  GetLivePackageOriginEndpointResponse() {}

  explicit GetLivePackageOriginEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLivePackageOriginEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLivePackageOriginEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~GetLivePackageOriginEndpointResponse() = default;
};
class GetLiveRecordJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetLiveRecordJobRequest() {}

  explicit GetLiveRecordJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetLiveRecordJobRequest() = default;
};
class GetLiveRecordJobResponseBodyRecordJobRecordOutput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> type{};

  GetLiveRecordJobResponseBodyRecordJobRecordOutput() {}

  explicit GetLiveRecordJobResponseBodyRecordJobRecordOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetLiveRecordJobResponseBodyRecordJobRecordOutput() = default;
};
class GetLiveRecordJobResponseBodyRecordJobStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  GetLiveRecordJobResponseBodyRecordJobStreamInput() {}

  explicit GetLiveRecordJobResponseBodyRecordJobStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetLiveRecordJobResponseBodyRecordJobStreamInput() = default;
};
class GetLiveRecordJobResponseBodyRecordJob : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<GetLiveRecordJobResponseBodyRecordJobRecordOutput> recordOutput{};
  shared_ptr<string> status{};
  shared_ptr<GetLiveRecordJobResponseBodyRecordJobStreamInput> streamInput{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  GetLiveRecordJobResponseBodyRecordJob() {}

  explicit GetLiveRecordJobResponseBodyRecordJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (recordOutput) {
      res["RecordOutput"] = recordOutput ? boost::any(recordOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("RecordOutput") != m.end() && !m["RecordOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordOutput"].type()) {
        GetLiveRecordJobResponseBodyRecordJobRecordOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordOutput"]));
        recordOutput = make_shared<GetLiveRecordJobResponseBodyRecordJobRecordOutput>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        GetLiveRecordJobResponseBodyRecordJobStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<GetLiveRecordJobResponseBodyRecordJobStreamInput>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~GetLiveRecordJobResponseBodyRecordJob() = default;
};
class GetLiveRecordJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetLiveRecordJobResponseBodyRecordJob> recordJob{};
  shared_ptr<string> requestId{};

  GetLiveRecordJobResponseBody() {}

  explicit GetLiveRecordJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordJob) {
      res["RecordJob"] = recordJob ? boost::any(recordJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordJob") != m.end() && !m["RecordJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordJob"].type()) {
        GetLiveRecordJobResponseBodyRecordJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordJob"]));
        recordJob = make_shared<GetLiveRecordJobResponseBodyRecordJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLiveRecordJobResponseBody() = default;
};
class GetLiveRecordJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveRecordJobResponseBody> body{};

  GetLiveRecordJobResponse() {}

  explicit GetLiveRecordJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveRecordJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveRecordJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveRecordJobResponse() = default;
};
class GetLiveRecordTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> templateId{};

  GetLiveRecordTemplateRequest() {}

  explicit GetLiveRecordTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetLiveRecordTemplateRequest() = default;
};
class GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<long> sliceDuration{};
  shared_ptr<string> sliceOssObjectPrefix{};

  GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList() {}

  explicit GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList() = default;
};
class GetLiveRecordTemplateResponseBodyRecordTemplate : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> name{};
  shared_ptr<vector<GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList>> recordFormatList{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  GetLiveRecordTemplateResponseBodyRecordTemplate() {}

  explicit GetLiveRecordTemplateResponseBodyRecordTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordFormatList) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormatList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormatList"] = boost::any(temp1);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordFormatList") != m.end() && !m["RecordFormatList"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormatList"].type()) {
        vector<GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormatList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormatList = make_shared<vector<GetLiveRecordTemplateResponseBodyRecordTemplateRecordFormatList>>(expect1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetLiveRecordTemplateResponseBodyRecordTemplate() = default;
};
class GetLiveRecordTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetLiveRecordTemplateResponseBodyRecordTemplate> recordTemplate{};
  shared_ptr<string> requestId{};

  GetLiveRecordTemplateResponseBody() {}

  explicit GetLiveRecordTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordTemplate) {
      res["RecordTemplate"] = recordTemplate ? boost::any(recordTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordTemplate") != m.end() && !m["RecordTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordTemplate"].type()) {
        GetLiveRecordTemplateResponseBodyRecordTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordTemplate"]));
        recordTemplate = make_shared<GetLiveRecordTemplateResponseBodyRecordTemplate>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLiveRecordTemplateResponseBody() = default;
};
class GetLiveRecordTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveRecordTemplateResponseBody> body{};

  GetLiveRecordTemplateResponse() {}

  explicit GetLiveRecordTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveRecordTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveRecordTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveRecordTemplateResponse() = default;
};
class GetLiveSnapshotJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetLiveSnapshotJobRequest() {}

  explicit GetLiveSnapshotJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetLiveSnapshotJobRequest() = default;
};
class GetLiveSnapshotJobResponseBodySnapshotOutput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> storageType{};

  GetLiveSnapshotJobResponseBodySnapshotOutput() {}

  explicit GetLiveSnapshotJobResponseBodySnapshotOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~GetLiveSnapshotJobResponseBodySnapshotOutput() = default;
};
class GetLiveSnapshotJobResponseBodyStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  GetLiveSnapshotJobResponseBodyStreamInput() {}

  explicit GetLiveSnapshotJobResponseBodyStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetLiveSnapshotJobResponseBodyStreamInput() = default;
};
class GetLiveSnapshotJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> createTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> overwriteFormat{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sequenceFormat{};
  shared_ptr<GetLiveSnapshotJobResponseBodySnapshotOutput> snapshotOutput{};
  shared_ptr<string> status{};
  shared_ptr<GetLiveSnapshotJobResponseBodyStreamInput> streamInput{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> timeInterval{};

  GetLiveSnapshotJobResponseBody() {}

  explicit GetLiveSnapshotJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (overwriteFormat) {
      res["OverwriteFormat"] = boost::any(*overwriteFormat);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sequenceFormat) {
      res["SequenceFormat"] = boost::any(*sequenceFormat);
    }
    if (snapshotOutput) {
      res["SnapshotOutput"] = snapshotOutput ? boost::any(snapshotOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("OverwriteFormat") != m.end() && !m["OverwriteFormat"].empty()) {
      overwriteFormat = make_shared<string>(boost::any_cast<string>(m["OverwriteFormat"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SequenceFormat") != m.end() && !m["SequenceFormat"].empty()) {
      sequenceFormat = make_shared<string>(boost::any_cast<string>(m["SequenceFormat"]));
    }
    if (m.find("SnapshotOutput") != m.end() && !m["SnapshotOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotOutput"].type()) {
        GetLiveSnapshotJobResponseBodySnapshotOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotOutput"]));
        snapshotOutput = make_shared<GetLiveSnapshotJobResponseBodySnapshotOutput>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        GetLiveSnapshotJobResponseBodyStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<GetLiveSnapshotJobResponseBodyStreamInput>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
  }


  virtual ~GetLiveSnapshotJobResponseBody() = default;
};
class GetLiveSnapshotJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveSnapshotJobResponseBody> body{};

  GetLiveSnapshotJobResponse() {}

  explicit GetLiveSnapshotJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveSnapshotJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveSnapshotJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveSnapshotJobResponse() = default;
};
class GetLiveSnapshotTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  GetLiveSnapshotTemplateRequest() {}

  explicit GetLiveSnapshotTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetLiveSnapshotTemplateRequest() = default;
};
class GetLiveSnapshotTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> overwriteFormat{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sequenceFormat{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> timeInterval{};
  shared_ptr<string> type{};

  GetLiveSnapshotTemplateResponseBody() {}

  explicit GetLiveSnapshotTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (overwriteFormat) {
      res["OverwriteFormat"] = boost::any(*overwriteFormat);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sequenceFormat) {
      res["SequenceFormat"] = boost::any(*sequenceFormat);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("OverwriteFormat") != m.end() && !m["OverwriteFormat"].empty()) {
      overwriteFormat = make_shared<string>(boost::any_cast<string>(m["OverwriteFormat"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SequenceFormat") != m.end() && !m["SequenceFormat"].empty()) {
      sequenceFormat = make_shared<string>(boost::any_cast<string>(m["SequenceFormat"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetLiveSnapshotTemplateResponseBody() = default;
};
class GetLiveSnapshotTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveSnapshotTemplateResponseBody> body{};

  GetLiveSnapshotTemplateResponse() {}

  explicit GetLiveSnapshotTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveSnapshotTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveSnapshotTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveSnapshotTemplateResponse() = default;
};
class GetLiveTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetLiveTranscodeJobRequest() {}

  explicit GetLiveTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetLiveTranscodeJobRequest() = default;
};
class GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos : public Darabonba::Model {
public:
  shared_ptr<string> outputUrl{};
  shared_ptr<string> type{};

  GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos() {}

  explicit GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputUrl) {
      res["OutputUrl"] = boost::any(*outputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputUrl") != m.end() && !m["OutputUrl"].empty()) {
      outputUrl = make_shared<string>(boost::any_cast<string>(m["OutputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos() = default;
};
class GetLiveTranscodeJobResponseBodyJobOutputStream : public Darabonba::Model {
public:
  shared_ptr<vector<GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos>> streamInfos{};

  GetLiveTranscodeJobResponseBodyJobOutputStream() {}

  explicit GetLiveTranscodeJobResponseBodyJobOutputStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamInfos) {
      vector<boost::any> temp1;
      for(auto item1:*streamInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamInfos") != m.end() && !m["StreamInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamInfos"].type()) {
        vector<GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamInfos = make_shared<vector<GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos>>(expect1);
      }
    }
  }


  virtual ~GetLiveTranscodeJobResponseBodyJobOutputStream() = default;
};
class GetLiveTranscodeJobResponseBodyJobStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> inputUrl{};
  shared_ptr<string> type{};

  GetLiveTranscodeJobResponseBodyJobStreamInput() {}

  explicit GetLiveTranscodeJobResponseBodyJobStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputUrl) {
      res["InputUrl"] = boost::any(*inputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputUrl") != m.end() && !m["InputUrl"].empty()) {
      inputUrl = make_shared<string>(boost::any_cast<string>(m["InputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetLiveTranscodeJobResponseBodyJobStreamInput() = default;
};
class GetLiveTranscodeJobResponseBodyJob : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<GetLiveTranscodeJobResponseBodyJobOutputStream> outputStream{};
  shared_ptr<long> startMode{};
  shared_ptr<long> status{};
  shared_ptr<GetLiveTranscodeJobResponseBodyJobStreamInput> streamInput{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateType{};

  GetLiveTranscodeJobResponseBodyJob() {}

  explicit GetLiveTranscodeJobResponseBodyJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputStream) {
      res["OutputStream"] = outputStream ? boost::any(outputStream->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startMode) {
      res["StartMode"] = boost::any(*startMode);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputStream") != m.end() && !m["OutputStream"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputStream"].type()) {
        GetLiveTranscodeJobResponseBodyJobOutputStream model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputStream"]));
        outputStream = make_shared<GetLiveTranscodeJobResponseBodyJobOutputStream>(model1);
      }
    }
    if (m.find("StartMode") != m.end() && !m["StartMode"].empty()) {
      startMode = make_shared<long>(boost::any_cast<long>(m["StartMode"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        GetLiveTranscodeJobResponseBodyJobStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<GetLiveTranscodeJobResponseBodyJobStreamInput>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~GetLiveTranscodeJobResponseBodyJob() = default;
};
class GetLiveTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetLiveTranscodeJobResponseBodyJob> job{};
  shared_ptr<string> requestId{};

  GetLiveTranscodeJobResponseBody() {}

  explicit GetLiveTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      res["Job"] = job ? boost::any(job->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(map<string, boost::any>) == m["Job"].type()) {
        GetLiveTranscodeJobResponseBodyJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Job"]));
        job = make_shared<GetLiveTranscodeJobResponseBodyJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLiveTranscodeJobResponseBody() = default;
};
class GetLiveTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveTranscodeJobResponseBody> body{};

  GetLiveTranscodeJobResponse() {}

  explicit GetLiveTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveTranscodeJobResponse() = default;
};
class GetLiveTranscodeTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  GetLiveTranscodeTemplateRequest() {}

  explicit GetLiveTranscodeTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetLiveTranscodeTemplateRequest() = default;
};
class GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> samplerate{};

  GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams() {}

  explicit GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams() = default;
};
class GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> codec{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> profile{};
  shared_ptr<string> width{};

  GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams() {}

  explicit GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams() = default;
};
class GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig : public Darabonba::Model {
public:
  shared_ptr<GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams> audioParams{};
  shared_ptr<GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams> videoParams{};

  GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig() {}

  explicit GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioParams) {
      res["AudioParams"] = audioParams ? boost::any(audioParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoParams) {
      res["VideoParams"] = videoParams ? boost::any(videoParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioParams") != m.end() && !m["AudioParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioParams"].type()) {
        GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioParams"]));
        audioParams = make_shared<GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams>(model1);
      }
    }
    if (m.find("VideoParams") != m.end() && !m["VideoParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoParams"].type()) {
        GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoParams"]));
        videoParams = make_shared<GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams>(model1);
      }
    }
  }


  virtual ~GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig() = default;
};
class GetLiveTranscodeTemplateResponseBodyTemplateContent : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<string> name{};
  shared_ptr<GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  GetLiveTranscodeTemplateResponseBodyTemplateContent() {}

  explicit GetLiveTranscodeTemplateResponseBodyTemplateContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetLiveTranscodeTemplateResponseBodyTemplateContent() = default;
};
class GetLiveTranscodeTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetLiveTranscodeTemplateResponseBodyTemplateContent> templateContent{};

  GetLiveTranscodeTemplateResponseBody() {}

  explicit GetLiveTranscodeTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateContent) {
      res["TemplateContent"] = templateContent ? boost::any(templateContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateContent") != m.end() && !m["TemplateContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateContent"].type()) {
        GetLiveTranscodeTemplateResponseBodyTemplateContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateContent"]));
        templateContent = make_shared<GetLiveTranscodeTemplateResponseBodyTemplateContent>(model1);
      }
    }
  }


  virtual ~GetLiveTranscodeTemplateResponseBody() = default;
};
class GetLiveTranscodeTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLiveTranscodeTemplateResponseBody> body{};

  GetLiveTranscodeTemplateResponse() {}

  explicit GetLiveTranscodeTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLiveTranscodeTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLiveTranscodeTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetLiveTranscodeTemplateResponse() = default;
};
class GetMediaConnectFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};

  GetMediaConnectFlowRequest() {}

  explicit GetMediaConnectFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
  }


  virtual ~GetMediaConnectFlowRequest() = default;
};
class GetMediaConnectFlowResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> flowFailover{};
  shared_ptr<string> flowId{};
  shared_ptr<string> flowName{};
  shared_ptr<string> flowStatus{};
  shared_ptr<string> startTime{};

  GetMediaConnectFlowResponseBodyContent() {}

  explicit GetMediaConnectFlowResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (flowFailover) {
      res["FlowFailover"] = boost::any(*flowFailover);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowName) {
      res["FlowName"] = boost::any(*flowName);
    }
    if (flowStatus) {
      res["FlowStatus"] = boost::any(*flowStatus);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FlowFailover") != m.end() && !m["FlowFailover"].empty()) {
      flowFailover = make_shared<string>(boost::any_cast<string>(m["FlowFailover"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowName") != m.end() && !m["FlowName"].empty()) {
      flowName = make_shared<string>(boost::any_cast<string>(m["FlowName"]));
    }
    if (m.find("FlowStatus") != m.end() && !m["FlowStatus"].empty()) {
      flowStatus = make_shared<string>(boost::any_cast<string>(m["FlowStatus"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetMediaConnectFlowResponseBodyContent() = default;
};
class GetMediaConnectFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaConnectFlowResponseBodyContent> content{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retcode{};

  GetMediaConnectFlowResponseBody() {}

  explicit GetMediaConnectFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retcode) {
      res["Retcode"] = boost::any(*retcode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        GetMediaConnectFlowResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<GetMediaConnectFlowResponseBodyContent>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Retcode") != m.end() && !m["Retcode"].empty()) {
      retcode = make_shared<long>(boost::any_cast<long>(m["Retcode"]));
    }
  }


  virtual ~GetMediaConnectFlowResponseBody() = default;
};
class GetMediaConnectFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaConnectFlowResponseBody> body{};

  GetMediaConnectFlowResponse() {}

  explicit GetMediaConnectFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaConnectFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaConnectFlowResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaConnectFlowResponse() = default;
};
class GetMediaConnectFlowInputRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};

  GetMediaConnectFlowInputRequest() {}

  explicit GetMediaConnectFlowInputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
  }


  virtual ~GetMediaConnectFlowInputRequest() = default;
};
class GetMediaConnectFlowInputResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> backupCidrs{};
  shared_ptr<string> backupCreateTime{};
  shared_ptr<string> backupInputName{};
  shared_ptr<string> backupInputStatus{};
  shared_ptr<string> backupInputUrl{};
  shared_ptr<long> backupMaxBitrate{};
  shared_ptr<long> backupSrtLatency{};
  shared_ptr<string> backupSrtPassphrase{};
  shared_ptr<long> backupSrtPbkeyLen{};
  shared_ptr<string> cidrs{};
  shared_ptr<string> createTime{};
  shared_ptr<string> inputName{};
  shared_ptr<string> inputProtocol{};
  shared_ptr<string> inputStatus{};
  shared_ptr<string> inputUrl{};
  shared_ptr<long> maxBitrate{};
  shared_ptr<string> pairFlowId{};
  shared_ptr<string> pairOutputName{};
  shared_ptr<long> srtLatency{};
  shared_ptr<string> srtPassphrase{};
  shared_ptr<long> srtPbkeyLen{};

  GetMediaConnectFlowInputResponseBodyContent() {}

  explicit GetMediaConnectFlowInputResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupCidrs) {
      res["BackupCidrs"] = boost::any(*backupCidrs);
    }
    if (backupCreateTime) {
      res["BackupCreateTime"] = boost::any(*backupCreateTime);
    }
    if (backupInputName) {
      res["BackupInputName"] = boost::any(*backupInputName);
    }
    if (backupInputStatus) {
      res["BackupInputStatus"] = boost::any(*backupInputStatus);
    }
    if (backupInputUrl) {
      res["BackupInputUrl"] = boost::any(*backupInputUrl);
    }
    if (backupMaxBitrate) {
      res["BackupMaxBitrate"] = boost::any(*backupMaxBitrate);
    }
    if (backupSrtLatency) {
      res["BackupSrtLatency"] = boost::any(*backupSrtLatency);
    }
    if (backupSrtPassphrase) {
      res["BackupSrtPassphrase"] = boost::any(*backupSrtPassphrase);
    }
    if (backupSrtPbkeyLen) {
      res["BackupSrtPbkeyLen"] = boost::any(*backupSrtPbkeyLen);
    }
    if (cidrs) {
      res["Cidrs"] = boost::any(*cidrs);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (inputName) {
      res["InputName"] = boost::any(*inputName);
    }
    if (inputProtocol) {
      res["InputProtocol"] = boost::any(*inputProtocol);
    }
    if (inputStatus) {
      res["InputStatus"] = boost::any(*inputStatus);
    }
    if (inputUrl) {
      res["InputUrl"] = boost::any(*inputUrl);
    }
    if (maxBitrate) {
      res["MaxBitrate"] = boost::any(*maxBitrate);
    }
    if (pairFlowId) {
      res["PairFlowId"] = boost::any(*pairFlowId);
    }
    if (pairOutputName) {
      res["PairOutputName"] = boost::any(*pairOutputName);
    }
    if (srtLatency) {
      res["SrtLatency"] = boost::any(*srtLatency);
    }
    if (srtPassphrase) {
      res["SrtPassphrase"] = boost::any(*srtPassphrase);
    }
    if (srtPbkeyLen) {
      res["SrtPbkeyLen"] = boost::any(*srtPbkeyLen);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupCidrs") != m.end() && !m["BackupCidrs"].empty()) {
      backupCidrs = make_shared<string>(boost::any_cast<string>(m["BackupCidrs"]));
    }
    if (m.find("BackupCreateTime") != m.end() && !m["BackupCreateTime"].empty()) {
      backupCreateTime = make_shared<string>(boost::any_cast<string>(m["BackupCreateTime"]));
    }
    if (m.find("BackupInputName") != m.end() && !m["BackupInputName"].empty()) {
      backupInputName = make_shared<string>(boost::any_cast<string>(m["BackupInputName"]));
    }
    if (m.find("BackupInputStatus") != m.end() && !m["BackupInputStatus"].empty()) {
      backupInputStatus = make_shared<string>(boost::any_cast<string>(m["BackupInputStatus"]));
    }
    if (m.find("BackupInputUrl") != m.end() && !m["BackupInputUrl"].empty()) {
      backupInputUrl = make_shared<string>(boost::any_cast<string>(m["BackupInputUrl"]));
    }
    if (m.find("BackupMaxBitrate") != m.end() && !m["BackupMaxBitrate"].empty()) {
      backupMaxBitrate = make_shared<long>(boost::any_cast<long>(m["BackupMaxBitrate"]));
    }
    if (m.find("BackupSrtLatency") != m.end() && !m["BackupSrtLatency"].empty()) {
      backupSrtLatency = make_shared<long>(boost::any_cast<long>(m["BackupSrtLatency"]));
    }
    if (m.find("BackupSrtPassphrase") != m.end() && !m["BackupSrtPassphrase"].empty()) {
      backupSrtPassphrase = make_shared<string>(boost::any_cast<string>(m["BackupSrtPassphrase"]));
    }
    if (m.find("BackupSrtPbkeyLen") != m.end() && !m["BackupSrtPbkeyLen"].empty()) {
      backupSrtPbkeyLen = make_shared<long>(boost::any_cast<long>(m["BackupSrtPbkeyLen"]));
    }
    if (m.find("Cidrs") != m.end() && !m["Cidrs"].empty()) {
      cidrs = make_shared<string>(boost::any_cast<string>(m["Cidrs"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("InputName") != m.end() && !m["InputName"].empty()) {
      inputName = make_shared<string>(boost::any_cast<string>(m["InputName"]));
    }
    if (m.find("InputProtocol") != m.end() && !m["InputProtocol"].empty()) {
      inputProtocol = make_shared<string>(boost::any_cast<string>(m["InputProtocol"]));
    }
    if (m.find("InputStatus") != m.end() && !m["InputStatus"].empty()) {
      inputStatus = make_shared<string>(boost::any_cast<string>(m["InputStatus"]));
    }
    if (m.find("InputUrl") != m.end() && !m["InputUrl"].empty()) {
      inputUrl = make_shared<string>(boost::any_cast<string>(m["InputUrl"]));
    }
    if (m.find("MaxBitrate") != m.end() && !m["MaxBitrate"].empty()) {
      maxBitrate = make_shared<long>(boost::any_cast<long>(m["MaxBitrate"]));
    }
    if (m.find("PairFlowId") != m.end() && !m["PairFlowId"].empty()) {
      pairFlowId = make_shared<string>(boost::any_cast<string>(m["PairFlowId"]));
    }
    if (m.find("PairOutputName") != m.end() && !m["PairOutputName"].empty()) {
      pairOutputName = make_shared<string>(boost::any_cast<string>(m["PairOutputName"]));
    }
    if (m.find("SrtLatency") != m.end() && !m["SrtLatency"].empty()) {
      srtLatency = make_shared<long>(boost::any_cast<long>(m["SrtLatency"]));
    }
    if (m.find("SrtPassphrase") != m.end() && !m["SrtPassphrase"].empty()) {
      srtPassphrase = make_shared<string>(boost::any_cast<string>(m["SrtPassphrase"]));
    }
    if (m.find("SrtPbkeyLen") != m.end() && !m["SrtPbkeyLen"].empty()) {
      srtPbkeyLen = make_shared<long>(boost::any_cast<long>(m["SrtPbkeyLen"]));
    }
  }


  virtual ~GetMediaConnectFlowInputResponseBodyContent() = default;
};
class GetMediaConnectFlowInputResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaConnectFlowInputResponseBodyContent> content{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};

  GetMediaConnectFlowInputResponseBody() {}

  explicit GetMediaConnectFlowInputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        GetMediaConnectFlowInputResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<GetMediaConnectFlowInputResponseBodyContent>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
  }


  virtual ~GetMediaConnectFlowInputResponseBody() = default;
};
class GetMediaConnectFlowInputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaConnectFlowInputResponseBody> body{};

  GetMediaConnectFlowInputResponse() {}

  explicit GetMediaConnectFlowInputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaConnectFlowInputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaConnectFlowInputResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaConnectFlowInputResponse() = default;
};
class GetMediaConnectFlowOutputRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};
  shared_ptr<string> outputName{};

  GetMediaConnectFlowOutputRequest() {}

  explicit GetMediaConnectFlowOutputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (outputName) {
      res["OutputName"] = boost::any(*outputName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("OutputName") != m.end() && !m["OutputName"].empty()) {
      outputName = make_shared<string>(boost::any_cast<string>(m["OutputName"]));
    }
  }


  virtual ~GetMediaConnectFlowOutputRequest() = default;
};
class GetMediaConnectFlowOutputResponseBodyContent : public Darabonba::Model {
public:
  shared_ptr<string> cidrs{};
  shared_ptr<string> createTime{};
  shared_ptr<string> forbid{};
  shared_ptr<string> outputName{};
  shared_ptr<string> outputProtocol{};
  shared_ptr<string> outputUrl{};
  shared_ptr<string> pairFlowId{};
  shared_ptr<string> pairInputName{};
  shared_ptr<long> playerLimit{};
  shared_ptr<long> srtLatency{};
  shared_ptr<string> srtPassphrase{};
  shared_ptr<long> srtPbkeyLen{};

  GetMediaConnectFlowOutputResponseBodyContent() {}

  explicit GetMediaConnectFlowOutputResponseBodyContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrs) {
      res["Cidrs"] = boost::any(*cidrs);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (forbid) {
      res["Forbid"] = boost::any(*forbid);
    }
    if (outputName) {
      res["OutputName"] = boost::any(*outputName);
    }
    if (outputProtocol) {
      res["OutputProtocol"] = boost::any(*outputProtocol);
    }
    if (outputUrl) {
      res["OutputUrl"] = boost::any(*outputUrl);
    }
    if (pairFlowId) {
      res["PairFlowId"] = boost::any(*pairFlowId);
    }
    if (pairInputName) {
      res["PairInputName"] = boost::any(*pairInputName);
    }
    if (playerLimit) {
      res["PlayerLimit"] = boost::any(*playerLimit);
    }
    if (srtLatency) {
      res["SrtLatency"] = boost::any(*srtLatency);
    }
    if (srtPassphrase) {
      res["SrtPassphrase"] = boost::any(*srtPassphrase);
    }
    if (srtPbkeyLen) {
      res["SrtPbkeyLen"] = boost::any(*srtPbkeyLen);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cidrs") != m.end() && !m["Cidrs"].empty()) {
      cidrs = make_shared<string>(boost::any_cast<string>(m["Cidrs"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Forbid") != m.end() && !m["Forbid"].empty()) {
      forbid = make_shared<string>(boost::any_cast<string>(m["Forbid"]));
    }
    if (m.find("OutputName") != m.end() && !m["OutputName"].empty()) {
      outputName = make_shared<string>(boost::any_cast<string>(m["OutputName"]));
    }
    if (m.find("OutputProtocol") != m.end() && !m["OutputProtocol"].empty()) {
      outputProtocol = make_shared<string>(boost::any_cast<string>(m["OutputProtocol"]));
    }
    if (m.find("OutputUrl") != m.end() && !m["OutputUrl"].empty()) {
      outputUrl = make_shared<string>(boost::any_cast<string>(m["OutputUrl"]));
    }
    if (m.find("PairFlowId") != m.end() && !m["PairFlowId"].empty()) {
      pairFlowId = make_shared<string>(boost::any_cast<string>(m["PairFlowId"]));
    }
    if (m.find("PairInputName") != m.end() && !m["PairInputName"].empty()) {
      pairInputName = make_shared<string>(boost::any_cast<string>(m["PairInputName"]));
    }
    if (m.find("PlayerLimit") != m.end() && !m["PlayerLimit"].empty()) {
      playerLimit = make_shared<long>(boost::any_cast<long>(m["PlayerLimit"]));
    }
    if (m.find("SrtLatency") != m.end() && !m["SrtLatency"].empty()) {
      srtLatency = make_shared<long>(boost::any_cast<long>(m["SrtLatency"]));
    }
    if (m.find("SrtPassphrase") != m.end() && !m["SrtPassphrase"].empty()) {
      srtPassphrase = make_shared<string>(boost::any_cast<string>(m["SrtPassphrase"]));
    }
    if (m.find("SrtPbkeyLen") != m.end() && !m["SrtPbkeyLen"].empty()) {
      srtPbkeyLen = make_shared<long>(boost::any_cast<long>(m["SrtPbkeyLen"]));
    }
  }


  virtual ~GetMediaConnectFlowOutputResponseBodyContent() = default;
};
class GetMediaConnectFlowOutputResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaConnectFlowOutputResponseBodyContent> content{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};

  GetMediaConnectFlowOutputResponseBody() {}

  explicit GetMediaConnectFlowOutputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        GetMediaConnectFlowOutputResponseBodyContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<GetMediaConnectFlowOutputResponseBodyContent>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
  }


  virtual ~GetMediaConnectFlowOutputResponseBody() = default;
};
class GetMediaConnectFlowOutputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaConnectFlowOutputResponseBody> body{};

  GetMediaConnectFlowOutputResponse() {}

  explicit GetMediaConnectFlowOutputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaConnectFlowOutputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaConnectFlowOutputResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaConnectFlowOutputResponse() = default;
};
class GetMediaConvertJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetMediaConvertJobRequest() {}

  explicit GetMediaConvertJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetMediaConvertJobRequest() = default;
};
class GetMediaConvertJobResponseBodyJobConfig : public Darabonba::Model {
public:
  shared_ptr<vector<MediaConvertInput>> inputs{};
  shared_ptr<string> jobName{};
  shared_ptr<vector<MediaConvertOutputGroup>> outputGroups{};
  shared_ptr<vector<MediaConvertOutput>> outputs{};

  GetMediaConvertJobResponseBodyJobConfig() {}

  explicit GetMediaConvertJobResponseBodyJobConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputs) {
      vector<boost::any> temp1;
      for(auto item1:*inputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Inputs"] = boost::any(temp1);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (outputGroups) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroups"] = boost::any(temp1);
    }
    if (outputs) {
      vector<boost::any> temp1;
      for(auto item1:*outputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outputs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Inputs"].type()) {
        vector<MediaConvertInput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Inputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertInput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputs = make_shared<vector<MediaConvertInput>>(expect1);
      }
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("OutputGroups") != m.end() && !m["OutputGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroups"].type()) {
        vector<MediaConvertOutputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroups = make_shared<vector<MediaConvertOutputGroup>>(expect1);
      }
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Outputs"].type()) {
        vector<MediaConvertOutput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputs = make_shared<vector<MediaConvertOutput>>(expect1);
      }
    }
  }


  virtual ~GetMediaConvertJobResponseBodyJobConfig() = default;
};
class GetMediaConvertJobResponseBodyJob : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> code{};
  shared_ptr<GetMediaConvertJobResponseBodyJobConfig> config{};
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<vector<MediaConvertOutputDetail>> outputDetails{};
  shared_ptr<vector<MediaConvertOutputGroupDetail>> outputGroupDetails{};
  shared_ptr<long> percent{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};

  GetMediaConvertJobResponseBodyJob() {}

  explicit GetMediaConvertJobResponseBodyJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (outputDetails) {
      vector<boost::any> temp1;
      for(auto item1:*outputDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputDetails"] = boost::any(temp1);
    }
    if (outputGroupDetails) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroupDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroupDetails"] = boost::any(temp1);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        GetMediaConvertJobResponseBodyJobConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<GetMediaConvertJobResponseBodyJobConfig>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OutputDetails") != m.end() && !m["OutputDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputDetails"].type()) {
        vector<MediaConvertOutputDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutputDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputDetails = make_shared<vector<MediaConvertOutputDetail>>(expect1);
      }
    }
    if (m.find("OutputGroupDetails") != m.end() && !m["OutputGroupDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroupDetails"].type()) {
        vector<MediaConvertOutputGroupDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroupDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutputGroupDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroupDetails = make_shared<vector<MediaConvertOutputGroupDetail>>(expect1);
      }
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetMediaConvertJobResponseBodyJob() = default;
};
class GetMediaConvertJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaConvertJobResponseBodyJob> job{};
  shared_ptr<string> requestId{};

  GetMediaConvertJobResponseBody() {}

  explicit GetMediaConvertJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      res["Job"] = job ? boost::any(job->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(map<string, boost::any>) == m["Job"].type()) {
        GetMediaConvertJobResponseBodyJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Job"]));
        job = make_shared<GetMediaConvertJobResponseBodyJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMediaConvertJobResponseBody() = default;
};
class GetMediaConvertJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaConvertJobResponseBody> body{};

  GetMediaConvertJobResponse() {}

  explicit GetMediaConvertJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaConvertJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaConvertJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaConvertJobResponse() = default;
};
class GetMediaInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> authTimeout{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> outputType{};
  shared_ptr<string> returnDetailedInfo{};

  GetMediaInfoRequest() {}

  explicit GetMediaInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authTimeout) {
      res["AuthTimeout"] = boost::any(*authTimeout);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (outputType) {
      res["OutputType"] = boost::any(*outputType);
    }
    if (returnDetailedInfo) {
      res["ReturnDetailedInfo"] = boost::any(*returnDetailedInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthTimeout") != m.end() && !m["AuthTimeout"].empty()) {
      authTimeout = make_shared<long>(boost::any_cast<long>(m["AuthTimeout"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("OutputType") != m.end() && !m["OutputType"].empty()) {
      outputType = make_shared<string>(boost::any_cast<string>(m["OutputType"]));
    }
    if (m.find("ReturnDetailedInfo") != m.end() && !m["ReturnDetailedInfo"].empty()) {
      returnDetailedInfo = make_shared<string>(boost::any_cast<string>(m["ReturnDetailedInfo"]));
    }
  }


  virtual ~GetMediaInfoRequest() = default;
};
class GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJobResults : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> type{};

  GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJobResults() {}

  explicit GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJobResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJobResults() = default;
};
class GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJob : public Darabonba::Model {
public:
  shared_ptr<string> aiJobId{};
  shared_ptr<string> resultUrl{};
  shared_ptr<vector<GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJobResults>> results{};
  shared_ptr<string> status{};

  GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJob() {}

  explicit GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiJobId) {
      res["AiJobId"] = boost::any(*aiJobId);
    }
    if (resultUrl) {
      res["ResultUrl"] = boost::any(*resultUrl);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiJobId") != m.end() && !m["AiJobId"].empty()) {
      aiJobId = make_shared<string>(boost::any_cast<string>(m["AiJobId"]));
    }
    if (m.find("ResultUrl") != m.end() && !m["ResultUrl"].empty()) {
      resultUrl = make_shared<string>(boost::any_cast<string>(m["ResultUrl"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJobResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJobResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJobResults>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJob() = default;
};
class GetMediaInfoResponseBodyMediaInfoAiRoughData : public Darabonba::Model {
public:
  shared_ptr<string> aiCategory{};
  shared_ptr<string> aiJobId{};
  shared_ptr<string> result{};
  shared_ptr<string> saveType{};
  shared_ptr<GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJob> standardSmartTagJob{};
  shared_ptr<string> status{};

  GetMediaInfoResponseBodyMediaInfoAiRoughData() {}

  explicit GetMediaInfoResponseBodyMediaInfoAiRoughData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiCategory) {
      res["AiCategory"] = boost::any(*aiCategory);
    }
    if (aiJobId) {
      res["AiJobId"] = boost::any(*aiJobId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (saveType) {
      res["SaveType"] = boost::any(*saveType);
    }
    if (standardSmartTagJob) {
      res["StandardSmartTagJob"] = standardSmartTagJob ? boost::any(standardSmartTagJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiCategory") != m.end() && !m["AiCategory"].empty()) {
      aiCategory = make_shared<string>(boost::any_cast<string>(m["AiCategory"]));
    }
    if (m.find("AiJobId") != m.end() && !m["AiJobId"].empty()) {
      aiJobId = make_shared<string>(boost::any_cast<string>(m["AiJobId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("SaveType") != m.end() && !m["SaveType"].empty()) {
      saveType = make_shared<string>(boost::any_cast<string>(m["SaveType"]));
    }
    if (m.find("StandardSmartTagJob") != m.end() && !m["StandardSmartTagJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["StandardSmartTagJob"].type()) {
        GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StandardSmartTagJob"]));
        standardSmartTagJob = make_shared<GetMediaInfoResponseBodyMediaInfoAiRoughDataStandardSmartTagJob>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfoAiRoughData() = default;
};
class GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList() {}

  explicit GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList() = default;
};
class GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> createTime{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo() {}

  explicit GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo() = default;
};
class GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList() {}

  explicit GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList() = default;
};
class GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> nbFrames{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList() {}

  explicit GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (nbFrames) {
      res["Nb_frames"] = boost::any(*nbFrames);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Nb_frames") != m.end() && !m["Nb_frames"].empty()) {
      nbFrames = make_shared<string>(boost::any_cast<string>(m["Nb_frames"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList() = default;
};
class GetMediaInfoResponseBodyMediaInfoFileInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList>> subtitleStreamInfoList{};
  shared_ptr<vector<GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList>> videoStreamInfoList{};

  GetMediaInfoResponseBodyMediaInfoFileInfoList() {}

  explicit GetMediaInfoResponseBodyMediaInfoFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStreamInfoList"] = boost::any(temp1);
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo>(model1);
      }
    }
    if (m.find("SubtitleStreamInfoList") != m.end() && !m["SubtitleStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStreamInfoList"].type()) {
        vector<GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStreamInfoList = make_shared<vector<GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList>>(expect1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfoFileInfoList() = default;
};
class GetMediaInfoResponseBodyMediaInfoMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> biz{};
  shared_ptr<string> businessType{};
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> snapshots{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteImages{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> uploadSource{};
  shared_ptr<string> userData{};

  GetMediaInfoResponseBodyMediaInfoMediaBasicInfo() {}

  explicit GetMediaInfoResponseBodyMediaInfoMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (biz) {
      res["Biz"] = boost::any(*biz);
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteImages) {
      res["SpriteImages"] = boost::any(*spriteImages);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (uploadSource) {
      res["UploadSource"] = boost::any(*uploadSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Biz") != m.end() && !m["Biz"].empty()) {
      biz = make_shared<string>(boost::any_cast<string>(m["Biz"]));
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      snapshots = make_shared<string>(boost::any_cast<string>(m["Snapshots"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteImages") != m.end() && !m["SpriteImages"].empty()) {
      spriteImages = make_shared<string>(boost::any_cast<string>(m["SpriteImages"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UploadSource") != m.end() && !m["UploadSource"].empty()) {
      uploadSource = make_shared<string>(boost::any_cast<string>(m["UploadSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfoMediaBasicInfo() = default;
};
class GetMediaInfoResponseBodyMediaInfo : public Darabonba::Model {
public:
  shared_ptr<GetMediaInfoResponseBodyMediaInfoAiRoughData> aiRoughData{};
  shared_ptr<vector<GetMediaInfoResponseBodyMediaInfoFileInfoList>> fileInfoList{};
  shared_ptr<GetMediaInfoResponseBodyMediaInfoMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  GetMediaInfoResponseBodyMediaInfo() {}

  explicit GetMediaInfoResponseBodyMediaInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiRoughData) {
      res["AiRoughData"] = aiRoughData ? boost::any(aiRoughData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiRoughData") != m.end() && !m["AiRoughData"].empty()) {
      if (typeid(map<string, boost::any>) == m["AiRoughData"].type()) {
        GetMediaInfoResponseBodyMediaInfoAiRoughData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AiRoughData"]));
        aiRoughData = make_shared<GetMediaInfoResponseBodyMediaInfoAiRoughData>(model1);
      }
    }
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<GetMediaInfoResponseBodyMediaInfoFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaInfoResponseBodyMediaInfoFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<GetMediaInfoResponseBodyMediaInfoFileInfoList>>(expect1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        GetMediaInfoResponseBodyMediaInfoMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<GetMediaInfoResponseBodyMediaInfoMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~GetMediaInfoResponseBodyMediaInfo() = default;
};
class GetMediaInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaInfoResponseBodyMediaInfo> mediaInfo{};
  shared_ptr<string> requestId{};

  GetMediaInfoResponseBody() {}

  explicit GetMediaInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfo) {
      res["MediaInfo"] = mediaInfo ? boost::any(mediaInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfo") != m.end() && !m["MediaInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfo"].type()) {
        GetMediaInfoResponseBodyMediaInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfo"]));
        mediaInfo = make_shared<GetMediaInfoResponseBodyMediaInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMediaInfoResponseBody() = default;
};
class GetMediaInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaInfoResponseBody> body{};

  GetMediaInfoResponse() {}

  explicit GetMediaInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaInfoResponse() = default;
};
class GetMediaInfoJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetMediaInfoJobRequest() {}

  explicit GetMediaInfoJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetMediaInfoJobRequest() = default;
};
class GetMediaInfoJobResponseBodyMediaInfoJobInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetMediaInfoJobResponseBodyMediaInfoJobInput() {}

  explicit GetMediaInfoJobResponseBodyMediaInfoJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetMediaInfoJobResponseBodyMediaInfoJobInput() = default;
};
class GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList() {}

  explicit GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList() = default;
};
class GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo() {}

  explicit GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo() = default;
};
class GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFps{};
  shared_ptr<string> bitRate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeBase{};
  shared_ptr<string> width{};

  GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList() {}

  explicit GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFps) {
      res["Avg_fps"] = boost::any(*avgFps);
    }
    if (bitRate) {
      res["Bit_rate"] = boost::any(*bitRate);
    }
    if (codecLongName) {
      res["Codec_long_name"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["Codec_name"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["Codec_tag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["Codec_tag_string"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["Codec_time_base"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["Has_b_frames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["Start_time"] = boost::any(*startTime);
    }
    if (timeBase) {
      res["Time_base"] = boost::any(*timeBase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avg_fps") != m.end() && !m["Avg_fps"].empty()) {
      avgFps = make_shared<string>(boost::any_cast<string>(m["Avg_fps"]));
    }
    if (m.find("Bit_rate") != m.end() && !m["Bit_rate"].empty()) {
      bitRate = make_shared<string>(boost::any_cast<string>(m["Bit_rate"]));
    }
    if (m.find("Codec_long_name") != m.end() && !m["Codec_long_name"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["Codec_long_name"]));
    }
    if (m.find("Codec_name") != m.end() && !m["Codec_name"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["Codec_name"]));
    }
    if (m.find("Codec_tag") != m.end() && !m["Codec_tag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["Codec_tag"]));
    }
    if (m.find("Codec_tag_string") != m.end() && !m["Codec_tag_string"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["Codec_tag_string"]));
    }
    if (m.find("Codec_time_base") != m.end() && !m["Codec_time_base"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["Codec_time_base"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Has_b_frames") != m.end() && !m["Has_b_frames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["Has_b_frames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Start_time") != m.end() && !m["Start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["Start_time"]));
    }
    if (m.find("Time_base") != m.end() && !m["Time_base"].empty()) {
      timeBase = make_shared<string>(boost::any_cast<string>(m["Time_base"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList() = default;
};
class GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty : public Darabonba::Model {
public:
  shared_ptr<vector<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList>> videoStreamInfoList{};

  GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty() {}

  explicit GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo>(model1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty() = default;
};
class GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig() {}

  explicit GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig() = default;
};
class GetMediaInfoJobResponseBodyMediaInfoJob : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> finishTime{};
  shared_ptr<GetMediaInfoJobResponseBodyMediaInfoJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty> mediaInfoProperty{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> submitResultJson{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  GetMediaInfoJobResponseBodyMediaInfoJob() {}

  explicit GetMediaInfoJobResponseBodyMediaInfoJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaInfoProperty) {
      res["MediaInfoProperty"] = mediaInfoProperty ? boost::any(mediaInfoProperty->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitResultJson) {
      res["SubmitResultJson"] = boost::any(*submitResultJson);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        GetMediaInfoJobResponseBodyMediaInfoJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<GetMediaInfoJobResponseBodyMediaInfoJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaInfoProperty") != m.end() && !m["MediaInfoProperty"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoProperty"].type()) {
        GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoProperty"]));
        mediaInfoProperty = make_shared<GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitResultJson") != m.end() && !m["SubmitResultJson"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SubmitResultJson"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      submitResultJson = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetMediaInfoJobResponseBodyMediaInfoJob() = default;
};
class GetMediaInfoJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaInfoJobResponseBodyMediaInfoJob> mediaInfoJob{};
  shared_ptr<string> requestId{};

  GetMediaInfoJobResponseBody() {}

  explicit GetMediaInfoJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfoJob) {
      res["MediaInfoJob"] = mediaInfoJob ? boost::any(mediaInfoJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfoJob") != m.end() && !m["MediaInfoJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoJob"].type()) {
        GetMediaInfoJobResponseBodyMediaInfoJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoJob"]));
        mediaInfoJob = make_shared<GetMediaInfoJobResponseBodyMediaInfoJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMediaInfoJobResponseBody() = default;
};
class GetMediaInfoJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaInfoJobResponseBody> body{};

  GetMediaInfoJobResponse() {}

  explicit GetMediaInfoJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaInfoJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaInfoJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaInfoJobResponse() = default;
};
class GetMediaLiveChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};

  GetMediaLiveChannelRequest() {}

  explicit GetMediaLiveChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
  }


  virtual ~GetMediaLiveChannelRequest() = default;
};
class GetMediaLiveChannelResponseBodyChannelAudioSettingsAudioCodecSetting : public Darabonba::Model {
public:
  shared_ptr<long> bitrate{};
  shared_ptr<string> profile{};
  shared_ptr<long> sampleRate{};

  GetMediaLiveChannelResponseBodyChannelAudioSettingsAudioCodecSetting() {}

  explicit GetMediaLiveChannelResponseBodyChannelAudioSettingsAudioCodecSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<long>(boost::any_cast<long>(m["SampleRate"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelAudioSettingsAudioCodecSetting() = default;
};
class GetMediaLiveChannelResponseBodyChannelAudioSettings : public Darabonba::Model {
public:
  shared_ptr<string> audioCodec{};
  shared_ptr<GetMediaLiveChannelResponseBodyChannelAudioSettingsAudioCodecSetting> audioCodecSetting{};
  shared_ptr<string> audioSelectorName{};
  shared_ptr<string> languageCode{};
  shared_ptr<string> languageName{};
  shared_ptr<string> name{};

  GetMediaLiveChannelResponseBodyChannelAudioSettings() {}

  explicit GetMediaLiveChannelResponseBodyChannelAudioSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioCodec) {
      res["AudioCodec"] = boost::any(*audioCodec);
    }
    if (audioCodecSetting) {
      res["AudioCodecSetting"] = audioCodecSetting ? boost::any(audioCodecSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioSelectorName) {
      res["AudioSelectorName"] = boost::any(*audioSelectorName);
    }
    if (languageCode) {
      res["LanguageCode"] = boost::any(*languageCode);
    }
    if (languageName) {
      res["LanguageName"] = boost::any(*languageName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioCodec") != m.end() && !m["AudioCodec"].empty()) {
      audioCodec = make_shared<string>(boost::any_cast<string>(m["AudioCodec"]));
    }
    if (m.find("AudioCodecSetting") != m.end() && !m["AudioCodecSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioCodecSetting"].type()) {
        GetMediaLiveChannelResponseBodyChannelAudioSettingsAudioCodecSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioCodecSetting"]));
        audioCodecSetting = make_shared<GetMediaLiveChannelResponseBodyChannelAudioSettingsAudioCodecSetting>(model1);
      }
    }
    if (m.find("AudioSelectorName") != m.end() && !m["AudioSelectorName"].empty()) {
      audioSelectorName = make_shared<string>(boost::any_cast<string>(m["AudioSelectorName"]));
    }
    if (m.find("LanguageCode") != m.end() && !m["LanguageCode"].empty()) {
      languageCode = make_shared<string>(boost::any_cast<string>(m["LanguageCode"]));
    }
    if (m.find("LanguageName") != m.end() && !m["LanguageName"].empty()) {
      languageName = make_shared<string>(boost::any_cast<string>(m["LanguageName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelAudioSettings() = default;
};
class GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioLanguageSelection : public Darabonba::Model {
public:
  shared_ptr<string> languageCode{};

  GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioLanguageSelection() {}

  explicit GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioLanguageSelection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (languageCode) {
      res["LanguageCode"] = boost::any(*languageCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LanguageCode") != m.end() && !m["LanguageCode"].empty()) {
      languageCode = make_shared<string>(boost::any_cast<string>(m["LanguageCode"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioLanguageSelection() = default;
};
class GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioPidSelection : public Darabonba::Model {
public:
  shared_ptr<long> pid{};

  GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioPidSelection() {}

  explicit GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioPidSelection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<long>(boost::any_cast<long>(m["Pid"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioPidSelection() = default;
};
class GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioTrackSelection : public Darabonba::Model {
public:
  shared_ptr<long> trackId{};

  GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioTrackSelection() {}

  explicit GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioTrackSelection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trackId) {
      res["TrackId"] = boost::any(*trackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrackId") != m.end() && !m["TrackId"].empty()) {
      trackId = make_shared<long>(boost::any_cast<long>(m["TrackId"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioTrackSelection() = default;
};
class GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectors : public Darabonba::Model {
public:
  shared_ptr<GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioLanguageSelection> audioLanguageSelection{};
  shared_ptr<GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioPidSelection> audioPidSelection{};
  shared_ptr<vector<GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioTrackSelection>> audioTrackSelection{};
  shared_ptr<string> name{};

  GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectors() {}

  explicit GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLanguageSelection) {
      res["AudioLanguageSelection"] = audioLanguageSelection ? boost::any(audioLanguageSelection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioPidSelection) {
      res["AudioPidSelection"] = audioPidSelection ? boost::any(audioPidSelection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioTrackSelection) {
      vector<boost::any> temp1;
      for(auto item1:*audioTrackSelection){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioTrackSelection"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLanguageSelection") != m.end() && !m["AudioLanguageSelection"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioLanguageSelection"].type()) {
        GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioLanguageSelection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioLanguageSelection"]));
        audioLanguageSelection = make_shared<GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioLanguageSelection>(model1);
      }
    }
    if (m.find("AudioPidSelection") != m.end() && !m["AudioPidSelection"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioPidSelection"].type()) {
        GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioPidSelection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioPidSelection"]));
        audioPidSelection = make_shared<GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioPidSelection>(model1);
      }
    }
    if (m.find("AudioTrackSelection") != m.end() && !m["AudioTrackSelection"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioTrackSelection"].type()) {
        vector<GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioTrackSelection> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioTrackSelection"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioTrackSelection model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioTrackSelection = make_shared<vector<GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectorsAudioTrackSelection>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectors() = default;
};
class GetMediaLiveChannelResponseBodyChannelInputAttachments : public Darabonba::Model {
public:
  shared_ptr<vector<GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectors>> audioSelectors{};
  shared_ptr<string> inputId{};
  shared_ptr<string> inputName{};
  shared_ptr<string> languageName{};

  GetMediaLiveChannelResponseBodyChannelInputAttachments() {}

  explicit GetMediaLiveChannelResponseBodyChannelInputAttachments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSelectors) {
      vector<boost::any> temp1;
      for(auto item1:*audioSelectors){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioSelectors"] = boost::any(temp1);
    }
    if (inputId) {
      res["InputId"] = boost::any(*inputId);
    }
    if (inputName) {
      res["InputName"] = boost::any(*inputName);
    }
    if (languageName) {
      res["LanguageName"] = boost::any(*languageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSelectors") != m.end() && !m["AudioSelectors"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioSelectors"].type()) {
        vector<GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectors> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioSelectors"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectors model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioSelectors = make_shared<vector<GetMediaLiveChannelResponseBodyChannelInputAttachmentsAudioSelectors>>(expect1);
      }
    }
    if (m.find("InputId") != m.end() && !m["InputId"].empty()) {
      inputId = make_shared<string>(boost::any_cast<string>(m["InputId"]));
    }
    if (m.find("InputName") != m.end() && !m["InputName"].empty()) {
      inputName = make_shared<string>(boost::any_cast<string>(m["InputName"]));
    }
    if (m.find("LanguageName") != m.end() && !m["LanguageName"].empty()) {
      languageName = make_shared<string>(boost::any_cast<string>(m["LanguageName"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelInputAttachments() = default;
};
class GetMediaLiveChannelResponseBodyChannelOutputGroupsMediaPackageGroupSetting : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> groupName{};

  GetMediaLiveChannelResponseBodyChannelOutputGroupsMediaPackageGroupSetting() {}

  explicit GetMediaLiveChannelResponseBodyChannelOutputGroupsMediaPackageGroupSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelOutputGroupsMediaPackageGroupSetting() = default;
};
class GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputsMediaPackageOutputSetting : public Darabonba::Model {
public:
  shared_ptr<string> audioGroupId{};
  shared_ptr<string> nameModifier{};

  GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputsMediaPackageOutputSetting() {}

  explicit GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputsMediaPackageOutputSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioGroupId) {
      res["AudioGroupId"] = boost::any(*audioGroupId);
    }
    if (nameModifier) {
      res["NameModifier"] = boost::any(*nameModifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioGroupId") != m.end() && !m["AudioGroupId"].empty()) {
      audioGroupId = make_shared<string>(boost::any_cast<string>(m["AudioGroupId"]));
    }
    if (m.find("NameModifier") != m.end() && !m["NameModifier"].empty()) {
      nameModifier = make_shared<string>(boost::any_cast<string>(m["NameModifier"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputsMediaPackageOutputSetting() = default;
};
class GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> audioSettingNames{};
  shared_ptr<GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputsMediaPackageOutputSetting> mediaPackageOutputSetting{};
  shared_ptr<long> mediaType{};
  shared_ptr<string> name{};
  shared_ptr<string> videoSettingName{};

  GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputs() {}

  explicit GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSettingNames) {
      res["AudioSettingNames"] = boost::any(*audioSettingNames);
    }
    if (mediaPackageOutputSetting) {
      res["MediaPackageOutputSetting"] = mediaPackageOutputSetting ? boost::any(mediaPackageOutputSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (videoSettingName) {
      res["VideoSettingName"] = boost::any(*videoSettingName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSettingNames") != m.end() && !m["AudioSettingNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AudioSettingNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AudioSettingNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      audioSettingNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MediaPackageOutputSetting") != m.end() && !m["MediaPackageOutputSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaPackageOutputSetting"].type()) {
        GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputsMediaPackageOutputSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaPackageOutputSetting"]));
        mediaPackageOutputSetting = make_shared<GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputsMediaPackageOutputSetting>(model1);
      }
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<long>(boost::any_cast<long>(m["MediaType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("VideoSettingName") != m.end() && !m["VideoSettingName"].empty()) {
      videoSettingName = make_shared<string>(boost::any_cast<string>(m["VideoSettingName"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputs() = default;
};
class GetMediaLiveChannelResponseBodyChannelOutputGroups : public Darabonba::Model {
public:
  shared_ptr<GetMediaLiveChannelResponseBodyChannelOutputGroupsMediaPackageGroupSetting> mediaPackageGroupSetting{};
  shared_ptr<string> monitorUrl{};
  shared_ptr<string> name{};
  shared_ptr<vector<GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputs>> outputs{};
  shared_ptr<string> type{};

  GetMediaLiveChannelResponseBodyChannelOutputGroups() {}

  explicit GetMediaLiveChannelResponseBodyChannelOutputGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaPackageGroupSetting) {
      res["MediaPackageGroupSetting"] = mediaPackageGroupSetting ? boost::any(mediaPackageGroupSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (monitorUrl) {
      res["MonitorUrl"] = boost::any(*monitorUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      vector<boost::any> temp1;
      for(auto item1:*outputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outputs"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaPackageGroupSetting") != m.end() && !m["MediaPackageGroupSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaPackageGroupSetting"].type()) {
        GetMediaLiveChannelResponseBodyChannelOutputGroupsMediaPackageGroupSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaPackageGroupSetting"]));
        mediaPackageGroupSetting = make_shared<GetMediaLiveChannelResponseBodyChannelOutputGroupsMediaPackageGroupSetting>(model1);
      }
    }
    if (m.find("MonitorUrl") != m.end() && !m["MonitorUrl"].empty()) {
      monitorUrl = make_shared<string>(boost::any_cast<string>(m["MonitorUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Outputs"].type()) {
        vector<GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputs = make_shared<vector<GetMediaLiveChannelResponseBodyChannelOutputGroupsOutputs>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelOutputGroups() = default;
};
class GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingCodecDetail : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> profile{};

  GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingCodecDetail() {}

  explicit GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingCodecDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingCodecDetail() = default;
};
class GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingFramerate : public Darabonba::Model {
public:
  shared_ptr<string> framerateControl{};
  shared_ptr<long> framerateDenominator{};
  shared_ptr<long> framerateNumerator{};

  GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingFramerate() {}

  explicit GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingFramerate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (framerateControl) {
      res["FramerateControl"] = boost::any(*framerateControl);
    }
    if (framerateDenominator) {
      res["FramerateDenominator"] = boost::any(*framerateDenominator);
    }
    if (framerateNumerator) {
      res["FramerateNumerator"] = boost::any(*framerateNumerator);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FramerateControl") != m.end() && !m["FramerateControl"].empty()) {
      framerateControl = make_shared<string>(boost::any_cast<string>(m["FramerateControl"]));
    }
    if (m.find("FramerateDenominator") != m.end() && !m["FramerateDenominator"].empty()) {
      framerateDenominator = make_shared<long>(boost::any_cast<long>(m["FramerateDenominator"]));
    }
    if (m.find("FramerateNumerator") != m.end() && !m["FramerateNumerator"].empty()) {
      framerateNumerator = make_shared<long>(boost::any_cast<long>(m["FramerateNumerator"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingFramerate() = default;
};
class GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingGop : public Darabonba::Model {
public:
  shared_ptr<long> bframesNum{};
  shared_ptr<long> gopSize{};
  shared_ptr<string> gopSizeUnits{};

  GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingGop() {}

  explicit GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingGop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bframesNum) {
      res["BframesNum"] = boost::any(*bframesNum);
    }
    if (gopSize) {
      res["GopSize"] = boost::any(*gopSize);
    }
    if (gopSizeUnits) {
      res["GopSizeUnits"] = boost::any(*gopSizeUnits);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BframesNum") != m.end() && !m["BframesNum"].empty()) {
      bframesNum = make_shared<long>(boost::any_cast<long>(m["BframesNum"]));
    }
    if (m.find("GopSize") != m.end() && !m["GopSize"].empty()) {
      gopSize = make_shared<long>(boost::any_cast<long>(m["GopSize"]));
    }
    if (m.find("GopSizeUnits") != m.end() && !m["GopSizeUnits"].empty()) {
      gopSizeUnits = make_shared<string>(boost::any_cast<string>(m["GopSizeUnits"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingGop() = default;
};
class GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingRate : public Darabonba::Model {
public:
  shared_ptr<long> bitrate{};
  shared_ptr<long> bufferSize{};
  shared_ptr<long> maxBitrate{};
  shared_ptr<string> rateControlMode{};

  GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingRate() {}

  explicit GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingRate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufferSize) {
      res["BufferSize"] = boost::any(*bufferSize);
    }
    if (maxBitrate) {
      res["MaxBitrate"] = boost::any(*maxBitrate);
    }
    if (rateControlMode) {
      res["RateControlMode"] = boost::any(*rateControlMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("BufferSize") != m.end() && !m["BufferSize"].empty()) {
      bufferSize = make_shared<long>(boost::any_cast<long>(m["BufferSize"]));
    }
    if (m.find("MaxBitrate") != m.end() && !m["MaxBitrate"].empty()) {
      maxBitrate = make_shared<long>(boost::any_cast<long>(m["MaxBitrate"]));
    }
    if (m.find("RateControlMode") != m.end() && !m["RateControlMode"].empty()) {
      rateControlMode = make_shared<string>(boost::any_cast<string>(m["RateControlMode"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingRate() = default;
};
class GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSetting : public Darabonba::Model {
public:
  shared_ptr<GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingCodecDetail> codecDetail{};
  shared_ptr<GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingFramerate> framerate{};
  shared_ptr<GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingGop> gop{};
  shared_ptr<GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingRate> rate{};

  GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSetting() {}

  explicit GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codecDetail) {
      res["CodecDetail"] = codecDetail ? boost::any(codecDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (framerate) {
      res["Framerate"] = framerate ? boost::any(framerate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gop) {
      res["Gop"] = gop ? boost::any(gop->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rate) {
      res["Rate"] = rate ? boost::any(rate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodecDetail") != m.end() && !m["CodecDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["CodecDetail"].type()) {
        GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingCodecDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CodecDetail"]));
        codecDetail = make_shared<GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingCodecDetail>(model1);
      }
    }
    if (m.find("Framerate") != m.end() && !m["Framerate"].empty()) {
      if (typeid(map<string, boost::any>) == m["Framerate"].type()) {
        GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingFramerate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Framerate"]));
        framerate = make_shared<GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingFramerate>(model1);
      }
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gop"].type()) {
        GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingGop model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gop"]));
        gop = make_shared<GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingGop>(model1);
      }
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rate"].type()) {
        GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingRate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rate"]));
        rate = make_shared<GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSettingRate>(model1);
      }
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSetting() = default;
};
class GetMediaLiveChannelResponseBodyChannelVideoSettings : public Darabonba::Model {
public:
  shared_ptr<long> height{};
  shared_ptr<string> name{};
  shared_ptr<string> videoCodec{};
  shared_ptr<GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSetting> videoCodecSetting{};
  shared_ptr<string> videoCodecType{};
  shared_ptr<long> width{};

  GetMediaLiveChannelResponseBodyChannelVideoSettings() {}

  explicit GetMediaLiveChannelResponseBodyChannelVideoSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (videoCodec) {
      res["VideoCodec"] = boost::any(*videoCodec);
    }
    if (videoCodecSetting) {
      res["VideoCodecSetting"] = videoCodecSetting ? boost::any(videoCodecSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCodecType) {
      res["VideoCodecType"] = boost::any(*videoCodecType);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("VideoCodec") != m.end() && !m["VideoCodec"].empty()) {
      videoCodec = make_shared<string>(boost::any_cast<string>(m["VideoCodec"]));
    }
    if (m.find("VideoCodecSetting") != m.end() && !m["VideoCodecSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoCodecSetting"].type()) {
        GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoCodecSetting"]));
        videoCodecSetting = make_shared<GetMediaLiveChannelResponseBodyChannelVideoSettingsVideoCodecSetting>(model1);
      }
    }
    if (m.find("VideoCodecType") != m.end() && !m["VideoCodecType"].empty()) {
      videoCodecType = make_shared<string>(boost::any_cast<string>(m["VideoCodecType"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannelVideoSettings() = default;
};
class GetMediaLiveChannelResponseBodyChannel : public Darabonba::Model {
public:
  shared_ptr<vector<GetMediaLiveChannelResponseBodyChannelAudioSettings>> audioSettings{};
  shared_ptr<string> channelId{};
  shared_ptr<string> createTime{};
  shared_ptr<vector<GetMediaLiveChannelResponseBodyChannelInputAttachments>> inputAttachments{};
  shared_ptr<string> lastStartTime{};
  shared_ptr<string> lastStopTime{};
  shared_ptr<string> name{};
  shared_ptr<vector<GetMediaLiveChannelResponseBodyChannelOutputGroups>> outputGroups{};
  shared_ptr<string> state{};
  shared_ptr<vector<GetMediaLiveChannelResponseBodyChannelVideoSettings>> videoSettings{};

  GetMediaLiveChannelResponseBodyChannel() {}

  explicit GetMediaLiveChannelResponseBodyChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSettings) {
      vector<boost::any> temp1;
      for(auto item1:*audioSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioSettings"] = boost::any(temp1);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (inputAttachments) {
      vector<boost::any> temp1;
      for(auto item1:*inputAttachments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputAttachments"] = boost::any(temp1);
    }
    if (lastStartTime) {
      res["LastStartTime"] = boost::any(*lastStartTime);
    }
    if (lastStopTime) {
      res["LastStopTime"] = boost::any(*lastStopTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputGroups) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroups"] = boost::any(temp1);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (videoSettings) {
      vector<boost::any> temp1;
      for(auto item1:*videoSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoSettings"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSettings") != m.end() && !m["AudioSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioSettings"].type()) {
        vector<GetMediaLiveChannelResponseBodyChannelAudioSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaLiveChannelResponseBodyChannelAudioSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioSettings = make_shared<vector<GetMediaLiveChannelResponseBodyChannelAudioSettings>>(expect1);
      }
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("InputAttachments") != m.end() && !m["InputAttachments"].empty()) {
      if (typeid(vector<boost::any>) == m["InputAttachments"].type()) {
        vector<GetMediaLiveChannelResponseBodyChannelInputAttachments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputAttachments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaLiveChannelResponseBodyChannelInputAttachments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputAttachments = make_shared<vector<GetMediaLiveChannelResponseBodyChannelInputAttachments>>(expect1);
      }
    }
    if (m.find("LastStartTime") != m.end() && !m["LastStartTime"].empty()) {
      lastStartTime = make_shared<string>(boost::any_cast<string>(m["LastStartTime"]));
    }
    if (m.find("LastStopTime") != m.end() && !m["LastStopTime"].empty()) {
      lastStopTime = make_shared<string>(boost::any_cast<string>(m["LastStopTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputGroups") != m.end() && !m["OutputGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroups"].type()) {
        vector<GetMediaLiveChannelResponseBodyChannelOutputGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaLiveChannelResponseBodyChannelOutputGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroups = make_shared<vector<GetMediaLiveChannelResponseBodyChannelOutputGroups>>(expect1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("VideoSettings") != m.end() && !m["VideoSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoSettings"].type()) {
        vector<GetMediaLiveChannelResponseBodyChannelVideoSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaLiveChannelResponseBodyChannelVideoSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoSettings = make_shared<vector<GetMediaLiveChannelResponseBodyChannelVideoSettings>>(expect1);
      }
    }
  }


  virtual ~GetMediaLiveChannelResponseBodyChannel() = default;
};
class GetMediaLiveChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaLiveChannelResponseBodyChannel> channel{};
  shared_ptr<string> requestId{};

  GetMediaLiveChannelResponseBody() {}

  explicit GetMediaLiveChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["Channel"] = channel ? boost::any(channel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      if (typeid(map<string, boost::any>) == m["Channel"].type()) {
        GetMediaLiveChannelResponseBodyChannel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Channel"]));
        channel = make_shared<GetMediaLiveChannelResponseBodyChannel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMediaLiveChannelResponseBody() = default;
};
class GetMediaLiveChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaLiveChannelResponseBody> body{};

  GetMediaLiveChannelResponse() {}

  explicit GetMediaLiveChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaLiveChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaLiveChannelResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaLiveChannelResponse() = default;
};
class GetMediaLiveInputRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputId{};

  GetMediaLiveInputRequest() {}

  explicit GetMediaLiveInputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputId) {
      res["InputId"] = boost::any(*inputId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputId") != m.end() && !m["InputId"].empty()) {
      inputId = make_shared<string>(boost::any_cast<string>(m["InputId"]));
    }
  }


  virtual ~GetMediaLiveInputRequest() = default;
};
class GetMediaLiveInputResponseBodyInputInputInfos : public Darabonba::Model {
public:
  shared_ptr<string> destHost{};
  shared_ptr<string> flowId{};
  shared_ptr<string> flowOutputName{};
  shared_ptr<string> monitorUrl{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<string> streamName{};

  GetMediaLiveInputResponseBodyInputInputInfos() {}

  explicit GetMediaLiveInputResponseBodyInputInputInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destHost) {
      res["DestHost"] = boost::any(*destHost);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowOutputName) {
      res["FlowOutputName"] = boost::any(*flowOutputName);
    }
    if (monitorUrl) {
      res["MonitorUrl"] = boost::any(*monitorUrl);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestHost") != m.end() && !m["DestHost"].empty()) {
      destHost = make_shared<string>(boost::any_cast<string>(m["DestHost"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowOutputName") != m.end() && !m["FlowOutputName"].empty()) {
      flowOutputName = make_shared<string>(boost::any_cast<string>(m["FlowOutputName"]));
    }
    if (m.find("MonitorUrl") != m.end() && !m["MonitorUrl"].empty()) {
      monitorUrl = make_shared<string>(boost::any_cast<string>(m["MonitorUrl"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~GetMediaLiveInputResponseBodyInputInputInfos() = default;
};
class GetMediaLiveInputResponseBodyInput : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channelIds{};
  shared_ptr<string> createTime{};
  shared_ptr<string> inputId{};
  shared_ptr<vector<GetMediaLiveInputResponseBodyInputInputInfos>> inputInfos{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<string> type{};

  GetMediaLiveInputResponseBodyInput() {}

  explicit GetMediaLiveInputResponseBodyInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelIds) {
      res["ChannelIds"] = boost::any(*channelIds);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (inputId) {
      res["InputId"] = boost::any(*inputId);
    }
    if (inputInfos) {
      vector<boost::any> temp1;
      for(auto item1:*inputInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputInfos"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelIds") != m.end() && !m["ChannelIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ChannelIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ChannelIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channelIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("InputId") != m.end() && !m["InputId"].empty()) {
      inputId = make_shared<string>(boost::any_cast<string>(m["InputId"]));
    }
    if (m.find("InputInfos") != m.end() && !m["InputInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["InputInfos"].type()) {
        vector<GetMediaLiveInputResponseBodyInputInputInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMediaLiveInputResponseBodyInputInputInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputInfos = make_shared<vector<GetMediaLiveInputResponseBodyInputInputInfos>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetMediaLiveInputResponseBodyInput() = default;
};
class GetMediaLiveInputResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaLiveInputResponseBodyInput> input{};
  shared_ptr<string> requestId{};

  GetMediaLiveInputResponseBody() {}

  explicit GetMediaLiveInputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        GetMediaLiveInputResponseBodyInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<GetMediaLiveInputResponseBodyInput>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMediaLiveInputResponseBody() = default;
};
class GetMediaLiveInputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaLiveInputResponseBody> body{};

  GetMediaLiveInputResponse() {}

  explicit GetMediaLiveInputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaLiveInputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaLiveInputResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaLiveInputResponse() = default;
};
class GetMediaLiveInputSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityGroupId{};

  GetMediaLiveInputSecurityGroupRequest() {}

  explicit GetMediaLiveInputSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
  }


  virtual ~GetMediaLiveInputSecurityGroupRequest() = default;
};
class GetMediaLiveInputSecurityGroupResponseBodySecurityGroup : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<vector<string>> inputIds{};
  shared_ptr<string> name{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> whitelistRules{};

  GetMediaLiveInputSecurityGroupResponseBodySecurityGroup() {}

  explicit GetMediaLiveInputSecurityGroupResponseBodySecurityGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (inputIds) {
      res["InputIds"] = boost::any(*inputIds);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (whitelistRules) {
      res["WhitelistRules"] = boost::any(*whitelistRules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("InputIds") != m.end() && !m["InputIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InputIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InputIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      inputIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("WhitelistRules") != m.end() && !m["WhitelistRules"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WhitelistRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WhitelistRules"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      whitelistRules = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetMediaLiveInputSecurityGroupResponseBodySecurityGroup() = default;
};
class GetMediaLiveInputSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetMediaLiveInputSecurityGroupResponseBodySecurityGroup> securityGroup{};

  GetMediaLiveInputSecurityGroupResponseBody() {}

  explicit GetMediaLiveInputSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityGroup) {
      res["SecurityGroup"] = securityGroup ? boost::any(securityGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityGroup") != m.end() && !m["SecurityGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityGroup"].type()) {
        GetMediaLiveInputSecurityGroupResponseBodySecurityGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityGroup"]));
        securityGroup = make_shared<GetMediaLiveInputSecurityGroupResponseBodySecurityGroup>(model1);
      }
    }
  }


  virtual ~GetMediaLiveInputSecurityGroupResponseBody() = default;
};
class GetMediaLiveInputSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaLiveInputSecurityGroupResponseBody> body{};

  GetMediaLiveInputSecurityGroupResponse() {}

  explicit GetMediaLiveInputSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaLiveInputSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaLiveInputSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaLiveInputSecurityGroupResponse() = default;
};
class GetMediaMarksRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaMarkIds{};

  GetMediaMarksRequest() {}

  explicit GetMediaMarksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaMarkIds) {
      res["MediaMarkIds"] = boost::any(*mediaMarkIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaMarkIds") != m.end() && !m["MediaMarkIds"].empty()) {
      mediaMarkIds = make_shared<string>(boost::any_cast<string>(m["MediaMarkIds"]));
    }
  }


  virtual ~GetMediaMarksRequest() = default;
};
class GetMediaMarksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaMarks{};
  shared_ptr<string> requestId{};

  GetMediaMarksResponseBody() {}

  explicit GetMediaMarksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaMarks) {
      res["MediaMarks"] = boost::any(*mediaMarks);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaMarks") != m.end() && !m["MediaMarks"].empty()) {
      mediaMarks = make_shared<string>(boost::any_cast<string>(m["MediaMarks"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMediaMarksResponseBody() = default;
};
class GetMediaMarksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaMarksResponseBody> body{};

  GetMediaMarksResponse() {}

  explicit GetMediaMarksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaMarksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaMarksResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaMarksResponse() = default;
};
class GetMediaProducingJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetMediaProducingJobRequest() {}

  explicit GetMediaProducingJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetMediaProducingJobRequest() = default;
};
class GetMediaProducingJobResponseBodyMediaProducingJob : public Darabonba::Model {
public:
  shared_ptr<string> clipsParam{};
  shared_ptr<string> code{};
  shared_ptr<string> completeTime{};
  shared_ptr<string> createTime{};
  shared_ptr<double> duration{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaURL{};
  shared_ptr<string> message{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<long> progress{};
  shared_ptr<string> projectId{};
  shared_ptr<string> status{};
  shared_ptr<string> subJobMaterials{};
  shared_ptr<string> templateId{};
  shared_ptr<string> timeline{};
  shared_ptr<string> userData{};
  shared_ptr<string> vodMediaId{};

  GetMediaProducingJobResponseBodyMediaProducingJob() {}

  explicit GetMediaProducingJobResponseBodyMediaProducingJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaURL) {
      res["MediaURL"] = boost::any(*mediaURL);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subJobMaterials) {
      res["SubJobMaterials"] = boost::any(*subJobMaterials);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (vodMediaId) {
      res["VodMediaId"] = boost::any(*vodMediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaURL") != m.end() && !m["MediaURL"].empty()) {
      mediaURL = make_shared<string>(boost::any_cast<string>(m["MediaURL"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubJobMaterials") != m.end() && !m["SubJobMaterials"].empty()) {
      subJobMaterials = make_shared<string>(boost::any_cast<string>(m["SubJobMaterials"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VodMediaId") != m.end() && !m["VodMediaId"].empty()) {
      vodMediaId = make_shared<string>(boost::any_cast<string>(m["VodMediaId"]));
    }
  }


  virtual ~GetMediaProducingJobResponseBodyMediaProducingJob() = default;
};
class GetMediaProducingJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetMediaProducingJobResponseBodyMediaProducingJob> mediaProducingJob{};
  shared_ptr<string> requestId{};

  GetMediaProducingJobResponseBody() {}

  explicit GetMediaProducingJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaProducingJob) {
      res["MediaProducingJob"] = mediaProducingJob ? boost::any(mediaProducingJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaProducingJob") != m.end() && !m["MediaProducingJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaProducingJob"].type()) {
        GetMediaProducingJobResponseBodyMediaProducingJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaProducingJob"]));
        mediaProducingJob = make_shared<GetMediaProducingJobResponseBodyMediaProducingJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMediaProducingJobResponseBody() = default;
};
class GetMediaProducingJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMediaProducingJobResponseBody> body{};

  GetMediaProducingJobResponse() {}

  explicit GetMediaProducingJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMediaProducingJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMediaProducingJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetMediaProducingJobResponse() = default;
};
class GetPackageJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetPackageJobRequest() {}

  explicit GetPackageJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetPackageJobRequest() = default;
};
class GetPackageJobResponseBodyPackageJobInputsInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetPackageJobResponseBodyPackageJobInputsInput() {}

  explicit GetPackageJobResponseBodyPackageJobInputsInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetPackageJobResponseBodyPackageJobInputsInput() = default;
};
class GetPackageJobResponseBodyPackageJobInputs : public Darabonba::Model {
public:
  shared_ptr<GetPackageJobResponseBodyPackageJobInputsInput> input{};

  GetPackageJobResponseBodyPackageJobInputs() {}

  explicit GetPackageJobResponseBodyPackageJobInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        GetPackageJobResponseBodyPackageJobInputsInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<GetPackageJobResponseBodyPackageJobInputsInput>(model1);
      }
    }
  }


  virtual ~GetPackageJobResponseBodyPackageJobInputs() = default;
};
class GetPackageJobResponseBodyPackageJobOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetPackageJobResponseBodyPackageJobOutput() {}

  explicit GetPackageJobResponseBodyPackageJobOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetPackageJobResponseBodyPackageJobOutput() = default;
};
class GetPackageJobResponseBodyPackageJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<vector<GetPackageJobResponseBodyPackageJobInputs>> inputs{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<GetPackageJobResponseBodyPackageJobOutput> output{};
  shared_ptr<string> outputUrl{};
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};
  shared_ptr<string> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  GetPackageJobResponseBodyPackageJob() {}

  explicit GetPackageJobResponseBodyPackageJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (inputs) {
      vector<boost::any> temp1;
      for(auto item1:*inputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Inputs"] = boost::any(temp1);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outputUrl) {
      res["OutputUrl"] = boost::any(*outputUrl);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Inputs"].type()) {
        vector<GetPackageJobResponseBodyPackageJobInputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Inputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPackageJobResponseBodyPackageJobInputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputs = make_shared<vector<GetPackageJobResponseBodyPackageJobInputs>>(expect1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        GetPackageJobResponseBodyPackageJobOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<GetPackageJobResponseBodyPackageJobOutput>(model1);
      }
    }
    if (m.find("OutputUrl") != m.end() && !m["OutputUrl"].empty()) {
      outputUrl = make_shared<string>(boost::any_cast<string>(m["OutputUrl"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetPackageJobResponseBodyPackageJob() = default;
};
class GetPackageJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPackageJobResponseBodyPackageJob> packageJob{};
  shared_ptr<string> requestId{};

  GetPackageJobResponseBody() {}

  explicit GetPackageJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packageJob) {
      res["PackageJob"] = packageJob ? boost::any(packageJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackageJob") != m.end() && !m["PackageJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["PackageJob"].type()) {
        GetPackageJobResponseBodyPackageJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PackageJob"]));
        packageJob = make_shared<GetPackageJobResponseBodyPackageJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPackageJobResponseBody() = default;
};
class GetPackageJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPackageJobResponseBody> body{};

  GetPackageJobResponse() {}

  explicit GetPackageJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPackageJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPackageJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetPackageJobResponse() = default;
};
class GetPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};

  GetPipelineRequest() {}

  explicit GetPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~GetPipelineRequest() = default;
};
class GetPipelineResponseBodyPipeline : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};
  shared_ptr<string> speed{};
  shared_ptr<string> status{};

  GetPipelineResponseBodyPipeline() {}

  explicit GetPipelineResponseBodyPipeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetPipelineResponseBodyPipeline() = default;
};
class GetPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPipelineResponseBodyPipeline> pipeline{};
  shared_ptr<string> requestId{};

  GetPipelineResponseBody() {}

  explicit GetPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipeline) {
      res["Pipeline"] = pipeline ? boost::any(pipeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pipeline") != m.end() && !m["Pipeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pipeline"].type()) {
        GetPipelineResponseBodyPipeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pipeline"]));
        pipeline = make_shared<GetPipelineResponseBodyPipeline>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPipelineResponseBody() = default;
};
class GetPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPipelineResponseBody> body{};

  GetPipelineResponse() {}

  explicit GetPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~GetPipelineResponse() = default;
};
class GetPlayInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> authTimeout{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};

  GetPlayInfoRequest() {}

  explicit GetPlayInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authTimeout) {
      res["AuthTimeout"] = boost::any(*authTimeout);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthTimeout") != m.end() && !m["AuthTimeout"].empty()) {
      authTimeout = make_shared<long>(boost::any_cast<long>(m["AuthTimeout"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~GetPlayInfoRequest() = default;
};
class GetPlayInfoResponseBodyMediaBase : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};

  GetPlayInfoResponseBodyMediaBase() {}

  explicit GetPlayInfoResponseBodyMediaBase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetPlayInfoResponseBodyMediaBase() = default;
};
class GetPlayInfoResponseBodyPlayInfoList : public Darabonba::Model {
public:
  shared_ptr<long> bitDepth{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> definition{};
  shared_ptr<string> duration{};
  shared_ptr<long> encrypt{};
  shared_ptr<string> encryptType{};
  shared_ptr<string> fileURL{};
  shared_ptr<string> format{};
  shared_ptr<string> fps{};
  shared_ptr<string> HDRType{};
  shared_ptr<long> height{};
  shared_ptr<string> jobId{};
  shared_ptr<string> modificationTime{};
  shared_ptr<string> narrowBandType{};
  shared_ptr<string> playURL{};
  shared_ptr<long> size{};
  shared_ptr<string> status{};
  shared_ptr<string> streamTags{};
  shared_ptr<string> streamType{};
  shared_ptr<string> transTemplateType{};
  shared_ptr<string> watermarkId{};
  shared_ptr<long> width{};

  GetPlayInfoResponseBodyPlayInfoList() {}

  explicit GetPlayInfoResponseBodyPlayInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitDepth) {
      res["BitDepth"] = boost::any(*bitDepth);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (encrypt) {
      res["Encrypt"] = boost::any(*encrypt);
    }
    if (encryptType) {
      res["EncryptType"] = boost::any(*encryptType);
    }
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (HDRType) {
      res["HDRType"] = boost::any(*HDRType);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (narrowBandType) {
      res["NarrowBandType"] = boost::any(*narrowBandType);
    }
    if (playURL) {
      res["PlayURL"] = boost::any(*playURL);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamTags) {
      res["StreamTags"] = boost::any(*streamTags);
    }
    if (streamType) {
      res["StreamType"] = boost::any(*streamType);
    }
    if (transTemplateType) {
      res["TransTemplateType"] = boost::any(*transTemplateType);
    }
    if (watermarkId) {
      res["WatermarkId"] = boost::any(*watermarkId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BitDepth") != m.end() && !m["BitDepth"].empty()) {
      bitDepth = make_shared<long>(boost::any_cast<long>(m["BitDepth"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Encrypt") != m.end() && !m["Encrypt"].empty()) {
      encrypt = make_shared<long>(boost::any_cast<long>(m["Encrypt"]));
    }
    if (m.find("EncryptType") != m.end() && !m["EncryptType"].empty()) {
      encryptType = make_shared<string>(boost::any_cast<string>(m["EncryptType"]));
    }
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HDRType") != m.end() && !m["HDRType"].empty()) {
      HDRType = make_shared<string>(boost::any_cast<string>(m["HDRType"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("NarrowBandType") != m.end() && !m["NarrowBandType"].empty()) {
      narrowBandType = make_shared<string>(boost::any_cast<string>(m["NarrowBandType"]));
    }
    if (m.find("PlayURL") != m.end() && !m["PlayURL"].empty()) {
      playURL = make_shared<string>(boost::any_cast<string>(m["PlayURL"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StreamTags") != m.end() && !m["StreamTags"].empty()) {
      streamTags = make_shared<string>(boost::any_cast<string>(m["StreamTags"]));
    }
    if (m.find("StreamType") != m.end() && !m["StreamType"].empty()) {
      streamType = make_shared<string>(boost::any_cast<string>(m["StreamType"]));
    }
    if (m.find("TransTemplateType") != m.end() && !m["TransTemplateType"].empty()) {
      transTemplateType = make_shared<string>(boost::any_cast<string>(m["TransTemplateType"]));
    }
    if (m.find("WatermarkId") != m.end() && !m["WatermarkId"].empty()) {
      watermarkId = make_shared<string>(boost::any_cast<string>(m["WatermarkId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~GetPlayInfoResponseBodyPlayInfoList() = default;
};
class GetPlayInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPlayInfoResponseBodyMediaBase> mediaBase{};
  shared_ptr<vector<GetPlayInfoResponseBodyPlayInfoList>> playInfoList{};
  shared_ptr<string> requestId{};

  GetPlayInfoResponseBody() {}

  explicit GetPlayInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaBase) {
      res["MediaBase"] = mediaBase ? boost::any(mediaBase->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (playInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*playInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PlayInfoList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaBase") != m.end() && !m["MediaBase"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBase"].type()) {
        GetPlayInfoResponseBodyMediaBase model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBase"]));
        mediaBase = make_shared<GetPlayInfoResponseBodyMediaBase>(model1);
      }
    }
    if (m.find("PlayInfoList") != m.end() && !m["PlayInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["PlayInfoList"].type()) {
        vector<GetPlayInfoResponseBodyPlayInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PlayInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPlayInfoResponseBodyPlayInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        playInfoList = make_shared<vector<GetPlayInfoResponseBodyPlayInfoList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPlayInfoResponseBody() = default;
};
class GetPlayInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPlayInfoResponseBody> body{};

  GetPlayInfoResponse() {}

  explicit GetPlayInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPlayInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPlayInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetPlayInfoResponse() = default;
};
class GetProgramRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> programName{};

  GetProgramRequest() {}

  explicit GetProgramRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
  }


  virtual ~GetProgramRequest() = default;
};
class GetProgramResponseBody : public Darabonba::Model {
public:
  shared_ptr<ChannelAssemblyProgram> program{};
  shared_ptr<string> requestId{};

  GetProgramResponseBody() {}

  explicit GetProgramResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (program) {
      res["Program"] = program ? boost::any(program->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Program") != m.end() && !m["Program"].empty()) {
      if (typeid(map<string, boost::any>) == m["Program"].type()) {
        ChannelAssemblyProgram model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Program"]));
        program = make_shared<ChannelAssemblyProgram>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetProgramResponseBody() = default;
};
class GetProgramResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProgramResponseBody> body{};

  GetProgramResponse() {}

  explicit GetProgramResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProgramResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProgramResponseBody>(model1);
      }
    }
  }


  virtual ~GetProgramResponse() = default;
};
class GetProjectExportJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetProjectExportJobRequest() {}

  explicit GetProjectExportJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetProjectExportJobRequest() = default;
};
class GetProjectExportJobResponseBodyProjectExportJobExportResult : public Darabonba::Model {
public:
  shared_ptr<string> projectUrl{};
  shared_ptr<string> timeline{};

  GetProjectExportJobResponseBodyProjectExportJobExportResult() {}

  explicit GetProjectExportJobResponseBodyProjectExportJobExportResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectUrl) {
      res["ProjectUrl"] = boost::any(*projectUrl);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectUrl") != m.end() && !m["ProjectUrl"].empty()) {
      projectUrl = make_shared<string>(boost::any_cast<string>(m["ProjectUrl"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
  }


  virtual ~GetProjectExportJobResponseBodyProjectExportJobExportResult() = default;
};
class GetProjectExportJobResponseBodyProjectExportJob : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetProjectExportJobResponseBodyProjectExportJobExportResult> exportResult{};
  shared_ptr<string> exportType{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> projectId{};
  shared_ptr<string> status{};
  shared_ptr<string> userData{};

  GetProjectExportJobResponseBodyProjectExportJob() {}

  explicit GetProjectExportJobResponseBodyProjectExportJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (exportResult) {
      res["ExportResult"] = exportResult ? boost::any(exportResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (exportType) {
      res["ExportType"] = boost::any(*exportType);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExportResult") != m.end() && !m["ExportResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExportResult"].type()) {
        GetProjectExportJobResponseBodyProjectExportJobExportResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExportResult"]));
        exportResult = make_shared<GetProjectExportJobResponseBodyProjectExportJobExportResult>(model1);
      }
    }
    if (m.find("ExportType") != m.end() && !m["ExportType"].empty()) {
      exportType = make_shared<string>(boost::any_cast<string>(m["ExportType"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetProjectExportJobResponseBodyProjectExportJob() = default;
};
class GetProjectExportJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetProjectExportJobResponseBodyProjectExportJob> projectExportJob{};
  shared_ptr<string> requestId{};

  GetProjectExportJobResponseBody() {}

  explicit GetProjectExportJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectExportJob) {
      res["ProjectExportJob"] = projectExportJob ? boost::any(projectExportJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectExportJob") != m.end() && !m["ProjectExportJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectExportJob"].type()) {
        GetProjectExportJobResponseBodyProjectExportJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectExportJob"]));
        projectExportJob = make_shared<GetProjectExportJobResponseBodyProjectExportJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetProjectExportJobResponseBody() = default;
};
class GetProjectExportJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProjectExportJobResponseBody> body{};

  GetProjectExportJobResponse() {}

  explicit GetProjectExportJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProjectExportJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProjectExportJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetProjectExportJobResponse() = default;
};
class GetPublicMediaInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};

  GetPublicMediaInfoRequest() {}

  explicit GetPublicMediaInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~GetPublicMediaInfoRequest() = default;
};
class GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> type{};

  GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData() {}

  explicit GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData() = default;
};
class GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> profile{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList() {}

  explicit GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList() = default;
};
class GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo() {}

  explicit GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo() = default;
};
class GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList() {}

  explicit GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList() = default;
};
class GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFPS{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> nbFrames{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};
  shared_ptr<string> width{};

  GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList() {}

  explicit GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFPS) {
      res["AvgFPS"] = boost::any(*avgFPS);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (nbFrames) {
      res["Nb_frames"] = boost::any(*nbFrames);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgFPS") != m.end() && !m["AvgFPS"].empty()) {
      avgFPS = make_shared<string>(boost::any_cast<string>(m["AvgFPS"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Nb_frames") != m.end() && !m["Nb_frames"].empty()) {
      nbFrames = make_shared<string>(boost::any_cast<string>(m["Nb_frames"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList() = default;
};
class GetPublicMediaInfoResponseBodyMediaInfoFileInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList>> subtitleStreamInfoList{};
  shared_ptr<vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList>> videoStreamInfoList{};

  GetPublicMediaInfoResponseBodyMediaInfoFileInfoList() {}

  explicit GetPublicMediaInfoResponseBodyMediaInfoFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (subtitleStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*subtitleStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitleStreamInfoList"] = boost::any(temp1);
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo>(model1);
      }
    }
    if (m.find("SubtitleStreamInfoList") != m.end() && !m["SubtitleStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitleStreamInfoList"].type()) {
        vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitleStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitleStreamInfoList = make_shared<vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList>>(expect1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~GetPublicMediaInfoResponseBodyMediaInfoFileInfoList() = default;
};
class GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteImages{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo() {}

  explicit GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteImages) {
      res["SpriteImages"] = boost::any(*spriteImages);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteImages") != m.end() && !m["SpriteImages"].empty()) {
      spriteImages = make_shared<string>(boost::any_cast<string>(m["SpriteImages"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo() = default;
};
class GetPublicMediaInfoResponseBodyMediaInfo : public Darabonba::Model {
public:
  shared_ptr<GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData> dynamicMetaData{};
  shared_ptr<vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoList>> fileInfoList{};
  shared_ptr<GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  GetPublicMediaInfoResponseBodyMediaInfo() {}

  explicit GetPublicMediaInfoResponseBodyMediaInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicMetaData) {
      res["DynamicMetaData"] = dynamicMetaData ? boost::any(dynamicMetaData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicMetaData") != m.end() && !m["DynamicMetaData"].empty()) {
      if (typeid(map<string, boost::any>) == m["DynamicMetaData"].type()) {
        GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DynamicMetaData"]));
        dynamicMetaData = make_shared<GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData>(model1);
      }
    }
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPublicMediaInfoResponseBodyMediaInfoFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<GetPublicMediaInfoResponseBodyMediaInfoFileInfoList>>(expect1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~GetPublicMediaInfoResponseBodyMediaInfo() = default;
};
class GetPublicMediaInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPublicMediaInfoResponseBodyMediaInfo> mediaInfo{};
  shared_ptr<string> requestId{};

  GetPublicMediaInfoResponseBody() {}

  explicit GetPublicMediaInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfo) {
      res["MediaInfo"] = mediaInfo ? boost::any(mediaInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfo") != m.end() && !m["MediaInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfo"].type()) {
        GetPublicMediaInfoResponseBodyMediaInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfo"]));
        mediaInfo = make_shared<GetPublicMediaInfoResponseBodyMediaInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPublicMediaInfoResponseBody() = default;
};
class GetPublicMediaInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPublicMediaInfoResponseBody> body{};

  GetPublicMediaInfoResponse() {}

  explicit GetPublicMediaInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPublicMediaInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPublicMediaInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetPublicMediaInfoResponse() = default;
};
class GetSmartHandleJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetSmartHandleJobRequest() {}

  explicit GetSmartHandleJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetSmartHandleJobRequest() = default;
};
class GetSmartHandleJobResponseBodyJobResult : public Darabonba::Model {
public:
  shared_ptr<string> aiResult{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaUrl{};
  shared_ptr<string> usage{};

  GetSmartHandleJobResponseBodyJobResult() {}

  explicit GetSmartHandleJobResponseBodyJobResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiResult) {
      res["AiResult"] = boost::any(*aiResult);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaUrl) {
      res["MediaUrl"] = boost::any(*mediaUrl);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiResult") != m.end() && !m["AiResult"].empty()) {
      aiResult = make_shared<string>(boost::any_cast<string>(m["AiResult"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaUrl") != m.end() && !m["MediaUrl"].empty()) {
      mediaUrl = make_shared<string>(boost::any_cast<string>(m["MediaUrl"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~GetSmartHandleJobResponseBodyJobResult() = default;
};
class GetSmartHandleJobResponseBodySmartJobInfoInputConfig : public Darabonba::Model {
public:
  shared_ptr<string> inputFile{};

  GetSmartHandleJobResponseBodySmartJobInfoInputConfig() {}

  explicit GetSmartHandleJobResponseBodySmartJobInfoInputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputFile) {
      res["InputFile"] = boost::any(*inputFile);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      inputFile = make_shared<string>(boost::any_cast<string>(m["InputFile"]));
    }
  }


  virtual ~GetSmartHandleJobResponseBodySmartJobInfoInputConfig() = default;
};
class GetSmartHandleJobResponseBodySmartJobInfoOutputConfig : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> object{};

  GetSmartHandleJobResponseBodySmartJobInfoOutputConfig() {}

  explicit GetSmartHandleJobResponseBodySmartJobInfoOutputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~GetSmartHandleJobResponseBodySmartJobInfoOutputConfig() = default;
};
class GetSmartHandleJobResponseBodySmartJobInfo : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<GetSmartHandleJobResponseBodySmartJobInfoInputConfig> inputConfig{};
  shared_ptr<string> jobType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<GetSmartHandleJobResponseBodySmartJobInfoOutputConfig> outputConfig{};
  shared_ptr<string> title{};
  shared_ptr<string> userId{};

  GetSmartHandleJobResponseBodySmartJobInfo() {}

  explicit GetSmartHandleJobResponseBodySmartJobInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputConfig) {
      res["InputConfig"] = inputConfig ? boost::any(inputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (outputConfig) {
      res["OutputConfig"] = outputConfig ? boost::any(outputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputConfig"].type()) {
        GetSmartHandleJobResponseBodySmartJobInfoInputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputConfig"]));
        inputConfig = make_shared<GetSmartHandleJobResponseBodySmartJobInfoInputConfig>(model1);
      }
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputConfig"].type()) {
        GetSmartHandleJobResponseBodySmartJobInfoOutputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputConfig"]));
        outputConfig = make_shared<GetSmartHandleJobResponseBodySmartJobInfoOutputConfig>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetSmartHandleJobResponseBodySmartJobInfo() = default;
};
class GetSmartHandleJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> jobId{};
  shared_ptr<GetSmartHandleJobResponseBodyJobResult> jobResult{};
  shared_ptr<string> output{};
  shared_ptr<string> requestId{};
  shared_ptr<GetSmartHandleJobResponseBodySmartJobInfo> smartJobInfo{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};

  GetSmartHandleJobResponseBody() {}

  explicit GetSmartHandleJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobResult) {
      res["JobResult"] = jobResult ? boost::any(jobResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (smartJobInfo) {
      res["SmartJobInfo"] = smartJobInfo ? boost::any(smartJobInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobResult") != m.end() && !m["JobResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobResult"].type()) {
        GetSmartHandleJobResponseBodyJobResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobResult"]));
        jobResult = make_shared<GetSmartHandleJobResponseBodyJobResult>(model1);
      }
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SmartJobInfo") != m.end() && !m["SmartJobInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmartJobInfo"].type()) {
        GetSmartHandleJobResponseBodySmartJobInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmartJobInfo"]));
        smartJobInfo = make_shared<GetSmartHandleJobResponseBodySmartJobInfo>(model1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetSmartHandleJobResponseBody() = default;
};
class GetSmartHandleJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSmartHandleJobResponseBody> body{};

  GetSmartHandleJobResponse() {}

  explicit GetSmartHandleJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSmartHandleJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSmartHandleJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetSmartHandleJobResponse() = default;
};
class GetSnapshotJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  GetSnapshotJobRequest() {}

  explicit GetSnapshotJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetSnapshotJobRequest() = default;
};
class GetSnapshotJobResponseBodySnapshotJobInputOssFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  GetSnapshotJobResponseBodySnapshotJobInputOssFile() {}

  explicit GetSnapshotJobResponseBodySnapshotJobInputOssFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~GetSnapshotJobResponseBodySnapshotJobInputOssFile() = default;
};
class GetSnapshotJobResponseBodySnapshotJobInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<GetSnapshotJobResponseBodySnapshotJobInputOssFile> ossFile{};
  shared_ptr<string> type{};

  GetSnapshotJobResponseBodySnapshotJobInput() {}

  explicit GetSnapshotJobResponseBodySnapshotJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (ossFile) {
      res["OssFile"] = ossFile ? boost::any(ossFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("OssFile") != m.end() && !m["OssFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssFile"].type()) {
        GetSnapshotJobResponseBodySnapshotJobInputOssFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssFile"]));
        ossFile = make_shared<GetSnapshotJobResponseBodySnapshotJobInputOssFile>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetSnapshotJobResponseBodySnapshotJobInput() = default;
};
class GetSnapshotJobResponseBodySnapshotJobOutputOssFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  GetSnapshotJobResponseBodySnapshotJobOutputOssFile() {}

  explicit GetSnapshotJobResponseBodySnapshotJobOutputOssFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~GetSnapshotJobResponseBodySnapshotJobOutputOssFile() = default;
};
class GetSnapshotJobResponseBodySnapshotJobOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<GetSnapshotJobResponseBodySnapshotJobOutputOssFile> ossFile{};
  shared_ptr<string> type{};

  GetSnapshotJobResponseBodySnapshotJobOutput() {}

  explicit GetSnapshotJobResponseBodySnapshotJobOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (ossFile) {
      res["OssFile"] = ossFile ? boost::any(ossFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("OssFile") != m.end() && !m["OssFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssFile"].type()) {
        GetSnapshotJobResponseBodySnapshotJobOutputOssFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssFile"]));
        ossFile = make_shared<GetSnapshotJobResponseBodySnapshotJobOutputOssFile>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetSnapshotJobResponseBodySnapshotJobOutput() = default;
};
class GetSnapshotJobResponseBodySnapshotJob : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> code{};
  shared_ptr<long> count{};
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<GetSnapshotJobResponseBodySnapshotJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<GetSnapshotJobResponseBodySnapshotJobOutput> output{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> type{};
  shared_ptr<string> userData{};

  GetSnapshotJobResponseBodySnapshotJob() {}

  explicit GetSnapshotJobResponseBodySnapshotJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        GetSnapshotJobResponseBodySnapshotJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<GetSnapshotJobResponseBodySnapshotJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        GetSnapshotJobResponseBodySnapshotJobOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<GetSnapshotJobResponseBodySnapshotJobOutput>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetSnapshotJobResponseBodySnapshotJob() = default;
};
class GetSnapshotJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetSnapshotJobResponseBodySnapshotJob> snapshotJob{};

  GetSnapshotJobResponseBody() {}

  explicit GetSnapshotJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotJob) {
      res["SnapshotJob"] = snapshotJob ? boost::any(snapshotJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotJob") != m.end() && !m["SnapshotJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotJob"].type()) {
        GetSnapshotJobResponseBodySnapshotJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotJob"]));
        snapshotJob = make_shared<GetSnapshotJobResponseBodySnapshotJob>(model1);
      }
    }
  }


  virtual ~GetSnapshotJobResponseBody() = default;
};
class GetSnapshotJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSnapshotJobResponseBody> body{};

  GetSnapshotJobResponse() {}

  explicit GetSnapshotJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSnapshotJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSnapshotJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetSnapshotJobResponse() = default;
};
class GetSnapshotUrlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> timeout{};

  GetSnapshotUrlsRequest() {}

  explicit GetSnapshotUrlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
  }


  virtual ~GetSnapshotUrlsRequest() = default;
};
class GetSnapshotUrlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> snapshotUrls{};
  shared_ptr<long> total{};
  shared_ptr<string> webVTTUrl{};

  GetSnapshotUrlsResponseBody() {}

  explicit GetSnapshotUrlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snapshotUrls) {
      res["SnapshotUrls"] = boost::any(*snapshotUrls);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (webVTTUrl) {
      res["WebVTTUrl"] = boost::any(*webVTTUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnapshotUrls") != m.end() && !m["SnapshotUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SnapshotUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SnapshotUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snapshotUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("WebVTTUrl") != m.end() && !m["WebVTTUrl"].empty()) {
      webVTTUrl = make_shared<string>(boost::any_cast<string>(m["WebVTTUrl"]));
    }
  }


  virtual ~GetSnapshotUrlsResponseBody() = default;
};
class GetSnapshotUrlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSnapshotUrlsResponseBody> body{};

  GetSnapshotUrlsResponse() {}

  explicit GetSnapshotUrlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSnapshotUrlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSnapshotUrlsResponseBody>(model1);
      }
    }
  }


  virtual ~GetSnapshotUrlsResponse() = default;
};
class GetSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceType{};

  GetSourceRequest() {}

  explicit GetSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~GetSourceRequest() = default;
};
class GetSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ChannelAssemblySource> source{};

  GetSourceResponseBody() {}

  explicit GetSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (source) {
      res["Source"] = source ? boost::any(source->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(map<string, boost::any>) == m["Source"].type()) {
        ChannelAssemblySource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Source"]));
        source = make_shared<ChannelAssemblySource>(model1);
      }
    }
  }


  virtual ~GetSourceResponseBody() = default;
};
class GetSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSourceResponseBody> body{};

  GetSourceResponse() {}

  explicit GetSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSourceResponseBody>(model1);
      }
    }
  }


  virtual ~GetSourceResponse() = default;
};
class GetSourceLocationRequest : public Darabonba::Model {
public:
  shared_ptr<string> sourceLocationName{};

  GetSourceLocationRequest() {}

  explicit GetSourceLocationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
  }


  virtual ~GetSourceLocationRequest() = default;
};
class GetSourceLocationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ChannelAssemblySourceLocation> sourceLocation{};

  GetSourceLocationResponseBody() {}

  explicit GetSourceLocationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceLocation) {
      res["SourceLocation"] = sourceLocation ? boost::any(sourceLocation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceLocation") != m.end() && !m["SourceLocation"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceLocation"].type()) {
        ChannelAssemblySourceLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceLocation"]));
        sourceLocation = make_shared<ChannelAssemblySourceLocation>(model1);
      }
    }
  }


  virtual ~GetSourceLocationResponseBody() = default;
};
class GetSourceLocationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSourceLocationResponseBody> body{};

  GetSourceLocationResponse() {}

  explicit GetSourceLocationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSourceLocationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSourceLocationResponseBody>(model1);
      }
    }
  }


  virtual ~GetSourceLocationResponse() = default;
};
class GetStorageListRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> status{};
  shared_ptr<string> storageType{};

  GetStorageListRequest() {}

  explicit GetStorageListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~GetStorageListRequest() = default;
};
class GetStorageListResponseBodyStorageInfoList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> creationTime{};
  shared_ptr<bool> defaultStorage{};
  shared_ptr<bool> editingTempFileStorage{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> path{};
  shared_ptr<string> status{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> storageType{};

  GetStorageListResponseBodyStorageInfoList() {}

  explicit GetStorageListResponseBodyStorageInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (defaultStorage) {
      res["DefaultStorage"] = boost::any(*defaultStorage);
    }
    if (editingTempFileStorage) {
      res["EditingTempFileStorage"] = boost::any(*editingTempFileStorage);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DefaultStorage") != m.end() && !m["DefaultStorage"].empty()) {
      defaultStorage = make_shared<bool>(boost::any_cast<bool>(m["DefaultStorage"]));
    }
    if (m.find("EditingTempFileStorage") != m.end() && !m["EditingTempFileStorage"].empty()) {
      editingTempFileStorage = make_shared<bool>(boost::any_cast<bool>(m["EditingTempFileStorage"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~GetStorageListResponseBodyStorageInfoList() = default;
};
class GetStorageListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetStorageListResponseBodyStorageInfoList>> storageInfoList{};

  GetStorageListResponseBody() {}

  explicit GetStorageListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (storageInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*storageInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StorageInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StorageInfoList") != m.end() && !m["StorageInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["StorageInfoList"].type()) {
        vector<GetStorageListResponseBodyStorageInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StorageInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetStorageListResponseBodyStorageInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        storageInfoList = make_shared<vector<GetStorageListResponseBodyStorageInfoList>>(expect1);
      }
    }
  }


  virtual ~GetStorageListResponseBody() = default;
};
class GetStorageListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetStorageListResponseBody> body{};

  GetStorageListResponse() {}

  explicit GetStorageListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetStorageListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetStorageListResponseBody>(model1);
      }
    }
  }


  virtual ~GetStorageListResponse() = default;
};
class GetSystemTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  GetSystemTemplateRequest() {}

  explicit GetSystemTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetSystemTemplateRequest() = default;
};
class GetSystemTemplateResponseBodySystemTemplate : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> subtype{};
  shared_ptr<string> subtypeName{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> type{};
  shared_ptr<string> typeName_{};

  GetSystemTemplateResponseBodySystemTemplate() {}

  explicit GetSystemTemplateResponseBodySystemTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (subtypeName) {
      res["SubtypeName"] = boost::any(*subtypeName);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<long>(boost::any_cast<long>(m["Subtype"]));
    }
    if (m.find("SubtypeName") != m.end() && !m["SubtypeName"].empty()) {
      subtypeName = make_shared<string>(boost::any_cast<string>(m["SubtypeName"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~GetSystemTemplateResponseBodySystemTemplate() = default;
};
class GetSystemTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetSystemTemplateResponseBodySystemTemplate> systemTemplate{};

  GetSystemTemplateResponseBody() {}

  explicit GetSystemTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (systemTemplate) {
      res["SystemTemplate"] = systemTemplate ? boost::any(systemTemplate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SystemTemplate") != m.end() && !m["SystemTemplate"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemTemplate"].type()) {
        GetSystemTemplateResponseBodySystemTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemTemplate"]));
        systemTemplate = make_shared<GetSystemTemplateResponseBodySystemTemplate>(model1);
      }
    }
  }


  virtual ~GetSystemTemplateResponseBody() = default;
};
class GetSystemTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSystemTemplateResponseBody> body{};

  GetSystemTemplateResponse() {}

  explicit GetSystemTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSystemTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSystemTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetSystemTemplateResponse() = default;
};
class GetTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> relatedMediaidFlag{};
  shared_ptr<string> templateId{};

  GetTemplateRequest() {}

  explicit GetTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (relatedMediaidFlag) {
      res["RelatedMediaidFlag"] = boost::any(*relatedMediaidFlag);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RelatedMediaidFlag") != m.end() && !m["RelatedMediaidFlag"].empty()) {
      relatedMediaidFlag = make_shared<string>(boost::any_cast<string>(m["RelatedMediaidFlag"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTemplateRequest() = default;
};
class GetTemplateResponseBodyTemplate : public Darabonba::Model {
public:
  shared_ptr<string> clipsParam{};
  shared_ptr<string> config{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createSource{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> modifiedSource{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<string> previewMedia{};
  shared_ptr<string> previewMediaStatus{};
  shared_ptr<string> relatedMediaids{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  GetTemplateResponseBodyTemplate() {}

  explicit GetTemplateResponseBodyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (modifiedSource) {
      res["ModifiedSource"] = boost::any(*modifiedSource);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (previewMedia) {
      res["PreviewMedia"] = boost::any(*previewMedia);
    }
    if (previewMediaStatus) {
      res["PreviewMediaStatus"] = boost::any(*previewMediaStatus);
    }
    if (relatedMediaids) {
      res["RelatedMediaids"] = boost::any(*relatedMediaids);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ModifiedSource") != m.end() && !m["ModifiedSource"].empty()) {
      modifiedSource = make_shared<string>(boost::any_cast<string>(m["ModifiedSource"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PreviewMedia") != m.end() && !m["PreviewMedia"].empty()) {
      previewMedia = make_shared<string>(boost::any_cast<string>(m["PreviewMedia"]));
    }
    if (m.find("PreviewMediaStatus") != m.end() && !m["PreviewMediaStatus"].empty()) {
      previewMediaStatus = make_shared<string>(boost::any_cast<string>(m["PreviewMediaStatus"]));
    }
    if (m.find("RelatedMediaids") != m.end() && !m["RelatedMediaids"].empty()) {
      relatedMediaids = make_shared<string>(boost::any_cast<string>(m["RelatedMediaids"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTemplateResponseBodyTemplate() = default;
};
class GetTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetTemplateResponseBodyTemplate> template_{};

  GetTemplateResponseBody() {}

  explicit GetTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (template_) {
      res["Template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(map<string, boost::any>) == m["Template"].type()) {
        GetTemplateResponseBodyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Template"]));
        template_ = make_shared<GetTemplateResponseBodyTemplate>(model1);
      }
    }
  }


  virtual ~GetTemplateResponseBody() = default;
};
class GetTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTemplateResponseBody> body{};

  GetTemplateResponse() {}

  explicit GetTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~GetTemplateResponse() = default;
};
class GetTemplateMaterialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileList{};
  shared_ptr<string> templateId{};

  GetTemplateMaterialsRequest() {}

  explicit GetTemplateMaterialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileList) {
      res["FileList"] = boost::any(*fileList);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileList") != m.end() && !m["FileList"].empty()) {
      fileList = make_shared<string>(boost::any_cast<string>(m["FileList"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTemplateMaterialsRequest() = default;
};
class GetTemplateMaterialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> materialUrls{};
  shared_ptr<string> requestId{};

  GetTemplateMaterialsResponseBody() {}

  explicit GetTemplateMaterialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (materialUrls) {
      res["MaterialUrls"] = boost::any(*materialUrls);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaterialUrls") != m.end() && !m["MaterialUrls"].empty()) {
      materialUrls = make_shared<string>(boost::any_cast<string>(m["MaterialUrls"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetTemplateMaterialsResponseBody() = default;
};
class GetTemplateMaterialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTemplateMaterialsResponseBody> body{};

  GetTemplateMaterialsResponse() {}

  explicit GetTemplateMaterialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTemplateMaterialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTemplateMaterialsResponseBody>(model1);
      }
    }
  }


  virtual ~GetTemplateMaterialsResponse() = default;
};
class GetTemplateParamsRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  GetTemplateParamsRequest() {}

  explicit GetTemplateParamsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTemplateParamsRequest() = default;
};
class GetTemplateParamsResponseBodyParamList : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> coverUrl{};
  shared_ptr<string> key{};
  shared_ptr<string> mediaUrl{};
  shared_ptr<string> type{};

  GetTemplateParamsResponseBodyParamList() {}

  explicit GetTemplateParamsResponseBodyParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (mediaUrl) {
      res["MediaUrl"] = boost::any(*mediaUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("MediaUrl") != m.end() && !m["MediaUrl"].empty()) {
      mediaUrl = make_shared<string>(boost::any_cast<string>(m["MediaUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTemplateParamsResponseBodyParamList() = default;
};
class GetTemplateParamsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetTemplateParamsResponseBodyParamList>> paramList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> templateId{};

  GetTemplateParamsResponseBody() {}

  explicit GetTemplateParamsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (paramList) {
      vector<boost::any> temp1;
      for(auto item1:*paramList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParamList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParamList") != m.end() && !m["ParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParamList"].type()) {
        vector<GetTemplateParamsResponseBodyParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTemplateParamsResponseBodyParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paramList = make_shared<vector<GetTemplateParamsResponseBodyParamList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTemplateParamsResponseBody() = default;
};
class GetTemplateParamsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTemplateParamsResponseBody> body{};

  GetTemplateParamsResponse() {}

  explicit GetTemplateParamsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTemplateParamsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTemplateParamsResponseBody>(model1);
      }
    }
  }


  virtual ~GetTemplateParamsResponse() = default;
};
class GetTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> parentJobId{};

  GetTranscodeJobRequest() {}

  explicit GetTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parentJobId) {
      res["ParentJobId"] = boost::any(*parentJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParentJobId") != m.end() && !m["ParentJobId"].empty()) {
      parentJobId = make_shared<string>(boost::any_cast<string>(m["ParentJobId"]));
    }
  }


  virtual ~GetTranscodeJobRequest() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobInputGroup : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetTranscodeJobResponseBodyTranscodeParentJobInputGroup() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobInputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobInputGroup() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> outputUrl{};
  shared_ptr<string> type{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (outputUrl) {
      res["OutputUrl"] = boost::any(*outputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("OutputUrl") != m.end() && !m["OutputUrl"].empty()) {
      outputUrl = make_shared<string>(boost::any_cast<string>(m["OutputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs : public Darabonba::Model {
public:
  shared_ptr<string> audioIndex{};
  shared_ptr<double> duration{};
  shared_ptr<double> start{};
  shared_ptr<string> videoIndex{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioIndex) {
      res["AudioIndex"] = boost::any(*audioIndex);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (videoIndex) {
      res["VideoIndex"] = boost::any(*videoIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioIndex") != m.end() && !m["AudioIndex"].empty()) {
      audioIndex = make_shared<string>(boost::any_cast<string>(m["AudioIndex"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<double>(boost::any_cast<double>(m["Start"]));
    }
    if (m.find("VideoIndex") != m.end() && !m["VideoIndex"].empty()) {
      videoIndex = make_shared<string>(boost::any_cast<string>(m["VideoIndex"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption : public Darabonba::Model {
public:
  shared_ptr<string> cipherText{};
  shared_ptr<string> decryptKeyUri{};
  shared_ptr<string> encryptType{};
  shared_ptr<string> keyServiceType{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cipherText) {
      res["CipherText"] = boost::any(*cipherText);
    }
    if (decryptKeyUri) {
      res["DecryptKeyUri"] = boost::any(*decryptKeyUri);
    }
    if (encryptType) {
      res["EncryptType"] = boost::any(*encryptType);
    }
    if (keyServiceType) {
      res["KeyServiceType"] = boost::any(*keyServiceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CipherText") != m.end() && !m["CipherText"].empty()) {
      cipherText = make_shared<string>(boost::any_cast<string>(m["CipherText"]));
    }
    if (m.find("DecryptKeyUri") != m.end() && !m["DecryptKeyUri"].empty()) {
      decryptKeyUri = make_shared<string>(boost::any_cast<string>(m["DecryptKeyUri"]));
    }
    if (m.find("EncryptType") != m.end() && !m["EncryptType"].empty()) {
      encryptType = make_shared<string>(boost::any_cast<string>(m["EncryptType"]));
    }
    if (m.find("KeyServiceType") != m.end() && !m["KeyServiceType"].empty()) {
      keyServiceType = make_shared<string>(boost::any_cast<string>(m["KeyServiceType"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile> file{};
  shared_ptr<string> height{};
  shared_ptr<string> referPos{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline> timeline{};
  shared_ptr<string> width{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile> file{};
  shared_ptr<string> format{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> adaptive{};
  shared_ptr<string> borderColor{};
  shared_ptr<long> borderWidth{};
  shared_ptr<string> content{};
  shared_ptr<string> fontAlpha{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<long> fontSize{};
  shared_ptr<string> left{};
  shared_ptr<string> top{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adaptive) {
      res["Adaptive"] = boost::any(*adaptive);
    }
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidth) {
      res["BorderWidth"] = boost::any(*borderWidth);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fontAlpha) {
      res["FontAlpha"] = boost::any(*fontAlpha);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSize) {
      res["FontSize"] = boost::any(*fontSize);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adaptive") != m.end() && !m["Adaptive"].empty()) {
      adaptive = make_shared<string>(boost::any_cast<string>(m["Adaptive"]));
    }
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidth") != m.end() && !m["BorderWidth"].empty()) {
      borderWidth = make_shared<long>(boost::any_cast<long>(m["BorderWidth"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FontAlpha") != m.end() && !m["FontAlpha"].empty()) {
      fontAlpha = make_shared<string>(boost::any_cast<string>(m["FontAlpha"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSize") != m.end() && !m["FontSize"].empty()) {
      fontSize = make_shared<long>(boost::any_cast<long>(m["FontSize"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> integratedLoudnessTarget{};
  shared_ptr<string> loudnessRangeTarget{};
  shared_ptr<string> method{};
  shared_ptr<string> truePeak{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedLoudnessTarget) {
      res["IntegratedLoudnessTarget"] = boost::any(*integratedLoudnessTarget);
    }
    if (loudnessRangeTarget) {
      res["LoudnessRangeTarget"] = boost::any(*loudnessRangeTarget);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (truePeak) {
      res["TruePeak"] = boost::any(*truePeak);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedLoudnessTarget") != m.end() && !m["IntegratedLoudnessTarget"].empty()) {
      integratedLoudnessTarget = make_shared<string>(boost::any_cast<string>(m["IntegratedLoudnessTarget"]));
    }
    if (m.find("LoudnessRangeTarget") != m.end() && !m["LoudnessRangeTarget"].empty()) {
      loudnessRangeTarget = make_shared<string>(boost::any_cast<string>(m["LoudnessRangeTarget"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("TruePeak") != m.end() && !m["TruePeak"].empty()) {
      truePeak = make_shared<string>(boost::any_cast<string>(m["TruePeak"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume> volume{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> forceSegTime{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (forceSegTime) {
      res["ForceSegTime"] = boost::any(*forceSegTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ForceSegTime") != m.end() && !m["ForceSegTime"].empty()) {
      forceSegTime = make_shared<string>(boost::any_cast<string>(m["ForceSegTime"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment> segment{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo : public Darabonba::Model {
public:
  shared_ptr<string> abrMax{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abrMax) {
      res["AbrMax"] = boost::any(*abrMax);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbrMax") != m.end() && !m["AbrMax"].empty()) {
      abrMax = make_shared<string>(boost::any_cast<string>(m["AbrMax"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio> audio{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer> container{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig> muxConfig{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig> transConfig{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo> video{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig : public Darabonba::Model {
public:
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs>> combineConfigs{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption> encryption{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks>> imageWatermarks{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles>> subtitles{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks>> textWatermarks{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode> transcode{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (combineConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*combineConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CombineConfigs"] = boost::any(temp1);
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*imageWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageWatermarks"] = boost::any(temp1);
    }
    if (subtitles) {
      vector<boost::any> temp1;
      for(auto item1:*subtitles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitles"] = boost::any(temp1);
    }
    if (textWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*textWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextWatermarks"] = boost::any(temp1);
    }
    if (transcode) {
      res["Transcode"] = transcode ? boost::any(transcode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CombineConfigs") != m.end() && !m["CombineConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["CombineConfigs"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CombineConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        combineConfigs = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs>>(expect1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption>(model1);
      }
    }
    if (m.find("ImageWatermarks") != m.end() && !m["ImageWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageWatermarks"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageWatermarks = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks>>(expect1);
      }
    }
    if (m.find("Subtitles") != m.end() && !m["Subtitles"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitles"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitles = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles>>(expect1);
      }
    }
    if (m.find("TextWatermarks") != m.end() && !m["TextWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["TextWatermarks"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textWatermarks = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks>>(expect1);
      }
    }
    if (m.find("Transcode") != m.end() && !m["Transcode"].empty()) {
      if (typeid(map<string, boost::any>) == m["Transcode"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Transcode"]));
        transcode = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput> output{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig> processConfig{};

  GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (processConfig) {
      res["ProcessConfig"] = processConfig ? boost::any(processConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput>(model1);
      }
    }
    if (m.find("ProcessConfig") != m.end() && !m["ProcessConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProcessConfig"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProcessConfig"]));
        processConfig = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup : public Darabonba::Model {
public:
  shared_ptr<string> inputUrl{};
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputUrl) {
      res["InputUrl"] = boost::any(*inputUrl);
    }
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputUrl") != m.end() && !m["InputUrl"].empty()) {
      inputUrl = make_shared<string>(boost::any_cast<string>(m["InputUrl"]));
    }
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFps{};
  shared_ptr<string> bitRate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeBase{};
  shared_ptr<string> width{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFps) {
      res["Avg_fps"] = boost::any(*avgFps);
    }
    if (bitRate) {
      res["Bit_rate"] = boost::any(*bitRate);
    }
    if (codecLongName) {
      res["Codec_long_name"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["Codec_name"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["Codec_tag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["Codec_tag_string"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["Codec_time_base"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["Has_b_frames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["Start_time"] = boost::any(*startTime);
    }
    if (timeBase) {
      res["Time_base"] = boost::any(*timeBase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avg_fps") != m.end() && !m["Avg_fps"].empty()) {
      avgFps = make_shared<string>(boost::any_cast<string>(m["Avg_fps"]));
    }
    if (m.find("Bit_rate") != m.end() && !m["Bit_rate"].empty()) {
      bitRate = make_shared<string>(boost::any_cast<string>(m["Bit_rate"]));
    }
    if (m.find("Codec_long_name") != m.end() && !m["Codec_long_name"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["Codec_long_name"]));
    }
    if (m.find("Codec_name") != m.end() && !m["Codec_name"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["Codec_name"]));
    }
    if (m.find("Codec_tag") != m.end() && !m["Codec_tag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["Codec_tag"]));
    }
    if (m.find("Codec_tag_string") != m.end() && !m["Codec_tag_string"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["Codec_tag_string"]));
    }
    if (m.find("Codec_time_base") != m.end() && !m["Codec_time_base"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["Codec_time_base"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Has_b_frames") != m.end() && !m["Has_b_frames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["Has_b_frames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Start_time") != m.end() && !m["Start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["Start_time"]));
    }
    if (m.find("Time_base") != m.end() && !m["Time_base"].empty()) {
      timeBase = make_shared<string>(boost::any_cast<string>(m["Time_base"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta : public Darabonba::Model {
public:
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList>> videoStreamInfoList{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo>(model1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> outputUrl{};
  shared_ptr<string> type{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (outputUrl) {
      res["OutputUrl"] = boost::any(*outputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("OutputUrl") != m.end() && !m["OutputUrl"].empty()) {
      outputUrl = make_shared<string>(boost::any_cast<string>(m["OutputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs : public Darabonba::Model {
public:
  shared_ptr<string> audioIndex{};
  shared_ptr<double> duration{};
  shared_ptr<double> start{};
  shared_ptr<string> videoIndex{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioIndex) {
      res["AudioIndex"] = boost::any(*audioIndex);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (videoIndex) {
      res["VideoIndex"] = boost::any(*videoIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioIndex") != m.end() && !m["AudioIndex"].empty()) {
      audioIndex = make_shared<string>(boost::any_cast<string>(m["AudioIndex"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<double>(boost::any_cast<double>(m["Start"]));
    }
    if (m.find("VideoIndex") != m.end() && !m["VideoIndex"].empty()) {
      videoIndex = make_shared<string>(boost::any_cast<string>(m["VideoIndex"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption : public Darabonba::Model {
public:
  shared_ptr<string> cipherText{};
  shared_ptr<string> decryptKeyUri{};
  shared_ptr<string> encryptType{};
  shared_ptr<string> keyServiceType{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cipherText) {
      res["CipherText"] = boost::any(*cipherText);
    }
    if (decryptKeyUri) {
      res["DecryptKeyUri"] = boost::any(*decryptKeyUri);
    }
    if (encryptType) {
      res["EncryptType"] = boost::any(*encryptType);
    }
    if (keyServiceType) {
      res["KeyServiceType"] = boost::any(*keyServiceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CipherText") != m.end() && !m["CipherText"].empty()) {
      cipherText = make_shared<string>(boost::any_cast<string>(m["CipherText"]));
    }
    if (m.find("DecryptKeyUri") != m.end() && !m["DecryptKeyUri"].empty()) {
      decryptKeyUri = make_shared<string>(boost::any_cast<string>(m["DecryptKeyUri"]));
    }
    if (m.find("EncryptType") != m.end() && !m["EncryptType"].empty()) {
      encryptType = make_shared<string>(boost::any_cast<string>(m["EncryptType"]));
    }
    if (m.find("KeyServiceType") != m.end() && !m["KeyServiceType"].empty()) {
      keyServiceType = make_shared<string>(boost::any_cast<string>(m["KeyServiceType"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile> file{};
  shared_ptr<string> height{};
  shared_ptr<string> referPos{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline> timeline{};
  shared_ptr<string> width{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile> file{};
  shared_ptr<string> format{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> adaptive{};
  shared_ptr<string> borderColor{};
  shared_ptr<long> borderWidth{};
  shared_ptr<string> content{};
  shared_ptr<string> fontAlpha{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<long> fontSize{};
  shared_ptr<string> left{};
  shared_ptr<string> top{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adaptive) {
      res["Adaptive"] = boost::any(*adaptive);
    }
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidth) {
      res["BorderWidth"] = boost::any(*borderWidth);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fontAlpha) {
      res["FontAlpha"] = boost::any(*fontAlpha);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSize) {
      res["FontSize"] = boost::any(*fontSize);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adaptive") != m.end() && !m["Adaptive"].empty()) {
      adaptive = make_shared<string>(boost::any_cast<string>(m["Adaptive"]));
    }
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidth") != m.end() && !m["BorderWidth"].empty()) {
      borderWidth = make_shared<long>(boost::any_cast<long>(m["BorderWidth"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FontAlpha") != m.end() && !m["FontAlpha"].empty()) {
      fontAlpha = make_shared<string>(boost::any_cast<string>(m["FontAlpha"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSize") != m.end() && !m["FontSize"].empty()) {
      fontSize = make_shared<long>(boost::any_cast<long>(m["FontSize"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> integratedLoudnessTarget{};
  shared_ptr<string> loudnessRangeTarget{};
  shared_ptr<string> method{};
  shared_ptr<string> truePeak{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedLoudnessTarget) {
      res["IntegratedLoudnessTarget"] = boost::any(*integratedLoudnessTarget);
    }
    if (loudnessRangeTarget) {
      res["LoudnessRangeTarget"] = boost::any(*loudnessRangeTarget);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (truePeak) {
      res["TruePeak"] = boost::any(*truePeak);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedLoudnessTarget") != m.end() && !m["IntegratedLoudnessTarget"].empty()) {
      integratedLoudnessTarget = make_shared<string>(boost::any_cast<string>(m["IntegratedLoudnessTarget"]));
    }
    if (m.find("LoudnessRangeTarget") != m.end() && !m["LoudnessRangeTarget"].empty()) {
      loudnessRangeTarget = make_shared<string>(boost::any_cast<string>(m["LoudnessRangeTarget"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("TruePeak") != m.end() && !m["TruePeak"].empty()) {
      truePeak = make_shared<string>(boost::any_cast<string>(m["TruePeak"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume> volume{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> forceSegTime{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (forceSegTime) {
      res["ForceSegTime"] = boost::any(*forceSegTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ForceSegTime") != m.end() && !m["ForceSegTime"].empty()) {
      forceSegTime = make_shared<string>(boost::any_cast<string>(m["ForceSegTime"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment> segment{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo : public Darabonba::Model {
public:
  shared_ptr<string> abrMax{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abrMax) {
      res["AbrMax"] = boost::any(*abrMax);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbrMax") != m.end() && !m["AbrMax"].empty()) {
      abrMax = make_shared<string>(boost::any_cast<string>(m["AbrMax"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio> audio{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer> container{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig> muxConfig{};
  shared_ptr<map<string, string>> tags{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig> transConfig{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo> video{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Tags"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode : public Darabonba::Model {
public:
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig : public Darabonba::Model {
public:
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs>> combineConfigs{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption> encryption{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks>> imageWatermarks{};
  shared_ptr<bool> isInheritTags{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles>> subtitles{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks>> textWatermarks{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode> transcode{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (combineConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*combineConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CombineConfigs"] = boost::any(temp1);
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*imageWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageWatermarks"] = boost::any(temp1);
    }
    if (isInheritTags) {
      res["IsInheritTags"] = boost::any(*isInheritTags);
    }
    if (subtitles) {
      vector<boost::any> temp1;
      for(auto item1:*subtitles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitles"] = boost::any(temp1);
    }
    if (textWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*textWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextWatermarks"] = boost::any(temp1);
    }
    if (transcode) {
      res["Transcode"] = transcode ? boost::any(transcode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CombineConfigs") != m.end() && !m["CombineConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["CombineConfigs"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CombineConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        combineConfigs = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs>>(expect1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption>(model1);
      }
    }
    if (m.find("ImageWatermarks") != m.end() && !m["ImageWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageWatermarks"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageWatermarks = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks>>(expect1);
      }
    }
    if (m.find("IsInheritTags") != m.end() && !m["IsInheritTags"].empty()) {
      isInheritTags = make_shared<bool>(boost::any_cast<bool>(m["IsInheritTags"]));
    }
    if (m.find("Subtitles") != m.end() && !m["Subtitles"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitles"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitles = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles>>(expect1);
      }
    }
    if (m.find("TextWatermarks") != m.end() && !m["TextWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["TextWatermarks"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textWatermarks = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks>>(expect1);
      }
    }
    if (m.find("Transcode") != m.end() && !m["Transcode"].empty()) {
      if (typeid(map<string, boost::any>) == m["Transcode"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Transcode"]));
        transcode = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup>> inputGroup{};
  shared_ptr<string> jobId{};
  shared_ptr<long> jobIndex{};
  shared_ptr<string> name{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta> outFileMeta{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput> output{};
  shared_ptr<string> parentJobId{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig> processConfig{};
  shared_ptr<string> requestId{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> submitResultJson{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> userData{};

  GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (inputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*inputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputGroup"] = boost::any(temp1);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobIndex) {
      res["JobIndex"] = boost::any(*jobIndex);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outFileMeta) {
      res["OutFileMeta"] = outFileMeta ? boost::any(outFileMeta->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentJobId) {
      res["ParentJobId"] = boost::any(*parentJobId);
    }
    if (processConfig) {
      res["ProcessConfig"] = processConfig ? boost::any(processConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitResultJson) {
      res["SubmitResultJson"] = boost::any(*submitResultJson);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("InputGroup") != m.end() && !m["InputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["InputGroup"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputGroup = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup>>(expect1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobIndex") != m.end() && !m["JobIndex"].empty()) {
      jobIndex = make_shared<long>(boost::any_cast<long>(m["JobIndex"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutFileMeta") != m.end() && !m["OutFileMeta"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutFileMeta"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutFileMeta"]));
        outFileMeta = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta>(model1);
      }
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput>(model1);
      }
    }
    if (m.find("ParentJobId") != m.end() && !m["ParentJobId"].empty()) {
      parentJobId = make_shared<string>(boost::any_cast<string>(m["ParentJobId"]));
    }
    if (m.find("ProcessConfig") != m.end() && !m["ProcessConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProcessConfig"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProcessConfig"]));
        processConfig = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitResultJson") != m.end() && !m["SubmitResultJson"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SubmitResultJson"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      submitResultJson = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList() = default;
};
class GetTranscodeJobResponseBodyTranscodeParentJob : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobInputGroup>> inputGroup{};
  shared_ptr<long> jobCount{};
  shared_ptr<string> name{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup>> outputGroup{};
  shared_ptr<string> parentJobId{};
  shared_ptr<long> percent{};
  shared_ptr<string> requestId{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList>> transcodeJobList{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  GetTranscodeJobResponseBodyTranscodeParentJob() {}

  explicit GetTranscodeJobResponseBodyTranscodeParentJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (inputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*inputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputGroup"] = boost::any(temp1);
    }
    if (jobCount) {
      res["JobCount"] = boost::any(*jobCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroup"] = boost::any(temp1);
    }
    if (parentJobId) {
      res["ParentJobId"] = boost::any(*parentJobId);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (transcodeJobList) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeJobList"] = boost::any(temp1);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("InputGroup") != m.end() && !m["InputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["InputGroup"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobInputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobInputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputGroup = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobInputGroup>>(expect1);
      }
    }
    if (m.find("JobCount") != m.end() && !m["JobCount"].empty()) {
      jobCount = make_shared<long>(boost::any_cast<long>(m["JobCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputGroup") != m.end() && !m["OutputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroup"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroup = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup>>(expect1);
      }
    }
    if (m.find("ParentJobId") != m.end() && !m["ParentJobId"].empty()) {
      parentJobId = make_shared<string>(boost::any_cast<string>(m["ParentJobId"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TranscodeJobList") != m.end() && !m["TranscodeJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeJobList"].type()) {
        vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeJobList = make_shared<vector<GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList>>(expect1);
      }
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetTranscodeJobResponseBodyTranscodeParentJob() = default;
};
class GetTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetTranscodeJobResponseBodyTranscodeParentJob> transcodeParentJob{};

  GetTranscodeJobResponseBody() {}

  explicit GetTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transcodeParentJob) {
      res["TranscodeParentJob"] = transcodeParentJob ? boost::any(transcodeParentJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TranscodeParentJob") != m.end() && !m["TranscodeParentJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeParentJob"].type()) {
        GetTranscodeJobResponseBodyTranscodeParentJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeParentJob"]));
        transcodeParentJob = make_shared<GetTranscodeJobResponseBodyTranscodeParentJob>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponseBody() = default;
};
class GetTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTranscodeJobResponseBody> body{};

  GetTranscodeJobResponse() {}

  explicit GetTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetTranscodeJobResponse() = default;
};
class GetUrlUploadInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobIds{};
  shared_ptr<string> uploadURLs{};

  GetUrlUploadInfosRequest() {}

  explicit GetUrlUploadInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (uploadURLs) {
      res["UploadURLs"] = boost::any(*uploadURLs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("UploadURLs") != m.end() && !m["UploadURLs"].empty()) {
      uploadURLs = make_shared<string>(boost::any_cast<string>(m["UploadURLs"]));
    }
  }


  virtual ~GetUrlUploadInfosRequest() = default;
};
class GetUrlUploadInfosResponseBodyURLUploadInfoList : public Darabonba::Model {
public:
  shared_ptr<string> completeTime{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> status{};
  shared_ptr<string> uploadURL{};
  shared_ptr<string> userData{};

  GetUrlUploadInfosResponseBodyURLUploadInfoList() {}

  explicit GetUrlUploadInfosResponseBodyURLUploadInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uploadURL) {
      res["UploadURL"] = boost::any(*uploadURL);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UploadURL") != m.end() && !m["UploadURL"].empty()) {
      uploadURL = make_shared<string>(boost::any_cast<string>(m["UploadURL"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetUrlUploadInfosResponseBodyURLUploadInfoList() = default;
};
class GetUrlUploadInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> nonExists{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetUrlUploadInfosResponseBodyURLUploadInfoList>> URLUploadInfoList{};

  GetUrlUploadInfosResponseBody() {}

  explicit GetUrlUploadInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonExists) {
      res["NonExists"] = boost::any(*nonExists);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (URLUploadInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*URLUploadInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["URLUploadInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NonExists") != m.end() && !m["NonExists"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NonExists"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NonExists"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nonExists = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("URLUploadInfoList") != m.end() && !m["URLUploadInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["URLUploadInfoList"].type()) {
        vector<GetUrlUploadInfosResponseBodyURLUploadInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["URLUploadInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUrlUploadInfosResponseBodyURLUploadInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        URLUploadInfoList = make_shared<vector<GetUrlUploadInfosResponseBodyURLUploadInfoList>>(expect1);
      }
    }
  }


  virtual ~GetUrlUploadInfosResponseBody() = default;
};
class GetUrlUploadInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUrlUploadInfosResponseBody> body{};

  GetUrlUploadInfosResponse() {}

  explicit GetUrlUploadInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUrlUploadInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUrlUploadInfosResponseBody>(model1);
      }
    }
  }


  virtual ~GetUrlUploadInfosResponse() = default;
};
class GetVideoListRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  GetVideoListRequest() {}

  explicit GetVideoListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetVideoListRequest() = default;
};
class GetVideoListResponseBodyMediaList : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> coverUrl{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<double> duration{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> modificationTime{};
  shared_ptr<long> size{};
  shared_ptr<vector<string>> snapshots{};
  shared_ptr<string> status{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};

  GetVideoListResponseBodyMediaList() {}

  explicit GetVideoListResponseBodyMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Snapshots"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Snapshots"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snapshots = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetVideoListResponseBodyMediaList() = default;
};
class GetVideoListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetVideoListResponseBodyMediaList>> mediaList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<long> total{};

  GetVideoListResponseBody() {}

  explicit GetVideoListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (mediaList) {
      vector<boost::any> temp1;
      for(auto item1:*mediaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("MediaList") != m.end() && !m["MediaList"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaList"].type()) {
        vector<GetVideoListResponseBodyMediaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVideoListResponseBodyMediaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaList = make_shared<vector<GetVideoListResponseBodyMediaList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetVideoListResponseBody() = default;
};
class GetVideoListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVideoListResponseBody> body{};

  GetVideoListResponse() {}

  explicit GetVideoListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVideoListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVideoListResponseBody>(model1);
      }
    }
  }


  virtual ~GetVideoListResponse() = default;
};
class GetVodPackagingAssetRequest : public Darabonba::Model {
public:
  shared_ptr<string> assetName{};

  GetVodPackagingAssetRequest() {}

  explicit GetVodPackagingAssetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetName) {
      res["AssetName"] = boost::any(*assetName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetName") != m.end() && !m["AssetName"].empty()) {
      assetName = make_shared<string>(boost::any_cast<string>(m["AssetName"]));
    }
  }


  virtual ~GetVodPackagingAssetRequest() = default;
};
class GetVodPackagingAssetResponseBodyAssetEgressEndpoints : public Darabonba::Model {
public:
  shared_ptr<string> configurationName{};
  shared_ptr<string> status{};
  shared_ptr<string> url{};

  GetVodPackagingAssetResponseBodyAssetEgressEndpoints() {}

  explicit GetVodPackagingAssetResponseBodyAssetEgressEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationName) {
      res["ConfigurationName"] = boost::any(*configurationName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationName") != m.end() && !m["ConfigurationName"].empty()) {
      configurationName = make_shared<string>(boost::any_cast<string>(m["ConfigurationName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetVodPackagingAssetResponseBodyAssetEgressEndpoints() = default;
};
class GetVodPackagingAssetResponseBodyAssetInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  GetVodPackagingAssetResponseBodyAssetInput() {}

  explicit GetVodPackagingAssetResponseBodyAssetInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetVodPackagingAssetResponseBodyAssetInput() = default;
};
class GetVodPackagingAssetResponseBodyAsset : public Darabonba::Model {
public:
  shared_ptr<string> assetName{};
  shared_ptr<string> contentId{};
  shared_ptr<string> createTime{};
  shared_ptr<vector<GetVodPackagingAssetResponseBodyAssetEgressEndpoints>> egressEndpoints{};
  shared_ptr<string> groupName{};
  shared_ptr<GetVodPackagingAssetResponseBodyAssetInput> input{};

  GetVodPackagingAssetResponseBodyAsset() {}

  explicit GetVodPackagingAssetResponseBodyAsset(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetName) {
      res["AssetName"] = boost::any(*assetName);
    }
    if (contentId) {
      res["ContentId"] = boost::any(*contentId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (egressEndpoints) {
      vector<boost::any> temp1;
      for(auto item1:*egressEndpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EgressEndpoints"] = boost::any(temp1);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetName") != m.end() && !m["AssetName"].empty()) {
      assetName = make_shared<string>(boost::any_cast<string>(m["AssetName"]));
    }
    if (m.find("ContentId") != m.end() && !m["ContentId"].empty()) {
      contentId = make_shared<string>(boost::any_cast<string>(m["ContentId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EgressEndpoints") != m.end() && !m["EgressEndpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["EgressEndpoints"].type()) {
        vector<GetVodPackagingAssetResponseBodyAssetEgressEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EgressEndpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVodPackagingAssetResponseBodyAssetEgressEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        egressEndpoints = make_shared<vector<GetVodPackagingAssetResponseBodyAssetEgressEndpoints>>(expect1);
      }
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        GetVodPackagingAssetResponseBodyAssetInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<GetVodPackagingAssetResponseBodyAssetInput>(model1);
      }
    }
  }


  virtual ~GetVodPackagingAssetResponseBodyAsset() = default;
};
class GetVodPackagingAssetResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetVodPackagingAssetResponseBodyAsset> asset{};
  shared_ptr<string> requestId{};

  GetVodPackagingAssetResponseBody() {}

  explicit GetVodPackagingAssetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asset) {
      res["Asset"] = asset ? boost::any(asset->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asset") != m.end() && !m["Asset"].empty()) {
      if (typeid(map<string, boost::any>) == m["Asset"].type()) {
        GetVodPackagingAssetResponseBodyAsset model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Asset"]));
        asset = make_shared<GetVodPackagingAssetResponseBodyAsset>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetVodPackagingAssetResponseBody() = default;
};
class GetVodPackagingAssetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVodPackagingAssetResponseBody> body{};

  GetVodPackagingAssetResponse() {}

  explicit GetVodPackagingAssetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVodPackagingAssetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVodPackagingAssetResponseBody>(model1);
      }
    }
  }


  virtual ~GetVodPackagingAssetResponse() = default;
};
class GetVodPackagingConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> configurationName{};

  GetVodPackagingConfigurationRequest() {}

  explicit GetVodPackagingConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configurationName) {
      res["ConfigurationName"] = boost::any(*configurationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigurationName") != m.end() && !m["ConfigurationName"].empty()) {
      configurationName = make_shared<string>(boost::any_cast<string>(m["ConfigurationName"]));
    }
  }


  virtual ~GetVodPackagingConfigurationRequest() = default;
};
class GetVodPackagingConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<VodPackagingConfiguration> packagingConfiguration{};
  shared_ptr<string> requestId{};

  GetVodPackagingConfigurationResponseBody() {}

  explicit GetVodPackagingConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packagingConfiguration) {
      res["PackagingConfiguration"] = packagingConfiguration ? boost::any(packagingConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackagingConfiguration") != m.end() && !m["PackagingConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["PackagingConfiguration"].type()) {
        VodPackagingConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PackagingConfiguration"]));
        packagingConfiguration = make_shared<VodPackagingConfiguration>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetVodPackagingConfigurationResponseBody() = default;
};
class GetVodPackagingConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVodPackagingConfigurationResponseBody> body{};

  GetVodPackagingConfigurationResponse() {}

  explicit GetVodPackagingConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVodPackagingConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVodPackagingConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~GetVodPackagingConfigurationResponse() = default;
};
class GetVodPackagingGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};

  GetVodPackagingGroupRequest() {}

  explicit GetVodPackagingGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~GetVodPackagingGroupRequest() = default;
};
class GetVodPackagingGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<VodPackagingGroup> packagingGroup{};
  shared_ptr<string> requestId{};

  GetVodPackagingGroupResponseBody() {}

  explicit GetVodPackagingGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packagingGroup) {
      res["PackagingGroup"] = packagingGroup ? boost::any(packagingGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackagingGroup") != m.end() && !m["PackagingGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["PackagingGroup"].type()) {
        VodPackagingGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PackagingGroup"]));
        packagingGroup = make_shared<VodPackagingGroup>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetVodPackagingGroupResponseBody() = default;
};
class GetVodPackagingGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVodPackagingGroupResponseBody> body{};

  GetVodPackagingGroupResponse() {}

  explicit GetVodPackagingGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVodPackagingGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVodPackagingGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetVodPackagingGroupResponse() = default;
};
class GetWorkflowTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  GetWorkflowTaskRequest() {}

  explicit GetWorkflowTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetWorkflowTaskRequest() = default;
};
class GetWorkflowTaskResponseBodyWorkflowTaskWorkflow : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> workflowId{};

  GetWorkflowTaskResponseBodyWorkflowTaskWorkflow() {}

  explicit GetWorkflowTaskResponseBodyWorkflowTaskWorkflow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<string>(boost::any_cast<string>(m["WorkflowId"]));
    }
  }


  virtual ~GetWorkflowTaskResponseBodyWorkflowTaskWorkflow() = default;
};
class GetWorkflowTaskResponseBodyWorkflowTask : public Darabonba::Model {
public:
  shared_ptr<string> activityResults{};
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskInput{};
  shared_ptr<string> userData{};
  shared_ptr<GetWorkflowTaskResponseBodyWorkflowTaskWorkflow> workflow{};

  GetWorkflowTaskResponseBodyWorkflowTask() {}

  explicit GetWorkflowTaskResponseBodyWorkflowTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activityResults) {
      res["ActivityResults"] = boost::any(*activityResults);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskInput) {
      res["TaskInput"] = boost::any(*taskInput);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (workflow) {
      res["Workflow"] = workflow ? boost::any(workflow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActivityResults") != m.end() && !m["ActivityResults"].empty()) {
      activityResults = make_shared<string>(boost::any_cast<string>(m["ActivityResults"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskInput") != m.end() && !m["TaskInput"].empty()) {
      taskInput = make_shared<string>(boost::any_cast<string>(m["TaskInput"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Workflow") != m.end() && !m["Workflow"].empty()) {
      if (typeid(map<string, boost::any>) == m["Workflow"].type()) {
        GetWorkflowTaskResponseBodyWorkflowTaskWorkflow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Workflow"]));
        workflow = make_shared<GetWorkflowTaskResponseBodyWorkflowTaskWorkflow>(model1);
      }
    }
  }


  virtual ~GetWorkflowTaskResponseBodyWorkflowTask() = default;
};
class GetWorkflowTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetWorkflowTaskResponseBodyWorkflowTask> workflowTask{};

  GetWorkflowTaskResponseBody() {}

  explicit GetWorkflowTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (workflowTask) {
      res["WorkflowTask"] = workflowTask ? boost::any(workflowTask->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WorkflowTask") != m.end() && !m["WorkflowTask"].empty()) {
      if (typeid(map<string, boost::any>) == m["WorkflowTask"].type()) {
        GetWorkflowTaskResponseBodyWorkflowTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WorkflowTask"]));
        workflowTask = make_shared<GetWorkflowTaskResponseBodyWorkflowTask>(model1);
      }
    }
  }


  virtual ~GetWorkflowTaskResponseBody() = default;
};
class GetWorkflowTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetWorkflowTaskResponseBody> body{};

  GetWorkflowTaskResponse() {}

  explicit GetWorkflowTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetWorkflowTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetWorkflowTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetWorkflowTaskResponse() = default;
};
class InsertMediaToSearchLibRequest : public Darabonba::Model {
public:
  shared_ptr<string> imagesInput{};
  shared_ptr<string> input{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> msgBody{};
  shared_ptr<string> searchLibName{};

  InsertMediaToSearchLibRequest() {}

  explicit InsertMediaToSearchLibRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imagesInput) {
      res["ImagesInput"] = boost::any(*imagesInput);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (msgBody) {
      res["MsgBody"] = boost::any(*msgBody);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImagesInput") != m.end() && !m["ImagesInput"].empty()) {
      imagesInput = make_shared<string>(boost::any_cast<string>(m["ImagesInput"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("MsgBody") != m.end() && !m["MsgBody"].empty()) {
      msgBody = make_shared<string>(boost::any_cast<string>(m["MsgBody"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
  }


  virtual ~InsertMediaToSearchLibRequest() = default;
};
class InsertMediaToSearchLibResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  InsertMediaToSearchLibResponseBody() {}

  explicit InsertMediaToSearchLibResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~InsertMediaToSearchLibResponseBody() = default;
};
class InsertMediaToSearchLibResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertMediaToSearchLibResponseBody> body{};

  InsertMediaToSearchLibResponse() {}

  explicit InsertMediaToSearchLibResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertMediaToSearchLibResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertMediaToSearchLibResponseBody>(model1);
      }
    }
  }


  virtual ~InsertMediaToSearchLibResponse() = default;
};
class ListAIAgentDialoguesRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> roundLimit{};
  shared_ptr<string> sessionId{};
  shared_ptr<long> startTime{};

  ListAIAgentDialoguesRequest() {}

  explicit ListAIAgentDialoguesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (roundLimit) {
      res["RoundLimit"] = boost::any(*roundLimit);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RoundLimit") != m.end() && !m["RoundLimit"].empty()) {
      roundLimit = make_shared<string>(boost::any_cast<string>(m["RoundLimit"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListAIAgentDialoguesRequest() = default;
};
class ListAIAgentDialoguesResponseBodyDialoguesAttachedFileList : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> type{};
  shared_ptr<string> url{};

  ListAIAgentDialoguesResponseBodyDialoguesAttachedFileList() {}

  explicit ListAIAgentDialoguesResponseBodyDialoguesAttachedFileList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListAIAgentDialoguesResponseBodyDialoguesAttachedFileList() = default;
};
class ListAIAgentDialoguesResponseBodyDialogues : public Darabonba::Model {
public:
  shared_ptr<vector<ListAIAgentDialoguesResponseBodyDialoguesAttachedFileList>> attachedFileList{};
  shared_ptr<string> dialogueId{};
  shared_ptr<string> extend{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> producer{};
  shared_ptr<string> reasoningText{};
  shared_ptr<string> roundId{};
  shared_ptr<string> source{};
  shared_ptr<string> text{};
  shared_ptr<long> time{};
  shared_ptr<string> type{};

  ListAIAgentDialoguesResponseBodyDialogues() {}

  explicit ListAIAgentDialoguesResponseBodyDialogues(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attachedFileList) {
      vector<boost::any> temp1;
      for(auto item1:*attachedFileList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttachedFileList"] = boost::any(temp1);
    }
    if (dialogueId) {
      res["DialogueId"] = boost::any(*dialogueId);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (producer) {
      res["Producer"] = boost::any(*producer);
    }
    if (reasoningText) {
      res["ReasoningText"] = boost::any(*reasoningText);
    }
    if (roundId) {
      res["RoundId"] = boost::any(*roundId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttachedFileList") != m.end() && !m["AttachedFileList"].empty()) {
      if (typeid(vector<boost::any>) == m["AttachedFileList"].type()) {
        vector<ListAIAgentDialoguesResponseBodyDialoguesAttachedFileList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttachedFileList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAIAgentDialoguesResponseBodyDialoguesAttachedFileList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attachedFileList = make_shared<vector<ListAIAgentDialoguesResponseBodyDialoguesAttachedFileList>>(expect1);
      }
    }
    if (m.find("DialogueId") != m.end() && !m["DialogueId"].empty()) {
      dialogueId = make_shared<string>(boost::any_cast<string>(m["DialogueId"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Producer") != m.end() && !m["Producer"].empty()) {
      producer = make_shared<string>(boost::any_cast<string>(m["Producer"]));
    }
    if (m.find("ReasoningText") != m.end() && !m["ReasoningText"].empty()) {
      reasoningText = make_shared<string>(boost::any_cast<string>(m["ReasoningText"]));
    }
    if (m.find("RoundId") != m.end() && !m["RoundId"].empty()) {
      roundId = make_shared<string>(boost::any_cast<string>(m["RoundId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListAIAgentDialoguesResponseBodyDialogues() = default;
};
class ListAIAgentDialoguesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAIAgentDialoguesResponseBodyDialogues>> dialogues{};
  shared_ptr<string> requestId{};

  ListAIAgentDialoguesResponseBody() {}

  explicit ListAIAgentDialoguesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dialogues) {
      vector<boost::any> temp1;
      for(auto item1:*dialogues){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Dialogues"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dialogues") != m.end() && !m["Dialogues"].empty()) {
      if (typeid(vector<boost::any>) == m["Dialogues"].type()) {
        vector<ListAIAgentDialoguesResponseBodyDialogues> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Dialogues"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAIAgentDialoguesResponseBodyDialogues model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dialogues = make_shared<vector<ListAIAgentDialoguesResponseBodyDialogues>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAIAgentDialoguesResponseBody() = default;
};
class ListAIAgentDialoguesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAIAgentDialoguesResponseBody> body{};

  ListAIAgentDialoguesResponse() {}

  explicit ListAIAgentDialoguesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAIAgentDialoguesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAIAgentDialoguesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAIAgentDialoguesResponse() = default;
};
class ListAIAgentInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> AIAgentId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};

  ListAIAgentInstanceRequest() {}

  explicit ListAIAgentInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIAgentId) {
      res["AIAgentId"] = boost::any(*AIAgentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIAgentId") != m.end() && !m["AIAgentId"].empty()) {
      AIAgentId = make_shared<string>(boost::any_cast<string>(m["AIAgentId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ListAIAgentInstanceRequest() = default;
};
class ListAIAgentInstanceResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<AIAgentConfig> agentConfig{};
  shared_ptr<string> callLogUrl{};
  shared_ptr<AIAgentRuntimeConfig> runtimeConfig{};
  shared_ptr<string> status{};
  shared_ptr<AIAgentTemplateConfig> templateConfig{};
  shared_ptr<string> userData{};

  ListAIAgentInstanceResponseBodyInstances() {}

  explicit ListAIAgentInstanceResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentConfig) {
      res["AgentConfig"] = agentConfig ? boost::any(agentConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (callLogUrl) {
      res["CallLogUrl"] = boost::any(*callLogUrl);
    }
    if (runtimeConfig) {
      res["RuntimeConfig"] = runtimeConfig ? boost::any(runtimeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentConfig") != m.end() && !m["AgentConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AgentConfig"].type()) {
        AIAgentConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AgentConfig"]));
        agentConfig = make_shared<AIAgentConfig>(model1);
      }
    }
    if (m.find("CallLogUrl") != m.end() && !m["CallLogUrl"].empty()) {
      callLogUrl = make_shared<string>(boost::any_cast<string>(m["CallLogUrl"]));
    }
    if (m.find("RuntimeConfig") != m.end() && !m["RuntimeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeConfig"].type()) {
        AIAgentRuntimeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeConfig"]));
        runtimeConfig = make_shared<AIAgentRuntimeConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        AIAgentTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<AIAgentTemplateConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ListAIAgentInstanceResponseBodyInstances() = default;
};
class ListAIAgentInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAIAgentInstanceResponseBodyInstances>> instances{};
  shared_ptr<string> requestId{};

  ListAIAgentInstanceResponseBody() {}

  explicit ListAIAgentInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<ListAIAgentInstanceResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAIAgentInstanceResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<ListAIAgentInstanceResponseBodyInstances>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAIAgentInstanceResponseBody() = default;
};
class ListAIAgentInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAIAgentInstanceResponseBody> body{};

  ListAIAgentInstanceResponse() {}

  explicit ListAIAgentInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAIAgentInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAIAgentInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ListAIAgentInstanceResponse() = default;
};
class ListAIAgentPhoneNumberRequest : public Darabonba::Model {
public:
  shared_ptr<string> number{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> status{};

  ListAIAgentPhoneNumberRequest() {}

  explicit ListAIAgentPhoneNumberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListAIAgentPhoneNumberRequest() = default;
};
class ListAIAgentPhoneNumberResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> phoneNumber{};
  shared_ptr<long> status{};

  ListAIAgentPhoneNumberResponseBodyData() {}

  explicit ListAIAgentPhoneNumberResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListAIAgentPhoneNumberResponseBodyData() = default;
};
class ListAIAgentPhoneNumberResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAIAgentPhoneNumberResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalNumber{};

  ListAIAgentPhoneNumberResponseBody() {}

  explicit ListAIAgentPhoneNumberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalNumber) {
      res["TotalNumber"] = boost::any(*totalNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAIAgentPhoneNumberResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAIAgentPhoneNumberResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAIAgentPhoneNumberResponseBodyData>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalNumber") != m.end() && !m["TotalNumber"].empty()) {
      totalNumber = make_shared<long>(boost::any_cast<long>(m["TotalNumber"]));
    }
  }


  virtual ~ListAIAgentPhoneNumberResponseBody() = default;
};
class ListAIAgentPhoneNumberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAIAgentPhoneNumberResponseBody> body{};

  ListAIAgentPhoneNumberResponse() {}

  explicit ListAIAgentPhoneNumberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAIAgentPhoneNumberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAIAgentPhoneNumberResponseBody>(model1);
      }
    }
  }


  virtual ~ListAIAgentPhoneNumberResponse() = default;
};
class ListAdInsertionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};

  ListAdInsertionsRequest() {}

  explicit ListAdInsertionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~ListAdInsertionsRequest() = default;
};
class ListAdInsertionsResponseBodyConfigsCdnConfig : public Darabonba::Model {
public:
  shared_ptr<string> adSegmentUrlPrefix{};
  shared_ptr<string> contentSegmentUrlPrefix{};

  ListAdInsertionsResponseBodyConfigsCdnConfig() {}

  explicit ListAdInsertionsResponseBodyConfigsCdnConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adSegmentUrlPrefix) {
      res["AdSegmentUrlPrefix"] = boost::any(*adSegmentUrlPrefix);
    }
    if (contentSegmentUrlPrefix) {
      res["ContentSegmentUrlPrefix"] = boost::any(*contentSegmentUrlPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdSegmentUrlPrefix") != m.end() && !m["AdSegmentUrlPrefix"].empty()) {
      adSegmentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["AdSegmentUrlPrefix"]));
    }
    if (m.find("ContentSegmentUrlPrefix") != m.end() && !m["ContentSegmentUrlPrefix"].empty()) {
      contentSegmentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["ContentSegmentUrlPrefix"]));
    }
  }


  virtual ~ListAdInsertionsResponseBodyConfigsCdnConfig() = default;
};
class ListAdInsertionsResponseBodyConfigsManifestEndpointConfig : public Darabonba::Model {
public:
  shared_ptr<string> dashPrefix{};
  shared_ptr<string> hlsPrefix{};

  ListAdInsertionsResponseBodyConfigsManifestEndpointConfig() {}

  explicit ListAdInsertionsResponseBodyConfigsManifestEndpointConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dashPrefix) {
      res["DashPrefix"] = boost::any(*dashPrefix);
    }
    if (hlsPrefix) {
      res["HlsPrefix"] = boost::any(*hlsPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DashPrefix") != m.end() && !m["DashPrefix"].empty()) {
      dashPrefix = make_shared<string>(boost::any_cast<string>(m["DashPrefix"]));
    }
    if (m.find("HlsPrefix") != m.end() && !m["HlsPrefix"].empty()) {
      hlsPrefix = make_shared<string>(boost::any_cast<string>(m["HlsPrefix"]));
    }
  }


  virtual ~ListAdInsertionsResponseBodyConfigsManifestEndpointConfig() = default;
};
class ListAdInsertionsResponseBodyConfigs : public Darabonba::Model {
public:
  shared_ptr<string> adMarkerPassthrough{};
  shared_ptr<string> adsUrl{};
  shared_ptr<ListAdInsertionsResponseBodyConfigsCdnConfig> cdnConfig{};
  shared_ptr<string> configAliases{};
  shared_ptr<string> contentUrlPrefix{};
  shared_ptr<string> createTime{};
  shared_ptr<string> lastModified{};
  shared_ptr<ListAdInsertionsResponseBodyConfigsManifestEndpointConfig> manifestEndpointConfig{};
  shared_ptr<string> name{};
  shared_ptr<long> personalizationThreshold{};
  shared_ptr<string> slateAdUrl{};

  ListAdInsertionsResponseBodyConfigs() {}

  explicit ListAdInsertionsResponseBodyConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adMarkerPassthrough) {
      res["AdMarkerPassthrough"] = boost::any(*adMarkerPassthrough);
    }
    if (adsUrl) {
      res["AdsUrl"] = boost::any(*adsUrl);
    }
    if (cdnConfig) {
      res["CdnConfig"] = cdnConfig ? boost::any(cdnConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configAliases) {
      res["ConfigAliases"] = boost::any(*configAliases);
    }
    if (contentUrlPrefix) {
      res["ContentUrlPrefix"] = boost::any(*contentUrlPrefix);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (manifestEndpointConfig) {
      res["ManifestEndpointConfig"] = manifestEndpointConfig ? boost::any(manifestEndpointConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (personalizationThreshold) {
      res["PersonalizationThreshold"] = boost::any(*personalizationThreshold);
    }
    if (slateAdUrl) {
      res["SlateAdUrl"] = boost::any(*slateAdUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdMarkerPassthrough") != m.end() && !m["AdMarkerPassthrough"].empty()) {
      adMarkerPassthrough = make_shared<string>(boost::any_cast<string>(m["AdMarkerPassthrough"]));
    }
    if (m.find("AdsUrl") != m.end() && !m["AdsUrl"].empty()) {
      adsUrl = make_shared<string>(boost::any_cast<string>(m["AdsUrl"]));
    }
    if (m.find("CdnConfig") != m.end() && !m["CdnConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CdnConfig"].type()) {
        ListAdInsertionsResponseBodyConfigsCdnConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CdnConfig"]));
        cdnConfig = make_shared<ListAdInsertionsResponseBodyConfigsCdnConfig>(model1);
      }
    }
    if (m.find("ConfigAliases") != m.end() && !m["ConfigAliases"].empty()) {
      configAliases = make_shared<string>(boost::any_cast<string>(m["ConfigAliases"]));
    }
    if (m.find("ContentUrlPrefix") != m.end() && !m["ContentUrlPrefix"].empty()) {
      contentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["ContentUrlPrefix"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("ManifestEndpointConfig") != m.end() && !m["ManifestEndpointConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ManifestEndpointConfig"].type()) {
        ListAdInsertionsResponseBodyConfigsManifestEndpointConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ManifestEndpointConfig"]));
        manifestEndpointConfig = make_shared<ListAdInsertionsResponseBodyConfigsManifestEndpointConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PersonalizationThreshold") != m.end() && !m["PersonalizationThreshold"].empty()) {
      personalizationThreshold = make_shared<long>(boost::any_cast<long>(m["PersonalizationThreshold"]));
    }
    if (m.find("SlateAdUrl") != m.end() && !m["SlateAdUrl"].empty()) {
      slateAdUrl = make_shared<string>(boost::any_cast<string>(m["SlateAdUrl"]));
    }
  }


  virtual ~ListAdInsertionsResponseBodyConfigs() = default;
};
class ListAdInsertionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAdInsertionsResponseBodyConfigs>> configs{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> totalCount{};

  ListAdInsertionsResponseBody() {}

  explicit ListAdInsertionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Configs"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(vector<boost::any>) == m["Configs"].type()) {
        vector<ListAdInsertionsResponseBodyConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAdInsertionsResponseBodyConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<ListAdInsertionsResponseBodyConfigs>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAdInsertionsResponseBody() = default;
};
class ListAdInsertionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAdInsertionsResponseBody> body{};

  ListAdInsertionsResponse() {}

  explicit ListAdInsertionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAdInsertionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAdInsertionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAdInsertionsResponse() = default;
};
class ListAlertsRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> gmtEnd{};
  shared_ptr<string> gmtStart{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceArn{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortByModifiedTime{};

  ListAlertsRequest() {}

  explicit ListAlertsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (gmtEnd) {
      res["GmtEnd"] = boost::any(*gmtEnd);
    }
    if (gmtStart) {
      res["GmtStart"] = boost::any(*gmtStart);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceArn) {
      res["ResourceArn"] = boost::any(*resourceArn);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortByModifiedTime) {
      res["SortByModifiedTime"] = boost::any(*sortByModifiedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("GmtEnd") != m.end() && !m["GmtEnd"].empty()) {
      gmtEnd = make_shared<string>(boost::any_cast<string>(m["GmtEnd"]));
    }
    if (m.find("GmtStart") != m.end() && !m["GmtStart"].empty()) {
      gmtStart = make_shared<string>(boost::any_cast<string>(m["GmtStart"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceArn") != m.end() && !m["ResourceArn"].empty()) {
      resourceArn = make_shared<string>(boost::any_cast<string>(m["ResourceArn"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortByModifiedTime") != m.end() && !m["SortByModifiedTime"].empty()) {
      sortByModifiedTime = make_shared<string>(boost::any_cast<string>(m["SortByModifiedTime"]));
    }
  }


  virtual ~ListAlertsRequest() = default;
};
class ListAlertsResponseBodyAlerts : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> code{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> message{};
  shared_ptr<string> relatedResourceArns{};
  shared_ptr<string> resourceArn{};

  ListAlertsResponseBodyAlerts() {}

  explicit ListAlertsResponseBodyAlerts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (relatedResourceArns) {
      res["RelatedResourceArns"] = boost::any(*relatedResourceArns);
    }
    if (resourceArn) {
      res["ResourceArn"] = boost::any(*resourceArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RelatedResourceArns") != m.end() && !m["RelatedResourceArns"].empty()) {
      relatedResourceArns = make_shared<string>(boost::any_cast<string>(m["RelatedResourceArns"]));
    }
    if (m.find("ResourceArn") != m.end() && !m["ResourceArn"].empty()) {
      resourceArn = make_shared<string>(boost::any_cast<string>(m["ResourceArn"]));
    }
  }


  virtual ~ListAlertsResponseBodyAlerts() = default;
};
class ListAlertsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertsResponseBodyAlerts>> alerts{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListAlertsResponseBody() {}

  explicit ListAlertsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alerts) {
      vector<boost::any> temp1;
      for(auto item1:*alerts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Alerts"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alerts") != m.end() && !m["Alerts"].empty()) {
      if (typeid(vector<boost::any>) == m["Alerts"].type()) {
        vector<ListAlertsResponseBodyAlerts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Alerts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertsResponseBodyAlerts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alerts = make_shared<vector<ListAlertsResponseBodyAlerts>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAlertsResponseBody() = default;
};
class ListAlertsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAlertsResponseBody> body{};

  ListAlertsResponse() {}

  explicit ListAlertsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAlertsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAlertsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAlertsResponse() = default;
};
class ListAllPublicMediaTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> entityId{};

  ListAllPublicMediaTagsRequest() {}

  explicit ListAllPublicMediaTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
  }


  virtual ~ListAllPublicMediaTagsRequest() = default;
};
class ListAllPublicMediaTagsResponseBodyMediaTagListOptions : public Darabonba::Model {
public:
  shared_ptr<string> optionChineseName{};
  shared_ptr<string> optionEnglishName{};
  shared_ptr<string> optionId{};

  ListAllPublicMediaTagsResponseBodyMediaTagListOptions() {}

  explicit ListAllPublicMediaTagsResponseBodyMediaTagListOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (optionChineseName) {
      res["OptionChineseName"] = boost::any(*optionChineseName);
    }
    if (optionEnglishName) {
      res["OptionEnglishName"] = boost::any(*optionEnglishName);
    }
    if (optionId) {
      res["OptionId"] = boost::any(*optionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OptionChineseName") != m.end() && !m["OptionChineseName"].empty()) {
      optionChineseName = make_shared<string>(boost::any_cast<string>(m["OptionChineseName"]));
    }
    if (m.find("OptionEnglishName") != m.end() && !m["OptionEnglishName"].empty()) {
      optionEnglishName = make_shared<string>(boost::any_cast<string>(m["OptionEnglishName"]));
    }
    if (m.find("OptionId") != m.end() && !m["OptionId"].empty()) {
      optionId = make_shared<string>(boost::any_cast<string>(m["OptionId"]));
    }
  }


  virtual ~ListAllPublicMediaTagsResponseBodyMediaTagListOptions() = default;
};
class ListAllPublicMediaTagsResponseBodyMediaTagList : public Darabonba::Model {
public:
  shared_ptr<string> mediaTagId{};
  shared_ptr<string> mediaTagNameChinese{};
  shared_ptr<string> mediaTagNameEnglish{};
  shared_ptr<vector<ListAllPublicMediaTagsResponseBodyMediaTagListOptions>> options{};

  ListAllPublicMediaTagsResponseBodyMediaTagList() {}

  explicit ListAllPublicMediaTagsResponseBodyMediaTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaTagId) {
      res["MediaTagId"] = boost::any(*mediaTagId);
    }
    if (mediaTagNameChinese) {
      res["MediaTagNameChinese"] = boost::any(*mediaTagNameChinese);
    }
    if (mediaTagNameEnglish) {
      res["MediaTagNameEnglish"] = boost::any(*mediaTagNameEnglish);
    }
    if (options) {
      vector<boost::any> temp1;
      for(auto item1:*options){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Options"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaTagId") != m.end() && !m["MediaTagId"].empty()) {
      mediaTagId = make_shared<string>(boost::any_cast<string>(m["MediaTagId"]));
    }
    if (m.find("MediaTagNameChinese") != m.end() && !m["MediaTagNameChinese"].empty()) {
      mediaTagNameChinese = make_shared<string>(boost::any_cast<string>(m["MediaTagNameChinese"]));
    }
    if (m.find("MediaTagNameEnglish") != m.end() && !m["MediaTagNameEnglish"].empty()) {
      mediaTagNameEnglish = make_shared<string>(boost::any_cast<string>(m["MediaTagNameEnglish"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      if (typeid(vector<boost::any>) == m["Options"].type()) {
        vector<ListAllPublicMediaTagsResponseBodyMediaTagListOptions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Options"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllPublicMediaTagsResponseBodyMediaTagListOptions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        options = make_shared<vector<ListAllPublicMediaTagsResponseBodyMediaTagListOptions>>(expect1);
      }
    }
  }


  virtual ~ListAllPublicMediaTagsResponseBodyMediaTagList() = default;
};
class ListAllPublicMediaTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAllPublicMediaTagsResponseBodyMediaTagList>> mediaTagList{};
  shared_ptr<string> requestId{};

  ListAllPublicMediaTagsResponseBody() {}

  explicit ListAllPublicMediaTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaTagList) {
      vector<boost::any> temp1;
      for(auto item1:*mediaTagList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaTagList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaTagList") != m.end() && !m["MediaTagList"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaTagList"].type()) {
        vector<ListAllPublicMediaTagsResponseBodyMediaTagList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaTagList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllPublicMediaTagsResponseBodyMediaTagList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaTagList = make_shared<vector<ListAllPublicMediaTagsResponseBodyMediaTagList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAllPublicMediaTagsResponseBody() = default;
};
class ListAllPublicMediaTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAllPublicMediaTagsResponseBody> body{};

  ListAllPublicMediaTagsResponse() {}

  explicit ListAllPublicMediaTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAllPublicMediaTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAllPublicMediaTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAllPublicMediaTagsResponse() = default;
};
class ListAvatarTrainingJobsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  ListAvatarTrainingJobsRequest() {}

  explicit ListAvatarTrainingJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListAvatarTrainingJobsRequest() = default;
};
class ListAvatarTrainingJobsResponseBodyDataAvatarTrainingJobList : public Darabonba::Model {
public:
  shared_ptr<string> avatarDescription{};
  shared_ptr<string> avatarId{};
  shared_ptr<string> avatarName{};
  shared_ptr<string> avatarType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> firstTrainingTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> lastTrainingTime{};
  shared_ptr<string> message{};
  shared_ptr<string> portrait{};
  shared_ptr<string> status{};

  ListAvatarTrainingJobsResponseBodyDataAvatarTrainingJobList() {}

  explicit ListAvatarTrainingJobsResponseBodyDataAvatarTrainingJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarDescription) {
      res["AvatarDescription"] = boost::any(*avatarDescription);
    }
    if (avatarId) {
      res["AvatarId"] = boost::any(*avatarId);
    }
    if (avatarName) {
      res["AvatarName"] = boost::any(*avatarName);
    }
    if (avatarType) {
      res["AvatarType"] = boost::any(*avatarType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (firstTrainingTime) {
      res["FirstTrainingTime"] = boost::any(*firstTrainingTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (lastTrainingTime) {
      res["LastTrainingTime"] = boost::any(*lastTrainingTime);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (portrait) {
      res["Portrait"] = boost::any(*portrait);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarDescription") != m.end() && !m["AvatarDescription"].empty()) {
      avatarDescription = make_shared<string>(boost::any_cast<string>(m["AvatarDescription"]));
    }
    if (m.find("AvatarId") != m.end() && !m["AvatarId"].empty()) {
      avatarId = make_shared<string>(boost::any_cast<string>(m["AvatarId"]));
    }
    if (m.find("AvatarName") != m.end() && !m["AvatarName"].empty()) {
      avatarName = make_shared<string>(boost::any_cast<string>(m["AvatarName"]));
    }
    if (m.find("AvatarType") != m.end() && !m["AvatarType"].empty()) {
      avatarType = make_shared<string>(boost::any_cast<string>(m["AvatarType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FirstTrainingTime") != m.end() && !m["FirstTrainingTime"].empty()) {
      firstTrainingTime = make_shared<string>(boost::any_cast<string>(m["FirstTrainingTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("LastTrainingTime") != m.end() && !m["LastTrainingTime"].empty()) {
      lastTrainingTime = make_shared<string>(boost::any_cast<string>(m["LastTrainingTime"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Portrait") != m.end() && !m["Portrait"].empty()) {
      portrait = make_shared<string>(boost::any_cast<string>(m["Portrait"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListAvatarTrainingJobsResponseBodyDataAvatarTrainingJobList() = default;
};
class ListAvatarTrainingJobsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListAvatarTrainingJobsResponseBodyDataAvatarTrainingJobList>> avatarTrainingJobList{};
  shared_ptr<long> totalCount{};

  ListAvatarTrainingJobsResponseBodyData() {}

  explicit ListAvatarTrainingJobsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarTrainingJobList) {
      vector<boost::any> temp1;
      for(auto item1:*avatarTrainingJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvatarTrainingJobList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarTrainingJobList") != m.end() && !m["AvatarTrainingJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["AvatarTrainingJobList"].type()) {
        vector<ListAvatarTrainingJobsResponseBodyDataAvatarTrainingJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvatarTrainingJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAvatarTrainingJobsResponseBodyDataAvatarTrainingJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        avatarTrainingJobList = make_shared<vector<ListAvatarTrainingJobsResponseBodyDataAvatarTrainingJobList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAvatarTrainingJobsResponseBodyData() = default;
};
class ListAvatarTrainingJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAvatarTrainingJobsResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAvatarTrainingJobsResponseBody() {}

  explicit ListAvatarTrainingJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAvatarTrainingJobsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAvatarTrainingJobsResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAvatarTrainingJobsResponseBody() = default;
};
class ListAvatarTrainingJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAvatarTrainingJobsResponseBody> body{};

  ListAvatarTrainingJobsResponse() {}

  explicit ListAvatarTrainingJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAvatarTrainingJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAvatarTrainingJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAvatarTrainingJobsResponse() = default;
};
class ListAvatarsRequest : public Darabonba::Model {
public:
  shared_ptr<string> avatarType{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};

  ListAvatarsRequest() {}

  explicit ListAvatarsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarType) {
      res["AvatarType"] = boost::any(*avatarType);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarType") != m.end() && !m["AvatarType"].empty()) {
      avatarType = make_shared<string>(boost::any_cast<string>(m["AvatarType"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListAvatarsRequest() = default;
};
class ListAvatarsResponseBodyDataAvatarList : public Darabonba::Model {
public:
  shared_ptr<string> avatarDescription{};
  shared_ptr<string> avatarId{};
  shared_ptr<string> avatarName{};
  shared_ptr<string> avatarType{};
  shared_ptr<string> portrait{};
  shared_ptr<string> thumbnail{};
  shared_ptr<bool> transparent{};

  ListAvatarsResponseBodyDataAvatarList() {}

  explicit ListAvatarsResponseBodyDataAvatarList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarDescription) {
      res["AvatarDescription"] = boost::any(*avatarDescription);
    }
    if (avatarId) {
      res["AvatarId"] = boost::any(*avatarId);
    }
    if (avatarName) {
      res["AvatarName"] = boost::any(*avatarName);
    }
    if (avatarType) {
      res["AvatarType"] = boost::any(*avatarType);
    }
    if (portrait) {
      res["Portrait"] = boost::any(*portrait);
    }
    if (thumbnail) {
      res["Thumbnail"] = boost::any(*thumbnail);
    }
    if (transparent) {
      res["Transparent"] = boost::any(*transparent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarDescription") != m.end() && !m["AvatarDescription"].empty()) {
      avatarDescription = make_shared<string>(boost::any_cast<string>(m["AvatarDescription"]));
    }
    if (m.find("AvatarId") != m.end() && !m["AvatarId"].empty()) {
      avatarId = make_shared<string>(boost::any_cast<string>(m["AvatarId"]));
    }
    if (m.find("AvatarName") != m.end() && !m["AvatarName"].empty()) {
      avatarName = make_shared<string>(boost::any_cast<string>(m["AvatarName"]));
    }
    if (m.find("AvatarType") != m.end() && !m["AvatarType"].empty()) {
      avatarType = make_shared<string>(boost::any_cast<string>(m["AvatarType"]));
    }
    if (m.find("Portrait") != m.end() && !m["Portrait"].empty()) {
      portrait = make_shared<string>(boost::any_cast<string>(m["Portrait"]));
    }
    if (m.find("Thumbnail") != m.end() && !m["Thumbnail"].empty()) {
      thumbnail = make_shared<string>(boost::any_cast<string>(m["Thumbnail"]));
    }
    if (m.find("Transparent") != m.end() && !m["Transparent"].empty()) {
      transparent = make_shared<bool>(boost::any_cast<bool>(m["Transparent"]));
    }
  }


  virtual ~ListAvatarsResponseBodyDataAvatarList() = default;
};
class ListAvatarsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListAvatarsResponseBodyDataAvatarList>> avatarList{};
  shared_ptr<long> totalCount{};

  ListAvatarsResponseBodyData() {}

  explicit ListAvatarsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarList) {
      vector<boost::any> temp1;
      for(auto item1:*avatarList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvatarList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarList") != m.end() && !m["AvatarList"].empty()) {
      if (typeid(vector<boost::any>) == m["AvatarList"].type()) {
        vector<ListAvatarsResponseBodyDataAvatarList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvatarList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAvatarsResponseBodyDataAvatarList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        avatarList = make_shared<vector<ListAvatarsResponseBodyDataAvatarList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAvatarsResponseBodyData() = default;
};
class ListAvatarsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListAvatarsResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAvatarsResponseBody() {}

  explicit ListAvatarsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAvatarsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAvatarsResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAvatarsResponseBody() = default;
};
class ListAvatarsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAvatarsResponseBody> body{};

  ListAvatarsResponse() {}

  explicit ListAvatarsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAvatarsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAvatarsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAvatarsResponse() = default;
};
class ListBatchMediaProducingJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  ListBatchMediaProducingJobsRequest() {}

  explicit ListBatchMediaProducingJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListBatchMediaProducingJobsRequest() = default;
};
class ListBatchMediaProducingJobsResponseBodyEditingBatchJobList : public Darabonba::Model {
public:
  shared_ptr<string> completeTime{};
  shared_ptr<string> createTime{};
  shared_ptr<string> editingConfig{};
  shared_ptr<string> extend{};
  shared_ptr<string> inputConfig{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> outputConfig{};
  shared_ptr<string> status{};
  shared_ptr<string> userData{};

  ListBatchMediaProducingJobsResponseBodyEditingBatchJobList() {}

  explicit ListBatchMediaProducingJobsResponseBodyEditingBatchJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (editingConfig) {
      res["EditingConfig"] = boost::any(*editingConfig);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (inputConfig) {
      res["InputConfig"] = boost::any(*inputConfig);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      editingConfig = make_shared<string>(boost::any_cast<string>(m["EditingConfig"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      inputConfig = make_shared<string>(boost::any_cast<string>(m["InputConfig"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ListBatchMediaProducingJobsResponseBodyEditingBatchJobList() = default;
};
class ListBatchMediaProducingJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListBatchMediaProducingJobsResponseBodyEditingBatchJobList>> editingBatchJobList{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  ListBatchMediaProducingJobsResponseBody() {}

  explicit ListBatchMediaProducingJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editingBatchJobList) {
      vector<boost::any> temp1;
      for(auto item1:*editingBatchJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EditingBatchJobList"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditingBatchJobList") != m.end() && !m["EditingBatchJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["EditingBatchJobList"].type()) {
        vector<ListBatchMediaProducingJobsResponseBodyEditingBatchJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EditingBatchJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBatchMediaProducingJobsResponseBodyEditingBatchJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        editingBatchJobList = make_shared<vector<ListBatchMediaProducingJobsResponseBodyEditingBatchJobList>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListBatchMediaProducingJobsResponseBody() = default;
};
class ListBatchMediaProducingJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBatchMediaProducingJobsResponseBody> body{};

  ListBatchMediaProducingJobsResponse() {}

  explicit ListBatchMediaProducingJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBatchMediaProducingJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBatchMediaProducingJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListBatchMediaProducingJobsResponse() = default;
};
class ListChannelAlertsRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> gmtEnd{};
  shared_ptr<string> gmtStart{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceArn{};
  shared_ptr<string> sortByModifiedTime{};

  ListChannelAlertsRequest() {}

  explicit ListChannelAlertsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (gmtEnd) {
      res["GmtEnd"] = boost::any(*gmtEnd);
    }
    if (gmtStart) {
      res["GmtStart"] = boost::any(*gmtStart);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceArn) {
      res["ResourceArn"] = boost::any(*resourceArn);
    }
    if (sortByModifiedTime) {
      res["SortByModifiedTime"] = boost::any(*sortByModifiedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("GmtEnd") != m.end() && !m["GmtEnd"].empty()) {
      gmtEnd = make_shared<string>(boost::any_cast<string>(m["GmtEnd"]));
    }
    if (m.find("GmtStart") != m.end() && !m["GmtStart"].empty()) {
      gmtStart = make_shared<string>(boost::any_cast<string>(m["GmtStart"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceArn") != m.end() && !m["ResourceArn"].empty()) {
      resourceArn = make_shared<string>(boost::any_cast<string>(m["ResourceArn"]));
    }
    if (m.find("SortByModifiedTime") != m.end() && !m["SortByModifiedTime"].empty()) {
      sortByModifiedTime = make_shared<string>(boost::any_cast<string>(m["SortByModifiedTime"]));
    }
  }


  virtual ~ListChannelAlertsRequest() = default;
};
class ListChannelAlertsResponseBodyProgramAlerts : public Darabonba::Model {
public:
  shared_ptr<string> arn{};
  shared_ptr<string> category{};
  shared_ptr<long> count{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> programName{};

  ListChannelAlertsResponseBodyProgramAlerts() {}

  explicit ListChannelAlertsResponseBodyProgramAlerts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arn) {
      res["Arn"] = boost::any(*arn);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arn") != m.end() && !m["Arn"].empty()) {
      arn = make_shared<string>(boost::any_cast<string>(m["Arn"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
  }


  virtual ~ListChannelAlertsResponseBodyProgramAlerts() = default;
};
class ListChannelAlertsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListChannelAlertsResponseBodyProgramAlerts>> programAlerts{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListChannelAlertsResponseBody() {}

  explicit ListChannelAlertsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (programAlerts) {
      vector<boost::any> temp1;
      for(auto item1:*programAlerts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProgramAlerts"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProgramAlerts") != m.end() && !m["ProgramAlerts"].empty()) {
      if (typeid(vector<boost::any>) == m["ProgramAlerts"].type()) {
        vector<ListChannelAlertsResponseBodyProgramAlerts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProgramAlerts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListChannelAlertsResponseBodyProgramAlerts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        programAlerts = make_shared<vector<ListChannelAlertsResponseBodyProgramAlerts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListChannelAlertsResponseBody() = default;
};
class ListChannelAlertsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListChannelAlertsResponseBody> body{};

  ListChannelAlertsResponse() {}

  explicit ListChannelAlertsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListChannelAlertsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListChannelAlertsResponseBody>(model1);
      }
    }
  }


  virtual ~ListChannelAlertsResponse() = default;
};
class ListChannelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> channelTier{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> playbackMode{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortByModifiedTime{};
  shared_ptr<long> state{};

  ListChannelsRequest() {}

  explicit ListChannelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (channelTier) {
      res["ChannelTier"] = boost::any(*channelTier);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (playbackMode) {
      res["PlaybackMode"] = boost::any(*playbackMode);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortByModifiedTime) {
      res["SortByModifiedTime"] = boost::any(*sortByModifiedTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ChannelTier") != m.end() && !m["ChannelTier"].empty()) {
      channelTier = make_shared<string>(boost::any_cast<string>(m["ChannelTier"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PlaybackMode") != m.end() && !m["PlaybackMode"].empty()) {
      playbackMode = make_shared<string>(boost::any_cast<string>(m["PlaybackMode"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortByModifiedTime") != m.end() && !m["SortByModifiedTime"].empty()) {
      sortByModifiedTime = make_shared<string>(boost::any_cast<string>(m["SortByModifiedTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
  }


  virtual ~ListChannelsRequest() = default;
};
class ListChannelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ChannelAssemblyChannel>> channelList{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListChannelsResponseBody() {}

  explicit ListChannelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelList) {
      vector<boost::any> temp1;
      for(auto item1:*channelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelList"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelList") != m.end() && !m["ChannelList"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelList"].type()) {
        vector<ChannelAssemblyChannel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ChannelAssemblyChannel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelList = make_shared<vector<ChannelAssemblyChannel>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListChannelsResponseBody() = default;
};
class ListChannelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListChannelsResponseBody> body{};

  ListChannelsResponse() {}

  explicit ListChannelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListChannelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListChannelsResponseBody>(model1);
      }
    }
  }


  virtual ~ListChannelsResponse() = default;
};
class ListCustomTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> subtype{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  ListCustomTemplatesRequest() {}

  explicit ListCustomTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<string>(boost::any_cast<string>(m["Subtype"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListCustomTemplatesRequest() = default;
};
class ListCustomTemplatesResponseBodyCustomTemplateListFrontendHintTranscodeTemplateHint : public Darabonba::Model {
public:
  shared_ptr<string> bitrateControlType{};

  ListCustomTemplatesResponseBodyCustomTemplateListFrontendHintTranscodeTemplateHint() {}

  explicit ListCustomTemplatesResponseBodyCustomTemplateListFrontendHintTranscodeTemplateHint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrateControlType) {
      res["BitrateControlType"] = boost::any(*bitrateControlType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BitrateControlType") != m.end() && !m["BitrateControlType"].empty()) {
      bitrateControlType = make_shared<string>(boost::any_cast<string>(m["BitrateControlType"]));
    }
  }


  virtual ~ListCustomTemplatesResponseBodyCustomTemplateListFrontendHintTranscodeTemplateHint() = default;
};
class ListCustomTemplatesResponseBodyCustomTemplateListFrontendHint : public Darabonba::Model {
public:
  shared_ptr<ListCustomTemplatesResponseBodyCustomTemplateListFrontendHintTranscodeTemplateHint> transcodeTemplateHint{};

  ListCustomTemplatesResponseBodyCustomTemplateListFrontendHint() {}

  explicit ListCustomTemplatesResponseBodyCustomTemplateListFrontendHint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (transcodeTemplateHint) {
      res["TranscodeTemplateHint"] = transcodeTemplateHint ? boost::any(transcodeTemplateHint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TranscodeTemplateHint") != m.end() && !m["TranscodeTemplateHint"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeTemplateHint"].type()) {
        ListCustomTemplatesResponseBodyCustomTemplateListFrontendHintTranscodeTemplateHint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeTemplateHint"]));
        transcodeTemplateHint = make_shared<ListCustomTemplatesResponseBodyCustomTemplateListFrontendHintTranscodeTemplateHint>(model1);
      }
    }
  }


  virtual ~ListCustomTemplatesResponseBodyCustomTemplateListFrontendHint() = default;
};
class ListCustomTemplatesResponseBodyCustomTemplateList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<ListCustomTemplatesResponseBodyCustomTemplateListFrontendHint> frontendHint{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> status{};
  shared_ptr<long> subtype{};
  shared_ptr<string> subtypeName{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> type{};
  shared_ptr<string> typeName_{};

  ListCustomTemplatesResponseBodyCustomTemplateList() {}

  explicit ListCustomTemplatesResponseBodyCustomTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (frontendHint) {
      res["FrontendHint"] = frontendHint ? boost::any(frontendHint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (subtypeName) {
      res["SubtypeName"] = boost::any(*subtypeName);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FrontendHint") != m.end() && !m["FrontendHint"].empty()) {
      if (typeid(map<string, boost::any>) == m["FrontendHint"].type()) {
        ListCustomTemplatesResponseBodyCustomTemplateListFrontendHint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FrontendHint"]));
        frontendHint = make_shared<ListCustomTemplatesResponseBodyCustomTemplateListFrontendHint>(model1);
      }
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<long>(boost::any_cast<long>(m["Subtype"]));
    }
    if (m.find("SubtypeName") != m.end() && !m["SubtypeName"].empty()) {
      subtypeName = make_shared<string>(boost::any_cast<string>(m["SubtypeName"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~ListCustomTemplatesResponseBodyCustomTemplateList() = default;
};
class ListCustomTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomTemplatesResponseBodyCustomTemplateList>> customTemplateList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  ListCustomTemplatesResponseBody() {}

  explicit ListCustomTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customTemplateList) {
      vector<boost::any> temp1;
      for(auto item1:*customTemplateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomTemplateList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomTemplateList") != m.end() && !m["CustomTemplateList"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomTemplateList"].type()) {
        vector<ListCustomTemplatesResponseBodyCustomTemplateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomTemplateList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomTemplatesResponseBodyCustomTemplateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customTemplateList = make_shared<vector<ListCustomTemplatesResponseBodyCustomTemplateList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListCustomTemplatesResponseBody() = default;
};
class ListCustomTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomTemplatesResponseBody> body{};

  ListCustomTemplatesResponse() {}

  explicit ListCustomTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomTemplatesResponse() = default;
};
class ListCustomizedVoiceJobsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> type{};

  ListCustomizedVoiceJobsRequest() {}

  explicit ListCustomizedVoiceJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListCustomizedVoiceJobsRequest() = default;
};
class ListCustomizedVoiceJobsResponseBodyDataCustomizedVoiceJobList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> gender{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> scenario{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> voiceDesc{};
  shared_ptr<string> voiceId{};
  shared_ptr<string> voiceName{};

  ListCustomizedVoiceJobsResponseBodyDataCustomizedVoiceJobList() {}

  explicit ListCustomizedVoiceJobsResponseBodyDataCustomizedVoiceJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (gender) {
      res["Gender"] = boost::any(*gender);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (voiceDesc) {
      res["VoiceDesc"] = boost::any(*voiceDesc);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    if (voiceName) {
      res["VoiceName"] = boost::any(*voiceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Gender") != m.end() && !m["Gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["Gender"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VoiceDesc") != m.end() && !m["VoiceDesc"].empty()) {
      voiceDesc = make_shared<string>(boost::any_cast<string>(m["VoiceDesc"]));
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
    if (m.find("VoiceName") != m.end() && !m["VoiceName"].empty()) {
      voiceName = make_shared<string>(boost::any_cast<string>(m["VoiceName"]));
    }
  }


  virtual ~ListCustomizedVoiceJobsResponseBodyDataCustomizedVoiceJobList() = default;
};
class ListCustomizedVoiceJobsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomizedVoiceJobsResponseBodyDataCustomizedVoiceJobList>> customizedVoiceJobList{};
  shared_ptr<long> totalCount{};

  ListCustomizedVoiceJobsResponseBodyData() {}

  explicit ListCustomizedVoiceJobsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customizedVoiceJobList) {
      vector<boost::any> temp1;
      for(auto item1:*customizedVoiceJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomizedVoiceJobList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomizedVoiceJobList") != m.end() && !m["CustomizedVoiceJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomizedVoiceJobList"].type()) {
        vector<ListCustomizedVoiceJobsResponseBodyDataCustomizedVoiceJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomizedVoiceJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomizedVoiceJobsResponseBodyDataCustomizedVoiceJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customizedVoiceJobList = make_shared<vector<ListCustomizedVoiceJobsResponseBodyDataCustomizedVoiceJobList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCustomizedVoiceJobsResponseBodyData() = default;
};
class ListCustomizedVoiceJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCustomizedVoiceJobsResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListCustomizedVoiceJobsResponseBody() {}

  explicit ListCustomizedVoiceJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCustomizedVoiceJobsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCustomizedVoiceJobsResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListCustomizedVoiceJobsResponseBody() = default;
};
class ListCustomizedVoiceJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomizedVoiceJobsResponseBody> body{};

  ListCustomizedVoiceJobsResponse() {}

  explicit ListCustomizedVoiceJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomizedVoiceJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomizedVoiceJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomizedVoiceJobsResponse() = default;
};
class ListCustomizedVoicesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> type{};

  ListCustomizedVoicesRequest() {}

  explicit ListCustomizedVoicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListCustomizedVoicesRequest() = default;
};
class ListCustomizedVoicesResponseBodyDataCustomizedVoiceList : public Darabonba::Model {
public:
  shared_ptr<string> demoAudioMediaId{};
  shared_ptr<string> gender{};
  shared_ptr<string> scenario{};
  shared_ptr<string> type{};
  shared_ptr<string> voiceDesc{};
  shared_ptr<string> voiceId{};
  shared_ptr<string> voiceName{};

  ListCustomizedVoicesResponseBodyDataCustomizedVoiceList() {}

  explicit ListCustomizedVoicesResponseBodyDataCustomizedVoiceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoAudioMediaId) {
      res["DemoAudioMediaId"] = boost::any(*demoAudioMediaId);
    }
    if (gender) {
      res["Gender"] = boost::any(*gender);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (voiceDesc) {
      res["VoiceDesc"] = boost::any(*voiceDesc);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    if (voiceName) {
      res["VoiceName"] = boost::any(*voiceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoAudioMediaId") != m.end() && !m["DemoAudioMediaId"].empty()) {
      demoAudioMediaId = make_shared<string>(boost::any_cast<string>(m["DemoAudioMediaId"]));
    }
    if (m.find("Gender") != m.end() && !m["Gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["Gender"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<string>(boost::any_cast<string>(m["Scenario"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VoiceDesc") != m.end() && !m["VoiceDesc"].empty()) {
      voiceDesc = make_shared<string>(boost::any_cast<string>(m["VoiceDesc"]));
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
    if (m.find("VoiceName") != m.end() && !m["VoiceName"].empty()) {
      voiceName = make_shared<string>(boost::any_cast<string>(m["VoiceName"]));
    }
  }


  virtual ~ListCustomizedVoicesResponseBodyDataCustomizedVoiceList() = default;
};
class ListCustomizedVoicesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomizedVoicesResponseBodyDataCustomizedVoiceList>> customizedVoiceList{};
  shared_ptr<long> totalCount{};

  ListCustomizedVoicesResponseBodyData() {}

  explicit ListCustomizedVoicesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customizedVoiceList) {
      vector<boost::any> temp1;
      for(auto item1:*customizedVoiceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomizedVoiceList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomizedVoiceList") != m.end() && !m["CustomizedVoiceList"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomizedVoiceList"].type()) {
        vector<ListCustomizedVoicesResponseBodyDataCustomizedVoiceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomizedVoiceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomizedVoicesResponseBodyDataCustomizedVoiceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customizedVoiceList = make_shared<vector<ListCustomizedVoicesResponseBodyDataCustomizedVoiceList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCustomizedVoicesResponseBodyData() = default;
};
class ListCustomizedVoicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCustomizedVoicesResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListCustomizedVoicesResponseBody() {}

  explicit ListCustomizedVoicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCustomizedVoicesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCustomizedVoicesResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListCustomizedVoicesResponseBody() = default;
};
class ListCustomizedVoicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomizedVoicesResponseBody> body{};

  ListCustomizedVoicesResponse() {}

  explicit ListCustomizedVoicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomizedVoicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomizedVoicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomizedVoicesResponse() = default;
};
class ListDNADBRequest : public Darabonba::Model {
public:
  shared_ptr<string> DBIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListDNADBRequest() {}

  explicit ListDNADBRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBIds) {
      res["DBIds"] = boost::any(*DBIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBIds") != m.end() && !m["DBIds"].empty()) {
      DBIds = make_shared<string>(boost::any_cast<string>(m["DBIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListDNADBRequest() = default;
};
class ListDNADBResponseBodyDBList : public Darabonba::Model {
public:
  shared_ptr<string> DBId{};
  shared_ptr<string> description{};
  shared_ptr<string> model{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};

  ListDNADBResponseBodyDBList() {}

  explicit ListDNADBResponseBodyDBList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBId) {
      res["DBId"] = boost::any(*DBId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBId") != m.end() && !m["DBId"].empty()) {
      DBId = make_shared<string>(boost::any_cast<string>(m["DBId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListDNADBResponseBodyDBList() = default;
};
class ListDNADBResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDNADBResponseBodyDBList>> DBList{};
  shared_ptr<string> requestId{};

  ListDNADBResponseBody() {}

  explicit ListDNADBResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBList) {
      vector<boost::any> temp1;
      for(auto item1:*DBList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DBList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBList") != m.end() && !m["DBList"].empty()) {
      if (typeid(vector<boost::any>) == m["DBList"].type()) {
        vector<ListDNADBResponseBodyDBList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DBList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDNADBResponseBodyDBList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DBList = make_shared<vector<ListDNADBResponseBodyDBList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDNADBResponseBody() = default;
};
class ListDNADBResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDNADBResponseBody> body{};

  ListDNADBResponse() {}

  explicit ListDNADBResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDNADBResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDNADBResponseBody>(model1);
      }
    }
  }


  virtual ~ListDNADBResponse() = default;
};
class ListDNAFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> DBId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListDNAFilesRequest() {}

  explicit ListDNAFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DBId) {
      res["DBId"] = boost::any(*DBId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DBId") != m.end() && !m["DBId"].empty()) {
      DBId = make_shared<string>(boost::any_cast<string>(m["DBId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListDNAFilesRequest() = default;
};
class ListDNAFilesResponseBodyFileListInputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  ListDNAFilesResponseBodyFileListInputFile() {}

  explicit ListDNAFilesResponseBodyFileListInputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~ListDNAFilesResponseBodyFileListInputFile() = default;
};
class ListDNAFilesResponseBodyFileList : public Darabonba::Model {
public:
  shared_ptr<ListDNAFilesResponseBodyFileListInputFile> inputFile{};
  shared_ptr<string> primaryKey{};

  ListDNAFilesResponseBodyFileList() {}

  explicit ListDNAFilesResponseBodyFileList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputFile) {
      res["InputFile"] = inputFile ? boost::any(inputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputFile"].type()) {
        ListDNAFilesResponseBodyFileListInputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputFile"]));
        inputFile = make_shared<ListDNAFilesResponseBodyFileListInputFile>(model1);
      }
    }
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
  }


  virtual ~ListDNAFilesResponseBodyFileList() = default;
};
class ListDNAFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDNAFilesResponseBodyFileList>> fileList{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListDNAFilesResponseBody() {}

  explicit ListDNAFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileList) {
      vector<boost::any> temp1;
      for(auto item1:*fileList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileList"] = boost::any(temp1);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileList") != m.end() && !m["FileList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileList"].type()) {
        vector<ListDNAFilesResponseBodyFileList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDNAFilesResponseBodyFileList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileList = make_shared<vector<ListDNAFilesResponseBodyFileList>>(expect1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDNAFilesResponseBody() = default;
};
class ListDNAFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDNAFilesResponseBody> body{};

  ListDNAFilesResponse() {}

  explicit ListDNAFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDNAFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDNAFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDNAFilesResponse() = default;
};
class ListDynamicImageJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfCreateTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startOfCreateTime{};
  shared_ptr<string> status{};

  ListDynamicImageJobsRequest() {}

  explicit ListDynamicImageJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfCreateTime) {
      res["EndOfCreateTime"] = boost::any(*endOfCreateTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startOfCreateTime) {
      res["StartOfCreateTime"] = boost::any(*startOfCreateTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfCreateTime") != m.end() && !m["EndOfCreateTime"].empty()) {
      endOfCreateTime = make_shared<string>(boost::any_cast<string>(m["EndOfCreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartOfCreateTime") != m.end() && !m["StartOfCreateTime"].empty()) {
      startOfCreateTime = make_shared<string>(boost::any_cast<string>(m["StartOfCreateTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListDynamicImageJobsRequest() = default;
};
class ListDynamicImageJobsResponseBodyJobsInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListDynamicImageJobsResponseBodyJobsInput() {}

  explicit ListDynamicImageJobsResponseBodyJobsInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDynamicImageJobsResponseBodyJobsInput() = default;
};
class ListDynamicImageJobsResponseBodyJobsOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListDynamicImageJobsResponseBodyJobsOutput() {}

  explicit ListDynamicImageJobsResponseBodyJobsOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDynamicImageJobsResponseBodyJobsOutput() = default;
};
class ListDynamicImageJobsResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<ListDynamicImageJobsResponseBodyJobsInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<ListDynamicImageJobsResponseBodyJobsOutput> output{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> templateId{};
  shared_ptr<string> triggerSource{};

  ListDynamicImageJobsResponseBodyJobs() {}

  explicit ListDynamicImageJobsResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListDynamicImageJobsResponseBodyJobsInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListDynamicImageJobsResponseBodyJobsInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        ListDynamicImageJobsResponseBodyJobsOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<ListDynamicImageJobsResponseBodyJobsOutput>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
  }


  virtual ~ListDynamicImageJobsResponseBodyJobs() = default;
};
class ListDynamicImageJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDynamicImageJobsResponseBodyJobs>> jobs{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListDynamicImageJobsResponseBody() {}

  explicit ListDynamicImageJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Jobs"] = boost::any(temp1);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["Jobs"].type()) {
        vector<ListDynamicImageJobsResponseBodyJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDynamicImageJobsResponseBodyJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<ListDynamicImageJobsResponseBodyJobs>>(expect1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDynamicImageJobsResponseBody() = default;
};
class ListDynamicImageJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDynamicImageJobsResponseBody> body{};

  ListDynamicImageJobsResponse() {}

  explicit ListDynamicImageJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDynamicImageJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDynamicImageJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDynamicImageJobsResponse() = default;
};
class ListEditingProjectsRequest : public Darabonba::Model {
public:
  shared_ptr<string> createSource{};
  shared_ptr<string> endTime{};
  shared_ptr<string> keyword{};
  shared_ptr<string> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> projectType{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> templateType{};

  ListEditingProjectsRequest() {}

  explicit ListEditingProjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (projectType) {
      res["ProjectType"] = boost::any(*projectType);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<string>(boost::any_cast<string>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ProjectType") != m.end() && !m["ProjectType"].empty()) {
      projectType = make_shared<string>(boost::any_cast<string>(m["ProjectType"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~ListEditingProjectsRequest() = default;
};
class ListEditingProjectsResponseBodyProjectList : public Darabonba::Model {
public:
  shared_ptr<string> businessConfig{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createSource{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> modifiedSource{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectType{};
  shared_ptr<string> status{};
  shared_ptr<string> templateType{};
  shared_ptr<string> title{};

  ListEditingProjectsResponseBodyProjectList() {}

  explicit ListEditingProjectsResponseBodyProjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessConfig) {
      res["BusinessConfig"] = boost::any(*businessConfig);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (modifiedSource) {
      res["ModifiedSource"] = boost::any(*modifiedSource);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectType) {
      res["ProjectType"] = boost::any(*projectType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessConfig") != m.end() && !m["BusinessConfig"].empty()) {
      businessConfig = make_shared<string>(boost::any_cast<string>(m["BusinessConfig"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ModifiedSource") != m.end() && !m["ModifiedSource"].empty()) {
      modifiedSource = make_shared<string>(boost::any_cast<string>(m["ModifiedSource"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectType") != m.end() && !m["ProjectType"].empty()) {
      projectType = make_shared<string>(boost::any_cast<string>(m["ProjectType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~ListEditingProjectsResponseBodyProjectList() = default;
};
class ListEditingProjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<ListEditingProjectsResponseBodyProjectList>> projectList{};
  shared_ptr<string> requestId{};

  ListEditingProjectsResponseBody() {}

  explicit ListEditingProjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (projectList) {
      vector<boost::any> temp1;
      for(auto item1:*projectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ProjectList") != m.end() && !m["ProjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectList"].type()) {
        vector<ListEditingProjectsResponseBodyProjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEditingProjectsResponseBodyProjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectList = make_shared<vector<ListEditingProjectsResponseBodyProjectList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListEditingProjectsResponseBody() = default;
};
class ListEditingProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEditingProjectsResponseBody> body{};

  ListEditingProjectsResponse() {}

  explicit ListEditingProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEditingProjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEditingProjectsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEditingProjectsResponse() = default;
};
class ListHotwordLibrariesRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> name{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> usageScenario{};

  ListHotwordLibrariesRequest() {}

  explicit ListHotwordLibrariesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (usageScenario) {
      res["UsageScenario"] = boost::any(*usageScenario);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("UsageScenario") != m.end() && !m["UsageScenario"].empty()) {
      usageScenario = make_shared<string>(boost::any_cast<string>(m["UsageScenario"]));
    }
  }


  virtual ~ListHotwordLibrariesRequest() = default;
};
class ListHotwordLibrariesResponseBodyHotwordLibraryList : public Darabonba::Model {
public:
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<string> hotwordLibraryId{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<string> usageScenario{};

  ListHotwordLibrariesResponseBodyHotwordLibraryList() {}

  explicit ListHotwordLibrariesResponseBodyHotwordLibraryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hotwordLibraryId) {
      res["HotwordLibraryId"] = boost::any(*hotwordLibraryId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (usageScenario) {
      res["UsageScenario"] = boost::any(*usageScenario);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HotwordLibraryId") != m.end() && !m["HotwordLibraryId"].empty()) {
      hotwordLibraryId = make_shared<string>(boost::any_cast<string>(m["HotwordLibraryId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UsageScenario") != m.end() && !m["UsageScenario"].empty()) {
      usageScenario = make_shared<string>(boost::any_cast<string>(m["UsageScenario"]));
    }
  }


  virtual ~ListHotwordLibrariesResponseBodyHotwordLibraryList() = default;
};
class ListHotwordLibrariesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListHotwordLibrariesResponseBodyHotwordLibraryList>> hotwordLibraryList{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListHotwordLibrariesResponseBody() {}

  explicit ListHotwordLibrariesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotwordLibraryList) {
      vector<boost::any> temp1;
      for(auto item1:*hotwordLibraryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HotwordLibraryList"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HotwordLibraryList") != m.end() && !m["HotwordLibraryList"].empty()) {
      if (typeid(vector<boost::any>) == m["HotwordLibraryList"].type()) {
        vector<ListHotwordLibrariesResponseBodyHotwordLibraryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HotwordLibraryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHotwordLibrariesResponseBodyHotwordLibraryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotwordLibraryList = make_shared<vector<ListHotwordLibrariesResponseBodyHotwordLibraryList>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHotwordLibrariesResponseBody() = default;
};
class ListHotwordLibrariesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHotwordLibrariesResponseBody> body{};

  ListHotwordLibrariesResponse() {}

  explicit ListHotwordLibrariesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHotwordLibrariesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHotwordLibrariesResponseBody>(model1);
      }
    }
  }


  virtual ~ListHotwordLibrariesResponse() = default;
};
class ListLivePackageChannelGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};

  ListLivePackageChannelGroupsRequest() {}

  explicit ListLivePackageChannelGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~ListLivePackageChannelGroupsRequest() = default;
};
class ListLivePackageChannelGroupsResponseBodyLivePackageChannelGroups : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> originDomain{};

  ListLivePackageChannelGroupsResponseBodyLivePackageChannelGroups() {}

  explicit ListLivePackageChannelGroupsResponseBodyLivePackageChannelGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (originDomain) {
      res["OriginDomain"] = boost::any(*originDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("OriginDomain") != m.end() && !m["OriginDomain"].empty()) {
      originDomain = make_shared<string>(boost::any_cast<string>(m["OriginDomain"]));
    }
  }


  virtual ~ListLivePackageChannelGroupsResponseBodyLivePackageChannelGroups() = default;
};
class ListLivePackageChannelGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLivePackageChannelGroupsResponseBodyLivePackageChannelGroups>> livePackageChannelGroups{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> totalCount{};

  ListLivePackageChannelGroupsResponseBody() {}

  explicit ListLivePackageChannelGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livePackageChannelGroups) {
      vector<boost::any> temp1;
      for(auto item1:*livePackageChannelGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LivePackageChannelGroups"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivePackageChannelGroups") != m.end() && !m["LivePackageChannelGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["LivePackageChannelGroups"].type()) {
        vector<ListLivePackageChannelGroupsResponseBodyLivePackageChannelGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LivePackageChannelGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLivePackageChannelGroupsResponseBodyLivePackageChannelGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        livePackageChannelGroups = make_shared<vector<ListLivePackageChannelGroupsResponseBodyLivePackageChannelGroups>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLivePackageChannelGroupsResponseBody() = default;
};
class ListLivePackageChannelGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLivePackageChannelGroupsResponseBody> body{};

  ListLivePackageChannelGroupsResponse() {}

  explicit ListLivePackageChannelGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLivePackageChannelGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLivePackageChannelGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLivePackageChannelGroupsResponse() = default;
};
class ListLivePackageChannelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};

  ListLivePackageChannelsRequest() {}

  explicit ListLivePackageChannelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~ListLivePackageChannelsRequest() = default;
};
class ListLivePackageChannelsResponseBodyLivePackageChannelsIngestEndpoints : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> password{};
  shared_ptr<string> url{};
  shared_ptr<string> username{};

  ListLivePackageChannelsResponseBodyLivePackageChannelsIngestEndpoints() {}

  explicit ListLivePackageChannelsResponseBodyLivePackageChannelsIngestEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~ListLivePackageChannelsResponseBodyLivePackageChannelsIngestEndpoints() = default;
};
class ListLivePackageChannelsResponseBodyLivePackageChannels : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<vector<ListLivePackageChannelsResponseBodyLivePackageChannelsIngestEndpoints>> ingestEndpoints{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> protocol{};
  shared_ptr<long> segmentCount{};
  shared_ptr<long> segmentDuration{};

  ListLivePackageChannelsResponseBodyLivePackageChannels() {}

  explicit ListLivePackageChannelsResponseBodyLivePackageChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (ingestEndpoints) {
      vector<boost::any> temp1;
      for(auto item1:*ingestEndpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngestEndpoints"] = boost::any(temp1);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (segmentCount) {
      res["SegmentCount"] = boost::any(*segmentCount);
    }
    if (segmentDuration) {
      res["SegmentDuration"] = boost::any(*segmentDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IngestEndpoints") != m.end() && !m["IngestEndpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["IngestEndpoints"].type()) {
        vector<ListLivePackageChannelsResponseBodyLivePackageChannelsIngestEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngestEndpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLivePackageChannelsResponseBodyLivePackageChannelsIngestEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingestEndpoints = make_shared<vector<ListLivePackageChannelsResponseBodyLivePackageChannelsIngestEndpoints>>(expect1);
      }
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SegmentCount") != m.end() && !m["SegmentCount"].empty()) {
      segmentCount = make_shared<long>(boost::any_cast<long>(m["SegmentCount"]));
    }
    if (m.find("SegmentDuration") != m.end() && !m["SegmentDuration"].empty()) {
      segmentDuration = make_shared<long>(boost::any_cast<long>(m["SegmentDuration"]));
    }
  }


  virtual ~ListLivePackageChannelsResponseBodyLivePackageChannels() = default;
};
class ListLivePackageChannelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLivePackageChannelsResponseBodyLivePackageChannels>> livePackageChannels{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> totalCount{};

  ListLivePackageChannelsResponseBody() {}

  explicit ListLivePackageChannelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livePackageChannels) {
      vector<boost::any> temp1;
      for(auto item1:*livePackageChannels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LivePackageChannels"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivePackageChannels") != m.end() && !m["LivePackageChannels"].empty()) {
      if (typeid(vector<boost::any>) == m["LivePackageChannels"].type()) {
        vector<ListLivePackageChannelsResponseBodyLivePackageChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LivePackageChannels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLivePackageChannelsResponseBodyLivePackageChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        livePackageChannels = make_shared<vector<ListLivePackageChannelsResponseBodyLivePackageChannels>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLivePackageChannelsResponseBody() = default;
};
class ListLivePackageChannelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLivePackageChannelsResponseBody> body{};

  ListLivePackageChannelsResponse() {}

  explicit ListLivePackageChannelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLivePackageChannelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLivePackageChannelsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLivePackageChannelsResponse() = default;
};
class ListLivePackageOriginEndpointsRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> groupName{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};

  ListLivePackageOriginEndpointsRequest() {}

  explicit ListLivePackageOriginEndpointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~ListLivePackageOriginEndpointsRequest() = default;
};
class ListLivePackageOriginEndpointsResponseBodyLivePackageOriginEndpoints : public Darabonba::Model {
public:
  shared_ptr<string> authorizationCode{};
  shared_ptr<string> channelName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> endpointUrl{};
  shared_ptr<string> groupName{};
  shared_ptr<string> ipBlacklist{};
  shared_ptr<string> ipWhitelist{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> manifestName{};
  shared_ptr<string> protocol{};
  shared_ptr<long> timeshiftVision{};

  ListLivePackageOriginEndpointsResponseBodyLivePackageOriginEndpoints() {}

  explicit ListLivePackageOriginEndpointsResponseBodyLivePackageOriginEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizationCode) {
      res["AuthorizationCode"] = boost::any(*authorizationCode);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (endpointUrl) {
      res["EndpointUrl"] = boost::any(*endpointUrl);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (ipBlacklist) {
      res["IpBlacklist"] = boost::any(*ipBlacklist);
    }
    if (ipWhitelist) {
      res["IpWhitelist"] = boost::any(*ipWhitelist);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (manifestName) {
      res["ManifestName"] = boost::any(*manifestName);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (timeshiftVision) {
      res["TimeshiftVision"] = boost::any(*timeshiftVision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizationCode") != m.end() && !m["AuthorizationCode"].empty()) {
      authorizationCode = make_shared<string>(boost::any_cast<string>(m["AuthorizationCode"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("EndpointUrl") != m.end() && !m["EndpointUrl"].empty()) {
      endpointUrl = make_shared<string>(boost::any_cast<string>(m["EndpointUrl"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IpBlacklist") != m.end() && !m["IpBlacklist"].empty()) {
      ipBlacklist = make_shared<string>(boost::any_cast<string>(m["IpBlacklist"]));
    }
    if (m.find("IpWhitelist") != m.end() && !m["IpWhitelist"].empty()) {
      ipWhitelist = make_shared<string>(boost::any_cast<string>(m["IpWhitelist"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("ManifestName") != m.end() && !m["ManifestName"].empty()) {
      manifestName = make_shared<string>(boost::any_cast<string>(m["ManifestName"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("TimeshiftVision") != m.end() && !m["TimeshiftVision"].empty()) {
      timeshiftVision = make_shared<long>(boost::any_cast<long>(m["TimeshiftVision"]));
    }
  }


  virtual ~ListLivePackageOriginEndpointsResponseBodyLivePackageOriginEndpoints() = default;
};
class ListLivePackageOriginEndpointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLivePackageOriginEndpointsResponseBodyLivePackageOriginEndpoints>> livePackageOriginEndpoints{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> totalCount{};

  ListLivePackageOriginEndpointsResponseBody() {}

  explicit ListLivePackageOriginEndpointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livePackageOriginEndpoints) {
      vector<boost::any> temp1;
      for(auto item1:*livePackageOriginEndpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LivePackageOriginEndpoints"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivePackageOriginEndpoints") != m.end() && !m["LivePackageOriginEndpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["LivePackageOriginEndpoints"].type()) {
        vector<ListLivePackageOriginEndpointsResponseBodyLivePackageOriginEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LivePackageOriginEndpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLivePackageOriginEndpointsResponseBodyLivePackageOriginEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        livePackageOriginEndpoints = make_shared<vector<ListLivePackageOriginEndpointsResponseBodyLivePackageOriginEndpoints>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLivePackageOriginEndpointsResponseBody() = default;
};
class ListLivePackageOriginEndpointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLivePackageOriginEndpointsResponseBody> body{};

  ListLivePackageOriginEndpointsResponse() {}

  explicit ListLivePackageOriginEndpointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLivePackageOriginEndpointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLivePackageOriginEndpointsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLivePackageOriginEndpointsResponse() = default;
};
class ListLiveRecordFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<vector<string>> jobIds{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> recordFormat{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};

  ListLiveRecordFilesRequest() {}

  explicit ListLiveRecordFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (recordFormat) {
      res["RecordFormat"] = boost::any(*recordFormat);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      recordFormat = make_shared<string>(boost::any_cast<string>(m["RecordFormat"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ListLiveRecordFilesRequest() = default;
};
class ListLiveRecordFilesResponseBodyFiles : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<double> duration{};
  shared_ptr<string> endTime{};
  shared_ptr<string> format{};
  shared_ptr<long> height{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> recordId{};
  shared_ptr<string> recordOutput{};
  shared_ptr<string> recordUrl{};
  shared_ptr<string> startTime{};
  shared_ptr<string> streamUrl{};
  shared_ptr<long> width{};

  ListLiveRecordFilesResponseBodyFiles() {}

  explicit ListLiveRecordFilesResponseBodyFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (recordOutput) {
      res["RecordOutput"] = boost::any(*recordOutput);
    }
    if (recordUrl) {
      res["RecordUrl"] = boost::any(*recordUrl);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamUrl) {
      res["StreamUrl"] = boost::any(*streamUrl);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("RecordOutput") != m.end() && !m["RecordOutput"].empty()) {
      recordOutput = make_shared<string>(boost::any_cast<string>(m["RecordOutput"]));
    }
    if (m.find("RecordUrl") != m.end() && !m["RecordUrl"].empty()) {
      recordUrl = make_shared<string>(boost::any_cast<string>(m["RecordUrl"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StreamUrl") != m.end() && !m["StreamUrl"].empty()) {
      streamUrl = make_shared<string>(boost::any_cast<string>(m["StreamUrl"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~ListLiveRecordFilesResponseBodyFiles() = default;
};
class ListLiveRecordFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveRecordFilesResponseBodyFiles>> files{};
  shared_ptr<long> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> totalCount{};

  ListLiveRecordFilesResponseBody() {}

  explicit ListLiveRecordFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<ListLiveRecordFilesResponseBodyFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveRecordFilesResponseBodyFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<ListLiveRecordFilesResponseBodyFiles>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListLiveRecordFilesResponseBody() = default;
};
class ListLiveRecordFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveRecordFilesResponseBody> body{};

  ListLiveRecordFilesResponse() {}

  explicit ListLiveRecordFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveRecordFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveRecordFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveRecordFilesResponse() = default;
};
class ListLiveRecordJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  ListLiveRecordJobsRequest() {}

  explicit ListLiveRecordJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListLiveRecordJobsRequest() = default;
};
class ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> type{};

  ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput() {}

  explicit ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput() = default;
};
class ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput() {}

  explicit ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput() = default;
};
class ListLiveRecordJobsResponseBodyLiveRecordJobs : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput> recordOutput{};
  shared_ptr<string> status{};
  shared_ptr<ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput> streamInput{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};

  ListLiveRecordJobsResponseBodyLiveRecordJobs() {}

  explicit ListLiveRecordJobsResponseBodyLiveRecordJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (recordOutput) {
      res["RecordOutput"] = recordOutput ? boost::any(recordOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("RecordOutput") != m.end() && !m["RecordOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordOutput"].type()) {
        ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordOutput"]));
        recordOutput = make_shared<ListLiveRecordJobsResponseBodyLiveRecordJobsRecordOutput>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<ListLiveRecordJobsResponseBodyLiveRecordJobsStreamInput>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~ListLiveRecordJobsResponseBodyLiveRecordJobs() = default;
};
class ListLiveRecordJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveRecordJobsResponseBodyLiveRecordJobs>> liveRecordJobs{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> totalCount{};

  ListLiveRecordJobsResponseBody() {}

  explicit ListLiveRecordJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (liveRecordJobs) {
      vector<boost::any> temp1;
      for(auto item1:*liveRecordJobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LiveRecordJobs"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LiveRecordJobs") != m.end() && !m["LiveRecordJobs"].empty()) {
      if (typeid(vector<boost::any>) == m["LiveRecordJobs"].type()) {
        vector<ListLiveRecordJobsResponseBodyLiveRecordJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LiveRecordJobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveRecordJobsResponseBodyLiveRecordJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        liveRecordJobs = make_shared<vector<ListLiveRecordJobsResponseBodyLiveRecordJobs>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLiveRecordJobsResponseBody() = default;
};
class ListLiveRecordJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveRecordJobsResponseBody> body{};

  ListLiveRecordJobsResponse() {}

  explicit ListLiveRecordJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveRecordJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveRecordJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveRecordJobsResponse() = default;
};
class ListLiveRecordTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<vector<string>> templateIds{};
  shared_ptr<string> type{};

  ListLiveRecordTemplatesRequest() {}

  explicit ListLiveRecordTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (templateIds) {
      res["TemplateIds"] = boost::any(*templateIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TemplateIds") != m.end() && !m["TemplateIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TemplateIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TemplateIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      templateIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveRecordTemplatesRequest() = default;
};
class ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<long> sliceDuration{};
  shared_ptr<string> sliceOssObjectPrefix{};

  ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList() {}

  explicit ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList() = default;
};
class ListLiveRecordTemplatesResponseBodyRecordTemplateList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList>> recordFormatList{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  ListLiveRecordTemplatesResponseBodyRecordTemplateList() {}

  explicit ListLiveRecordTemplatesResponseBodyRecordTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordFormatList) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormatList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormatList"] = boost::any(temp1);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordFormatList") != m.end() && !m["RecordFormatList"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormatList"].type()) {
        vector<ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormatList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormatList = make_shared<vector<ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList>>(expect1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveRecordTemplatesResponseBodyRecordTemplateList() = default;
};
class ListLiveRecordTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListLiveRecordTemplatesResponseBodyRecordTemplateList>> recordTemplateList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> totalCount{};

  ListLiveRecordTemplatesResponseBody() {}

  explicit ListLiveRecordTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (recordTemplateList) {
      vector<boost::any> temp1;
      for(auto item1:*recordTemplateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordTemplateList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RecordTemplateList") != m.end() && !m["RecordTemplateList"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordTemplateList"].type()) {
        vector<ListLiveRecordTemplatesResponseBodyRecordTemplateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordTemplateList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveRecordTemplatesResponseBodyRecordTemplateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordTemplateList = make_shared<vector<ListLiveRecordTemplatesResponseBodyRecordTemplateList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLiveRecordTemplatesResponseBody() = default;
};
class ListLiveRecordTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveRecordTemplatesResponseBody> body{};

  ListLiveRecordTemplatesResponse() {}

  explicit ListLiveRecordTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveRecordTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveRecordTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveRecordTemplatesResponse() = default;
};
class ListLiveSnapshotFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> jobId{};
  shared_ptr<long> limit{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};

  ListLiveSnapshotFilesRequest() {}

  explicit ListLiveSnapshotFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ListLiveSnapshotFilesRequest() = default;
};
class ListLiveSnapshotFilesResponseBodyFileList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createTimestamp{};
  shared_ptr<bool> isOverlay{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossEndpoint{};
  shared_ptr<string> ossObject{};

  ListLiveSnapshotFilesResponseBodyFileList() {}

  explicit ListLiveSnapshotFilesResponseBodyFileList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createTimestamp) {
      res["CreateTimestamp"] = boost::any(*createTimestamp);
    }
    if (isOverlay) {
      res["IsOverlay"] = boost::any(*isOverlay);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossEndpoint) {
      res["OssEndpoint"] = boost::any(*ossEndpoint);
    }
    if (ossObject) {
      res["OssObject"] = boost::any(*ossObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateTimestamp") != m.end() && !m["CreateTimestamp"].empty()) {
      createTimestamp = make_shared<long>(boost::any_cast<long>(m["CreateTimestamp"]));
    }
    if (m.find("IsOverlay") != m.end() && !m["IsOverlay"].empty()) {
      isOverlay = make_shared<bool>(boost::any_cast<bool>(m["IsOverlay"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssEndpoint") != m.end() && !m["OssEndpoint"].empty()) {
      ossEndpoint = make_shared<string>(boost::any_cast<string>(m["OssEndpoint"]));
    }
    if (m.find("OssObject") != m.end() && !m["OssObject"].empty()) {
      ossObject = make_shared<string>(boost::any_cast<string>(m["OssObject"]));
    }
  }


  virtual ~ListLiveSnapshotFilesResponseBodyFileList() = default;
};
class ListLiveSnapshotFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveSnapshotFilesResponseBodyFileList>> fileList{};
  shared_ptr<string> nextStartTime{};
  shared_ptr<string> requestId{};

  ListLiveSnapshotFilesResponseBody() {}

  explicit ListLiveSnapshotFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileList) {
      vector<boost::any> temp1;
      for(auto item1:*fileList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileList"] = boost::any(temp1);
    }
    if (nextStartTime) {
      res["NextStartTime"] = boost::any(*nextStartTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileList") != m.end() && !m["FileList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileList"].type()) {
        vector<ListLiveSnapshotFilesResponseBodyFileList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveSnapshotFilesResponseBodyFileList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileList = make_shared<vector<ListLiveSnapshotFilesResponseBodyFileList>>(expect1);
      }
    }
    if (m.find("NextStartTime") != m.end() && !m["NextStartTime"].empty()) {
      nextStartTime = make_shared<string>(boost::any_cast<string>(m["NextStartTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListLiveSnapshotFilesResponseBody() = default;
};
class ListLiveSnapshotFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveSnapshotFilesResponseBody> body{};

  ListLiveSnapshotFilesResponse() {}

  explicit ListLiveSnapshotFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveSnapshotFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveSnapshotFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveSnapshotFilesResponse() = default;
};
class ListLiveSnapshotJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKeyWord{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  ListLiveSnapshotJobsRequest() {}

  explicit ListLiveSnapshotJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKeyWord) {
      res["SearchKeyWord"] = boost::any(*searchKeyWord);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKeyWord") != m.end() && !m["SearchKeyWord"].empty()) {
      searchKeyWord = make_shared<string>(boost::any_cast<string>(m["SearchKeyWord"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListLiveSnapshotJobsRequest() = default;
};
class ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> storageType{};

  ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput() {}

  explicit ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput() = default;
};
class ListLiveSnapshotJobsResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput> snapshotOutput{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> timeInterval{};

  ListLiveSnapshotJobsResponseBodyJobList() {}

  explicit ListLiveSnapshotJobsResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (snapshotOutput) {
      res["SnapshotOutput"] = snapshotOutput ? boost::any(snapshotOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("SnapshotOutput") != m.end() && !m["SnapshotOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotOutput"].type()) {
        ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotOutput"]));
        snapshotOutput = make_shared<ListLiveSnapshotJobsResponseBodyJobListSnapshotOutput>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
  }


  virtual ~ListLiveSnapshotJobsResponseBodyJobList() = default;
};
class ListLiveSnapshotJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveSnapshotJobsResponseBodyJobList>> jobList{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> totalCount{};

  ListLiveSnapshotJobsResponseBody() {}

  explicit ListLiveSnapshotJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobList) {
      vector<boost::any> temp1;
      for(auto item1:*jobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobList"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(vector<boost::any>) == m["JobList"].type()) {
        vector<ListLiveSnapshotJobsResponseBodyJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveSnapshotJobsResponseBodyJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobList = make_shared<vector<ListLiveSnapshotJobsResponseBodyJobList>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLiveSnapshotJobsResponseBody() = default;
};
class ListLiveSnapshotJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveSnapshotJobsResponseBody> body{};

  ListLiveSnapshotJobsResponse() {}

  explicit ListLiveSnapshotJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveSnapshotJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveSnapshotJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveSnapshotJobsResponse() = default;
};
class ListLiveSnapshotTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKeyWord{};
  shared_ptr<string> sortBy{};
  shared_ptr<vector<string>> templateIds{};
  shared_ptr<string> type{};

  ListLiveSnapshotTemplatesRequest() {}

  explicit ListLiveSnapshotTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKeyWord) {
      res["SearchKeyWord"] = boost::any(*searchKeyWord);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (templateIds) {
      res["TemplateIds"] = boost::any(*templateIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKeyWord") != m.end() && !m["SearchKeyWord"].empty()) {
      searchKeyWord = make_shared<string>(boost::any_cast<string>(m["SearchKeyWord"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TemplateIds") != m.end() && !m["TemplateIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TemplateIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TemplateIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      templateIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveSnapshotTemplatesRequest() = default;
};
class ListLiveSnapshotTemplatesResponseBodyTemplateList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> timeInterval{};
  shared_ptr<string> type{};

  ListLiveSnapshotTemplatesResponseBodyTemplateList() {}

  explicit ListLiveSnapshotTemplatesResponseBodyTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveSnapshotTemplatesResponseBodyTemplateList() = default;
};
class ListLiveSnapshotTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<vector<ListLiveSnapshotTemplatesResponseBodyTemplateList>> templateList{};
  shared_ptr<long> totalCount{};

  ListLiveSnapshotTemplatesResponseBody() {}

  explicit ListLiveSnapshotTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (templateList) {
      vector<boost::any> temp1;
      for(auto item1:*templateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TemplateList") != m.end() && !m["TemplateList"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateList"].type()) {
        vector<ListLiveSnapshotTemplatesResponseBodyTemplateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveSnapshotTemplatesResponseBodyTemplateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateList = make_shared<vector<ListLiveSnapshotTemplatesResponseBodyTemplateList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLiveSnapshotTemplatesResponseBody() = default;
};
class ListLiveSnapshotTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveSnapshotTemplatesResponseBody> body{};

  ListLiveSnapshotTemplatesResponse() {}

  explicit ListLiveSnapshotTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveSnapshotTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveSnapshotTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveSnapshotTemplatesResponse() = default;
};
class ListLiveTranscodeJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyWord{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> startMode{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  ListLiveTranscodeJobsRequest() {}

  explicit ListLiveTranscodeJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyWord) {
      res["KeyWord"] = boost::any(*keyWord);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startMode) {
      res["StartMode"] = boost::any(*startMode);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyWord") != m.end() && !m["KeyWord"].empty()) {
      keyWord = make_shared<string>(boost::any_cast<string>(m["KeyWord"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartMode") != m.end() && !m["StartMode"].empty()) {
      startMode = make_shared<long>(boost::any_cast<long>(m["StartMode"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveTranscodeJobsRequest() = default;
};
class ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos : public Darabonba::Model {
public:
  shared_ptr<string> outputUrl{};
  shared_ptr<string> type{};

  ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos() {}

  explicit ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outputUrl) {
      res["OutputUrl"] = boost::any(*outputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutputUrl") != m.end() && !m["OutputUrl"].empty()) {
      outputUrl = make_shared<string>(boost::any_cast<string>(m["OutputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos() = default;
};
class ListLiveTranscodeJobsResponseBodyJobListOutputStream : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos>> streamInfos{};

  ListLiveTranscodeJobsResponseBodyJobListOutputStream() {}

  explicit ListLiveTranscodeJobsResponseBodyJobListOutputStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (streamInfos) {
      vector<boost::any> temp1;
      for(auto item1:*streamInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StreamInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StreamInfos") != m.end() && !m["StreamInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["StreamInfos"].type()) {
        vector<ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StreamInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        streamInfos = make_shared<vector<ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos>>(expect1);
      }
    }
  }


  virtual ~ListLiveTranscodeJobsResponseBodyJobListOutputStream() = default;
};
class ListLiveTranscodeJobsResponseBodyJobListStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> inputUrl{};
  shared_ptr<string> type{};

  ListLiveTranscodeJobsResponseBodyJobListStreamInput() {}

  explicit ListLiveTranscodeJobsResponseBodyJobListStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputUrl) {
      res["InputUrl"] = boost::any(*inputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputUrl") != m.end() && !m["InputUrl"].empty()) {
      inputUrl = make_shared<string>(boost::any_cast<string>(m["InputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveTranscodeJobsResponseBodyJobListStreamInput() = default;
};
class ListLiveTranscodeJobsResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<ListLiveTranscodeJobsResponseBodyJobListOutputStream> outputStream{};
  shared_ptr<long> startMode{};
  shared_ptr<long> status{};
  shared_ptr<ListLiveTranscodeJobsResponseBodyJobListStreamInput> streamInput{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateType{};

  ListLiveTranscodeJobsResponseBodyJobList() {}

  explicit ListLiveTranscodeJobsResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputStream) {
      res["OutputStream"] = outputStream ? boost::any(outputStream->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startMode) {
      res["StartMode"] = boost::any(*startMode);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputStream") != m.end() && !m["OutputStream"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputStream"].type()) {
        ListLiveTranscodeJobsResponseBodyJobListOutputStream model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputStream"]));
        outputStream = make_shared<ListLiveTranscodeJobsResponseBodyJobListOutputStream>(model1);
      }
    }
    if (m.find("StartMode") != m.end() && !m["StartMode"].empty()) {
      startMode = make_shared<long>(boost::any_cast<long>(m["StartMode"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        ListLiveTranscodeJobsResponseBodyJobListStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<ListLiveTranscodeJobsResponseBodyJobListStreamInput>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~ListLiveTranscodeJobsResponseBodyJobList() = default;
};
class ListLiveTranscodeJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListLiveTranscodeJobsResponseBodyJobList>> jobList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListLiveTranscodeJobsResponseBody() {}

  explicit ListLiveTranscodeJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobList) {
      vector<boost::any> temp1;
      for(auto item1:*jobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(vector<boost::any>) == m["JobList"].type()) {
        vector<ListLiveTranscodeJobsResponseBodyJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveTranscodeJobsResponseBodyJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobList = make_shared<vector<ListLiveTranscodeJobsResponseBodyJobList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLiveTranscodeJobsResponseBody() = default;
};
class ListLiveTranscodeJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveTranscodeJobsResponseBody> body{};

  ListLiveTranscodeJobsResponse() {}

  explicit ListLiveTranscodeJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveTranscodeJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveTranscodeJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveTranscodeJobsResponse() = default;
};
class ListLiveTranscodeTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> keyWord{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> type{};
  shared_ptr<string> videoCodec{};

  ListLiveTranscodeTemplatesRequest() {}

  explicit ListLiveTranscodeTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (keyWord) {
      res["KeyWord"] = boost::any(*keyWord);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (videoCodec) {
      res["VideoCodec"] = boost::any(*videoCodec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("KeyWord") != m.end() && !m["KeyWord"].empty()) {
      keyWord = make_shared<string>(boost::any_cast<string>(m["KeyWord"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VideoCodec") != m.end() && !m["VideoCodec"].empty()) {
      videoCodec = make_shared<string>(boost::any_cast<string>(m["VideoCodec"]));
    }
  }


  virtual ~ListLiveTranscodeTemplatesRequest() = default;
};
class ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> samplerate{};

  ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams() {}

  explicit ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams() = default;
};
class ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> codec{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> profile{};
  shared_ptr<string> width{};

  ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams() {}

  explicit ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams() = default;
};
class ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig : public Darabonba::Model {
public:
  shared_ptr<ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams> audioParams{};
  shared_ptr<ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams> videoParams{};

  ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig() {}

  explicit ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioParams) {
      res["AudioParams"] = audioParams ? boost::any(audioParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoParams) {
      res["VideoParams"] = videoParams ? boost::any(videoParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioParams") != m.end() && !m["AudioParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioParams"].type()) {
        ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioParams"]));
        audioParams = make_shared<ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams>(model1);
      }
    }
    if (m.find("VideoParams") != m.end() && !m["VideoParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoParams"].type()) {
        ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoParams"]));
        videoParams = make_shared<ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams>(model1);
      }
    }
  }


  virtual ~ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig() = default;
};
class ListLiveTranscodeTemplatesResponseBodyTemplateContentList : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<string> name{};
  shared_ptr<ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  ListLiveTranscodeTemplatesResponseBodyTemplateContentList() {}

  explicit ListLiveTranscodeTemplatesResponseBodyTemplateContentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLiveTranscodeTemplatesResponseBodyTemplateContentList() = default;
};
class ListLiveTranscodeTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListLiveTranscodeTemplatesResponseBodyTemplateContentList>> templateContentList{};
  shared_ptr<long> totalCount{};

  ListLiveTranscodeTemplatesResponseBody() {}

  explicit ListLiveTranscodeTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateContentList) {
      vector<boost::any> temp1;
      for(auto item1:*templateContentList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TemplateContentList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateContentList") != m.end() && !m["TemplateContentList"].empty()) {
      if (typeid(vector<boost::any>) == m["TemplateContentList"].type()) {
        vector<ListLiveTranscodeTemplatesResponseBodyTemplateContentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TemplateContentList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLiveTranscodeTemplatesResponseBodyTemplateContentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templateContentList = make_shared<vector<ListLiveTranscodeTemplatesResponseBodyTemplateContentList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLiveTranscodeTemplatesResponseBody() = default;
};
class ListLiveTranscodeTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLiveTranscodeTemplatesResponseBody> body{};

  ListLiveTranscodeTemplatesResponse() {}

  explicit ListLiveTranscodeTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLiveTranscodeTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLiveTranscodeTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListLiveTranscodeTemplatesResponse() = default;
};
class ListMediaBasicInfosRequest : public Darabonba::Model {
public:
  shared_ptr<long> authTimeout{};
  shared_ptr<string> businessType{};
  shared_ptr<string> endTime{};
  shared_ptr<bool> includeFileBasicInfo{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> source{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  ListMediaBasicInfosRequest() {}

  explicit ListMediaBasicInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authTimeout) {
      res["AuthTimeout"] = boost::any(*authTimeout);
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (includeFileBasicInfo) {
      res["IncludeFileBasicInfo"] = boost::any(*includeFileBasicInfo);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthTimeout") != m.end() && !m["AuthTimeout"].empty()) {
      authTimeout = make_shared<long>(boost::any_cast<long>(m["AuthTimeout"]));
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IncludeFileBasicInfo") != m.end() && !m["IncludeFileBasicInfo"].empty()) {
      includeFileBasicInfo = make_shared<bool>(boost::any_cast<bool>(m["IncludeFileBasicInfo"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListMediaBasicInfosRequest() = default;
};
class ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> createTime{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo() {}

  explicit ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo() = default;
};
class ListMediaBasicInfosResponseBodyMediaInfosFileInfoList : public Darabonba::Model {
public:
  shared_ptr<ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo> fileBasicInfo{};

  ListMediaBasicInfosResponseBodyMediaInfosFileInfoList() {}

  explicit ListMediaBasicInfosResponseBodyMediaInfosFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo>(model1);
      }
    }
  }


  virtual ~ListMediaBasicInfosResponseBodyMediaInfosFileInfoList() = default;
};
class ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> biz{};
  shared_ptr<string> businessType{};
  shared_ptr<long> cateId{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> snapshots{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteImages{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> transcodeStatus{};
  shared_ptr<string> uploadSource{};
  shared_ptr<string> userData{};

  ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo() {}

  explicit ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (biz) {
      res["Biz"] = boost::any(*biz);
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteImages) {
      res["SpriteImages"] = boost::any(*spriteImages);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (transcodeStatus) {
      res["TranscodeStatus"] = boost::any(*transcodeStatus);
    }
    if (uploadSource) {
      res["UploadSource"] = boost::any(*uploadSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Biz") != m.end() && !m["Biz"].empty()) {
      biz = make_shared<string>(boost::any_cast<string>(m["Biz"]));
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      snapshots = make_shared<string>(boost::any_cast<string>(m["Snapshots"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteImages") != m.end() && !m["SpriteImages"].empty()) {
      spriteImages = make_shared<string>(boost::any_cast<string>(m["SpriteImages"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TranscodeStatus") != m.end() && !m["TranscodeStatus"].empty()) {
      transcodeStatus = make_shared<string>(boost::any_cast<string>(m["TranscodeStatus"]));
    }
    if (m.find("UploadSource") != m.end() && !m["UploadSource"].empty()) {
      uploadSource = make_shared<string>(boost::any_cast<string>(m["UploadSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo() = default;
};
class ListMediaBasicInfosResponseBodyMediaInfos : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaBasicInfosResponseBodyMediaInfosFileInfoList>> fileInfoList{};
  shared_ptr<ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  ListMediaBasicInfosResponseBodyMediaInfos() {}

  explicit ListMediaBasicInfosResponseBodyMediaInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<ListMediaBasicInfosResponseBodyMediaInfosFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaBasicInfosResponseBodyMediaInfosFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<ListMediaBasicInfosResponseBodyMediaInfosFileInfoList>>(expect1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~ListMediaBasicInfosResponseBodyMediaInfos() = default;
};
class ListMediaBasicInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<vector<ListMediaBasicInfosResponseBodyMediaInfos>> mediaInfos{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListMediaBasicInfosResponseBody() {}

  explicit ListMediaBasicInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (mediaInfos) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInfos"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("MediaInfos") != m.end() && !m["MediaInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInfos"].type()) {
        vector<ListMediaBasicInfosResponseBodyMediaInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaBasicInfosResponseBodyMediaInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInfos = make_shared<vector<ListMediaBasicInfosResponseBodyMediaInfos>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMediaBasicInfosResponseBody() = default;
};
class ListMediaBasicInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMediaBasicInfosResponseBody> body{};

  ListMediaBasicInfosResponse() {}

  explicit ListMediaBasicInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMediaBasicInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMediaBasicInfosResponseBody>(model1);
      }
    }
  }


  virtual ~ListMediaBasicInfosResponse() = default;
};
class ListMediaConvertJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfCreateTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startOfCreateTime{};
  shared_ptr<string> status{};

  ListMediaConvertJobsRequest() {}

  explicit ListMediaConvertJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfCreateTime) {
      res["EndOfCreateTime"] = boost::any(*endOfCreateTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startOfCreateTime) {
      res["StartOfCreateTime"] = boost::any(*startOfCreateTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfCreateTime") != m.end() && !m["EndOfCreateTime"].empty()) {
      endOfCreateTime = make_shared<string>(boost::any_cast<string>(m["EndOfCreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartOfCreateTime") != m.end() && !m["StartOfCreateTime"].empty()) {
      startOfCreateTime = make_shared<string>(boost::any_cast<string>(m["StartOfCreateTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListMediaConvertJobsRequest() = default;
};
class ListMediaConvertJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<MediaConvertJobWithoutDetail>> jobs{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListMediaConvertJobsResponseBody() {}

  explicit ListMediaConvertJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Jobs"] = boost::any(temp1);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["Jobs"].type()) {
        vector<MediaConvertJobWithoutDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertJobWithoutDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<MediaConvertJobWithoutDetail>>(expect1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListMediaConvertJobsResponseBody() = default;
};
class ListMediaConvertJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMediaConvertJobsResponseBody> body{};

  ListMediaConvertJobsResponse() {}

  explicit ListMediaConvertJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMediaConvertJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMediaConvertJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMediaConvertJobsResponse() = default;
};
class ListMediaInfoJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfCreateTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startOfCreateTime{};
  shared_ptr<string> status{};

  ListMediaInfoJobsRequest() {}

  explicit ListMediaInfoJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfCreateTime) {
      res["EndOfCreateTime"] = boost::any(*endOfCreateTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startOfCreateTime) {
      res["StartOfCreateTime"] = boost::any(*startOfCreateTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfCreateTime") != m.end() && !m["EndOfCreateTime"].empty()) {
      endOfCreateTime = make_shared<string>(boost::any_cast<string>(m["EndOfCreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartOfCreateTime") != m.end() && !m["StartOfCreateTime"].empty()) {
      startOfCreateTime = make_shared<string>(boost::any_cast<string>(m["StartOfCreateTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListMediaInfoJobsRequest() = default;
};
class ListMediaInfoJobsResponseBodyJobsInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListMediaInfoJobsResponseBodyJobsInput() {}

  explicit ListMediaInfoJobsResponseBodyJobsInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListMediaInfoJobsResponseBodyJobsInput() = default;
};
class ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList() {}

  explicit ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList() = default;
};
class ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo() {}

  explicit ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo() = default;
};
class ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFps{};
  shared_ptr<string> bitRate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeBase{};
  shared_ptr<string> width{};

  ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList() {}

  explicit ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFps) {
      res["Avg_fps"] = boost::any(*avgFps);
    }
    if (bitRate) {
      res["Bit_rate"] = boost::any(*bitRate);
    }
    if (codecLongName) {
      res["Codec_long_name"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["Codec_name"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["Codec_tag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["Codec_tag_string"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["Codec_time_base"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["Has_b_frames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["Start_time"] = boost::any(*startTime);
    }
    if (timeBase) {
      res["Time_base"] = boost::any(*timeBase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avg_fps") != m.end() && !m["Avg_fps"].empty()) {
      avgFps = make_shared<string>(boost::any_cast<string>(m["Avg_fps"]));
    }
    if (m.find("Bit_rate") != m.end() && !m["Bit_rate"].empty()) {
      bitRate = make_shared<string>(boost::any_cast<string>(m["Bit_rate"]));
    }
    if (m.find("Codec_long_name") != m.end() && !m["Codec_long_name"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["Codec_long_name"]));
    }
    if (m.find("Codec_name") != m.end() && !m["Codec_name"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["Codec_name"]));
    }
    if (m.find("Codec_tag") != m.end() && !m["Codec_tag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["Codec_tag"]));
    }
    if (m.find("Codec_tag_string") != m.end() && !m["Codec_tag_string"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["Codec_tag_string"]));
    }
    if (m.find("Codec_time_base") != m.end() && !m["Codec_time_base"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["Codec_time_base"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Has_b_frames") != m.end() && !m["Has_b_frames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["Has_b_frames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Start_time") != m.end() && !m["Start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["Start_time"]));
    }
    if (m.find("Time_base") != m.end() && !m["Time_base"].empty()) {
      timeBase = make_shared<string>(boost::any_cast<string>(m["Time_base"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList() = default;
};
class ListMediaInfoJobsResponseBodyJobsMediaInfoProperty : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList>> videoStreamInfoList{};

  ListMediaInfoJobsResponseBodyJobsMediaInfoProperty() {}

  explicit ListMediaInfoJobsResponseBodyJobsMediaInfoProperty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo>(model1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~ListMediaInfoJobsResponseBodyJobsMediaInfoProperty() = default;
};
class ListMediaInfoJobsResponseBodyJobsScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  ListMediaInfoJobsResponseBodyJobsScheduleConfig() {}

  explicit ListMediaInfoJobsResponseBodyJobsScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~ListMediaInfoJobsResponseBodyJobsScheduleConfig() = default;
};
class ListMediaInfoJobsResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> finishTime{};
  shared_ptr<ListMediaInfoJobsResponseBodyJobsInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<ListMediaInfoJobsResponseBodyJobsMediaInfoProperty> mediaInfoProperty{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<ListMediaInfoJobsResponseBodyJobsScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> submitResultJson{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  ListMediaInfoJobsResponseBodyJobs() {}

  explicit ListMediaInfoJobsResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaInfoProperty) {
      res["MediaInfoProperty"] = mediaInfoProperty ? boost::any(mediaInfoProperty->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitResultJson) {
      res["SubmitResultJson"] = boost::any(*submitResultJson);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListMediaInfoJobsResponseBodyJobsInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListMediaInfoJobsResponseBodyJobsInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaInfoProperty") != m.end() && !m["MediaInfoProperty"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoProperty"].type()) {
        ListMediaInfoJobsResponseBodyJobsMediaInfoProperty model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoProperty"]));
        mediaInfoProperty = make_shared<ListMediaInfoJobsResponseBodyJobsMediaInfoProperty>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        ListMediaInfoJobsResponseBodyJobsScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<ListMediaInfoJobsResponseBodyJobsScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitResultJson") != m.end() && !m["SubmitResultJson"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SubmitResultJson"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      submitResultJson = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ListMediaInfoJobsResponseBodyJobs() = default;
};
class ListMediaInfoJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaInfoJobsResponseBodyJobs>> jobs{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListMediaInfoJobsResponseBody() {}

  explicit ListMediaInfoJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Jobs"] = boost::any(temp1);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["Jobs"].type()) {
        vector<ListMediaInfoJobsResponseBodyJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaInfoJobsResponseBodyJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<ListMediaInfoJobsResponseBodyJobs>>(expect1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListMediaInfoJobsResponseBody() = default;
};
class ListMediaInfoJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMediaInfoJobsResponseBody> body{};

  ListMediaInfoJobsResponse() {}

  explicit ListMediaInfoJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMediaInfoJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMediaInfoJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMediaInfoJobsResponse() = default;
};
class ListMediaLiveChannelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> skip{};
  shared_ptr<string> sortOrder{};
  shared_ptr<string> states{};

  ListMediaLiveChannelsRequest() {}

  explicit ListMediaLiveChannelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (skip) {
      res["Skip"] = boost::any(*skip);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (states) {
      res["States"] = boost::any(*states);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Skip") != m.end() && !m["Skip"].empty()) {
      skip = make_shared<long>(boost::any_cast<long>(m["Skip"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("States") != m.end() && !m["States"].empty()) {
      states = make_shared<string>(boost::any_cast<string>(m["States"]));
    }
  }


  virtual ~ListMediaLiveChannelsRequest() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsAudioSettingsAudioCodecSetting : public Darabonba::Model {
public:
  shared_ptr<long> bitrate{};
  shared_ptr<string> profile{};
  shared_ptr<long> sampleRate{};

  ListMediaLiveChannelsResponseBodyChannelsAudioSettingsAudioCodecSetting() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsAudioSettingsAudioCodecSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<long>(boost::any_cast<long>(m["SampleRate"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsAudioSettingsAudioCodecSetting() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsAudioSettings : public Darabonba::Model {
public:
  shared_ptr<string> audioCodec{};
  shared_ptr<ListMediaLiveChannelsResponseBodyChannelsAudioSettingsAudioCodecSetting> audioCodecSetting{};
  shared_ptr<string> audioSelectorName{};
  shared_ptr<string> languageCode{};
  shared_ptr<string> languageName{};
  shared_ptr<string> name{};

  ListMediaLiveChannelsResponseBodyChannelsAudioSettings() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsAudioSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioCodec) {
      res["AudioCodec"] = boost::any(*audioCodec);
    }
    if (audioCodecSetting) {
      res["AudioCodecSetting"] = audioCodecSetting ? boost::any(audioCodecSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioSelectorName) {
      res["AudioSelectorName"] = boost::any(*audioSelectorName);
    }
    if (languageCode) {
      res["LanguageCode"] = boost::any(*languageCode);
    }
    if (languageName) {
      res["LanguageName"] = boost::any(*languageName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioCodec") != m.end() && !m["AudioCodec"].empty()) {
      audioCodec = make_shared<string>(boost::any_cast<string>(m["AudioCodec"]));
    }
    if (m.find("AudioCodecSetting") != m.end() && !m["AudioCodecSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioCodecSetting"].type()) {
        ListMediaLiveChannelsResponseBodyChannelsAudioSettingsAudioCodecSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioCodecSetting"]));
        audioCodecSetting = make_shared<ListMediaLiveChannelsResponseBodyChannelsAudioSettingsAudioCodecSetting>(model1);
      }
    }
    if (m.find("AudioSelectorName") != m.end() && !m["AudioSelectorName"].empty()) {
      audioSelectorName = make_shared<string>(boost::any_cast<string>(m["AudioSelectorName"]));
    }
    if (m.find("LanguageCode") != m.end() && !m["LanguageCode"].empty()) {
      languageCode = make_shared<string>(boost::any_cast<string>(m["LanguageCode"]));
    }
    if (m.find("LanguageName") != m.end() && !m["LanguageName"].empty()) {
      languageName = make_shared<string>(boost::any_cast<string>(m["LanguageName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsAudioSettings() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioLanguageSelection : public Darabonba::Model {
public:
  shared_ptr<string> languageCode{};

  ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioLanguageSelection() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioLanguageSelection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (languageCode) {
      res["LanguageCode"] = boost::any(*languageCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LanguageCode") != m.end() && !m["LanguageCode"].empty()) {
      languageCode = make_shared<string>(boost::any_cast<string>(m["LanguageCode"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioLanguageSelection() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioPidSelection : public Darabonba::Model {
public:
  shared_ptr<long> pid{};

  ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioPidSelection() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioPidSelection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<long>(boost::any_cast<long>(m["Pid"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioPidSelection() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioTrackSelection : public Darabonba::Model {
public:
  shared_ptr<long> trackId{};

  ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioTrackSelection() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioTrackSelection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trackId) {
      res["TrackId"] = boost::any(*trackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrackId") != m.end() && !m["TrackId"].empty()) {
      trackId = make_shared<long>(boost::any_cast<long>(m["TrackId"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioTrackSelection() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectors : public Darabonba::Model {
public:
  shared_ptr<ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioLanguageSelection> audioLanguageSelection{};
  shared_ptr<ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioPidSelection> audioPidSelection{};
  shared_ptr<vector<ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioTrackSelection>> audioTrackSelection{};
  shared_ptr<string> name{};

  ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectors() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLanguageSelection) {
      res["AudioLanguageSelection"] = audioLanguageSelection ? boost::any(audioLanguageSelection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioPidSelection) {
      res["AudioPidSelection"] = audioPidSelection ? boost::any(audioPidSelection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioTrackSelection) {
      vector<boost::any> temp1;
      for(auto item1:*audioTrackSelection){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioTrackSelection"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLanguageSelection") != m.end() && !m["AudioLanguageSelection"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioLanguageSelection"].type()) {
        ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioLanguageSelection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioLanguageSelection"]));
        audioLanguageSelection = make_shared<ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioLanguageSelection>(model1);
      }
    }
    if (m.find("AudioPidSelection") != m.end() && !m["AudioPidSelection"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioPidSelection"].type()) {
        ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioPidSelection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioPidSelection"]));
        audioPidSelection = make_shared<ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioPidSelection>(model1);
      }
    }
    if (m.find("AudioTrackSelection") != m.end() && !m["AudioTrackSelection"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioTrackSelection"].type()) {
        vector<ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioTrackSelection> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioTrackSelection"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioTrackSelection model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioTrackSelection = make_shared<vector<ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectorsAudioTrackSelection>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectors() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsInputAttachments : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectors>> audioSelectors{};
  shared_ptr<string> inputId{};
  shared_ptr<string> inputName{};
  shared_ptr<string> languageName{};

  ListMediaLiveChannelsResponseBodyChannelsInputAttachments() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsInputAttachments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSelectors) {
      vector<boost::any> temp1;
      for(auto item1:*audioSelectors){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioSelectors"] = boost::any(temp1);
    }
    if (inputId) {
      res["InputId"] = boost::any(*inputId);
    }
    if (inputName) {
      res["InputName"] = boost::any(*inputName);
    }
    if (languageName) {
      res["LanguageName"] = boost::any(*languageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSelectors") != m.end() && !m["AudioSelectors"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioSelectors"].type()) {
        vector<ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectors> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioSelectors"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectors model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioSelectors = make_shared<vector<ListMediaLiveChannelsResponseBodyChannelsInputAttachmentsAudioSelectors>>(expect1);
      }
    }
    if (m.find("InputId") != m.end() && !m["InputId"].empty()) {
      inputId = make_shared<string>(boost::any_cast<string>(m["InputId"]));
    }
    if (m.find("InputName") != m.end() && !m["InputName"].empty()) {
      inputName = make_shared<string>(boost::any_cast<string>(m["InputName"]));
    }
    if (m.find("LanguageName") != m.end() && !m["LanguageName"].empty()) {
      languageName = make_shared<string>(boost::any_cast<string>(m["LanguageName"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsInputAttachments() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsOutputGroupsMediaPackageGroupSetting : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> groupName{};

  ListMediaLiveChannelsResponseBodyChannelsOutputGroupsMediaPackageGroupSetting() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsOutputGroupsMediaPackageGroupSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsOutputGroupsMediaPackageGroupSetting() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputsMediaPackageOutputSetting : public Darabonba::Model {
public:
  shared_ptr<string> audioGroupId{};
  shared_ptr<string> nameModifier{};

  ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputsMediaPackageOutputSetting() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputsMediaPackageOutputSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioGroupId) {
      res["AudioGroupId"] = boost::any(*audioGroupId);
    }
    if (nameModifier) {
      res["NameModifier"] = boost::any(*nameModifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioGroupId") != m.end() && !m["AudioGroupId"].empty()) {
      audioGroupId = make_shared<string>(boost::any_cast<string>(m["AudioGroupId"]));
    }
    if (m.find("NameModifier") != m.end() && !m["NameModifier"].empty()) {
      nameModifier = make_shared<string>(boost::any_cast<string>(m["NameModifier"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputsMediaPackageOutputSetting() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> audioSettingNames{};
  shared_ptr<ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputsMediaPackageOutputSetting> mediaPackageOutputSetting{};
  shared_ptr<long> mediaType{};
  shared_ptr<string> name{};
  shared_ptr<string> videoSettingName{};

  ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputs() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSettingNames) {
      res["AudioSettingNames"] = boost::any(*audioSettingNames);
    }
    if (mediaPackageOutputSetting) {
      res["MediaPackageOutputSetting"] = mediaPackageOutputSetting ? boost::any(mediaPackageOutputSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (videoSettingName) {
      res["VideoSettingName"] = boost::any(*videoSettingName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSettingNames") != m.end() && !m["AudioSettingNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AudioSettingNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AudioSettingNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      audioSettingNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MediaPackageOutputSetting") != m.end() && !m["MediaPackageOutputSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaPackageOutputSetting"].type()) {
        ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputsMediaPackageOutputSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaPackageOutputSetting"]));
        mediaPackageOutputSetting = make_shared<ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputsMediaPackageOutputSetting>(model1);
      }
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<long>(boost::any_cast<long>(m["MediaType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("VideoSettingName") != m.end() && !m["VideoSettingName"].empty()) {
      videoSettingName = make_shared<string>(boost::any_cast<string>(m["VideoSettingName"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputs() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsOutputGroups : public Darabonba::Model {
public:
  shared_ptr<ListMediaLiveChannelsResponseBodyChannelsOutputGroupsMediaPackageGroupSetting> mediaPackageGroupSetting{};
  shared_ptr<string> monitorUrl{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputs>> outputs{};
  shared_ptr<string> type{};

  ListMediaLiveChannelsResponseBodyChannelsOutputGroups() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsOutputGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaPackageGroupSetting) {
      res["MediaPackageGroupSetting"] = mediaPackageGroupSetting ? boost::any(mediaPackageGroupSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (monitorUrl) {
      res["MonitorUrl"] = boost::any(*monitorUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      vector<boost::any> temp1;
      for(auto item1:*outputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outputs"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaPackageGroupSetting") != m.end() && !m["MediaPackageGroupSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaPackageGroupSetting"].type()) {
        ListMediaLiveChannelsResponseBodyChannelsOutputGroupsMediaPackageGroupSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaPackageGroupSetting"]));
        mediaPackageGroupSetting = make_shared<ListMediaLiveChannelsResponseBodyChannelsOutputGroupsMediaPackageGroupSetting>(model1);
      }
    }
    if (m.find("MonitorUrl") != m.end() && !m["MonitorUrl"].empty()) {
      monitorUrl = make_shared<string>(boost::any_cast<string>(m["MonitorUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Outputs"].type()) {
        vector<ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputs = make_shared<vector<ListMediaLiveChannelsResponseBodyChannelsOutputGroupsOutputs>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsOutputGroups() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingCodecDetail : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> profile{};

  ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingCodecDetail() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingCodecDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingCodecDetail() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingFramerate : public Darabonba::Model {
public:
  shared_ptr<string> framerateControl{};
  shared_ptr<long> framerateDenominator{};
  shared_ptr<long> framerateNumerator{};

  ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingFramerate() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingFramerate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (framerateControl) {
      res["FramerateControl"] = boost::any(*framerateControl);
    }
    if (framerateDenominator) {
      res["FramerateDenominator"] = boost::any(*framerateDenominator);
    }
    if (framerateNumerator) {
      res["FramerateNumerator"] = boost::any(*framerateNumerator);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FramerateControl") != m.end() && !m["FramerateControl"].empty()) {
      framerateControl = make_shared<string>(boost::any_cast<string>(m["FramerateControl"]));
    }
    if (m.find("FramerateDenominator") != m.end() && !m["FramerateDenominator"].empty()) {
      framerateDenominator = make_shared<long>(boost::any_cast<long>(m["FramerateDenominator"]));
    }
    if (m.find("FramerateNumerator") != m.end() && !m["FramerateNumerator"].empty()) {
      framerateNumerator = make_shared<long>(boost::any_cast<long>(m["FramerateNumerator"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingFramerate() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingGop : public Darabonba::Model {
public:
  shared_ptr<long> bframesNum{};
  shared_ptr<long> gopSize{};
  shared_ptr<string> gopSizeUnits{};

  ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingGop() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingGop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bframesNum) {
      res["BframesNum"] = boost::any(*bframesNum);
    }
    if (gopSize) {
      res["GopSize"] = boost::any(*gopSize);
    }
    if (gopSizeUnits) {
      res["GopSizeUnits"] = boost::any(*gopSizeUnits);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BframesNum") != m.end() && !m["BframesNum"].empty()) {
      bframesNum = make_shared<long>(boost::any_cast<long>(m["BframesNum"]));
    }
    if (m.find("GopSize") != m.end() && !m["GopSize"].empty()) {
      gopSize = make_shared<long>(boost::any_cast<long>(m["GopSize"]));
    }
    if (m.find("GopSizeUnits") != m.end() && !m["GopSizeUnits"].empty()) {
      gopSizeUnits = make_shared<string>(boost::any_cast<string>(m["GopSizeUnits"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingGop() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingRate : public Darabonba::Model {
public:
  shared_ptr<long> bitrate{};
  shared_ptr<long> bufferSize{};
  shared_ptr<long> maxBitrate{};
  shared_ptr<string> rateControlMode{};

  ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingRate() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingRate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufferSize) {
      res["BufferSize"] = boost::any(*bufferSize);
    }
    if (maxBitrate) {
      res["MaxBitrate"] = boost::any(*maxBitrate);
    }
    if (rateControlMode) {
      res["RateControlMode"] = boost::any(*rateControlMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("BufferSize") != m.end() && !m["BufferSize"].empty()) {
      bufferSize = make_shared<long>(boost::any_cast<long>(m["BufferSize"]));
    }
    if (m.find("MaxBitrate") != m.end() && !m["MaxBitrate"].empty()) {
      maxBitrate = make_shared<long>(boost::any_cast<long>(m["MaxBitrate"]));
    }
    if (m.find("RateControlMode") != m.end() && !m["RateControlMode"].empty()) {
      rateControlMode = make_shared<string>(boost::any_cast<string>(m["RateControlMode"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingRate() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSetting : public Darabonba::Model {
public:
  shared_ptr<ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingCodecDetail> codecDetail{};
  shared_ptr<ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingFramerate> framerate{};
  shared_ptr<ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingGop> gop{};
  shared_ptr<ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingRate> rate{};

  ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSetting() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codecDetail) {
      res["CodecDetail"] = codecDetail ? boost::any(codecDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (framerate) {
      res["Framerate"] = framerate ? boost::any(framerate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gop) {
      res["Gop"] = gop ? boost::any(gop->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rate) {
      res["Rate"] = rate ? boost::any(rate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodecDetail") != m.end() && !m["CodecDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["CodecDetail"].type()) {
        ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingCodecDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CodecDetail"]));
        codecDetail = make_shared<ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingCodecDetail>(model1);
      }
    }
    if (m.find("Framerate") != m.end() && !m["Framerate"].empty()) {
      if (typeid(map<string, boost::any>) == m["Framerate"].type()) {
        ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingFramerate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Framerate"]));
        framerate = make_shared<ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingFramerate>(model1);
      }
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gop"].type()) {
        ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingGop model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gop"]));
        gop = make_shared<ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingGop>(model1);
      }
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rate"].type()) {
        ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingRate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rate"]));
        rate = make_shared<ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSettingRate>(model1);
      }
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSetting() = default;
};
class ListMediaLiveChannelsResponseBodyChannelsVideoSettings : public Darabonba::Model {
public:
  shared_ptr<long> height{};
  shared_ptr<string> name{};
  shared_ptr<string> videoCodec{};
  shared_ptr<ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSetting> videoCodecSetting{};
  shared_ptr<string> videoCodecType{};
  shared_ptr<long> width{};

  ListMediaLiveChannelsResponseBodyChannelsVideoSettings() {}

  explicit ListMediaLiveChannelsResponseBodyChannelsVideoSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (videoCodec) {
      res["VideoCodec"] = boost::any(*videoCodec);
    }
    if (videoCodecSetting) {
      res["VideoCodecSetting"] = videoCodecSetting ? boost::any(videoCodecSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCodecType) {
      res["VideoCodecType"] = boost::any(*videoCodecType);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("VideoCodec") != m.end() && !m["VideoCodec"].empty()) {
      videoCodec = make_shared<string>(boost::any_cast<string>(m["VideoCodec"]));
    }
    if (m.find("VideoCodecSetting") != m.end() && !m["VideoCodecSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoCodecSetting"].type()) {
        ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoCodecSetting"]));
        videoCodecSetting = make_shared<ListMediaLiveChannelsResponseBodyChannelsVideoSettingsVideoCodecSetting>(model1);
      }
    }
    if (m.find("VideoCodecType") != m.end() && !m["VideoCodecType"].empty()) {
      videoCodecType = make_shared<string>(boost::any_cast<string>(m["VideoCodecType"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannelsVideoSettings() = default;
};
class ListMediaLiveChannelsResponseBodyChannels : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaLiveChannelsResponseBodyChannelsAudioSettings>> audioSettings{};
  shared_ptr<string> channelId{};
  shared_ptr<string> createTime{};
  shared_ptr<vector<ListMediaLiveChannelsResponseBodyChannelsInputAttachments>> inputAttachments{};
  shared_ptr<string> lastStartTime{};
  shared_ptr<string> lastStopTime{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListMediaLiveChannelsResponseBodyChannelsOutputGroups>> outputGroups{};
  shared_ptr<string> state{};
  shared_ptr<vector<ListMediaLiveChannelsResponseBodyChannelsVideoSettings>> videoSettings{};

  ListMediaLiveChannelsResponseBodyChannels() {}

  explicit ListMediaLiveChannelsResponseBodyChannels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSettings) {
      vector<boost::any> temp1;
      for(auto item1:*audioSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioSettings"] = boost::any(temp1);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (inputAttachments) {
      vector<boost::any> temp1;
      for(auto item1:*inputAttachments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputAttachments"] = boost::any(temp1);
    }
    if (lastStartTime) {
      res["LastStartTime"] = boost::any(*lastStartTime);
    }
    if (lastStopTime) {
      res["LastStopTime"] = boost::any(*lastStopTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputGroups) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroups"] = boost::any(temp1);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (videoSettings) {
      vector<boost::any> temp1;
      for(auto item1:*videoSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoSettings"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSettings") != m.end() && !m["AudioSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioSettings"].type()) {
        vector<ListMediaLiveChannelsResponseBodyChannelsAudioSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaLiveChannelsResponseBodyChannelsAudioSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioSettings = make_shared<vector<ListMediaLiveChannelsResponseBodyChannelsAudioSettings>>(expect1);
      }
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("InputAttachments") != m.end() && !m["InputAttachments"].empty()) {
      if (typeid(vector<boost::any>) == m["InputAttachments"].type()) {
        vector<ListMediaLiveChannelsResponseBodyChannelsInputAttachments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputAttachments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaLiveChannelsResponseBodyChannelsInputAttachments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputAttachments = make_shared<vector<ListMediaLiveChannelsResponseBodyChannelsInputAttachments>>(expect1);
      }
    }
    if (m.find("LastStartTime") != m.end() && !m["LastStartTime"].empty()) {
      lastStartTime = make_shared<string>(boost::any_cast<string>(m["LastStartTime"]));
    }
    if (m.find("LastStopTime") != m.end() && !m["LastStopTime"].empty()) {
      lastStopTime = make_shared<string>(boost::any_cast<string>(m["LastStopTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputGroups") != m.end() && !m["OutputGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroups"].type()) {
        vector<ListMediaLiveChannelsResponseBodyChannelsOutputGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaLiveChannelsResponseBodyChannelsOutputGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroups = make_shared<vector<ListMediaLiveChannelsResponseBodyChannelsOutputGroups>>(expect1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("VideoSettings") != m.end() && !m["VideoSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoSettings"].type()) {
        vector<ListMediaLiveChannelsResponseBodyChannelsVideoSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaLiveChannelsResponseBodyChannelsVideoSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoSettings = make_shared<vector<ListMediaLiveChannelsResponseBodyChannelsVideoSettings>>(expect1);
      }
    }
  }


  virtual ~ListMediaLiveChannelsResponseBodyChannels() = default;
};
class ListMediaLiveChannelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaLiveChannelsResponseBodyChannels>> channels{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListMediaLiveChannelsResponseBody() {}

  explicit ListMediaLiveChannelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      vector<boost::any> temp1;
      for(auto item1:*channels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Channels"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      if (typeid(vector<boost::any>) == m["Channels"].type()) {
        vector<ListMediaLiveChannelsResponseBodyChannels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Channels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaLiveChannelsResponseBodyChannels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channels = make_shared<vector<ListMediaLiveChannelsResponseBodyChannels>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMediaLiveChannelsResponseBody() = default;
};
class ListMediaLiveChannelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMediaLiveChannelsResponseBody> body{};

  ListMediaLiveChannelsResponse() {}

  explicit ListMediaLiveChannelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMediaLiveChannelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMediaLiveChannelsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMediaLiveChannelsResponse() = default;
};
class ListMediaLiveInputSecurityGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> skip{};
  shared_ptr<string> sortOrder{};

  ListMediaLiveInputSecurityGroupsRequest() {}

  explicit ListMediaLiveInputSecurityGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (skip) {
      res["Skip"] = boost::any(*skip);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Skip") != m.end() && !m["Skip"].empty()) {
      skip = make_shared<long>(boost::any_cast<long>(m["Skip"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
  }


  virtual ~ListMediaLiveInputSecurityGroupsRequest() = default;
};
class ListMediaLiveInputSecurityGroupsResponseBodySecurityGroups : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<vector<string>> inputIds{};
  shared_ptr<string> name{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> whitelistRules{};

  ListMediaLiveInputSecurityGroupsResponseBodySecurityGroups() {}

  explicit ListMediaLiveInputSecurityGroupsResponseBodySecurityGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (inputIds) {
      res["InputIds"] = boost::any(*inputIds);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (whitelistRules) {
      res["WhitelistRules"] = boost::any(*whitelistRules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("InputIds") != m.end() && !m["InputIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InputIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InputIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      inputIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("WhitelistRules") != m.end() && !m["WhitelistRules"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WhitelistRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WhitelistRules"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      whitelistRules = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListMediaLiveInputSecurityGroupsResponseBodySecurityGroups() = default;
};
class ListMediaLiveInputSecurityGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListMediaLiveInputSecurityGroupsResponseBodySecurityGroups>> securityGroups{};
  shared_ptr<long> totalCount{};

  ListMediaLiveInputSecurityGroupsResponseBody() {}

  explicit ListMediaLiveInputSecurityGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityGroups) {
      vector<boost::any> temp1;
      for(auto item1:*securityGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityGroups"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityGroups") != m.end() && !m["SecurityGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityGroups"].type()) {
        vector<ListMediaLiveInputSecurityGroupsResponseBodySecurityGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaLiveInputSecurityGroupsResponseBodySecurityGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityGroups = make_shared<vector<ListMediaLiveInputSecurityGroupsResponseBodySecurityGroups>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMediaLiveInputSecurityGroupsResponseBody() = default;
};
class ListMediaLiveInputSecurityGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMediaLiveInputSecurityGroupsResponseBody> body{};

  ListMediaLiveInputSecurityGroupsResponse() {}

  explicit ListMediaLiveInputSecurityGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMediaLiveInputSecurityGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMediaLiveInputSecurityGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMediaLiveInputSecurityGroupsResponse() = default;
};
class ListMediaLiveInputsRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> skip{};
  shared_ptr<string> sortOrder{};
  shared_ptr<string> types{};

  ListMediaLiveInputsRequest() {}

  explicit ListMediaLiveInputsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (skip) {
      res["Skip"] = boost::any(*skip);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Skip") != m.end() && !m["Skip"].empty()) {
      skip = make_shared<long>(boost::any_cast<long>(m["Skip"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      types = make_shared<string>(boost::any_cast<string>(m["Types"]));
    }
  }


  virtual ~ListMediaLiveInputsRequest() = default;
};
class ListMediaLiveInputsResponseBodyInputsInputInfos : public Darabonba::Model {
public:
  shared_ptr<string> destHost{};
  shared_ptr<string> flowId{};
  shared_ptr<string> flowOutputName{};
  shared_ptr<string> monitorUrl{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<string> streamName{};

  ListMediaLiveInputsResponseBodyInputsInputInfos() {}

  explicit ListMediaLiveInputsResponseBodyInputsInputInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destHost) {
      res["DestHost"] = boost::any(*destHost);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowOutputName) {
      res["FlowOutputName"] = boost::any(*flowOutputName);
    }
    if (monitorUrl) {
      res["MonitorUrl"] = boost::any(*monitorUrl);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestHost") != m.end() && !m["DestHost"].empty()) {
      destHost = make_shared<string>(boost::any_cast<string>(m["DestHost"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowOutputName") != m.end() && !m["FlowOutputName"].empty()) {
      flowOutputName = make_shared<string>(boost::any_cast<string>(m["FlowOutputName"]));
    }
    if (m.find("MonitorUrl") != m.end() && !m["MonitorUrl"].empty()) {
      monitorUrl = make_shared<string>(boost::any_cast<string>(m["MonitorUrl"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~ListMediaLiveInputsResponseBodyInputsInputInfos() = default;
};
class ListMediaLiveInputsResponseBodyInputs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channelIds{};
  shared_ptr<string> createTime{};
  shared_ptr<string> inputId{};
  shared_ptr<vector<ListMediaLiveInputsResponseBodyInputsInputInfos>> inputInfos{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> securityGroupIds{};
  shared_ptr<string> type{};

  ListMediaLiveInputsResponseBodyInputs() {}

  explicit ListMediaLiveInputsResponseBodyInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelIds) {
      res["ChannelIds"] = boost::any(*channelIds);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (inputId) {
      res["InputId"] = boost::any(*inputId);
    }
    if (inputInfos) {
      vector<boost::any> temp1;
      for(auto item1:*inputInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputInfos"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelIds") != m.end() && !m["ChannelIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ChannelIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ChannelIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channelIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("InputId") != m.end() && !m["InputId"].empty()) {
      inputId = make_shared<string>(boost::any_cast<string>(m["InputId"]));
    }
    if (m.find("InputInfos") != m.end() && !m["InputInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["InputInfos"].type()) {
        vector<ListMediaLiveInputsResponseBodyInputsInputInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaLiveInputsResponseBodyInputsInputInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputInfos = make_shared<vector<ListMediaLiveInputsResponseBodyInputsInputInfos>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListMediaLiveInputsResponseBodyInputs() = default;
};
class ListMediaLiveInputsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediaLiveInputsResponseBodyInputs>> inputs{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListMediaLiveInputsResponseBody() {}

  explicit ListMediaLiveInputsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputs) {
      vector<boost::any> temp1;
      for(auto item1:*inputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Inputs"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Inputs"].type()) {
        vector<ListMediaLiveInputsResponseBodyInputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Inputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaLiveInputsResponseBodyInputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputs = make_shared<vector<ListMediaLiveInputsResponseBodyInputs>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMediaLiveInputsResponseBody() = default;
};
class ListMediaLiveInputsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMediaLiveInputsResponseBody> body{};

  ListMediaLiveInputsResponse() {}

  explicit ListMediaLiveInputsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMediaLiveInputsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMediaLiveInputsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMediaLiveInputsResponse() = default;
};
class ListMediaMarksRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaMarkIds{};

  ListMediaMarksRequest() {}

  explicit ListMediaMarksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaMarkIds) {
      res["MediaMarkIds"] = boost::any(*mediaMarkIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaMarkIds") != m.end() && !m["MediaMarkIds"].empty()) {
      mediaMarkIds = make_shared<string>(boost::any_cast<string>(m["MediaMarkIds"]));
    }
  }


  virtual ~ListMediaMarksRequest() = default;
};
class ListMediaMarksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaMarks{};
  shared_ptr<string> requestId{};

  ListMediaMarksResponseBody() {}

  explicit ListMediaMarksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaMarks) {
      res["MediaMarks"] = boost::any(*mediaMarks);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaMarks") != m.end() && !m["MediaMarks"].empty()) {
      mediaMarks = make_shared<string>(boost::any_cast<string>(m["MediaMarks"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListMediaMarksResponseBody() = default;
};
class ListMediaMarksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMediaMarksResponseBody> body{};

  ListMediaMarksResponse() {}

  explicit ListMediaMarksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMediaMarksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMediaMarksResponseBody>(model1);
      }
    }
  }


  virtual ~ListMediaMarksResponse() = default;
};
class ListMediaProducingJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> jobType{};
  shared_ptr<string> keyword{};
  shared_ptr<string> masterJobId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> projectId{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  ListMediaProducingJobsRequest() {}

  explicit ListMediaProducingJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (masterJobId) {
      res["MasterJobId"] = boost::any(*masterJobId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("MasterJobId") != m.end() && !m["MasterJobId"].empty()) {
      masterJobId = make_shared<string>(boost::any_cast<string>(m["MasterJobId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListMediaProducingJobsRequest() = default;
};
class ListMediaProducingJobsResponseBodyMediaProducingJobList : public Darabonba::Model {
public:
  shared_ptr<string> clipsParam{};
  shared_ptr<string> code{};
  shared_ptr<string> completeTime{};
  shared_ptr<string> createTime{};
  shared_ptr<double> duration{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaURL{};
  shared_ptr<string> message{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> projectId{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> userData{};

  ListMediaProducingJobsResponseBodyMediaProducingJobList() {}

  explicit ListMediaProducingJobsResponseBodyMediaProducingJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (completeTime) {
      res["CompleteTime"] = boost::any(*completeTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaURL) {
      res["MediaURL"] = boost::any(*mediaURL);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CompleteTime") != m.end() && !m["CompleteTime"].empty()) {
      completeTime = make_shared<string>(boost::any_cast<string>(m["CompleteTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaURL") != m.end() && !m["MediaURL"].empty()) {
      mediaURL = make_shared<string>(boost::any_cast<string>(m["MediaURL"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ListMediaProducingJobsResponseBodyMediaProducingJobList() = default;
};
class ListMediaProducingJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> maxResults{};
  shared_ptr<vector<ListMediaProducingJobsResponseBodyMediaProducingJobList>> mediaProducingJobList{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  ListMediaProducingJobsResponseBody() {}

  explicit ListMediaProducingJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (mediaProducingJobList) {
      vector<boost::any> temp1;
      for(auto item1:*mediaProducingJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaProducingJobList"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<string>(boost::any_cast<string>(m["MaxResults"]));
    }
    if (m.find("MediaProducingJobList") != m.end() && !m["MediaProducingJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaProducingJobList"].type()) {
        vector<ListMediaProducingJobsResponseBodyMediaProducingJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaProducingJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediaProducingJobsResponseBodyMediaProducingJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaProducingJobList = make_shared<vector<ListMediaProducingJobsResponseBodyMediaProducingJobList>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListMediaProducingJobsResponseBody() = default;
};
class ListMediaProducingJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMediaProducingJobsResponseBody> body{};

  ListMediaProducingJobsResponse() {}

  explicit ListMediaProducingJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMediaProducingJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMediaProducingJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMediaProducingJobsResponse() = default;
};
class ListPackageJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfCreateTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startOfCreateTime{};
  shared_ptr<string> status{};

  ListPackageJobsRequest() {}

  explicit ListPackageJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfCreateTime) {
      res["EndOfCreateTime"] = boost::any(*endOfCreateTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startOfCreateTime) {
      res["StartOfCreateTime"] = boost::any(*startOfCreateTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfCreateTime") != m.end() && !m["EndOfCreateTime"].empty()) {
      endOfCreateTime = make_shared<string>(boost::any_cast<string>(m["EndOfCreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartOfCreateTime") != m.end() && !m["StartOfCreateTime"].empty()) {
      startOfCreateTime = make_shared<string>(boost::any_cast<string>(m["StartOfCreateTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListPackageJobsRequest() = default;
};
class ListPackageJobsResponseBodyPackageJobListPackageJobsInputsInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListPackageJobsResponseBodyPackageJobListPackageJobsInputsInput() {}

  explicit ListPackageJobsResponseBodyPackageJobListPackageJobsInputsInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListPackageJobsResponseBodyPackageJobListPackageJobsInputsInput() = default;
};
class ListPackageJobsResponseBodyPackageJobListPackageJobsInputs : public Darabonba::Model {
public:
  shared_ptr<ListPackageJobsResponseBodyPackageJobListPackageJobsInputsInput> input{};

  ListPackageJobsResponseBodyPackageJobListPackageJobsInputs() {}

  explicit ListPackageJobsResponseBodyPackageJobListPackageJobsInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListPackageJobsResponseBodyPackageJobListPackageJobsInputsInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListPackageJobsResponseBodyPackageJobListPackageJobsInputsInput>(model1);
      }
    }
  }


  virtual ~ListPackageJobsResponseBodyPackageJobListPackageJobsInputs() = default;
};
class ListPackageJobsResponseBodyPackageJobListPackageJobsOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListPackageJobsResponseBodyPackageJobListPackageJobsOutput() {}

  explicit ListPackageJobsResponseBodyPackageJobListPackageJobsOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListPackageJobsResponseBodyPackageJobListPackageJobsOutput() = default;
};
class ListPackageJobsResponseBodyPackageJobListPackageJobs : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<vector<ListPackageJobsResponseBodyPackageJobListPackageJobsInputs>> inputs{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<ListPackageJobsResponseBodyPackageJobListPackageJobsOutput> output{};
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};
  shared_ptr<string> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  ListPackageJobsResponseBodyPackageJobListPackageJobs() {}

  explicit ListPackageJobsResponseBodyPackageJobListPackageJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (inputs) {
      vector<boost::any> temp1;
      for(auto item1:*inputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Inputs"] = boost::any(temp1);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Inputs"].type()) {
        vector<ListPackageJobsResponseBodyPackageJobListPackageJobsInputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Inputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPackageJobsResponseBodyPackageJobListPackageJobsInputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputs = make_shared<vector<ListPackageJobsResponseBodyPackageJobListPackageJobsInputs>>(expect1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        ListPackageJobsResponseBodyPackageJobListPackageJobsOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<ListPackageJobsResponseBodyPackageJobListPackageJobsOutput>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ListPackageJobsResponseBodyPackageJobListPackageJobs() = default;
};
class ListPackageJobsResponseBodyPackageJobList : public Darabonba::Model {
public:
  shared_ptr<string> nextPageToken{};
  shared_ptr<vector<ListPackageJobsResponseBodyPackageJobListPackageJobs>> packageJobs{};

  ListPackageJobsResponseBodyPackageJobList() {}

  explicit ListPackageJobsResponseBodyPackageJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (packageJobs) {
      vector<boost::any> temp1;
      for(auto item1:*packageJobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PackageJobs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("PackageJobs") != m.end() && !m["PackageJobs"].empty()) {
      if (typeid(vector<boost::any>) == m["PackageJobs"].type()) {
        vector<ListPackageJobsResponseBodyPackageJobListPackageJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PackageJobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPackageJobsResponseBodyPackageJobListPackageJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        packageJobs = make_shared<vector<ListPackageJobsResponseBodyPackageJobListPackageJobs>>(expect1);
      }
    }
  }


  virtual ~ListPackageJobsResponseBodyPackageJobList() = default;
};
class ListPackageJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListPackageJobsResponseBodyPackageJobList> packageJobList{};
  shared_ptr<string> requestId{};

  ListPackageJobsResponseBody() {}

  explicit ListPackageJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packageJobList) {
      res["PackageJobList"] = packageJobList ? boost::any(packageJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackageJobList") != m.end() && !m["PackageJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PackageJobList"].type()) {
        ListPackageJobsResponseBodyPackageJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PackageJobList"]));
        packageJobList = make_shared<ListPackageJobsResponseBodyPackageJobList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPackageJobsResponseBody() = default;
};
class ListPackageJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPackageJobsResponseBody> body{};

  ListPackageJobsResponse() {}

  explicit ListPackageJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPackageJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPackageJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPackageJobsResponse() = default;
};
class ListPipelinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> speed{};

  ListPipelinesRequest() {}

  explicit ListPipelinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
  }


  virtual ~ListPipelinesRequest() = default;
};
class ListPipelinesResponseBodyPipelineList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};
  shared_ptr<string> speed{};
  shared_ptr<string> status{};

  ListPipelinesResponseBodyPipelineList() {}

  explicit ListPipelinesResponseBodyPipelineList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<string>(boost::any_cast<string>(m["Speed"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListPipelinesResponseBodyPipelineList() = default;
};
class ListPipelinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListPipelinesResponseBodyPipelineList>> pipelineList{};
  shared_ptr<string> requestId{};

  ListPipelinesResponseBody() {}

  explicit ListPipelinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineList) {
      vector<boost::any> temp1;
      for(auto item1:*pipelineList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PipelineList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineList") != m.end() && !m["PipelineList"].empty()) {
      if (typeid(vector<boost::any>) == m["PipelineList"].type()) {
        vector<ListPipelinesResponseBodyPipelineList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PipelineList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPipelinesResponseBodyPipelineList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pipelineList = make_shared<vector<ListPipelinesResponseBodyPipelineList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPipelinesResponseBody() = default;
};
class ListPipelinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPipelinesResponseBody> body{};

  ListPipelinesResponse() {}

  explicit ListPipelinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPipelinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPipelinesResponseBody>(model1);
      }
    }
  }


  virtual ~ListPipelinesResponse() = default;
};
class ListProgramsRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> programName{};
  shared_ptr<string> sortBy{};

  ListProgramsRequest() {}

  explicit ListProgramsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<string>(boost::any_cast<string>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~ListProgramsRequest() = default;
};
class ListProgramsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ChannelAssemblyProgram>> programs{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListProgramsResponseBody() {}

  explicit ListProgramsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (programs) {
      vector<boost::any> temp1;
      for(auto item1:*programs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Programs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Programs") != m.end() && !m["Programs"].empty()) {
      if (typeid(vector<boost::any>) == m["Programs"].type()) {
        vector<ChannelAssemblyProgram> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Programs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ChannelAssemblyProgram model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        programs = make_shared<vector<ChannelAssemblyProgram>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListProgramsResponseBody() = default;
};
class ListProgramsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProgramsResponseBody> body{};

  ListProgramsResponse() {}

  explicit ListProgramsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProgramsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProgramsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProgramsResponse() = default;
};
class ListPublicMediaBasicInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<bool> includeFileBasicInfo{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> mediaTagId{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};

  ListPublicMediaBasicInfosRequest() {}

  explicit ListPublicMediaBasicInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (includeFileBasicInfo) {
      res["IncludeFileBasicInfo"] = boost::any(*includeFileBasicInfo);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (mediaTagId) {
      res["MediaTagId"] = boost::any(*mediaTagId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("IncludeFileBasicInfo") != m.end() && !m["IncludeFileBasicInfo"].empty()) {
      includeFileBasicInfo = make_shared<bool>(boost::any_cast<bool>(m["IncludeFileBasicInfo"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("MediaTagId") != m.end() && !m["MediaTagId"].empty()) {
      mediaTagId = make_shared<string>(boost::any_cast<string>(m["MediaTagId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListPublicMediaBasicInfosRequest() = default;
};
class ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo() {}

  explicit ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo() = default;
};
class ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList : public Darabonba::Model {
public:
  shared_ptr<ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo> fileBasicInfo{};

  ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList() {}

  explicit ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo>(model1);
      }
    }
  }


  virtual ~ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList() = default;
};
class ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> snapshots{};
  shared_ptr<string> source{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> transcodeStatus{};
  shared_ptr<string> userData{};

  ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo() {}

  explicit ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (transcodeStatus) {
      res["TranscodeStatus"] = boost::any(*transcodeStatus);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      snapshots = make_shared<string>(boost::any_cast<string>(m["Snapshots"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TranscodeStatus") != m.end() && !m["TranscodeStatus"].empty()) {
      transcodeStatus = make_shared<string>(boost::any_cast<string>(m["TranscodeStatus"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo() = default;
};
class ListPublicMediaBasicInfosResponseBodyMediaInfos : public Darabonba::Model {
public:
  shared_ptr<vector<ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList>> fileInfoList{};
  shared_ptr<ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  ListPublicMediaBasicInfosResponseBodyMediaInfos() {}

  explicit ListPublicMediaBasicInfosResponseBodyMediaInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList>>(expect1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~ListPublicMediaBasicInfosResponseBodyMediaInfos() = default;
};
class ListPublicMediaBasicInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<vector<ListPublicMediaBasicInfosResponseBodyMediaInfos>> mediaInfos{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListPublicMediaBasicInfosResponseBody() {}

  explicit ListPublicMediaBasicInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (mediaInfos) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInfos"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("MediaInfos") != m.end() && !m["MediaInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInfos"].type()) {
        vector<ListPublicMediaBasicInfosResponseBodyMediaInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPublicMediaBasicInfosResponseBodyMediaInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInfos = make_shared<vector<ListPublicMediaBasicInfosResponseBodyMediaInfos>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPublicMediaBasicInfosResponseBody() = default;
};
class ListPublicMediaBasicInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPublicMediaBasicInfosResponseBody> body{};

  ListPublicMediaBasicInfosResponse() {}

  explicit ListPublicMediaBasicInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPublicMediaBasicInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPublicMediaBasicInfosResponseBody>(model1);
      }
    }
  }


  virtual ~ListPublicMediaBasicInfosResponse() = default;
};
class ListRecognitionEntitiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> libId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListRecognitionEntitiesRequest() {}

  explicit ListRecognitionEntitiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (libId) {
      res["LibId"] = boost::any(*libId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("LibId") != m.end() && !m["LibId"].empty()) {
      libId = make_shared<string>(boost::any_cast<string>(m["LibId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListRecognitionEntitiesRequest() = default;
};
class ListRecognitionEntitiesResponseBodyEntitiesEntity : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<string> entityInfo{};
  shared_ptr<string> entityName{};

  ListRecognitionEntitiesResponseBodyEntitiesEntity() {}

  explicit ListRecognitionEntitiesResponseBodyEntitiesEntity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (entityInfo) {
      res["EntityInfo"] = boost::any(*entityInfo);
    }
    if (entityName) {
      res["EntityName"] = boost::any(*entityName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("EntityInfo") != m.end() && !m["EntityInfo"].empty()) {
      entityInfo = make_shared<string>(boost::any_cast<string>(m["EntityInfo"]));
    }
    if (m.find("EntityName") != m.end() && !m["EntityName"].empty()) {
      entityName = make_shared<string>(boost::any_cast<string>(m["EntityName"]));
    }
  }


  virtual ~ListRecognitionEntitiesResponseBodyEntitiesEntity() = default;
};
class ListRecognitionEntitiesResponseBodyEntities : public Darabonba::Model {
public:
  shared_ptr<vector<ListRecognitionEntitiesResponseBodyEntitiesEntity>> entity{};

  ListRecognitionEntitiesResponseBodyEntities() {}

  explicit ListRecognitionEntitiesResponseBodyEntities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entity) {
      vector<boost::any> temp1;
      for(auto item1:*entity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Entity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Entity") != m.end() && !m["Entity"].empty()) {
      if (typeid(vector<boost::any>) == m["Entity"].type()) {
        vector<ListRecognitionEntitiesResponseBodyEntitiesEntity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Entity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRecognitionEntitiesResponseBodyEntitiesEntity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        entity = make_shared<vector<ListRecognitionEntitiesResponseBodyEntitiesEntity>>(expect1);
      }
    }
  }


  virtual ~ListRecognitionEntitiesResponseBodyEntities() = default;
};
class ListRecognitionEntitiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListRecognitionEntitiesResponseBodyEntities> entities{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListRecognitionEntitiesResponseBody() {}

  explicit ListRecognitionEntitiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entities) {
      res["Entities"] = entities ? boost::any(entities->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Entities") != m.end() && !m["Entities"].empty()) {
      if (typeid(map<string, boost::any>) == m["Entities"].type()) {
        ListRecognitionEntitiesResponseBodyEntities model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Entities"]));
        entities = make_shared<ListRecognitionEntitiesResponseBodyEntities>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRecognitionEntitiesResponseBody() = default;
};
class ListRecognitionEntitiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRecognitionEntitiesResponseBody> body{};

  ListRecognitionEntitiesResponse() {}

  explicit ListRecognitionEntitiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRecognitionEntitiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRecognitionEntitiesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRecognitionEntitiesResponse() = default;
};
class ListRecognitionLibsRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListRecognitionLibsRequest() {}

  explicit ListRecognitionLibsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListRecognitionLibsRequest() = default;
};
class ListRecognitionLibsResponseBodyLibsLib : public Darabonba::Model {
public:
  shared_ptr<string> libDescription{};
  shared_ptr<string> libId{};
  shared_ptr<string> libName{};

  ListRecognitionLibsResponseBodyLibsLib() {}

  explicit ListRecognitionLibsResponseBodyLibsLib(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (libDescription) {
      res["LibDescription"] = boost::any(*libDescription);
    }
    if (libId) {
      res["LibId"] = boost::any(*libId);
    }
    if (libName) {
      res["LibName"] = boost::any(*libName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LibDescription") != m.end() && !m["LibDescription"].empty()) {
      libDescription = make_shared<string>(boost::any_cast<string>(m["LibDescription"]));
    }
    if (m.find("LibId") != m.end() && !m["LibId"].empty()) {
      libId = make_shared<string>(boost::any_cast<string>(m["LibId"]));
    }
    if (m.find("LibName") != m.end() && !m["LibName"].empty()) {
      libName = make_shared<string>(boost::any_cast<string>(m["LibName"]));
    }
  }


  virtual ~ListRecognitionLibsResponseBodyLibsLib() = default;
};
class ListRecognitionLibsResponseBodyLibs : public Darabonba::Model {
public:
  shared_ptr<vector<ListRecognitionLibsResponseBodyLibsLib>> lib{};

  ListRecognitionLibsResponseBodyLibs() {}

  explicit ListRecognitionLibsResponseBodyLibs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lib) {
      vector<boost::any> temp1;
      for(auto item1:*lib){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Lib"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lib") != m.end() && !m["Lib"].empty()) {
      if (typeid(vector<boost::any>) == m["Lib"].type()) {
        vector<ListRecognitionLibsResponseBodyLibsLib> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Lib"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRecognitionLibsResponseBodyLibsLib model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lib = make_shared<vector<ListRecognitionLibsResponseBodyLibsLib>>(expect1);
      }
    }
  }


  virtual ~ListRecognitionLibsResponseBodyLibs() = default;
};
class ListRecognitionLibsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListRecognitionLibsResponseBodyLibs> libs{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListRecognitionLibsResponseBody() {}

  explicit ListRecognitionLibsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (libs) {
      res["Libs"] = libs ? boost::any(libs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Libs") != m.end() && !m["Libs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Libs"].type()) {
        ListRecognitionLibsResponseBodyLibs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Libs"]));
        libs = make_shared<ListRecognitionLibsResponseBodyLibs>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRecognitionLibsResponseBody() = default;
};
class ListRecognitionLibsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRecognitionLibsResponseBody> body{};

  ListRecognitionLibsResponse() {}

  explicit ListRecognitionLibsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRecognitionLibsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRecognitionLibsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRecognitionLibsResponse() = default;
};
class ListRecognitionSamplesRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> entityId{};
  shared_ptr<string> libId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  ListRecognitionSamplesRequest() {}

  explicit ListRecognitionSamplesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (libId) {
      res["LibId"] = boost::any(*libId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("LibId") != m.end() && !m["LibId"].empty()) {
      libId = make_shared<string>(boost::any_cast<string>(m["LibId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~ListRecognitionSamplesRequest() = default;
};
class ListRecognitionSamplesResponseBodySamplesSample : public Darabonba::Model {
public:
  shared_ptr<string> imageUrl{};
  shared_ptr<string> sampleId{};

  ListRecognitionSamplesResponseBodySamplesSample() {}

  explicit ListRecognitionSamplesResponseBodySamplesSample(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageUrl) {
      res["ImageUrl"] = boost::any(*imageUrl);
    }
    if (sampleId) {
      res["SampleId"] = boost::any(*sampleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageUrl") != m.end() && !m["ImageUrl"].empty()) {
      imageUrl = make_shared<string>(boost::any_cast<string>(m["ImageUrl"]));
    }
    if (m.find("SampleId") != m.end() && !m["SampleId"].empty()) {
      sampleId = make_shared<string>(boost::any_cast<string>(m["SampleId"]));
    }
  }


  virtual ~ListRecognitionSamplesResponseBodySamplesSample() = default;
};
class ListRecognitionSamplesResponseBodySamples : public Darabonba::Model {
public:
  shared_ptr<vector<ListRecognitionSamplesResponseBodySamplesSample>> sample{};

  ListRecognitionSamplesResponseBodySamples() {}

  explicit ListRecognitionSamplesResponseBodySamples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sample) {
      vector<boost::any> temp1;
      for(auto item1:*sample){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sample"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      if (typeid(vector<boost::any>) == m["Sample"].type()) {
        vector<ListRecognitionSamplesResponseBodySamplesSample> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sample"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRecognitionSamplesResponseBodySamplesSample model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sample = make_shared<vector<ListRecognitionSamplesResponseBodySamplesSample>>(expect1);
      }
    }
  }


  virtual ~ListRecognitionSamplesResponseBodySamples() = default;
};
class ListRecognitionSamplesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<ListRecognitionSamplesResponseBodySamples> samples{};
  shared_ptr<long> totalCount{};

  ListRecognitionSamplesResponseBody() {}

  explicit ListRecognitionSamplesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (samples) {
      res["Samples"] = samples ? boost::any(samples->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Samples") != m.end() && !m["Samples"].empty()) {
      if (typeid(map<string, boost::any>) == m["Samples"].type()) {
        ListRecognitionSamplesResponseBodySamples model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Samples"]));
        samples = make_shared<ListRecognitionSamplesResponseBodySamples>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRecognitionSamplesResponseBody() = default;
};
class ListRecognitionSamplesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRecognitionSamplesResponseBody> body{};

  ListRecognitionSamplesResponse() {}

  explicit ListRecognitionSamplesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRecognitionSamplesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRecognitionSamplesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRecognitionSamplesResponse() = default;
};
class ListSchedulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> windowDurationSeconds{};

  ListSchedulesRequest() {}

  explicit ListSchedulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (windowDurationSeconds) {
      res["WindowDurationSeconds"] = boost::any(*windowDurationSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("WindowDurationSeconds") != m.end() && !m["WindowDurationSeconds"].empty()) {
      windowDurationSeconds = make_shared<long>(boost::any_cast<long>(m["WindowDurationSeconds"]));
    }
  }


  virtual ~ListSchedulesRequest() = default;
};
class ListSchedulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ChannelAssemblyScheduleData>> programs{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListSchedulesResponseBody() {}

  explicit ListSchedulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (programs) {
      vector<boost::any> temp1;
      for(auto item1:*programs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Programs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Programs") != m.end() && !m["Programs"].empty()) {
      if (typeid(vector<boost::any>) == m["Programs"].type()) {
        vector<ChannelAssemblyScheduleData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Programs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ChannelAssemblyScheduleData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        programs = make_shared<vector<ChannelAssemblyScheduleData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSchedulesResponseBody() = default;
};
class ListSchedulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSchedulesResponseBody> body{};

  ListSchedulesResponse() {}

  explicit ListSchedulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSchedulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSchedulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSchedulesResponse() = default;
};
class ListSearchLibRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};

  ListSearchLibRequest() {}

  explicit ListSearchLibRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListSearchLibRequest() = default;
};
class ListSearchLibResponseBodySearchLibInfoListIndexInfo : public Darabonba::Model {
public:
  shared_ptr<string> indexReadiness{};
  shared_ptr<string> indexStatus{};
  shared_ptr<string> indexType{};

  ListSearchLibResponseBodySearchLibInfoListIndexInfo() {}

  explicit ListSearchLibResponseBodySearchLibInfoListIndexInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (indexReadiness) {
      res["IndexReadiness"] = boost::any(*indexReadiness);
    }
    if (indexStatus) {
      res["IndexStatus"] = boost::any(*indexStatus);
    }
    if (indexType) {
      res["IndexType"] = boost::any(*indexType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IndexReadiness") != m.end() && !m["IndexReadiness"].empty()) {
      indexReadiness = make_shared<string>(boost::any_cast<string>(m["IndexReadiness"]));
    }
    if (m.find("IndexStatus") != m.end() && !m["IndexStatus"].empty()) {
      indexStatus = make_shared<string>(boost::any_cast<string>(m["IndexStatus"]));
    }
    if (m.find("IndexType") != m.end() && !m["IndexType"].empty()) {
      indexType = make_shared<string>(boost::any_cast<string>(m["IndexType"]));
    }
  }


  virtual ~ListSearchLibResponseBodySearchLibInfoListIndexInfo() = default;
};
class ListSearchLibResponseBodySearchLibInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<ListSearchLibResponseBodySearchLibInfoListIndexInfo>> indexInfo{};
  shared_ptr<string> searchLibName{};
  shared_ptr<string> status{};

  ListSearchLibResponseBodySearchLibInfoList() {}

  explicit ListSearchLibResponseBodySearchLibInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (indexInfo) {
      vector<boost::any> temp1;
      for(auto item1:*indexInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IndexInfo"] = boost::any(temp1);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IndexInfo") != m.end() && !m["IndexInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["IndexInfo"].type()) {
        vector<ListSearchLibResponseBodySearchLibInfoListIndexInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IndexInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSearchLibResponseBodySearchLibInfoListIndexInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        indexInfo = make_shared<vector<ListSearchLibResponseBodySearchLibInfoListIndexInfo>>(expect1);
      }
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListSearchLibResponseBodySearchLibInfoList() = default;
};
class ListSearchLibResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSearchLibResponseBodySearchLibInfoList>> searchLibInfoList{};
  shared_ptr<string> success{};
  shared_ptr<long> total{};

  ListSearchLibResponseBody() {}

  explicit ListSearchLibResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (searchLibInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*searchLibInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchLibInfoList"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SearchLibInfoList") != m.end() && !m["SearchLibInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchLibInfoList"].type()) {
        vector<ListSearchLibResponseBodySearchLibInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchLibInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSearchLibResponseBodySearchLibInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchLibInfoList = make_shared<vector<ListSearchLibResponseBodySearchLibInfoList>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSearchLibResponseBody() = default;
};
class ListSearchLibResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSearchLibResponseBody> body{};

  ListSearchLibResponse() {}

  explicit ListSearchLibResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSearchLibResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSearchLibResponseBody>(model1);
      }
    }
  }


  virtual ~ListSearchLibResponse() = default;
};
class ListSmartJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobState{};
  shared_ptr<string> jobType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};

  ListSmartJobsRequest() {}

  explicit ListSmartJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobState) {
      res["JobState"] = boost::any(*jobState);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobState") != m.end() && !m["JobState"].empty()) {
      jobState = make_shared<string>(boost::any_cast<string>(m["JobState"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~ListSmartJobsRequest() = default;
};
class ListSmartJobsResponseBodySmartJobListInputConfig : public Darabonba::Model {
public:
  shared_ptr<string> inputFile{};
  shared_ptr<string> keyword{};

  ListSmartJobsResponseBodySmartJobListInputConfig() {}

  explicit ListSmartJobsResponseBodySmartJobListInputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputFile) {
      res["InputFile"] = boost::any(*inputFile);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      inputFile = make_shared<string>(boost::any_cast<string>(m["InputFile"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
  }


  virtual ~ListSmartJobsResponseBodySmartJobListInputConfig() = default;
};
class ListSmartJobsResponseBodySmartJobListOutputConfig : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> object{};

  ListSmartJobsResponseBodySmartJobListOutputConfig() {}

  explicit ListSmartJobsResponseBodySmartJobListOutputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~ListSmartJobsResponseBodySmartJobListOutputConfig() = default;
};
class ListSmartJobsResponseBodySmartJobList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> editingConfig{};
  shared_ptr<ListSmartJobsResponseBodySmartJobListInputConfig> inputConfig{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobState{};
  shared_ptr<string> jobType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<ListSmartJobsResponseBodySmartJobListOutputConfig> outputConfig{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};
  shared_ptr<long> userId{};

  ListSmartJobsResponseBodySmartJobList() {}

  explicit ListSmartJobsResponseBodySmartJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (editingConfig) {
      res["EditingConfig"] = boost::any(*editingConfig);
    }
    if (inputConfig) {
      res["InputConfig"] = inputConfig ? boost::any(inputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobState) {
      res["JobState"] = boost::any(*jobState);
    }
    if (jobType) {
      res["JobType"] = boost::any(*jobType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (outputConfig) {
      res["OutputConfig"] = outputConfig ? boost::any(outputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      editingConfig = make_shared<string>(boost::any_cast<string>(m["EditingConfig"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputConfig"].type()) {
        ListSmartJobsResponseBodySmartJobListInputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputConfig"]));
        inputConfig = make_shared<ListSmartJobsResponseBodySmartJobListInputConfig>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobState") != m.end() && !m["JobState"].empty()) {
      jobState = make_shared<string>(boost::any_cast<string>(m["JobState"]));
    }
    if (m.find("JobType") != m.end() && !m["JobType"].empty()) {
      jobType = make_shared<string>(boost::any_cast<string>(m["JobType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputConfig"].type()) {
        ListSmartJobsResponseBodySmartJobListOutputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputConfig"]));
        outputConfig = make_shared<ListSmartJobsResponseBodySmartJobListOutputConfig>(model1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~ListSmartJobsResponseBodySmartJobList() = default;
};
class ListSmartJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSmartJobsResponseBodySmartJobList>> smartJobList{};
  shared_ptr<string> totalCount{};

  ListSmartJobsResponseBody() {}

  explicit ListSmartJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (smartJobList) {
      vector<boost::any> temp1;
      for(auto item1:*smartJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmartJobList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<string>(boost::any_cast<string>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SmartJobList") != m.end() && !m["SmartJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["SmartJobList"].type()) {
        vector<ListSmartJobsResponseBodySmartJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmartJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSmartJobsResponseBodySmartJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smartJobList = make_shared<vector<ListSmartJobsResponseBodySmartJobList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListSmartJobsResponseBody() = default;
};
class ListSmartJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSmartJobsResponseBody> body{};

  ListSmartJobsResponse() {}

  explicit ListSmartJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSmartJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSmartJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSmartJobsResponse() = default;
};
class ListSmartSysAvatarModelsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sdkVersion{};

  ListSmartSysAvatarModelsRequest() {}

  explicit ListSmartSysAvatarModelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sdkVersion) {
      res["SdkVersion"] = boost::any(*sdkVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SdkVersion") != m.end() && !m["SdkVersion"].empty()) {
      sdkVersion = make_shared<string>(boost::any_cast<string>(m["SdkVersion"]));
    }
  }


  virtual ~ListSmartSysAvatarModelsRequest() = default;
};
class ListSmartSysAvatarModelsResponseBodySmartSysAvatarModelList : public Darabonba::Model {
public:
  shared_ptr<string> avatarId{};
  shared_ptr<string> avatarName{};
  shared_ptr<long> bitrate{};
  shared_ptr<string> coverUrl{};
  shared_ptr<long> height{};
  shared_ptr<bool> outputMask{};
  shared_ptr<string> videoUrl{};
  shared_ptr<long> width{};

  ListSmartSysAvatarModelsResponseBodySmartSysAvatarModelList() {}

  explicit ListSmartSysAvatarModelsResponseBodySmartSysAvatarModelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarId) {
      res["AvatarId"] = boost::any(*avatarId);
    }
    if (avatarName) {
      res["AvatarName"] = boost::any(*avatarName);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (outputMask) {
      res["OutputMask"] = boost::any(*outputMask);
    }
    if (videoUrl) {
      res["VideoUrl"] = boost::any(*videoUrl);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarId") != m.end() && !m["AvatarId"].empty()) {
      avatarId = make_shared<string>(boost::any_cast<string>(m["AvatarId"]));
    }
    if (m.find("AvatarName") != m.end() && !m["AvatarName"].empty()) {
      avatarName = make_shared<string>(boost::any_cast<string>(m["AvatarName"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("OutputMask") != m.end() && !m["OutputMask"].empty()) {
      outputMask = make_shared<bool>(boost::any_cast<bool>(m["OutputMask"]));
    }
    if (m.find("VideoUrl") != m.end() && !m["VideoUrl"].empty()) {
      videoUrl = make_shared<string>(boost::any_cast<string>(m["VideoUrl"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~ListSmartSysAvatarModelsResponseBodySmartSysAvatarModelList() = default;
};
class ListSmartSysAvatarModelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSmartSysAvatarModelsResponseBodySmartSysAvatarModelList>> smartSysAvatarModelList{};
  shared_ptr<long> totalCount{};

  ListSmartSysAvatarModelsResponseBody() {}

  explicit ListSmartSysAvatarModelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (smartSysAvatarModelList) {
      vector<boost::any> temp1;
      for(auto item1:*smartSysAvatarModelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmartSysAvatarModelList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SmartSysAvatarModelList") != m.end() && !m["SmartSysAvatarModelList"].empty()) {
      if (typeid(vector<boost::any>) == m["SmartSysAvatarModelList"].type()) {
        vector<ListSmartSysAvatarModelsResponseBodySmartSysAvatarModelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmartSysAvatarModelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSmartSysAvatarModelsResponseBodySmartSysAvatarModelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smartSysAvatarModelList = make_shared<vector<ListSmartSysAvatarModelsResponseBodySmartSysAvatarModelList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSmartSysAvatarModelsResponseBody() = default;
};
class ListSmartSysAvatarModelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSmartSysAvatarModelsResponseBody> body{};

  ListSmartSysAvatarModelsResponse() {}

  explicit ListSmartSysAvatarModelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSmartSysAvatarModelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSmartSysAvatarModelsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSmartSysAvatarModelsResponse() = default;
};
class ListSmartVoiceGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> voiceType{};

  ListSmartVoiceGroupsRequest() {}

  explicit ListSmartVoiceGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (voiceType) {
      res["VoiceType"] = boost::any(*voiceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VoiceType") != m.end() && !m["VoiceType"].empty()) {
      voiceType = make_shared<string>(boost::any_cast<string>(m["VoiceType"]));
    }
  }


  virtual ~ListSmartVoiceGroupsRequest() = default;
};
class ListSmartVoiceGroupsResponseBodyVoiceGroupsVoiceList : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> name{};
  shared_ptr<string> remark{};
  shared_ptr<string> supportSampleRate{};
  shared_ptr<string> tag{};
  shared_ptr<string> voice{};
  shared_ptr<string> voiceType{};
  shared_ptr<string> voiceUrl{};

  ListSmartVoiceGroupsResponseBodyVoiceGroupsVoiceList() {}

  explicit ListSmartVoiceGroupsResponseBodyVoiceGroupsVoiceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (supportSampleRate) {
      res["SupportSampleRate"] = boost::any(*supportSampleRate);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    if (voiceType) {
      res["VoiceType"] = boost::any(*voiceType);
    }
    if (voiceUrl) {
      res["VoiceUrl"] = boost::any(*voiceUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SupportSampleRate") != m.end() && !m["SupportSampleRate"].empty()) {
      supportSampleRate = make_shared<string>(boost::any_cast<string>(m["SupportSampleRate"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
    if (m.find("VoiceType") != m.end() && !m["VoiceType"].empty()) {
      voiceType = make_shared<string>(boost::any_cast<string>(m["VoiceType"]));
    }
    if (m.find("VoiceUrl") != m.end() && !m["VoiceUrl"].empty()) {
      voiceUrl = make_shared<string>(boost::any_cast<string>(m["VoiceUrl"]));
    }
  }


  virtual ~ListSmartVoiceGroupsResponseBodyVoiceGroupsVoiceList() = default;
};
class ListSmartVoiceGroupsResponseBodyVoiceGroups : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<vector<ListSmartVoiceGroupsResponseBodyVoiceGroupsVoiceList>> voiceList{};

  ListSmartVoiceGroupsResponseBodyVoiceGroups() {}

  explicit ListSmartVoiceGroupsResponseBodyVoiceGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (voiceList) {
      vector<boost::any> temp1;
      for(auto item1:*voiceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VoiceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VoiceList") != m.end() && !m["VoiceList"].empty()) {
      if (typeid(vector<boost::any>) == m["VoiceList"].type()) {
        vector<ListSmartVoiceGroupsResponseBodyVoiceGroupsVoiceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VoiceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSmartVoiceGroupsResponseBodyVoiceGroupsVoiceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        voiceList = make_shared<vector<ListSmartVoiceGroupsResponseBodyVoiceGroupsVoiceList>>(expect1);
      }
    }
  }


  virtual ~ListSmartVoiceGroupsResponseBodyVoiceGroups() = default;
};
class ListSmartVoiceGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSmartVoiceGroupsResponseBodyVoiceGroups>> voiceGroups{};

  ListSmartVoiceGroupsResponseBody() {}

  explicit ListSmartVoiceGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (voiceGroups) {
      vector<boost::any> temp1;
      for(auto item1:*voiceGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VoiceGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VoiceGroups") != m.end() && !m["VoiceGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["VoiceGroups"].type()) {
        vector<ListSmartVoiceGroupsResponseBodyVoiceGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VoiceGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSmartVoiceGroupsResponseBodyVoiceGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        voiceGroups = make_shared<vector<ListSmartVoiceGroupsResponseBodyVoiceGroups>>(expect1);
      }
    }
  }


  virtual ~ListSmartVoiceGroupsResponseBody() = default;
};
class ListSmartVoiceGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSmartVoiceGroupsResponseBody> body{};

  ListSmartVoiceGroupsResponse() {}

  explicit ListSmartVoiceGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSmartVoiceGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSmartVoiceGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSmartVoiceGroupsResponse() = default;
};
class ListSnapshotJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfCreateTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startOfCreateTime{};
  shared_ptr<string> status{};

  ListSnapshotJobsRequest() {}

  explicit ListSnapshotJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfCreateTime) {
      res["EndOfCreateTime"] = boost::any(*endOfCreateTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startOfCreateTime) {
      res["StartOfCreateTime"] = boost::any(*startOfCreateTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfCreateTime") != m.end() && !m["EndOfCreateTime"].empty()) {
      endOfCreateTime = make_shared<string>(boost::any_cast<string>(m["EndOfCreateTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartOfCreateTime") != m.end() && !m["StartOfCreateTime"].empty()) {
      startOfCreateTime = make_shared<string>(boost::any_cast<string>(m["StartOfCreateTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListSnapshotJobsRequest() = default;
};
class ListSnapshotJobsResponseBodyJobsInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListSnapshotJobsResponseBodyJobsInput() {}

  explicit ListSnapshotJobsResponseBodyJobsInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListSnapshotJobsResponseBodyJobsInput() = default;
};
class ListSnapshotJobsResponseBodyJobsOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListSnapshotJobsResponseBodyJobsOutput() {}

  explicit ListSnapshotJobsResponseBodyJobsOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListSnapshotJobsResponseBodyJobsOutput() = default;
};
class ListSnapshotJobsResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<long> count{};
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<ListSnapshotJobsResponseBodyJobsInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<ListSnapshotJobsResponseBodyJobsOutput> output{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> templateId{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> type{};

  ListSnapshotJobsResponseBodyJobs() {}

  explicit ListSnapshotJobsResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListSnapshotJobsResponseBodyJobsInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListSnapshotJobsResponseBodyJobsInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        ListSnapshotJobsResponseBodyJobsOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<ListSnapshotJobsResponseBodyJobsOutput>(model1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListSnapshotJobsResponseBodyJobs() = default;
};
class ListSnapshotJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListSnapshotJobsResponseBodyJobs>> jobs{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListSnapshotJobsResponseBody() {}

  explicit ListSnapshotJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Jobs"] = boost::any(temp1);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["Jobs"].type()) {
        vector<ListSnapshotJobsResponseBodyJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSnapshotJobsResponseBodyJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<ListSnapshotJobsResponseBodyJobs>>(expect1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListSnapshotJobsResponseBody() = default;
};
class ListSnapshotJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSnapshotJobsResponseBody> body{};

  ListSnapshotJobsResponse() {}

  explicit ListSnapshotJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSnapshotJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSnapshotJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSnapshotJobsResponse() = default;
};
class ListSourceLocationsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> filterState{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortByModifiedTime{};
  shared_ptr<string> sourceLocationName{};

  ListSourceLocationsRequest() {}

  explicit ListSourceLocationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterState) {
      res["FilterState"] = boost::any(*filterState);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortByModifiedTime) {
      res["SortByModifiedTime"] = boost::any(*sortByModifiedTime);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilterState") != m.end() && !m["FilterState"].empty()) {
      filterState = make_shared<bool>(boost::any_cast<bool>(m["FilterState"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortByModifiedTime") != m.end() && !m["SortByModifiedTime"].empty()) {
      sortByModifiedTime = make_shared<string>(boost::any_cast<string>(m["SortByModifiedTime"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
  }


  virtual ~ListSourceLocationsRequest() = default;
};
class ListSourceLocationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ChannelAssemblySourceLocation>> sourceLocationList{};
  shared_ptr<long> totalCount{};

  ListSourceLocationsResponseBody() {}

  explicit ListSourceLocationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceLocationList) {
      vector<boost::any> temp1;
      for(auto item1:*sourceLocationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceLocationList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceLocationList") != m.end() && !m["SourceLocationList"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceLocationList"].type()) {
        vector<ChannelAssemblySourceLocation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceLocationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ChannelAssemblySourceLocation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceLocationList = make_shared<vector<ChannelAssemblySourceLocation>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSourceLocationsResponseBody() = default;
};
class ListSourceLocationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSourceLocationsResponseBody> body{};

  ListSourceLocationsResponse() {}

  explicit ListSourceLocationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSourceLocationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSourceLocationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSourceLocationsResponse() = default;
};
class ListSourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> filterState{};
  shared_ptr<string> pageNo{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> sortByModifiedTime{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceType{};

  ListSourcesRequest() {}

  explicit ListSourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterState) {
      res["FilterState"] = boost::any(*filterState);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (sortByModifiedTime) {
      res["SortByModifiedTime"] = boost::any(*sortByModifiedTime);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilterState") != m.end() && !m["FilterState"].empty()) {
      filterState = make_shared<bool>(boost::any_cast<bool>(m["FilterState"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<string>(boost::any_cast<string>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SortByModifiedTime") != m.end() && !m["SortByModifiedTime"].empty()) {
      sortByModifiedTime = make_shared<string>(boost::any_cast<string>(m["SortByModifiedTime"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~ListSourcesRequest() = default;
};
class ListSourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ChannelAssemblySource>> sourceList{};
  shared_ptr<long> totalCount{};

  ListSourcesResponseBody() {}

  explicit ListSourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceList) {
      vector<boost::any> temp1;
      for(auto item1:*sourceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceList") != m.end() && !m["SourceList"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceList"].type()) {
        vector<ChannelAssemblySource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ChannelAssemblySource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceList = make_shared<vector<ChannelAssemblySource>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSourcesResponseBody() = default;
};
class ListSourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSourcesResponseBody> body{};

  ListSourcesResponse() {}

  explicit ListSourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSourcesResponse() = default;
};
class ListSystemTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};
  shared_ptr<string> subtype{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  ListSystemTemplatesRequest() {}

  explicit ListSystemTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<string>(boost::any_cast<string>(m["Subtype"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListSystemTemplatesRequest() = default;
};
class ListSystemTemplatesResponseBodySystemTemplateList : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> subtype{};
  shared_ptr<string> subtypeName{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> type{};
  shared_ptr<string> typeName_{};

  ListSystemTemplatesResponseBodySystemTemplateList() {}

  explicit ListSystemTemplatesResponseBodySystemTemplateList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subtype) {
      res["Subtype"] = boost::any(*subtype);
    }
    if (subtypeName) {
      res["SubtypeName"] = boost::any(*subtypeName);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Subtype") != m.end() && !m["Subtype"].empty()) {
      subtype = make_shared<long>(boost::any_cast<long>(m["Subtype"]));
    }
    if (m.find("SubtypeName") != m.end() && !m["SubtypeName"].empty()) {
      subtypeName = make_shared<string>(boost::any_cast<string>(m["SubtypeName"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~ListSystemTemplatesResponseBodySystemTemplateList() = default;
};
class ListSystemTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSystemTemplatesResponseBodySystemTemplateList>> systemTemplateList{};
  shared_ptr<long> total{};

  ListSystemTemplatesResponseBody() {}

  explicit ListSystemTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (systemTemplateList) {
      vector<boost::any> temp1;
      for(auto item1:*systemTemplateList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemTemplateList"] = boost::any(temp1);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SystemTemplateList") != m.end() && !m["SystemTemplateList"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemTemplateList"].type()) {
        vector<ListSystemTemplatesResponseBodySystemTemplateList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemTemplateList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSystemTemplatesResponseBodySystemTemplateList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemTemplateList = make_shared<vector<ListSystemTemplatesResponseBodySystemTemplateList>>(expect1);
      }
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSystemTemplatesResponseBody() = default;
};
class ListSystemTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSystemTemplatesResponseBody> body{};

  ListSystemTemplatesResponse() {}

  explicit ListSystemTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSystemTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSystemTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSystemTemplatesResponse() = default;
};
class ListTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> createSource{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortType{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  ListTemplatesRequest() {}

  explicit ListTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortType) {
      res["SortType"] = boost::any(*sortType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortType") != m.end() && !m["SortType"].empty()) {
      sortType = make_shared<string>(boost::any_cast<string>(m["SortType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListTemplatesRequest() = default;
};
class ListTemplatesResponseBodyTemplates : public Darabonba::Model {
public:
  shared_ptr<string> clipsParam{};
  shared_ptr<string> config{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createSource{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> modifiedSource{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> name{};
  shared_ptr<string> previewMedia{};
  shared_ptr<string> previewMediaStatus{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> type{};

  ListTemplatesResponseBodyTemplates() {}

  explicit ListTemplatesResponseBodyTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (modifiedSource) {
      res["ModifiedSource"] = boost::any(*modifiedSource);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (previewMedia) {
      res["PreviewMedia"] = boost::any(*previewMedia);
    }
    if (previewMediaStatus) {
      res["PreviewMediaStatus"] = boost::any(*previewMediaStatus);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("ModifiedSource") != m.end() && !m["ModifiedSource"].empty()) {
      modifiedSource = make_shared<string>(boost::any_cast<string>(m["ModifiedSource"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PreviewMedia") != m.end() && !m["PreviewMedia"].empty()) {
      previewMedia = make_shared<string>(boost::any_cast<string>(m["PreviewMedia"]));
    }
    if (m.find("PreviewMediaStatus") != m.end() && !m["PreviewMediaStatus"].empty()) {
      previewMediaStatus = make_shared<string>(boost::any_cast<string>(m["PreviewMediaStatus"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListTemplatesResponseBodyTemplates() = default;
};
class ListTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTemplatesResponseBodyTemplates>> templates{};
  shared_ptr<long> totalCount{};

  ListTemplatesResponseBody() {}

  explicit ListTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templates) {
      vector<boost::any> temp1;
      for(auto item1:*templates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Templates"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      if (typeid(vector<boost::any>) == m["Templates"].type()) {
        vector<ListTemplatesResponseBodyTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Templates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTemplatesResponseBodyTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templates = make_shared<vector<ListTemplatesResponseBodyTemplates>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTemplatesResponseBody() = default;
};
class ListTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTemplatesResponseBody> body{};

  ListTemplatesResponse() {}

  explicit ListTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTemplatesResponse() = default;
};
class ListTranscodeJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfCreateTime{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> parentJobId{};
  shared_ptr<string> startOfCreateTime{};
  shared_ptr<string> status{};

  ListTranscodeJobsRequest() {}

  explicit ListTranscodeJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfCreateTime) {
      res["EndOfCreateTime"] = boost::any(*endOfCreateTime);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentJobId) {
      res["ParentJobId"] = boost::any(*parentJobId);
    }
    if (startOfCreateTime) {
      res["StartOfCreateTime"] = boost::any(*startOfCreateTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfCreateTime") != m.end() && !m["EndOfCreateTime"].empty()) {
      endOfCreateTime = make_shared<string>(boost::any_cast<string>(m["EndOfCreateTime"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ParentJobId") != m.end() && !m["ParentJobId"].empty()) {
      parentJobId = make_shared<string>(boost::any_cast<string>(m["ParentJobId"]));
    }
    if (m.find("StartOfCreateTime") != m.end() && !m["StartOfCreateTime"].empty()) {
      startOfCreateTime = make_shared<string>(boost::any_cast<string>(m["StartOfCreateTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListTranscodeJobsRequest() = default;
};
class ListTranscodeJobsResponseBodyJobsInputGroup : public Darabonba::Model {
public:
  shared_ptr<string> inputUrl{};
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListTranscodeJobsResponseBodyJobsInputGroup() {}

  explicit ListTranscodeJobsResponseBodyJobsInputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputUrl) {
      res["InputUrl"] = boost::any(*inputUrl);
    }
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputUrl") != m.end() && !m["InputUrl"].empty()) {
      inputUrl = make_shared<string>(boost::any_cast<string>(m["InputUrl"]));
    }
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsInputGroup() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> outputUrl{};
  shared_ptr<string> type{};

  ListTranscodeJobsResponseBodyJobsOutputGroupOutput() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (outputUrl) {
      res["OutputUrl"] = boost::any(*outputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("OutputUrl") != m.end() && !m["OutputUrl"].empty()) {
      outputUrl = make_shared<string>(boost::any_cast<string>(m["OutputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupOutput() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigCombineConfigs : public Darabonba::Model {
public:
  shared_ptr<string> audioIndex{};
  shared_ptr<double> duration{};
  shared_ptr<double> start{};
  shared_ptr<string> videoIndex{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigCombineConfigs() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigCombineConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioIndex) {
      res["AudioIndex"] = boost::any(*audioIndex);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (videoIndex) {
      res["VideoIndex"] = boost::any(*videoIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioIndex") != m.end() && !m["AudioIndex"].empty()) {
      audioIndex = make_shared<string>(boost::any_cast<string>(m["AudioIndex"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<double>(boost::any_cast<double>(m["Start"]));
    }
    if (m.find("VideoIndex") != m.end() && !m["VideoIndex"].empty()) {
      videoIndex = make_shared<string>(boost::any_cast<string>(m["VideoIndex"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigCombineConfigs() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigEncryption : public Darabonba::Model {
public:
  shared_ptr<string> cipherText{};
  shared_ptr<string> decryptKeyUri{};
  shared_ptr<string> encryptType{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigEncryption() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cipherText) {
      res["CipherText"] = boost::any(*cipherText);
    }
    if (decryptKeyUri) {
      res["DecryptKeyUri"] = boost::any(*decryptKeyUri);
    }
    if (encryptType) {
      res["EncryptType"] = boost::any(*encryptType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CipherText") != m.end() && !m["CipherText"].empty()) {
      cipherText = make_shared<string>(boost::any_cast<string>(m["CipherText"]));
    }
    if (m.find("DecryptKeyUri") != m.end() && !m["DecryptKeyUri"].empty()) {
      decryptKeyUri = make_shared<string>(boost::any_cast<string>(m["DecryptKeyUri"]));
    }
    if (m.find("EncryptType") != m.end() && !m["EncryptType"].empty()) {
      encryptType = make_shared<string>(boost::any_cast<string>(m["EncryptType"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigEncryption() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile> file{};
  shared_ptr<string> height{};
  shared_ptr<string> referPos{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline> timeline{};
  shared_ptr<string> width{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks : public Darabonba::Model {
public:
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile> file{};
  shared_ptr<string> format{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles : public Darabonba::Model {
public:
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> adaptive{};
  shared_ptr<string> borderColor{};
  shared_ptr<long> borderWidth{};
  shared_ptr<string> content{};
  shared_ptr<string> fontAlpha{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<long> fontSize{};
  shared_ptr<string> left{};
  shared_ptr<string> top{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adaptive) {
      res["Adaptive"] = boost::any(*adaptive);
    }
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidth) {
      res["BorderWidth"] = boost::any(*borderWidth);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fontAlpha) {
      res["FontAlpha"] = boost::any(*fontAlpha);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSize) {
      res["FontSize"] = boost::any(*fontSize);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adaptive") != m.end() && !m["Adaptive"].empty()) {
      adaptive = make_shared<string>(boost::any_cast<string>(m["Adaptive"]));
    }
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidth") != m.end() && !m["BorderWidth"].empty()) {
      borderWidth = make_shared<long>(boost::any_cast<long>(m["BorderWidth"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FontAlpha") != m.end() && !m["FontAlpha"].empty()) {
      fontAlpha = make_shared<string>(boost::any_cast<string>(m["FontAlpha"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSize") != m.end() && !m["FontSize"].empty()) {
      fontSize = make_shared<long>(boost::any_cast<long>(m["FontSize"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks : public Darabonba::Model {
public:
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> integratedLoudnessTarget{};
  shared_ptr<string> loudnessRangeTarget{};
  shared_ptr<string> method{};
  shared_ptr<string> truePeak{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedLoudnessTarget) {
      res["IntegratedLoudnessTarget"] = boost::any(*integratedLoudnessTarget);
    }
    if (loudnessRangeTarget) {
      res["LoudnessRangeTarget"] = boost::any(*loudnessRangeTarget);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (truePeak) {
      res["TruePeak"] = boost::any(*truePeak);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedLoudnessTarget") != m.end() && !m["IntegratedLoudnessTarget"].empty()) {
      integratedLoudnessTarget = make_shared<string>(boost::any_cast<string>(m["IntegratedLoudnessTarget"]));
    }
    if (m.find("LoudnessRangeTarget") != m.end() && !m["LoudnessRangeTarget"].empty()) {
      loudnessRangeTarget = make_shared<string>(boost::any_cast<string>(m["LoudnessRangeTarget"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("TruePeak") != m.end() && !m["TruePeak"].empty()) {
      truePeak = make_shared<string>(boost::any_cast<string>(m["TruePeak"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume> volume{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume>(model1);
      }
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> forceSegTime{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (forceSegTime) {
      res["ForceSegTime"] = boost::any(*forceSegTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ForceSegTime") != m.end() && !m["ForceSegTime"].empty()) {
      forceSegTime = make_shared<string>(boost::any_cast<string>(m["ForceSegTime"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig : public Darabonba::Model {
public:
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment> segment{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo : public Darabonba::Model {
public:
  shared_ptr<string> abrMax{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abrMax) {
      res["AbrMax"] = boost::any(*abrMax);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbrMax") != m.end() && !m["AbrMax"].empty()) {
      abrMax = make_shared<string>(boost::any_cast<string>(m["AbrMax"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio> audio{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer> container{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig> muxConfig{};
  shared_ptr<map<string, string>> tags{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo> video{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Tags"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo>(model1);
      }
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode : public Darabonba::Model {
public:
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig : public Darabonba::Model {
public:
  shared_ptr<vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigCombineConfigs>> combineConfigs{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigEncryption> encryption{};
  shared_ptr<vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks>> imageWatermarks{};
  shared_ptr<bool> isInheritTags{};
  shared_ptr<vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles>> subtitles{};
  shared_ptr<vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks>> textWatermarks{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode> transcode{};

  ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (combineConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*combineConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CombineConfigs"] = boost::any(temp1);
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*imageWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageWatermarks"] = boost::any(temp1);
    }
    if (isInheritTags) {
      res["IsInheritTags"] = boost::any(*isInheritTags);
    }
    if (subtitles) {
      vector<boost::any> temp1;
      for(auto item1:*subtitles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitles"] = boost::any(temp1);
    }
    if (textWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*textWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextWatermarks"] = boost::any(temp1);
    }
    if (transcode) {
      res["Transcode"] = transcode ? boost::any(transcode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CombineConfigs") != m.end() && !m["CombineConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["CombineConfigs"].type()) {
        vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigCombineConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CombineConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigCombineConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        combineConfigs = make_shared<vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigCombineConfigs>>(expect1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigEncryption>(model1);
      }
    }
    if (m.find("ImageWatermarks") != m.end() && !m["ImageWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageWatermarks"].type()) {
        vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageWatermarks = make_shared<vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks>>(expect1);
      }
    }
    if (m.find("IsInheritTags") != m.end() && !m["IsInheritTags"].empty()) {
      isInheritTags = make_shared<bool>(boost::any_cast<bool>(m["IsInheritTags"]));
    }
    if (m.find("Subtitles") != m.end() && !m["Subtitles"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitles"].type()) {
        vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitles = make_shared<vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles>>(expect1);
      }
    }
    if (m.find("TextWatermarks") != m.end() && !m["TextWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["TextWatermarks"].type()) {
        vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textWatermarks = make_shared<vector<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks>>(expect1);
      }
    }
    if (m.find("Transcode") != m.end() && !m["Transcode"].empty()) {
      if (typeid(map<string, boost::any>) == m["Transcode"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Transcode"]));
        transcode = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode>(model1);
      }
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig() = default;
};
class ListTranscodeJobsResponseBodyJobsOutputGroup : public Darabonba::Model {
public:
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupOutput> output{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig> processConfig{};

  ListTranscodeJobsResponseBodyJobsOutputGroup() {}

  explicit ListTranscodeJobsResponseBodyJobsOutputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (processConfig) {
      res["ProcessConfig"] = processConfig ? boost::any(processConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupOutput>(model1);
      }
    }
    if (m.find("ProcessConfig") != m.end() && !m["ProcessConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProcessConfig"].type()) {
        ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProcessConfig"]));
        processConfig = make_shared<ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig>(model1);
      }
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsOutputGroup() = default;
};
class ListTranscodeJobsResponseBodyJobsScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  ListTranscodeJobsResponseBodyJobsScheduleConfig() {}

  explicit ListTranscodeJobsResponseBodyJobsScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobsScheduleConfig() = default;
};
class ListTranscodeJobsResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<vector<ListTranscodeJobsResponseBodyJobsInputGroup>> inputGroup{};
  shared_ptr<long> jobCount{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListTranscodeJobsResponseBodyJobsOutputGroup>> outputGroup{};
  shared_ptr<string> parentJobId{};
  shared_ptr<long> percent{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTranscodeJobsResponseBodyJobsScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  ListTranscodeJobsResponseBodyJobs() {}

  explicit ListTranscodeJobsResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (inputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*inputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputGroup"] = boost::any(temp1);
    }
    if (jobCount) {
      res["JobCount"] = boost::any(*jobCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroup"] = boost::any(temp1);
    }
    if (parentJobId) {
      res["ParentJobId"] = boost::any(*parentJobId);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("InputGroup") != m.end() && !m["InputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["InputGroup"].type()) {
        vector<ListTranscodeJobsResponseBodyJobsInputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTranscodeJobsResponseBodyJobsInputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputGroup = make_shared<vector<ListTranscodeJobsResponseBodyJobsInputGroup>>(expect1);
      }
    }
    if (m.find("JobCount") != m.end() && !m["JobCount"].empty()) {
      jobCount = make_shared<long>(boost::any_cast<long>(m["JobCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputGroup") != m.end() && !m["OutputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroup"].type()) {
        vector<ListTranscodeJobsResponseBodyJobsOutputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTranscodeJobsResponseBodyJobsOutputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroup = make_shared<vector<ListTranscodeJobsResponseBodyJobsOutputGroup>>(expect1);
      }
    }
    if (m.find("ParentJobId") != m.end() && !m["ParentJobId"].empty()) {
      parentJobId = make_shared<string>(boost::any_cast<string>(m["ParentJobId"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        ListTranscodeJobsResponseBodyJobsScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<ListTranscodeJobsResponseBodyJobsScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBodyJobs() = default;
};
class ListTranscodeJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListTranscodeJobsResponseBodyJobs>> jobs{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> requestId{};

  ListTranscodeJobsResponseBody() {}

  explicit ListTranscodeJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobs) {
      vector<boost::any> temp1;
      for(auto item1:*jobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Jobs"] = boost::any(temp1);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(vector<boost::any>) == m["Jobs"].type()) {
        vector<ListTranscodeJobsResponseBodyJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Jobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTranscodeJobsResponseBodyJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobs = make_shared<vector<ListTranscodeJobsResponseBodyJobs>>(expect1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListTranscodeJobsResponseBody() = default;
};
class ListTranscodeJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTranscodeJobsResponseBody> body{};

  ListTranscodeJobsResponse() {}

  explicit ListTranscodeJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTranscodeJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTranscodeJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTranscodeJobsResponse() = default;
};
class ListVodPackagingAssetsRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};

  ListVodPackagingAssetsRequest() {}

  explicit ListVodPackagingAssetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~ListVodPackagingAssetsRequest() = default;
};
class ListVodPackagingAssetsResponseBodyAssetsInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  ListVodPackagingAssetsResponseBodyAssetsInput() {}

  explicit ListVodPackagingAssetsResponseBodyAssetsInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListVodPackagingAssetsResponseBodyAssetsInput() = default;
};
class ListVodPackagingAssetsResponseBodyAssets : public Darabonba::Model {
public:
  shared_ptr<string> assetName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<ListVodPackagingAssetsResponseBodyAssetsInput> input{};

  ListVodPackagingAssetsResponseBodyAssets() {}

  explicit ListVodPackagingAssetsResponseBodyAssets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetName) {
      res["AssetName"] = boost::any(*assetName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetName") != m.end() && !m["AssetName"].empty()) {
      assetName = make_shared<string>(boost::any_cast<string>(m["AssetName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        ListVodPackagingAssetsResponseBodyAssetsInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<ListVodPackagingAssetsResponseBodyAssetsInput>(model1);
      }
    }
  }


  virtual ~ListVodPackagingAssetsResponseBodyAssets() = default;
};
class ListVodPackagingAssetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListVodPackagingAssetsResponseBodyAssets>> assets{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> totalCount{};

  ListVodPackagingAssetsResponseBody() {}

  explicit ListVodPackagingAssetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assets) {
      vector<boost::any> temp1;
      for(auto item1:*assets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Assets"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Assets") != m.end() && !m["Assets"].empty()) {
      if (typeid(vector<boost::any>) == m["Assets"].type()) {
        vector<ListVodPackagingAssetsResponseBodyAssets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Assets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVodPackagingAssetsResponseBodyAssets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        assets = make_shared<vector<ListVodPackagingAssetsResponseBodyAssets>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListVodPackagingAssetsResponseBody() = default;
};
class ListVodPackagingAssetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListVodPackagingAssetsResponseBody> body{};

  ListVodPackagingAssetsResponse() {}

  explicit ListVodPackagingAssetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVodPackagingAssetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVodPackagingAssetsResponseBody>(model1);
      }
    }
  }


  virtual ~ListVodPackagingAssetsResponse() = default;
};
class ListVodPackagingConfigurationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};

  ListVodPackagingConfigurationsRequest() {}

  explicit ListVodPackagingConfigurationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~ListVodPackagingConfigurationsRequest() = default;
};
class ListVodPackagingConfigurationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<VodPackagingConfiguration>> packagingConfigurations{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> totalCount{};

  ListVodPackagingConfigurationsResponseBody() {}

  explicit ListVodPackagingConfigurationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packagingConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*packagingConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PackagingConfigurations"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackagingConfigurations") != m.end() && !m["PackagingConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["PackagingConfigurations"].type()) {
        vector<VodPackagingConfiguration> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PackagingConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            VodPackagingConfiguration model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        packagingConfigurations = make_shared<vector<VodPackagingConfiguration>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListVodPackagingConfigurationsResponseBody() = default;
};
class ListVodPackagingConfigurationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListVodPackagingConfigurationsResponseBody> body{};

  ListVodPackagingConfigurationsResponse() {}

  explicit ListVodPackagingConfigurationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVodPackagingConfigurationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVodPackagingConfigurationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListVodPackagingConfigurationsResponse() = default;
};
class ListVodPackagingGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};

  ListVodPackagingGroupsRequest() {}

  explicit ListVodPackagingGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~ListVodPackagingGroupsRequest() = default;
};
class ListVodPackagingGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<VodPackagingGroup>> packagingGroups{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sortBy{};
  shared_ptr<long> totalCount{};

  ListVodPackagingGroupsResponseBody() {}

  explicit ListVodPackagingGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packagingGroups) {
      vector<boost::any> temp1;
      for(auto item1:*packagingGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PackagingGroups"] = boost::any(temp1);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackagingGroups") != m.end() && !m["PackagingGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["PackagingGroups"].type()) {
        vector<VodPackagingGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PackagingGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            VodPackagingGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        packagingGroups = make_shared<vector<VodPackagingGroup>>(expect1);
      }
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListVodPackagingGroupsResponseBody() = default;
};
class ListVodPackagingGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListVodPackagingGroupsResponseBody> body{};

  ListVodPackagingGroupsResponse() {}

  explicit ListVodPackagingGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVodPackagingGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVodPackagingGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListVodPackagingGroupsResponse() = default;
};
class QueryCopyrightExtractJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  QueryCopyrightExtractJobRequest() {}

  explicit QueryCopyrightExtractJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryCopyrightExtractJobRequest() = default;
};
class QueryCopyrightExtractJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};

  QueryCopyrightExtractJobResponseBodyData() {}

  explicit QueryCopyrightExtractJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~QueryCopyrightExtractJobResponseBodyData() = default;
};
class QueryCopyrightExtractJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryCopyrightExtractJobResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> statusCode{};

  QueryCopyrightExtractJobResponseBody() {}

  explicit QueryCopyrightExtractJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryCopyrightExtractJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryCopyrightExtractJobResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["StatusCode"]));
    }
  }


  virtual ~QueryCopyrightExtractJobResponseBody() = default;
};
class QueryCopyrightExtractJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCopyrightExtractJobResponseBody> body{};

  QueryCopyrightExtractJobResponse() {}

  explicit QueryCopyrightExtractJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCopyrightExtractJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCopyrightExtractJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCopyrightExtractJobResponse() = default;
};
class QueryCopyrightJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> createTimeEnd{};
  shared_ptr<long> createTimeStart{};
  shared_ptr<string> jobId{};
  shared_ptr<long> level{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  QueryCopyrightJobListRequest() {}

  explicit QueryCopyrightJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimeEnd) {
      res["CreateTimeEnd"] = boost::any(*createTimeEnd);
    }
    if (createTimeStart) {
      res["CreateTimeStart"] = boost::any(*createTimeStart);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimeEnd") != m.end() && !m["CreateTimeEnd"].empty()) {
      createTimeEnd = make_shared<long>(boost::any_cast<long>(m["CreateTimeEnd"]));
    }
    if (m.find("CreateTimeStart") != m.end() && !m["CreateTimeStart"].empty()) {
      createTimeStart = make_shared<long>(boost::any_cast<long>(m["CreateTimeStart"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryCopyrightJobListRequest() = default;
};
class QueryCopyrightJobListResponseBodyDataInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  QueryCopyrightJobListResponseBodyDataInput() {}

  explicit QueryCopyrightJobListResponseBodyDataInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryCopyrightJobListResponseBodyDataInput() = default;
};
class QueryCopyrightJobListResponseBodyDataOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  QueryCopyrightJobListResponseBodyDataOutput() {}

  explicit QueryCopyrightJobListResponseBodyDataOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryCopyrightJobListResponseBodyDataOutput() = default;
};
class QueryCopyrightJobListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<QueryCopyrightJobListResponseBodyDataInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<long> level{};
  shared_ptr<string> message{};
  shared_ptr<QueryCopyrightJobListResponseBodyDataOutput> output{};
  shared_ptr<string> result{};
  shared_ptr<string> status{};
  shared_ptr<string> userData{};
  shared_ptr<long> userId{};

  QueryCopyrightJobListResponseBodyData() {}

  explicit QueryCopyrightJobListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryCopyrightJobListResponseBodyDataInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryCopyrightJobListResponseBodyDataInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        QueryCopyrightJobListResponseBodyDataOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<QueryCopyrightJobListResponseBodyDataOutput>(model1);
      }
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~QueryCopyrightJobListResponseBodyData() = default;
};
class QueryCopyrightJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryCopyrightJobListResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> statusCode{};

  QueryCopyrightJobListResponseBody() {}

  explicit QueryCopyrightJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryCopyrightJobListResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryCopyrightJobListResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryCopyrightJobListResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["StatusCode"]));
    }
  }


  virtual ~QueryCopyrightJobListResponseBody() = default;
};
class QueryCopyrightJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryCopyrightJobListResponseBody> body{};

  QueryCopyrightJobListResponse() {}

  explicit QueryCopyrightJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryCopyrightJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryCopyrightJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryCopyrightJobListResponse() = default;
};
class QueryDNAJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobIds{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryDNAJobListRequest() {}

  explicit QueryDNAJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryDNAJobListRequest() = default;
};
class QueryDNAJobListResponseBodyJobListInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  QueryDNAJobListResponseBodyJobListInput() {}

  explicit QueryDNAJobListResponseBodyJobListInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryDNAJobListResponseBodyJobListInput() = default;
};
class QueryDNAJobListResponseBodyJobList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> config{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> DBId{};
  shared_ptr<string> DNAResult{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> id{};
  shared_ptr<QueryDNAJobListResponseBodyJobListInput> input{};
  shared_ptr<string> message{};
  shared_ptr<string> primaryKey{};
  shared_ptr<string> status{};
  shared_ptr<string> userData{};

  QueryDNAJobListResponseBodyJobList() {}

  explicit QueryDNAJobListResponseBodyJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (DBId) {
      res["DBId"] = boost::any(*DBId);
    }
    if (DNAResult) {
      res["DNAResult"] = boost::any(*DNAResult);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DBId") != m.end() && !m["DBId"].empty()) {
      DBId = make_shared<string>(boost::any_cast<string>(m["DBId"]));
    }
    if (m.find("DNAResult") != m.end() && !m["DNAResult"].empty()) {
      DNAResult = make_shared<string>(boost::any_cast<string>(m["DNAResult"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryDNAJobListResponseBodyJobListInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryDNAJobListResponseBodyJobListInput>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QueryDNAJobListResponseBodyJobList() = default;
};
class QueryDNAJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryDNAJobListResponseBodyJobList>> jobList{};
  shared_ptr<string> requestId{};

  QueryDNAJobListResponseBody() {}

  explicit QueryDNAJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobList) {
      vector<boost::any> temp1;
      for(auto item1:*jobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JobList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobList") != m.end() && !m["JobList"].empty()) {
      if (typeid(vector<boost::any>) == m["JobList"].type()) {
        vector<QueryDNAJobListResponseBodyJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryDNAJobListResponseBodyJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jobList = make_shared<vector<QueryDNAJobListResponseBodyJobList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryDNAJobListResponseBody() = default;
};
class QueryDNAJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryDNAJobListResponseBody> body{};

  QueryDNAJobListResponse() {}

  explicit QueryDNAJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryDNAJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryDNAJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryDNAJobListResponse() = default;
};
class QueryIProductionJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> jobId{};

  QueryIProductionJobRequest() {}

  explicit QueryIProductionJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryIProductionJobRequest() = default;
};
class QueryIProductionJobResponseBodyInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  QueryIProductionJobResponseBodyInput() {}

  explicit QueryIProductionJobResponseBodyInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryIProductionJobResponseBodyInput() = default;
};
class QueryIProductionJobResponseBodyOutput : public Darabonba::Model {
public:
  shared_ptr<string> biz{};
  shared_ptr<string> media{};
  shared_ptr<string> outputUrl{};
  shared_ptr<string> type{};

  QueryIProductionJobResponseBodyOutput() {}

  explicit QueryIProductionJobResponseBodyOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (biz) {
      res["Biz"] = boost::any(*biz);
    }
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (outputUrl) {
      res["OutputUrl"] = boost::any(*outputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Biz") != m.end() && !m["Biz"].empty()) {
      biz = make_shared<string>(boost::any_cast<string>(m["Biz"]));
    }
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("OutputUrl") != m.end() && !m["OutputUrl"].empty()) {
      outputUrl = make_shared<string>(boost::any_cast<string>(m["OutputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryIProductionJobResponseBodyOutput() = default;
};
class QueryIProductionJobResponseBodyScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  QueryIProductionJobResponseBodyScheduleConfig() {}

  explicit QueryIProductionJobResponseBodyScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~QueryIProductionJobResponseBodyScheduleConfig() = default;
};
class QueryIProductionJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> functionName{};
  shared_ptr<QueryIProductionJobResponseBodyInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> name{};
  shared_ptr<QueryIProductionJobResponseBodyOutput> output{};
  shared_ptr<vector<string>> outputFiles{};
  shared_ptr<vector<string>> outputMediaIds{};
  shared_ptr<vector<string>> outputUrls{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<QueryIProductionJobResponseBodyScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};
  shared_ptr<string> userData{};

  QueryIProductionJobResponseBody() {}

  explicit QueryIProductionJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outputFiles) {
      res["OutputFiles"] = boost::any(*outputFiles);
    }
    if (outputMediaIds) {
      res["OutputMediaIds"] = boost::any(*outputMediaIds);
    }
    if (outputUrls) {
      res["OutputUrls"] = boost::any(*outputUrls);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryIProductionJobResponseBodyInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryIProductionJobResponseBodyInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        QueryIProductionJobResponseBodyOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<QueryIProductionJobResponseBodyOutput>(model1);
      }
    }
    if (m.find("OutputFiles") != m.end() && !m["OutputFiles"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OutputFiles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OutputFiles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      outputFiles = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OutputMediaIds") != m.end() && !m["OutputMediaIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OutputMediaIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OutputMediaIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      outputMediaIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OutputUrls") != m.end() && !m["OutputUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OutputUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OutputUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      outputUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        QueryIProductionJobResponseBodyScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<QueryIProductionJobResponseBodyScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QueryIProductionJobResponseBody() = default;
};
class QueryIProductionJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryIProductionJobResponseBody> body{};

  QueryIProductionJobResponse() {}

  explicit QueryIProductionJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryIProductionJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryIProductionJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryIProductionJobResponse() = default;
};
class QueryMediaCensorJobDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  QueryMediaCensorJobDetailRequest() {}

  explicit QueryMediaCensorJobDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailRequest() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult>> result{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults> results{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (results) {
      res["Results"] = results ? boost::any(results->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(map<string, boost::any>) == m["Results"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Results"]));
        results = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult>> coverImageCensorResult{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverImageCensorResult) {
      vector<boost::any> temp1;
      for(auto item1:*coverImageCensorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CoverImageCensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverImageCensorResult") != m.end() && !m["CoverImageCensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CoverImageCensorResult"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CoverImageCensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coverImageCensorResult = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult>> censorResult{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResult) {
      vector<boost::any> temp1;
      for(auto item1:*censorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResult") != m.end() && !m["CensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CensorResult"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        censorResult = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult>> censorResult{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResult) {
      vector<boost::any> temp1;
      for(auto item1:*censorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResult") != m.end() && !m["CensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CensorResult"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        censorResult = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults> censorResults{};
  shared_ptr<string> object{};
  shared_ptr<string> timestamp{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResults) {
      res["CensorResults"] = censorResults ? boost::any(censorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResults") != m.end() && !m["CensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorResults"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorResults"]));
        censorResults = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults>(model1);
      }
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline>> videoTimeline{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoTimeline) {
      vector<boost::any> temp1;
      for(auto item1:*videoTimeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoTimeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoTimeline") != m.end() && !m["VideoTimeline"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoTimeline"].type()) {
        vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoTimeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoTimeline = make_shared<vector<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults> censorResults{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines> videoTimelines{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResults) {
      res["CensorResults"] = censorResults ? boost::any(censorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (videoTimelines) {
      res["VideoTimelines"] = videoTimelines ? boost::any(videoTimelines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResults") != m.end() && !m["CensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorResults"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorResults"]));
        censorResults = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("VideoTimelines") != m.end() && !m["VideoTimelines"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoTimelines"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoTimelines"]));
        videoTimelines = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile> outputFile{};
  shared_ptr<string> videoCensor{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCensor) {
      res["VideoCensor"] = boost::any(*videoCensor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile>(model1);
      }
    }
    if (m.find("VideoCensor") != m.end() && !m["VideoCensor"].empty()) {
      videoCensor = make_shared<string>(boost::any_cast<string>(m["VideoCensor"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig() = default;
};
class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult> barrageCensorResult{};
  shared_ptr<string> code{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults> coverImageCensorResults{};
  shared_ptr<string> creationTime{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult> descCensorResult{};
  shared_ptr<string> finishTime{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> state{};
  shared_ptr<string> suggestion{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult> titleCensorResult{};
  shared_ptr<string> userData{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult> vensorCensorResult{};
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig> videoCensorConfig{};

  QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail() {}

  explicit QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (barrageCensorResult) {
      res["BarrageCensorResult"] = barrageCensorResult ? boost::any(barrageCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (coverImageCensorResults) {
      res["CoverImageCensorResults"] = coverImageCensorResults ? boost::any(coverImageCensorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (descCensorResult) {
      res["DescCensorResult"] = descCensorResult ? boost::any(descCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (titleCensorResult) {
      res["TitleCensorResult"] = titleCensorResult ? boost::any(titleCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (vensorCensorResult) {
      res["VensorCensorResult"] = vensorCensorResult ? boost::any(vensorCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCensorConfig) {
      res["VideoCensorConfig"] = videoCensorConfig ? boost::any(videoCensorConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BarrageCensorResult") != m.end() && !m["BarrageCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["BarrageCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BarrageCensorResult"]));
        barrageCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CoverImageCensorResults") != m.end() && !m["CoverImageCensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CoverImageCensorResults"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CoverImageCensorResults"]));
        coverImageCensorResults = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DescCensorResult") != m.end() && !m["DescCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["DescCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DescCensorResult"]));
        descCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult>(model1);
      }
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TitleCensorResult") != m.end() && !m["TitleCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TitleCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TitleCensorResult"]));
        titleCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VensorCensorResult") != m.end() && !m["VensorCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VensorCensorResult"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VensorCensorResult"]));
        vensorCensorResult = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult>(model1);
      }
    }
    if (m.find("VideoCensorConfig") != m.end() && !m["VideoCensorConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoCensorConfig"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoCensorConfig"]));
        videoCensorConfig = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail() = default;
};
class QueryMediaCensorJobDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail> mediaCensorJobDetail{};
  shared_ptr<string> requestId{};

  QueryMediaCensorJobDetailResponseBody() {}

  explicit QueryMediaCensorJobDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaCensorJobDetail) {
      res["MediaCensorJobDetail"] = mediaCensorJobDetail ? boost::any(mediaCensorJobDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaCensorJobDetail") != m.end() && !m["MediaCensorJobDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaCensorJobDetail"].type()) {
        QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaCensorJobDetail"]));
        mediaCensorJobDetail = make_shared<QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaCensorJobDetailResponseBody() = default;
};
class QueryMediaCensorJobDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaCensorJobDetailResponseBody> body{};

  QueryMediaCensorJobDetailResponse() {}

  explicit QueryMediaCensorJobDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaCensorJobDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaCensorJobDetailResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobDetailResponse() = default;
};
class QueryMediaCensorJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> endOfJobCreatedTimeRange{};
  shared_ptr<string> jobIds{};
  shared_ptr<long> maximumPageSize{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> startOfJobCreatedTimeRange{};
  shared_ptr<string> state{};

  QueryMediaCensorJobListRequest() {}

  explicit QueryMediaCensorJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endOfJobCreatedTimeRange) {
      res["EndOfJobCreatedTimeRange"] = boost::any(*endOfJobCreatedTimeRange);
    }
    if (jobIds) {
      res["JobIds"] = boost::any(*jobIds);
    }
    if (maximumPageSize) {
      res["MaximumPageSize"] = boost::any(*maximumPageSize);
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (startOfJobCreatedTimeRange) {
      res["StartOfJobCreatedTimeRange"] = boost::any(*startOfJobCreatedTimeRange);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndOfJobCreatedTimeRange") != m.end() && !m["EndOfJobCreatedTimeRange"].empty()) {
      endOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["EndOfJobCreatedTimeRange"]));
    }
    if (m.find("JobIds") != m.end() && !m["JobIds"].empty()) {
      jobIds = make_shared<string>(boost::any_cast<string>(m["JobIds"]));
    }
    if (m.find("MaximumPageSize") != m.end() && !m["MaximumPageSize"].empty()) {
      maximumPageSize = make_shared<long>(boost::any_cast<long>(m["MaximumPageSize"]));
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("StartOfJobCreatedTimeRange") != m.end() && !m["StartOfJobCreatedTimeRange"].empty()) {
      startOfJobCreatedTimeRange = make_shared<string>(boost::any_cast<string>(m["StartOfJobCreatedTimeRange"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~QueryMediaCensorJobListRequest() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult>> result{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResultsResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults> results{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (results) {
      res["Results"] = results ? boost::any(results->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(map<string, boost::any>) == m["Results"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Results"]));
        results = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResultResults>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult>> coverImageCensorResult{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverImageCensorResult) {
      vector<boost::any> temp1;
      for(auto item1:*coverImageCensorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CoverImageCensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoverImageCensorResult") != m.end() && !m["CoverImageCensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CoverImageCensorResult"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CoverImageCensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coverImageCensorResult = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResultsCoverImageCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult>> censorResult{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResult) {
      vector<boost::any> temp1;
      for(auto item1:*censorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResult") != m.end() && !m["CensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CensorResult"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        censorResult = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResultsCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> rate{};
  shared_ptr<string> scene{};
  shared_ptr<string> suggestion{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<string>(boost::any_cast<string>(m["Rate"]));
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult>> censorResult{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResult) {
      vector<boost::any> temp1;
      for(auto item1:*censorResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CensorResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResult") != m.end() && !m["CensorResult"].empty()) {
      if (typeid(vector<boost::any>) == m["CensorResult"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CensorResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        censorResult = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults> censorResults{};
  shared_ptr<string> object{};
  shared_ptr<string> timestamp{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResults) {
      res["CensorResults"] = censorResults ? boost::any(censorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResults") != m.end() && !m["CensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorResults"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorResults"]));
        censorResults = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimelineCensorResults>(model1);
      }
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline>> videoTimeline{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (videoTimeline) {
      vector<boost::any> temp1;
      for(auto item1:*videoTimeline){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoTimeline"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VideoTimeline") != m.end() && !m["VideoTimeline"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoTimeline"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoTimeline"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoTimeline = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelinesVideoTimeline>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults> censorResults{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines> videoTimelines{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (censorResults) {
      res["CensorResults"] = censorResults ? boost::any(censorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (videoTimelines) {
      res["VideoTimelines"] = videoTimelines ? boost::any(videoTimelines->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CensorResults") != m.end() && !m["CensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CensorResults"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CensorResults"]));
        censorResults = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultCensorResults>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("VideoTimelines") != m.end() && !m["VideoTimelines"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoTimelines"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoTimelines"]));
        videoTimelines = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResultVideoTimelines>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> location{};
  shared_ptr<string> object{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (object) {
      res["Object"] = boost::any(*object);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Object") != m.end() && !m["Object"].empty()) {
      object = make_shared<string>(boost::any_cast<string>(m["Object"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile> outputFile{};
  shared_ptr<string> videoCensor{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (outputFile) {
      res["OutputFile"] = outputFile ? boost::any(outputFile->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCensor) {
      res["VideoCensor"] = boost::any(*videoCensor);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("OutputFile") != m.end() && !m["OutputFile"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputFile"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputFile"]));
        outputFile = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfigOutputFile>(model1);
      }
    }
    if (m.find("VideoCensor") != m.end() && !m["VideoCensor"].empty()) {
      videoCensor = make_shared<string>(boost::any_cast<string>(m["VideoCensor"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult> barrageCensorResult{};
  shared_ptr<string> code{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults> coverImageCensorResults{};
  shared_ptr<string> creationTime{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult> descCensorResult{};
  shared_ptr<string> finishTime{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> state{};
  shared_ptr<string> suggestion{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult> titleCensorResult{};
  shared_ptr<string> userData{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult> vensorCensorResult{};
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig> videoCensorConfig{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (barrageCensorResult) {
      res["BarrageCensorResult"] = barrageCensorResult ? boost::any(barrageCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (coverImageCensorResults) {
      res["CoverImageCensorResults"] = coverImageCensorResults ? boost::any(coverImageCensorResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (descCensorResult) {
      res["DescCensorResult"] = descCensorResult ? boost::any(descCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (titleCensorResult) {
      res["TitleCensorResult"] = titleCensorResult ? boost::any(titleCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (vensorCensorResult) {
      res["VensorCensorResult"] = vensorCensorResult ? boost::any(vensorCensorResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCensorConfig) {
      res["VideoCensorConfig"] = videoCensorConfig ? boost::any(videoCensorConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BarrageCensorResult") != m.end() && !m["BarrageCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["BarrageCensorResult"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BarrageCensorResult"]));
        barrageCensorResult = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobBarrageCensorResult>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CoverImageCensorResults") != m.end() && !m["CoverImageCensorResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["CoverImageCensorResults"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CoverImageCensorResults"]));
        coverImageCensorResults = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobCoverImageCensorResults>(model1);
      }
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("DescCensorResult") != m.end() && !m["DescCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["DescCensorResult"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DescCensorResult"]));
        descCensorResult = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobDescCensorResult>(model1);
      }
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("TitleCensorResult") != m.end() && !m["TitleCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TitleCensorResult"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TitleCensorResult"]));
        titleCensorResult = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobTitleCensorResult>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VensorCensorResult") != m.end() && !m["VensorCensorResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VensorCensorResult"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VensorCensorResult"]));
        vensorCensorResult = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVensorCensorResult>(model1);
      }
    }
    if (m.find("VideoCensorConfig") != m.end() && !m["VideoCensorConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoCensorConfig"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoCensorConfig"]));
        videoCensorConfig = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJobVideoCensorConfig>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob() = default;
};
class QueryMediaCensorJobListResponseBodyMediaCensorJobList : public Darabonba::Model {
public:
  shared_ptr<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob>> mediaCensorJob{};

  QueryMediaCensorJobListResponseBodyMediaCensorJobList() {}

  explicit QueryMediaCensorJobListResponseBodyMediaCensorJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaCensorJob) {
      vector<boost::any> temp1;
      for(auto item1:*mediaCensorJob){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaCensorJob"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaCensorJob") != m.end() && !m["MediaCensorJob"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaCensorJob"].type()) {
        vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaCensorJob"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaCensorJob = make_shared<vector<QueryMediaCensorJobListResponseBodyMediaCensorJobListMediaCensorJob>>(expect1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyMediaCensorJobList() = default;
};
class QueryMediaCensorJobListResponseBodyNonExistIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> string{};

  QueryMediaCensorJobListResponseBodyNonExistIds() {}

  explicit QueryMediaCensorJobListResponseBodyNonExistIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (string) {
      res["String"] = boost::any(*string);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("String") != m.end() && !m["String"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["String"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["String"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      string = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~QueryMediaCensorJobListResponseBodyNonExistIds() = default;
};
class QueryMediaCensorJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryMediaCensorJobListResponseBodyMediaCensorJobList> mediaCensorJobList{};
  shared_ptr<string> nextPageToken{};
  shared_ptr<QueryMediaCensorJobListResponseBodyNonExistIds> nonExistIds{};
  shared_ptr<string> requestId{};

  QueryMediaCensorJobListResponseBody() {}

  explicit QueryMediaCensorJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaCensorJobList) {
      res["MediaCensorJobList"] = mediaCensorJobList ? boost::any(mediaCensorJobList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nextPageToken) {
      res["NextPageToken"] = boost::any(*nextPageToken);
    }
    if (nonExistIds) {
      res["NonExistIds"] = nonExistIds ? boost::any(nonExistIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaCensorJobList") != m.end() && !m["MediaCensorJobList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaCensorJobList"].type()) {
        QueryMediaCensorJobListResponseBodyMediaCensorJobList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaCensorJobList"]));
        mediaCensorJobList = make_shared<QueryMediaCensorJobListResponseBodyMediaCensorJobList>(model1);
      }
    }
    if (m.find("NextPageToken") != m.end() && !m["NextPageToken"].empty()) {
      nextPageToken = make_shared<string>(boost::any_cast<string>(m["NextPageToken"]));
    }
    if (m.find("NonExistIds") != m.end() && !m["NonExistIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["NonExistIds"].type()) {
        QueryMediaCensorJobListResponseBodyNonExistIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NonExistIds"]));
        nonExistIds = make_shared<QueryMediaCensorJobListResponseBodyNonExistIds>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryMediaCensorJobListResponseBody() = default;
};
class QueryMediaCensorJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaCensorJobListResponseBody> body{};

  QueryMediaCensorJobListResponse() {}

  explicit QueryMediaCensorJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaCensorJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaCensorJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaCensorJobListResponse() = default;
};
class QueryMediaIndexJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> searchLibName{};

  QueryMediaIndexJobRequest() {}

  explicit QueryMediaIndexJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
  }


  virtual ~QueryMediaIndexJobRequest() = default;
};
class QueryMediaIndexJobResponseBodyIndexJobInfoList : public Darabonba::Model {
public:
  shared_ptr<string> gmtFinish{};
  shared_ptr<string> gmtSubmit{};
  shared_ptr<string> indexType{};
  shared_ptr<string> status{};

  QueryMediaIndexJobResponseBodyIndexJobInfoList() {}

  explicit QueryMediaIndexJobResponseBodyIndexJobInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtFinish) {
      res["GmtFinish"] = boost::any(*gmtFinish);
    }
    if (gmtSubmit) {
      res["GmtSubmit"] = boost::any(*gmtSubmit);
    }
    if (indexType) {
      res["IndexType"] = boost::any(*indexType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtFinish") != m.end() && !m["GmtFinish"].empty()) {
      gmtFinish = make_shared<string>(boost::any_cast<string>(m["GmtFinish"]));
    }
    if (m.find("GmtSubmit") != m.end() && !m["GmtSubmit"].empty()) {
      gmtSubmit = make_shared<string>(boost::any_cast<string>(m["GmtSubmit"]));
    }
    if (m.find("IndexType") != m.end() && !m["IndexType"].empty()) {
      indexType = make_shared<string>(boost::any_cast<string>(m["IndexType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~QueryMediaIndexJobResponseBodyIndexJobInfoList() = default;
};
class QueryMediaIndexJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<QueryMediaIndexJobResponseBodyIndexJobInfoList>> indexJobInfoList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  QueryMediaIndexJobResponseBody() {}

  explicit QueryMediaIndexJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (indexJobInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*indexJobInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IndexJobInfoList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("IndexJobInfoList") != m.end() && !m["IndexJobInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["IndexJobInfoList"].type()) {
        vector<QueryMediaIndexJobResponseBodyIndexJobInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IndexJobInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryMediaIndexJobResponseBodyIndexJobInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        indexJobInfoList = make_shared<vector<QueryMediaIndexJobResponseBodyIndexJobInfoList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~QueryMediaIndexJobResponseBody() = default;
};
class QueryMediaIndexJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMediaIndexJobResponseBody> body{};

  QueryMediaIndexJobResponse() {}

  explicit QueryMediaIndexJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMediaIndexJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMediaIndexJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMediaIndexJobResponse() = default;
};
class QuerySearchIndexRequest : public Darabonba::Model {
public:
  shared_ptr<string> indexType{};
  shared_ptr<string> searchLibName{};

  QuerySearchIndexRequest() {}

  explicit QuerySearchIndexRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (indexType) {
      res["IndexType"] = boost::any(*indexType);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IndexType") != m.end() && !m["IndexType"].empty()) {
      indexType = make_shared<string>(boost::any_cast<string>(m["IndexType"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
  }


  virtual ~QuerySearchIndexRequest() = default;
};
class QuerySearchIndexResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> indexStatus{};
  shared_ptr<string> indexType{};
  shared_ptr<string> mediaTotal{};
  shared_ptr<string> requestId{};
  shared_ptr<string> searchLibName{};
  shared_ptr<string> success{};

  QuerySearchIndexResponseBody() {}

  explicit QuerySearchIndexResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (indexStatus) {
      res["IndexStatus"] = boost::any(*indexStatus);
    }
    if (indexType) {
      res["IndexType"] = boost::any(*indexType);
    }
    if (mediaTotal) {
      res["MediaTotal"] = boost::any(*mediaTotal);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("IndexStatus") != m.end() && !m["IndexStatus"].empty()) {
      indexStatus = make_shared<string>(boost::any_cast<string>(m["IndexStatus"]));
    }
    if (m.find("IndexType") != m.end() && !m["IndexType"].empty()) {
      indexType = make_shared<string>(boost::any_cast<string>(m["IndexType"]));
    }
    if (m.find("MediaTotal") != m.end() && !m["MediaTotal"].empty()) {
      mediaTotal = make_shared<string>(boost::any_cast<string>(m["MediaTotal"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~QuerySearchIndexResponseBody() = default;
};
class QuerySearchIndexResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySearchIndexResponseBody> body{};

  QuerySearchIndexResponse() {}

  explicit QuerySearchIndexResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySearchIndexResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySearchIndexResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySearchIndexResponse() = default;
};
class QuerySearchLibRequest : public Darabonba::Model {
public:
  shared_ptr<string> searchLibName{};

  QuerySearchLibRequest() {}

  explicit QuerySearchLibRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
  }


  virtual ~QuerySearchLibRequest() = default;
};
class QuerySearchLibResponseBodyIndexInfo : public Darabonba::Model {
public:
  shared_ptr<string> indexReadiness{};
  shared_ptr<string> indexStatus{};
  shared_ptr<string> indexType{};

  QuerySearchLibResponseBodyIndexInfo() {}

  explicit QuerySearchLibResponseBodyIndexInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (indexReadiness) {
      res["IndexReadiness"] = boost::any(*indexReadiness);
    }
    if (indexStatus) {
      res["IndexStatus"] = boost::any(*indexStatus);
    }
    if (indexType) {
      res["IndexType"] = boost::any(*indexType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IndexReadiness") != m.end() && !m["IndexReadiness"].empty()) {
      indexReadiness = make_shared<string>(boost::any_cast<string>(m["IndexReadiness"]));
    }
    if (m.find("IndexStatus") != m.end() && !m["IndexStatus"].empty()) {
      indexStatus = make_shared<string>(boost::any_cast<string>(m["IndexStatus"]));
    }
    if (m.find("IndexType") != m.end() && !m["IndexType"].empty()) {
      indexType = make_shared<string>(boost::any_cast<string>(m["IndexType"]));
    }
  }


  virtual ~QuerySearchLibResponseBodyIndexInfo() = default;
};
class QuerySearchLibResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<QuerySearchLibResponseBodyIndexInfo>> indexInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<string> searchLibName{};
  shared_ptr<string> status{};
  shared_ptr<string> success{};

  QuerySearchLibResponseBody() {}

  explicit QuerySearchLibResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (indexInfo) {
      vector<boost::any> temp1;
      for(auto item1:*indexInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IndexInfo"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("IndexInfo") != m.end() && !m["IndexInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["IndexInfo"].type()) {
        vector<QuerySearchLibResponseBodyIndexInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IndexInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySearchLibResponseBodyIndexInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        indexInfo = make_shared<vector<QuerySearchLibResponseBodyIndexInfo>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~QuerySearchLibResponseBody() = default;
};
class QuerySearchLibResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySearchLibResponseBody> body{};

  QuerySearchLibResponse() {}

  explicit QuerySearchLibResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySearchLibResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySearchLibResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySearchLibResponse() = default;
};
class QuerySmarttagJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> params{};

  QuerySmarttagJobRequest() {}

  explicit QuerySmarttagJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
  }


  virtual ~QuerySmarttagJobRequest() = default;
};
class QuerySmarttagJobResponseBodyResultsResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> type{};

  QuerySmarttagJobResponseBodyResultsResult() {}

  explicit QuerySmarttagJobResponseBodyResultsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QuerySmarttagJobResponseBodyResultsResult() = default;
};
class QuerySmarttagJobResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<vector<QuerySmarttagJobResponseBodyResultsResult>> result{};

  QuerySmarttagJobResponseBodyResults() {}

  explicit QuerySmarttagJobResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<QuerySmarttagJobResponseBodyResultsResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QuerySmarttagJobResponseBodyResultsResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<QuerySmarttagJobResponseBodyResultsResult>>(expect1);
      }
    }
  }


  virtual ~QuerySmarttagJobResponseBodyResults() = default;
};
class QuerySmarttagJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<QuerySmarttagJobResponseBodyResults> results{};
  shared_ptr<string> userData{};

  QuerySmarttagJobResponseBody() {}

  explicit QuerySmarttagJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      res["Results"] = results ? boost::any(results->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(map<string, boost::any>) == m["Results"].type()) {
        QuerySmarttagJobResponseBodyResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Results"]));
        results = make_shared<QuerySmarttagJobResponseBodyResults>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~QuerySmarttagJobResponseBody() = default;
};
class QuerySmarttagJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySmarttagJobResponseBody> body{};

  QuerySmarttagJobResponse() {}

  explicit QuerySmarttagJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySmarttagJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySmarttagJobResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySmarttagJobResponse() = default;
};
class QueryTraceAbJobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> createTimeEnd{};
  shared_ptr<long> createTimeStart{};
  shared_ptr<string> jobId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> traceMediaId{};

  QueryTraceAbJobListRequest() {}

  explicit QueryTraceAbJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimeEnd) {
      res["CreateTimeEnd"] = boost::any(*createTimeEnd);
    }
    if (createTimeStart) {
      res["CreateTimeStart"] = boost::any(*createTimeStart);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (traceMediaId) {
      res["TraceMediaId"] = boost::any(*traceMediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimeEnd") != m.end() && !m["CreateTimeEnd"].empty()) {
      createTimeEnd = make_shared<long>(boost::any_cast<long>(m["CreateTimeEnd"]));
    }
    if (m.find("CreateTimeStart") != m.end() && !m["CreateTimeStart"].empty()) {
      createTimeStart = make_shared<long>(boost::any_cast<long>(m["CreateTimeStart"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TraceMediaId") != m.end() && !m["TraceMediaId"].empty()) {
      traceMediaId = make_shared<string>(boost::any_cast<string>(m["TraceMediaId"]));
    }
  }


  virtual ~QueryTraceAbJobListRequest() = default;
};
class QueryTraceAbJobListResponseBodyDataInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  QueryTraceAbJobListResponseBodyDataInput() {}

  explicit QueryTraceAbJobListResponseBodyDataInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryTraceAbJobListResponseBodyDataInput() = default;
};
class QueryTraceAbJobListResponseBodyDataOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  QueryTraceAbJobListResponseBodyDataOutput() {}

  explicit QueryTraceAbJobListResponseBodyDataOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryTraceAbJobListResponseBodyDataOutput() = default;
};
class QueryTraceAbJobListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<QueryTraceAbJobListResponseBodyDataInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<long> level{};
  shared_ptr<QueryTraceAbJobListResponseBodyDataOutput> output{};
  shared_ptr<string> result{};
  shared_ptr<string> status{};
  shared_ptr<string> traceMediaId{};
  shared_ptr<string> userData{};
  shared_ptr<long> userId{};

  QueryTraceAbJobListResponseBodyData() {}

  explicit QueryTraceAbJobListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (traceMediaId) {
      res["TraceMediaId"] = boost::any(*traceMediaId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        QueryTraceAbJobListResponseBodyDataInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<QueryTraceAbJobListResponseBodyDataInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        QueryTraceAbJobListResponseBodyDataOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<QueryTraceAbJobListResponseBodyDataOutput>(model1);
      }
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TraceMediaId") != m.end() && !m["TraceMediaId"].empty()) {
      traceMediaId = make_shared<string>(boost::any_cast<string>(m["TraceMediaId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~QueryTraceAbJobListResponseBodyData() = default;
};
class QueryTraceAbJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTraceAbJobListResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> statusCode{};

  QueryTraceAbJobListResponseBody() {}

  explicit QueryTraceAbJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryTraceAbJobListResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTraceAbJobListResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryTraceAbJobListResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["StatusCode"]));
    }
  }


  virtual ~QueryTraceAbJobListResponseBody() = default;
};
class QueryTraceAbJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTraceAbJobListResponseBody> body{};

  QueryTraceAbJobListResponse() {}

  explicit QueryTraceAbJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTraceAbJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTraceAbJobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTraceAbJobListResponse() = default;
};
class QueryTraceExtractJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  QueryTraceExtractJobRequest() {}

  explicit QueryTraceExtractJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~QueryTraceExtractJobRequest() = default;
};
class QueryTraceExtractJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> trace{};

  QueryTraceExtractJobResponseBodyData() {}

  explicit QueryTraceExtractJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trace) {
      res["Trace"] = boost::any(*trace);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Trace") != m.end() && !m["Trace"].empty()) {
      trace = make_shared<string>(boost::any_cast<string>(m["Trace"]));
    }
  }


  virtual ~QueryTraceExtractJobResponseBodyData() = default;
};
class QueryTraceExtractJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<QueryTraceExtractJobResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> statusCode{};

  QueryTraceExtractJobResponseBody() {}

  explicit QueryTraceExtractJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryTraceExtractJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryTraceExtractJobResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["StatusCode"]));
    }
  }


  virtual ~QueryTraceExtractJobResponseBody() = default;
};
class QueryTraceExtractJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTraceExtractJobResponseBody> body{};

  QueryTraceExtractJobResponse() {}

  explicit QueryTraceExtractJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTraceExtractJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTraceExtractJobResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTraceExtractJobResponse() = default;
};
class QueryTraceM3u8JobListRequest : public Darabonba::Model {
public:
  shared_ptr<long> createTimeEnd{};
  shared_ptr<long> createTimeStart{};
  shared_ptr<string> jobId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  QueryTraceM3u8JobListRequest() {}

  explicit QueryTraceM3u8JobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimeEnd) {
      res["CreateTimeEnd"] = boost::any(*createTimeEnd);
    }
    if (createTimeStart) {
      res["CreateTimeStart"] = boost::any(*createTimeStart);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimeEnd") != m.end() && !m["CreateTimeEnd"].empty()) {
      createTimeEnd = make_shared<long>(boost::any_cast<long>(m["CreateTimeEnd"]));
    }
    if (m.find("CreateTimeStart") != m.end() && !m["CreateTimeStart"].empty()) {
      createTimeStart = make_shared<long>(boost::any_cast<long>(m["CreateTimeStart"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~QueryTraceM3u8JobListRequest() = default;
};
class QueryTraceM3u8JobListResponseBodyDataOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  QueryTraceM3u8JobListResponseBodyDataOutput() {}

  explicit QueryTraceM3u8JobListResponseBodyDataOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~QueryTraceM3u8JobListResponseBodyDataOutput() = default;
};
class QueryTraceM3u8JobListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> jobId{};
  shared_ptr<QueryTraceM3u8JobListResponseBodyDataOutput> output{};
  shared_ptr<string> status{};
  shared_ptr<string> trace{};
  shared_ptr<string> traceMediaId{};
  shared_ptr<string> userData{};
  shared_ptr<long> userId{};

  QueryTraceM3u8JobListResponseBodyData() {}

  explicit QueryTraceM3u8JobListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (trace) {
      res["Trace"] = boost::any(*trace);
    }
    if (traceMediaId) {
      res["TraceMediaId"] = boost::any(*traceMediaId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        QueryTraceM3u8JobListResponseBodyDataOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<QueryTraceM3u8JobListResponseBodyDataOutput>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Trace") != m.end() && !m["Trace"].empty()) {
      trace = make_shared<string>(boost::any_cast<string>(m["Trace"]));
    }
    if (m.find("TraceMediaId") != m.end() && !m["TraceMediaId"].empty()) {
      traceMediaId = make_shared<string>(boost::any_cast<string>(m["TraceMediaId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~QueryTraceM3u8JobListResponseBodyData() = default;
};
class QueryTraceM3u8JobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<QueryTraceM3u8JobListResponseBodyData>> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> statusCode{};

  QueryTraceM3u8JobListResponseBody() {}

  explicit QueryTraceM3u8JobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<QueryTraceM3u8JobListResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryTraceM3u8JobListResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<QueryTraceM3u8JobListResponseBodyData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["StatusCode"]));
    }
  }


  virtual ~QueryTraceM3u8JobListResponseBody() = default;
};
class QueryTraceM3u8JobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTraceM3u8JobListResponseBody> body{};

  QueryTraceM3u8JobListResponse() {}

  explicit QueryTraceM3u8JobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTraceM3u8JobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTraceM3u8JobListResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTraceM3u8JobListResponse() = default;
};
class RefreshUploadMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};

  RefreshUploadMediaRequest() {}

  explicit RefreshUploadMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~RefreshUploadMediaRequest() = default;
};
class RefreshUploadMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> uploadAddress{};
  shared_ptr<string> uploadAuth{};

  RefreshUploadMediaResponseBody() {}

  explicit RefreshUploadMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadAddress) {
      res["UploadAddress"] = boost::any(*uploadAddress);
    }
    if (uploadAuth) {
      res["UploadAuth"] = boost::any(*uploadAuth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadAddress") != m.end() && !m["UploadAddress"].empty()) {
      uploadAddress = make_shared<string>(boost::any_cast<string>(m["UploadAddress"]));
    }
    if (m.find("UploadAuth") != m.end() && !m["UploadAuth"].empty()) {
      uploadAuth = make_shared<string>(boost::any_cast<string>(m["UploadAuth"]));
    }
  }


  virtual ~RefreshUploadMediaResponseBody() = default;
};
class RefreshUploadMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshUploadMediaResponseBody> body{};

  RefreshUploadMediaResponse() {}

  explicit RefreshUploadMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshUploadMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshUploadMediaResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshUploadMediaResponse() = default;
};
class RegisterMediaInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<long> cateId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<bool> overwrite{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> registerConfig{};
  shared_ptr<string> smartTagTemplateId{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};
  shared_ptr<string> workflowId{};

  RegisterMediaInfoRequest() {}

  explicit RegisterMediaInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (overwrite) {
      res["Overwrite"] = boost::any(*overwrite);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (registerConfig) {
      res["RegisterConfig"] = boost::any(*registerConfig);
    }
    if (smartTagTemplateId) {
      res["SmartTagTemplateId"] = boost::any(*smartTagTemplateId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("Overwrite") != m.end() && !m["Overwrite"].empty()) {
      overwrite = make_shared<bool>(boost::any_cast<bool>(m["Overwrite"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("RegisterConfig") != m.end() && !m["RegisterConfig"].empty()) {
      registerConfig = make_shared<string>(boost::any_cast<string>(m["RegisterConfig"]));
    }
    if (m.find("SmartTagTemplateId") != m.end() && !m["SmartTagTemplateId"].empty()) {
      smartTagTemplateId = make_shared<string>(boost::any_cast<string>(m["SmartTagTemplateId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<string>(boost::any_cast<string>(m["WorkflowId"]));
    }
  }


  virtual ~RegisterMediaInfoRequest() = default;
};
class RegisterMediaInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};

  RegisterMediaInfoResponseBody() {}

  explicit RegisterMediaInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RegisterMediaInfoResponseBody() = default;
};
class RegisterMediaInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegisterMediaInfoResponseBody> body{};

  RegisterMediaInfoResponse() {}

  explicit RegisterMediaInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterMediaInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterMediaInfoResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterMediaInfoResponse() = default;
};
class RegisterMediaStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> userData{};

  RegisterMediaStreamRequest() {}

  explicit RegisterMediaStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~RegisterMediaStreamRequest() = default;
};
class RegisterMediaStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};

  RegisterMediaStreamResponseBody() {}

  explicit RegisterMediaStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RegisterMediaStreamResponseBody() = default;
};
class RegisterMediaStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegisterMediaStreamResponseBody> body{};

  RegisterMediaStreamResponse() {}

  explicit RegisterMediaStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterMediaStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterMediaStreamResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterMediaStreamResponse() = default;
};
class SearchEditingProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> createSource{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectType{};
  shared_ptr<string> sortBy{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> templateType{};

  SearchEditingProjectRequest() {}

  explicit SearchEditingProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectType) {
      res["ProjectType"] = boost::any(*projectType);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectType") != m.end() && !m["ProjectType"].empty()) {
      projectType = make_shared<string>(boost::any_cast<string>(m["ProjectType"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~SearchEditingProjectRequest() = default;
};
class SearchEditingProjectResponseBodyProjectList : public Darabonba::Model {
public:
  shared_ptr<string> businessConfig{};
  shared_ptr<string> businessStatus{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createSource{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> duration{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> modifiedSource{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectType{};
  shared_ptr<string> status{};
  shared_ptr<string> templateType{};
  shared_ptr<string> timeline{};
  shared_ptr<string> title{};

  SearchEditingProjectResponseBodyProjectList() {}

  explicit SearchEditingProjectResponseBodyProjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessConfig) {
      res["BusinessConfig"] = boost::any(*businessConfig);
    }
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createSource) {
      res["CreateSource"] = boost::any(*createSource);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (modifiedSource) {
      res["ModifiedSource"] = boost::any(*modifiedSource);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectType) {
      res["ProjectType"] = boost::any(*projectType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessConfig") != m.end() && !m["BusinessConfig"].empty()) {
      businessConfig = make_shared<string>(boost::any_cast<string>(m["BusinessConfig"]));
    }
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateSource") != m.end() && !m["CreateSource"].empty()) {
      createSource = make_shared<string>(boost::any_cast<string>(m["CreateSource"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ModifiedSource") != m.end() && !m["ModifiedSource"].empty()) {
      modifiedSource = make_shared<string>(boost::any_cast<string>(m["ModifiedSource"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectType") != m.end() && !m["ProjectType"].empty()) {
      projectType = make_shared<string>(boost::any_cast<string>(m["ProjectType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~SearchEditingProjectResponseBodyProjectList() = default;
};
class SearchEditingProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<SearchEditingProjectResponseBodyProjectList>> projectList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  SearchEditingProjectResponseBody() {}

  explicit SearchEditingProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (projectList) {
      vector<boost::any> temp1;
      for(auto item1:*projectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ProjectList") != m.end() && !m["ProjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectList"].type()) {
        vector<SearchEditingProjectResponseBodyProjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchEditingProjectResponseBodyProjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectList = make_shared<vector<SearchEditingProjectResponseBodyProjectList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchEditingProjectResponseBody() = default;
};
class SearchEditingProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchEditingProjectResponseBody> body{};

  SearchEditingProjectResponse() {}

  explicit SearchEditingProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchEditingProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchEditingProjectResponseBody>(model1);
      }
    }
  }


  virtual ~SearchEditingProjectResponse() = default;
};
class SearchIndexJobRerunRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaIds{};
  shared_ptr<string> searchLibName{};
  shared_ptr<string> task{};

  SearchIndexJobRerunRequest() {}

  explicit SearchIndexJobRerunRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    if (task) {
      res["Task"] = boost::any(*task);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
    if (m.find("Task") != m.end() && !m["Task"].empty()) {
      task = make_shared<string>(boost::any_cast<string>(m["Task"]));
    }
  }


  virtual ~SearchIndexJobRerunRequest() = default;
};
class SearchIndexJobRerunResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> mediaIdsNoExist{};

  SearchIndexJobRerunResponseBodyData() {}

  explicit SearchIndexJobRerunResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaIdsNoExist) {
      res["MediaIdsNoExist"] = boost::any(*mediaIdsNoExist);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaIdsNoExist") != m.end() && !m["MediaIdsNoExist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MediaIdsNoExist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MediaIdsNoExist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mediaIdsNoExist = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SearchIndexJobRerunResponseBodyData() = default;
};
class SearchIndexJobRerunResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SearchIndexJobRerunResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  SearchIndexJobRerunResponseBody() {}

  explicit SearchIndexJobRerunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SearchIndexJobRerunResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SearchIndexJobRerunResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~SearchIndexJobRerunResponseBody() = default;
};
class SearchIndexJobRerunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchIndexJobRerunResponseBody> body{};

  SearchIndexJobRerunResponse() {}

  explicit SearchIndexJobRerunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchIndexJobRerunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchIndexJobRerunResponseBody>(model1);
      }
    }
  }


  virtual ~SearchIndexJobRerunResponse() = default;
};
class SearchMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<string> match{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scrollToken{};
  shared_ptr<string> searchLibName{};
  shared_ptr<string> sortBy{};

  SearchMediaRequest() {}

  explicit SearchMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (match) {
      res["Match"] = boost::any(*match);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scrollToken) {
      res["ScrollToken"] = boost::any(*scrollToken);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("Match") != m.end() && !m["Match"].empty()) {
      match = make_shared<string>(boost::any_cast<string>(m["Match"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScrollToken") != m.end() && !m["ScrollToken"].empty()) {
      scrollToken = make_shared<string>(boost::any_cast<string>(m["ScrollToken"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~SearchMediaRequest() = default;
};
class SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrencesTracks : public Darabonba::Model {
public:
  shared_ptr<string> position{};
  shared_ptr<double> size{};
  shared_ptr<double> timestamp{};

  SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrencesTracks() {}

  explicit SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrencesTracks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<string>(boost::any_cast<string>(m["Position"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<double>(boost::any_cast<double>(m["Size"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<double>(boost::any_cast<double>(m["Timestamp"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrencesTracks() = default;
};
class SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrences : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> finegrainId{};
  shared_ptr<string> finegrainName{};
  shared_ptr<double> from{};
  shared_ptr<string> image{};
  shared_ptr<double> score{};
  shared_ptr<string> tableBatchSeqId{};
  shared_ptr<double> to{};
  shared_ptr<vector<SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrencesTracks>> tracks{};
  shared_ptr<string> clipId{};

  SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrences() {}

  explicit SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrences(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (finegrainId) {
      res["FinegrainId"] = boost::any(*finegrainId);
    }
    if (finegrainName) {
      res["FinegrainName"] = boost::any(*finegrainName);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (tableBatchSeqId) {
      res["TableBatchSeqId"] = boost::any(*tableBatchSeqId);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (tracks) {
      vector<boost::any> temp1;
      for(auto item1:*tracks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tracks"] = boost::any(temp1);
    }
    if (clipId) {
      res["clipId"] = boost::any(*clipId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FinegrainId") != m.end() && !m["FinegrainId"].empty()) {
      finegrainId = make_shared<string>(boost::any_cast<string>(m["FinegrainId"]));
    }
    if (m.find("FinegrainName") != m.end() && !m["FinegrainName"].empty()) {
      finegrainName = make_shared<string>(boost::any_cast<string>(m["FinegrainName"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<double>(boost::any_cast<double>(m["From"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<double>(boost::any_cast<double>(m["Score"]));
    }
    if (m.find("TableBatchSeqId") != m.end() && !m["TableBatchSeqId"].empty()) {
      tableBatchSeqId = make_shared<string>(boost::any_cast<string>(m["TableBatchSeqId"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<double>(boost::any_cast<double>(m["To"]));
    }
    if (m.find("Tracks") != m.end() && !m["Tracks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tracks"].type()) {
        vector<SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrencesTracks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tracks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrencesTracks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tracks = make_shared<vector<SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrencesTracks>>(expect1);
      }
    }
    if (m.find("clipId") != m.end() && !m["clipId"].empty()) {
      clipId = make_shared<string>(boost::any_cast<string>(m["clipId"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrences() = default;
};
class SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfo : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> faceId{};
  shared_ptr<string> labelId{};
  shared_ptr<string> labelName{};
  shared_ptr<string> labelType{};
  shared_ptr<vector<SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrences>> occurrences{};
  shared_ptr<string> source{};

  SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfo() {}

  explicit SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (faceId) {
      res["FaceId"] = boost::any(*faceId);
    }
    if (labelId) {
      res["LabelId"] = boost::any(*labelId);
    }
    if (labelName) {
      res["LabelName"] = boost::any(*labelName);
    }
    if (labelType) {
      res["LabelType"] = boost::any(*labelType);
    }
    if (occurrences) {
      vector<boost::any> temp1;
      for(auto item1:*occurrences){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Occurrences"] = boost::any(temp1);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("FaceId") != m.end() && !m["FaceId"].empty()) {
      faceId = make_shared<string>(boost::any_cast<string>(m["FaceId"]));
    }
    if (m.find("LabelId") != m.end() && !m["LabelId"].empty()) {
      labelId = make_shared<string>(boost::any_cast<string>(m["LabelId"]));
    }
    if (m.find("LabelName") != m.end() && !m["LabelName"].empty()) {
      labelName = make_shared<string>(boost::any_cast<string>(m["LabelName"]));
    }
    if (m.find("LabelType") != m.end() && !m["LabelType"].empty()) {
      labelType = make_shared<string>(boost::any_cast<string>(m["LabelType"]));
    }
    if (m.find("Occurrences") != m.end() && !m["Occurrences"].empty()) {
      if (typeid(vector<boost::any>) == m["Occurrences"].type()) {
        vector<SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrences> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Occurrences"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrences model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        occurrences = make_shared<vector<SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfoOccurrences>>(expect1);
      }
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfo() = default;
};
class SearchMediaResponseBodyMediaInfoListAiDataAsrInfo : public Darabonba::Model {
public:
  shared_ptr<string> clipId{};
  shared_ptr<string> content{};
  shared_ptr<double> from{};
  shared_ptr<double> timestamp{};
  shared_ptr<double> to{};

  SearchMediaResponseBodyMediaInfoListAiDataAsrInfo() {}

  explicit SearchMediaResponseBodyMediaInfoListAiDataAsrInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipId) {
      res["ClipId"] = boost::any(*clipId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipId") != m.end() && !m["ClipId"].empty()) {
      clipId = make_shared<string>(boost::any_cast<string>(m["ClipId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<double>(boost::any_cast<double>(m["From"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<double>(boost::any_cast<double>(m["Timestamp"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<double>(boost::any_cast<double>(m["To"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaInfoListAiDataAsrInfo() = default;
};
class SearchMediaResponseBodyMediaInfoListAiDataOcrInfo : public Darabonba::Model {
public:
  shared_ptr<string> clipId{};
  shared_ptr<string> content{};
  shared_ptr<double> from{};
  shared_ptr<double> timestamp{};
  shared_ptr<double> to{};

  SearchMediaResponseBodyMediaInfoListAiDataOcrInfo() {}

  explicit SearchMediaResponseBodyMediaInfoListAiDataOcrInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipId) {
      res["ClipId"] = boost::any(*clipId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipId") != m.end() && !m["ClipId"].empty()) {
      clipId = make_shared<string>(boost::any_cast<string>(m["ClipId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<double>(boost::any_cast<double>(m["From"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<double>(boost::any_cast<double>(m["Timestamp"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<double>(boost::any_cast<double>(m["To"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaInfoListAiDataOcrInfo() = default;
};
class SearchMediaResponseBodyMediaInfoListAiData : public Darabonba::Model {
public:
  shared_ptr<vector<SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfo>> aiLabelInfo{};
  shared_ptr<vector<SearchMediaResponseBodyMediaInfoListAiDataAsrInfo>> asrInfo{};
  shared_ptr<vector<SearchMediaResponseBodyMediaInfoListAiDataOcrInfo>> ocrInfo{};

  SearchMediaResponseBodyMediaInfoListAiData() {}

  explicit SearchMediaResponseBodyMediaInfoListAiData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiLabelInfo) {
      vector<boost::any> temp1;
      for(auto item1:*aiLabelInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AiLabelInfo"] = boost::any(temp1);
    }
    if (asrInfo) {
      vector<boost::any> temp1;
      for(auto item1:*asrInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AsrInfo"] = boost::any(temp1);
    }
    if (ocrInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ocrInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OcrInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiLabelInfo") != m.end() && !m["AiLabelInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["AiLabelInfo"].type()) {
        vector<SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AiLabelInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aiLabelInfo = make_shared<vector<SearchMediaResponseBodyMediaInfoListAiDataAiLabelInfo>>(expect1);
      }
    }
    if (m.find("AsrInfo") != m.end() && !m["AsrInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["AsrInfo"].type()) {
        vector<SearchMediaResponseBodyMediaInfoListAiDataAsrInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AsrInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaResponseBodyMediaInfoListAiDataAsrInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        asrInfo = make_shared<vector<SearchMediaResponseBodyMediaInfoListAiDataAsrInfo>>(expect1);
      }
    }
    if (m.find("OcrInfo") != m.end() && !m["OcrInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["OcrInfo"].type()) {
        vector<SearchMediaResponseBodyMediaInfoListAiDataOcrInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OcrInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaResponseBodyMediaInfoListAiDataOcrInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ocrInfo = make_shared<vector<SearchMediaResponseBodyMediaInfoListAiDataOcrInfo>>(expect1);
      }
    }
  }


  virtual ~SearchMediaResponseBodyMediaInfoListAiData() = default;
};
class SearchMediaResponseBodyMediaInfoListAiRoughData : public Darabonba::Model {
public:
  shared_ptr<string> aiCategory{};
  shared_ptr<string> aiJobId{};
  shared_ptr<string> result{};
  shared_ptr<string> saveType{};
  shared_ptr<string> status{};

  SearchMediaResponseBodyMediaInfoListAiRoughData() {}

  explicit SearchMediaResponseBodyMediaInfoListAiRoughData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiCategory) {
      res["AiCategory"] = boost::any(*aiCategory);
    }
    if (aiJobId) {
      res["AiJobId"] = boost::any(*aiJobId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (saveType) {
      res["SaveType"] = boost::any(*saveType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiCategory") != m.end() && !m["AiCategory"].empty()) {
      aiCategory = make_shared<string>(boost::any_cast<string>(m["AiCategory"]));
    }
    if (m.find("AiJobId") != m.end() && !m["AiJobId"].empty()) {
      aiJobId = make_shared<string>(boost::any_cast<string>(m["AiJobId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("SaveType") != m.end() && !m["SaveType"].empty()) {
      saveType = make_shared<string>(boost::any_cast<string>(m["SaveType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaInfoListAiRoughData() = default;
};
class SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> createTime{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> imagesInput{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo() {}

  explicit SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (imagesInput) {
      res["ImagesInput"] = boost::any(*imagesInput);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ImagesInput") != m.end() && !m["ImagesInput"].empty()) {
      imagesInput = make_shared<string>(boost::any_cast<string>(m["ImagesInput"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo() = default;
};
class SearchMediaResponseBodyMediaInfoListFileInfoList : public Darabonba::Model {
public:
  shared_ptr<SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo> fileBasicInfo{};

  SearchMediaResponseBodyMediaInfoListFileInfoList() {}

  explicit SearchMediaResponseBodyMediaInfoListFileInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo>(model1);
      }
    }
  }


  virtual ~SearchMediaResponseBodyMediaInfoListFileInfoList() = default;
};
class SearchMediaResponseBodyMediaInfoListIndexStatusList : public Darabonba::Model {
public:
  shared_ptr<string> indexStatus{};
  shared_ptr<string> indexType{};

  SearchMediaResponseBodyMediaInfoListIndexStatusList() {}

  explicit SearchMediaResponseBodyMediaInfoListIndexStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (indexStatus) {
      res["IndexStatus"] = boost::any(*indexStatus);
    }
    if (indexType) {
      res["IndexType"] = boost::any(*indexType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IndexStatus") != m.end() && !m["IndexStatus"].empty()) {
      indexStatus = make_shared<string>(boost::any_cast<string>(m["IndexStatus"]));
    }
    if (m.find("IndexType") != m.end() && !m["IndexType"].empty()) {
      indexType = make_shared<string>(boost::any_cast<string>(m["IndexType"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaInfoListIndexStatusList() = default;
};
class SearchMediaResponseBodyMediaInfoListMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> biz{};
  shared_ptr<string> businessType{};
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> snapshots{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteImages{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> transcodeStatus{};
  shared_ptr<string> uploadSource{};
  shared_ptr<string> userData{};
  shared_ptr<string> visionDescription{};

  SearchMediaResponseBodyMediaInfoListMediaBasicInfo() {}

  explicit SearchMediaResponseBodyMediaInfoListMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (biz) {
      res["Biz"] = boost::any(*biz);
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteImages) {
      res["SpriteImages"] = boost::any(*spriteImages);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (transcodeStatus) {
      res["TranscodeStatus"] = boost::any(*transcodeStatus);
    }
    if (uploadSource) {
      res["UploadSource"] = boost::any(*uploadSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (visionDescription) {
      res["VisionDescription"] = boost::any(*visionDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Biz") != m.end() && !m["Biz"].empty()) {
      biz = make_shared<string>(boost::any_cast<string>(m["Biz"]));
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      snapshots = make_shared<string>(boost::any_cast<string>(m["Snapshots"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteImages") != m.end() && !m["SpriteImages"].empty()) {
      spriteImages = make_shared<string>(boost::any_cast<string>(m["SpriteImages"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TranscodeStatus") != m.end() && !m["TranscodeStatus"].empty()) {
      transcodeStatus = make_shared<string>(boost::any_cast<string>(m["TranscodeStatus"]));
    }
    if (m.find("UploadSource") != m.end() && !m["UploadSource"].empty()) {
      uploadSource = make_shared<string>(boost::any_cast<string>(m["UploadSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("VisionDescription") != m.end() && !m["VisionDescription"].empty()) {
      visionDescription = make_shared<string>(boost::any_cast<string>(m["VisionDescription"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaInfoListMediaBasicInfo() = default;
};
class SearchMediaResponseBodyMediaInfoList : public Darabonba::Model {
public:
  shared_ptr<SearchMediaResponseBodyMediaInfoListAiData> aiData{};
  shared_ptr<SearchMediaResponseBodyMediaInfoListAiRoughData> aiRoughData{};
  shared_ptr<vector<SearchMediaResponseBodyMediaInfoListFileInfoList>> fileInfoList{};
  shared_ptr<vector<SearchMediaResponseBodyMediaInfoListIndexStatusList>> indexStatusList{};
  shared_ptr<SearchMediaResponseBodyMediaInfoListMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  SearchMediaResponseBodyMediaInfoList() {}

  explicit SearchMediaResponseBodyMediaInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiData) {
      res["AiData"] = aiData ? boost::any(aiData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (aiRoughData) {
      res["AiRoughData"] = aiRoughData ? boost::any(aiRoughData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*fileInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileInfoList"] = boost::any(temp1);
    }
    if (indexStatusList) {
      vector<boost::any> temp1;
      for(auto item1:*indexStatusList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IndexStatusList"] = boost::any(temp1);
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiData") != m.end() && !m["AiData"].empty()) {
      if (typeid(map<string, boost::any>) == m["AiData"].type()) {
        SearchMediaResponseBodyMediaInfoListAiData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AiData"]));
        aiData = make_shared<SearchMediaResponseBodyMediaInfoListAiData>(model1);
      }
    }
    if (m.find("AiRoughData") != m.end() && !m["AiRoughData"].empty()) {
      if (typeid(map<string, boost::any>) == m["AiRoughData"].type()) {
        SearchMediaResponseBodyMediaInfoListAiRoughData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AiRoughData"]));
        aiRoughData = make_shared<SearchMediaResponseBodyMediaInfoListAiRoughData>(model1);
      }
    }
    if (m.find("FileInfoList") != m.end() && !m["FileInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileInfoList"].type()) {
        vector<SearchMediaResponseBodyMediaInfoListFileInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaResponseBodyMediaInfoListFileInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileInfoList = make_shared<vector<SearchMediaResponseBodyMediaInfoListFileInfoList>>(expect1);
      }
    }
    if (m.find("IndexStatusList") != m.end() && !m["IndexStatusList"].empty()) {
      if (typeid(vector<boost::any>) == m["IndexStatusList"].type()) {
        vector<SearchMediaResponseBodyMediaInfoListIndexStatusList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IndexStatusList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaResponseBodyMediaInfoListIndexStatusList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        indexStatusList = make_shared<vector<SearchMediaResponseBodyMediaInfoListIndexStatusList>>(expect1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        SearchMediaResponseBodyMediaInfoListMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<SearchMediaResponseBodyMediaInfoListMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~SearchMediaResponseBodyMediaInfoList() = default;
};
class SearchMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<SearchMediaResponseBodyMediaInfoList>> mediaInfoList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> scrollToken{};
  shared_ptr<string> success{};
  shared_ptr<long> total{};

  SearchMediaResponseBody() {}

  explicit SearchMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (mediaInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInfoList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scrollToken) {
      res["ScrollToken"] = boost::any(*scrollToken);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("MediaInfoList") != m.end() && !m["MediaInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInfoList"].type()) {
        vector<SearchMediaResponseBodyMediaInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaResponseBodyMediaInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInfoList = make_shared<vector<SearchMediaResponseBodyMediaInfoList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScrollToken") != m.end() && !m["ScrollToken"].empty()) {
      scrollToken = make_shared<string>(boost::any_cast<string>(m["ScrollToken"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~SearchMediaResponseBody() = default;
};
class SearchMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchMediaResponseBody> body{};

  SearchMediaResponse() {}

  explicit SearchMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchMediaResponseBody>(model1);
      }
    }
  }


  virtual ~SearchMediaResponse() = default;
};
class SearchMediaByAILabelRequest : public Darabonba::Model {
public:
  shared_ptr<string> matchingMode{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> multimodalSearchType{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchLibName{};
  shared_ptr<string> sortBy{};
  shared_ptr<bool> specificSearch{};
  shared_ptr<string> text{};

  SearchMediaByAILabelRequest() {}

  explicit SearchMediaByAILabelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (matchingMode) {
      res["MatchingMode"] = boost::any(*matchingMode);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (multimodalSearchType) {
      res["MultimodalSearchType"] = boost::any(*multimodalSearchType);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    if (specificSearch) {
      res["SpecificSearch"] = boost::any(*specificSearch);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MatchingMode") != m.end() && !m["MatchingMode"].empty()) {
      matchingMode = make_shared<string>(boost::any_cast<string>(m["MatchingMode"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("MultimodalSearchType") != m.end() && !m["MultimodalSearchType"].empty()) {
      multimodalSearchType = make_shared<string>(boost::any_cast<string>(m["MultimodalSearchType"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
    if (m.find("SpecificSearch") != m.end() && !m["SpecificSearch"].empty()) {
      specificSearch = make_shared<bool>(boost::any_cast<bool>(m["SpecificSearch"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~SearchMediaByAILabelRequest() = default;
};
class SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrencesTracks : public Darabonba::Model {
public:
  shared_ptr<string> position{};
  shared_ptr<double> size{};
  shared_ptr<double> timestamp{};

  SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrencesTracks() {}

  explicit SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrencesTracks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<string>(boost::any_cast<string>(m["Position"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<double>(boost::any_cast<double>(m["Size"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<double>(boost::any_cast<double>(m["Timestamp"]));
    }
  }


  virtual ~SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrencesTracks() = default;
};
class SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrences : public Darabonba::Model {
public:
  shared_ptr<string> clipId{};
  shared_ptr<string> content{};
  shared_ptr<string> finegrainId{};
  shared_ptr<string> finegrainName{};
  shared_ptr<double> from{};
  shared_ptr<string> image{};
  shared_ptr<double> score{};
  shared_ptr<string> tableBatchSeqId{};
  shared_ptr<double> to{};
  shared_ptr<vector<SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrencesTracks>> tracks{};

  SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrences() {}

  explicit SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrences(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipId) {
      res["ClipId"] = boost::any(*clipId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (finegrainId) {
      res["FinegrainId"] = boost::any(*finegrainId);
    }
    if (finegrainName) {
      res["FinegrainName"] = boost::any(*finegrainName);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (image) {
      res["Image"] = boost::any(*image);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (tableBatchSeqId) {
      res["TableBatchSeqId"] = boost::any(*tableBatchSeqId);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (tracks) {
      vector<boost::any> temp1;
      for(auto item1:*tracks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tracks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipId") != m.end() && !m["ClipId"].empty()) {
      clipId = make_shared<string>(boost::any_cast<string>(m["ClipId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FinegrainId") != m.end() && !m["FinegrainId"].empty()) {
      finegrainId = make_shared<string>(boost::any_cast<string>(m["FinegrainId"]));
    }
    if (m.find("FinegrainName") != m.end() && !m["FinegrainName"].empty()) {
      finegrainName = make_shared<string>(boost::any_cast<string>(m["FinegrainName"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<double>(boost::any_cast<double>(m["From"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      image = make_shared<string>(boost::any_cast<string>(m["Image"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<double>(boost::any_cast<double>(m["Score"]));
    }
    if (m.find("TableBatchSeqId") != m.end() && !m["TableBatchSeqId"].empty()) {
      tableBatchSeqId = make_shared<string>(boost::any_cast<string>(m["TableBatchSeqId"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<double>(boost::any_cast<double>(m["To"]));
    }
    if (m.find("Tracks") != m.end() && !m["Tracks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tracks"].type()) {
        vector<SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrencesTracks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tracks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrencesTracks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tracks = make_shared<vector<SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrencesTracks>>(expect1);
      }
    }
  }


  virtual ~SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrences() = default;
};
class SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfo : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> faceId{};
  shared_ptr<string> labelId{};
  shared_ptr<string> labelName{};
  shared_ptr<string> labelType{};
  shared_ptr<vector<SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrences>> occurrences{};
  shared_ptr<string> source{};

  SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfo() {}

  explicit SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (faceId) {
      res["FaceId"] = boost::any(*faceId);
    }
    if (labelId) {
      res["LabelId"] = boost::any(*labelId);
    }
    if (labelName) {
      res["LabelName"] = boost::any(*labelName);
    }
    if (labelType) {
      res["LabelType"] = boost::any(*labelType);
    }
    if (occurrences) {
      vector<boost::any> temp1;
      for(auto item1:*occurrences){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Occurrences"] = boost::any(temp1);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("FaceId") != m.end() && !m["FaceId"].empty()) {
      faceId = make_shared<string>(boost::any_cast<string>(m["FaceId"]));
    }
    if (m.find("LabelId") != m.end() && !m["LabelId"].empty()) {
      labelId = make_shared<string>(boost::any_cast<string>(m["LabelId"]));
    }
    if (m.find("LabelName") != m.end() && !m["LabelName"].empty()) {
      labelName = make_shared<string>(boost::any_cast<string>(m["LabelName"]));
    }
    if (m.find("LabelType") != m.end() && !m["LabelType"].empty()) {
      labelType = make_shared<string>(boost::any_cast<string>(m["LabelType"]));
    }
    if (m.find("Occurrences") != m.end() && !m["Occurrences"].empty()) {
      if (typeid(vector<boost::any>) == m["Occurrences"].type()) {
        vector<SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrences> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Occurrences"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrences model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        occurrences = make_shared<vector<SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfoOccurrences>>(expect1);
      }
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfo() = default;
};
class SearchMediaByAILabelResponseBodyMediaListAiDataAsrInfo : public Darabonba::Model {
public:
  shared_ptr<string> clipId{};
  shared_ptr<string> content{};
  shared_ptr<double> from{};
  shared_ptr<double> timestamp{};
  shared_ptr<double> to{};

  SearchMediaByAILabelResponseBodyMediaListAiDataAsrInfo() {}

  explicit SearchMediaByAILabelResponseBodyMediaListAiDataAsrInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipId) {
      res["ClipId"] = boost::any(*clipId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipId") != m.end() && !m["ClipId"].empty()) {
      clipId = make_shared<string>(boost::any_cast<string>(m["ClipId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<double>(boost::any_cast<double>(m["From"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<double>(boost::any_cast<double>(m["Timestamp"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<double>(boost::any_cast<double>(m["To"]));
    }
  }


  virtual ~SearchMediaByAILabelResponseBodyMediaListAiDataAsrInfo() = default;
};
class SearchMediaByAILabelResponseBodyMediaListAiDataOcrInfo : public Darabonba::Model {
public:
  shared_ptr<string> clipId{};
  shared_ptr<string> content{};
  shared_ptr<double> from{};
  shared_ptr<double> timestamp{};
  shared_ptr<double> to{};

  SearchMediaByAILabelResponseBodyMediaListAiDataOcrInfo() {}

  explicit SearchMediaByAILabelResponseBodyMediaListAiDataOcrInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipId) {
      res["ClipId"] = boost::any(*clipId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipId") != m.end() && !m["ClipId"].empty()) {
      clipId = make_shared<string>(boost::any_cast<string>(m["ClipId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<double>(boost::any_cast<double>(m["From"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<double>(boost::any_cast<double>(m["Timestamp"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<double>(boost::any_cast<double>(m["To"]));
    }
  }


  virtual ~SearchMediaByAILabelResponseBodyMediaListAiDataOcrInfo() = default;
};
class SearchMediaByAILabelResponseBodyMediaListAiData : public Darabonba::Model {
public:
  shared_ptr<vector<SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfo>> aiLabelInfo{};
  shared_ptr<vector<SearchMediaByAILabelResponseBodyMediaListAiDataAsrInfo>> asrInfo{};
  shared_ptr<vector<SearchMediaByAILabelResponseBodyMediaListAiDataOcrInfo>> ocrInfo{};

  SearchMediaByAILabelResponseBodyMediaListAiData() {}

  explicit SearchMediaByAILabelResponseBodyMediaListAiData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiLabelInfo) {
      vector<boost::any> temp1;
      for(auto item1:*aiLabelInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AiLabelInfo"] = boost::any(temp1);
    }
    if (asrInfo) {
      vector<boost::any> temp1;
      for(auto item1:*asrInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AsrInfo"] = boost::any(temp1);
    }
    if (ocrInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ocrInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OcrInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiLabelInfo") != m.end() && !m["AiLabelInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["AiLabelInfo"].type()) {
        vector<SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AiLabelInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aiLabelInfo = make_shared<vector<SearchMediaByAILabelResponseBodyMediaListAiDataAiLabelInfo>>(expect1);
      }
    }
    if (m.find("AsrInfo") != m.end() && !m["AsrInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["AsrInfo"].type()) {
        vector<SearchMediaByAILabelResponseBodyMediaListAiDataAsrInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AsrInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaByAILabelResponseBodyMediaListAiDataAsrInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        asrInfo = make_shared<vector<SearchMediaByAILabelResponseBodyMediaListAiDataAsrInfo>>(expect1);
      }
    }
    if (m.find("OcrInfo") != m.end() && !m["OcrInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["OcrInfo"].type()) {
        vector<SearchMediaByAILabelResponseBodyMediaListAiDataOcrInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OcrInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaByAILabelResponseBodyMediaListAiDataOcrInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ocrInfo = make_shared<vector<SearchMediaByAILabelResponseBodyMediaListAiDataOcrInfo>>(expect1);
      }
    }
  }


  virtual ~SearchMediaByAILabelResponseBodyMediaListAiData() = default;
};
class SearchMediaByAILabelResponseBodyMediaList : public Darabonba::Model {
public:
  shared_ptr<SearchMediaByAILabelResponseBodyMediaListAiData> aiData{};
  shared_ptr<string> appId{};
  shared_ptr<string> coverUrl{};
  shared_ptr<string> creationTime{};
  shared_ptr<string> description{};
  shared_ptr<double> duration{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> modificationTime{};
  shared_ptr<long> size{};
  shared_ptr<vector<string>> snapshots{};
  shared_ptr<string> status{};
  shared_ptr<string> storageLocation{};
  shared_ptr<string> tags{};
  shared_ptr<string> title{};

  SearchMediaByAILabelResponseBodyMediaList() {}

  explicit SearchMediaByAILabelResponseBodyMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aiData) {
      res["AiData"] = aiData ? boost::any(aiData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (modificationTime) {
      res["ModificationTime"] = boost::any(*modificationTime);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (snapshots) {
      res["Snapshots"] = boost::any(*snapshots);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageLocation) {
      res["StorageLocation"] = boost::any(*storageLocation);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AiData") != m.end() && !m["AiData"].empty()) {
      if (typeid(map<string, boost::any>) == m["AiData"].type()) {
        SearchMediaByAILabelResponseBodyMediaListAiData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AiData"]));
        aiData = make_shared<SearchMediaByAILabelResponseBodyMediaListAiData>(model1);
      }
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<string>(boost::any_cast<string>(m["CreationTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("ModificationTime") != m.end() && !m["ModificationTime"].empty()) {
      modificationTime = make_shared<string>(boost::any_cast<string>(m["ModificationTime"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Snapshots"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Snapshots"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      snapshots = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageLocation") != m.end() && !m["StorageLocation"].empty()) {
      storageLocation = make_shared<string>(boost::any_cast<string>(m["StorageLocation"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~SearchMediaByAILabelResponseBodyMediaList() = default;
};
class SearchMediaByAILabelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<SearchMediaByAILabelResponseBodyMediaList>> mediaList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<long> total{};

  SearchMediaByAILabelResponseBody() {}

  explicit SearchMediaByAILabelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (mediaList) {
      vector<boost::any> temp1;
      for(auto item1:*mediaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("MediaList") != m.end() && !m["MediaList"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaList"].type()) {
        vector<SearchMediaByAILabelResponseBodyMediaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaByAILabelResponseBodyMediaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaList = make_shared<vector<SearchMediaByAILabelResponseBodyMediaList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~SearchMediaByAILabelResponseBody() = default;
};
class SearchMediaByAILabelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchMediaByAILabelResponseBody> body{};

  SearchMediaByAILabelResponse() {}

  explicit SearchMediaByAILabelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchMediaByAILabelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchMediaByAILabelResponseBody>(model1);
      }
    }
  }


  virtual ~SearchMediaByAILabelResponse() = default;
};
class SearchMediaByFaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<string> faceSearchToken{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> personImageUrl{};
  shared_ptr<string> searchLibName{};

  SearchMediaByFaceRequest() {}

  explicit SearchMediaByFaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (faceSearchToken) {
      res["FaceSearchToken"] = boost::any(*faceSearchToken);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (personImageUrl) {
      res["PersonImageUrl"] = boost::any(*personImageUrl);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("FaceSearchToken") != m.end() && !m["FaceSearchToken"].empty()) {
      faceSearchToken = make_shared<string>(boost::any_cast<string>(m["FaceSearchToken"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PersonImageUrl") != m.end() && !m["PersonImageUrl"].empty()) {
      personImageUrl = make_shared<string>(boost::any_cast<string>(m["PersonImageUrl"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
  }


  virtual ~SearchMediaByFaceRequest() = default;
};
class SearchMediaByFaceResponseBodyMediaInfoList : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};

  SearchMediaByFaceResponseBodyMediaInfoList() {}

  explicit SearchMediaByFaceResponseBodyMediaInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~SearchMediaByFaceResponseBodyMediaInfoList() = default;
};
class SearchMediaByFaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<SearchMediaByFaceResponseBodyMediaInfoList>> mediaInfoList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<long> total{};

  SearchMediaByFaceResponseBody() {}

  explicit SearchMediaByFaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (mediaInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*mediaInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaInfoList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("MediaInfoList") != m.end() && !m["MediaInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaInfoList"].type()) {
        vector<SearchMediaByFaceResponseBodyMediaInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaByFaceResponseBodyMediaInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaInfoList = make_shared<vector<SearchMediaByFaceResponseBodyMediaInfoList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~SearchMediaByFaceResponseBody() = default;
};
class SearchMediaByFaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchMediaByFaceResponseBody> body{};

  SearchMediaByFaceResponse() {}

  explicit SearchMediaByFaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchMediaByFaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchMediaByFaceResponseBody>(model1);
      }
    }
  }


  virtual ~SearchMediaByFaceResponse() = default;
};
class SearchMediaByHybridRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchLibName{};
  shared_ptr<string> text{};

  SearchMediaByHybridRequest() {}

  explicit SearchMediaByHybridRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~SearchMediaByHybridRequest() = default;
};
class SearchMediaByHybridResponseBodyMediaListClipInfo : public Darabonba::Model {
public:
  shared_ptr<double> from{};
  shared_ptr<double> score{};
  shared_ptr<double> to{};

  SearchMediaByHybridResponseBodyMediaListClipInfo() {}

  explicit SearchMediaByHybridResponseBodyMediaListClipInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<double>(boost::any_cast<double>(m["From"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<double>(boost::any_cast<double>(m["Score"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<double>(boost::any_cast<double>(m["To"]));
    }
  }


  virtual ~SearchMediaByHybridResponseBodyMediaListClipInfo() = default;
};
class SearchMediaByHybridResponseBodyMediaList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchMediaByHybridResponseBodyMediaListClipInfo>> clipInfo{};
  shared_ptr<string> mediaId{};

  SearchMediaByHybridResponseBodyMediaList() {}

  explicit SearchMediaByHybridResponseBodyMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipInfo) {
      vector<boost::any> temp1;
      for(auto item1:*clipInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClipInfo"] = boost::any(temp1);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipInfo") != m.end() && !m["ClipInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ClipInfo"].type()) {
        vector<SearchMediaByHybridResponseBodyMediaListClipInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClipInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaByHybridResponseBodyMediaListClipInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clipInfo = make_shared<vector<SearchMediaByHybridResponseBodyMediaListClipInfo>>(expect1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~SearchMediaByHybridResponseBodyMediaList() = default;
};
class SearchMediaByHybridResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<SearchMediaByHybridResponseBodyMediaList>> mediaList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<long> total{};

  SearchMediaByHybridResponseBody() {}

  explicit SearchMediaByHybridResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (mediaList) {
      vector<boost::any> temp1;
      for(auto item1:*mediaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("MediaList") != m.end() && !m["MediaList"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaList"].type()) {
        vector<SearchMediaByHybridResponseBodyMediaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaByHybridResponseBodyMediaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaList = make_shared<vector<SearchMediaByHybridResponseBodyMediaList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~SearchMediaByHybridResponseBody() = default;
};
class SearchMediaByHybridResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchMediaByHybridResponseBody> body{};

  SearchMediaByHybridResponse() {}

  explicit SearchMediaByHybridResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchMediaByHybridResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchMediaByHybridResponseBody>(model1);
      }
    }
  }


  virtual ~SearchMediaByHybridResponse() = default;
};
class SearchMediaByMultimodalRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaType{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchLibName{};
  shared_ptr<string> text{};

  SearchMediaByMultimodalRequest() {}

  explicit SearchMediaByMultimodalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~SearchMediaByMultimodalRequest() = default;
};
class SearchMediaByMultimodalResponseBodyMediaListClipInfo : public Darabonba::Model {
public:
  shared_ptr<double> from{};
  shared_ptr<double> score{};
  shared_ptr<double> to{};

  SearchMediaByMultimodalResponseBodyMediaListClipInfo() {}

  explicit SearchMediaByMultimodalResponseBodyMediaListClipInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<double>(boost::any_cast<double>(m["From"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<double>(boost::any_cast<double>(m["Score"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<double>(boost::any_cast<double>(m["To"]));
    }
  }


  virtual ~SearchMediaByMultimodalResponseBodyMediaListClipInfo() = default;
};
class SearchMediaByMultimodalResponseBodyMediaList : public Darabonba::Model {
public:
  shared_ptr<vector<SearchMediaByMultimodalResponseBodyMediaListClipInfo>> clipInfo{};
  shared_ptr<string> mediaId{};

  SearchMediaByMultimodalResponseBodyMediaList() {}

  explicit SearchMediaByMultimodalResponseBodyMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipInfo) {
      vector<boost::any> temp1;
      for(auto item1:*clipInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClipInfo"] = boost::any(temp1);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipInfo") != m.end() && !m["ClipInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ClipInfo"].type()) {
        vector<SearchMediaByMultimodalResponseBodyMediaListClipInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClipInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaByMultimodalResponseBodyMediaListClipInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clipInfo = make_shared<vector<SearchMediaByMultimodalResponseBodyMediaListClipInfo>>(expect1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~SearchMediaByMultimodalResponseBodyMediaList() = default;
};
class SearchMediaByMultimodalResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<SearchMediaByMultimodalResponseBodyMediaList>> mediaList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<long> total{};

  SearchMediaByMultimodalResponseBody() {}

  explicit SearchMediaByMultimodalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (mediaList) {
      vector<boost::any> temp1;
      for(auto item1:*mediaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("MediaList") != m.end() && !m["MediaList"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaList"].type()) {
        vector<SearchMediaByMultimodalResponseBodyMediaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaByMultimodalResponseBodyMediaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaList = make_shared<vector<SearchMediaByMultimodalResponseBodyMediaList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~SearchMediaByMultimodalResponseBody() = default;
};
class SearchMediaByMultimodalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchMediaByMultimodalResponseBody> body{};

  SearchMediaByMultimodalResponse() {}

  explicit SearchMediaByMultimodalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchMediaByMultimodalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchMediaByMultimodalResponseBody>(model1);
      }
    }
  }


  virtual ~SearchMediaByMultimodalResponse() = default;
};
class SearchMediaClipByFaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> entityId{};
  shared_ptr<string> faceSearchToken{};
  shared_ptr<string> mediaId{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchLibName{};

  SearchMediaClipByFaceRequest() {}

  explicit SearchMediaClipByFaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (faceSearchToken) {
      res["FaceSearchToken"] = boost::any(*faceSearchToken);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("FaceSearchToken") != m.end() && !m["FaceSearchToken"].empty()) {
      faceSearchToken = make_shared<string>(boost::any_cast<string>(m["FaceSearchToken"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
  }


  virtual ~SearchMediaClipByFaceRequest() = default;
};
class SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackDataBoxPosition : public Darabonba::Model {
public:
  shared_ptr<long> h{};
  shared_ptr<long> w{};
  shared_ptr<long> x{};
  shared_ptr<long> y{};

  SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackDataBoxPosition() {}

  explicit SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackDataBoxPosition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (h) {
      res["H"] = boost::any(*h);
    }
    if (w) {
      res["W"] = boost::any(*w);
    }
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("H") != m.end() && !m["H"].empty()) {
      h = make_shared<long>(boost::any_cast<long>(m["H"]));
    }
    if (m.find("W") != m.end() && !m["W"].empty()) {
      w = make_shared<long>(boost::any_cast<long>(m["W"]));
    }
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<long>(boost::any_cast<long>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<long>(boost::any_cast<long>(m["Y"]));
    }
  }


  virtual ~SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackDataBoxPosition() = default;
};
class SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackData : public Darabonba::Model {
public:
  shared_ptr<SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackDataBoxPosition> boxPosition{};
  shared_ptr<double> timestamp{};

  SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackData() {}

  explicit SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (boxPosition) {
      res["BoxPosition"] = boxPosition ? boost::any(boxPosition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BoxPosition") != m.end() && !m["BoxPosition"].empty()) {
      if (typeid(map<string, boost::any>) == m["BoxPosition"].type()) {
        SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackDataBoxPosition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BoxPosition"]));
        boxPosition = make_shared<SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackDataBoxPosition>(model1);
      }
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<double>(boost::any_cast<double>(m["Timestamp"]));
    }
  }


  virtual ~SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackData() = default;
};
class SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfos : public Darabonba::Model {
public:
  shared_ptr<double> endTime{};
  shared_ptr<string> expression{};
  shared_ptr<double> startTime{};
  shared_ptr<vector<SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackData>> trackData{};

  SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfos() {}

  explicit SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (trackData) {
      vector<boost::any> temp1;
      for(auto item1:*trackData){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TrackData"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<double>(boost::any_cast<double>(m["EndTime"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<double>(boost::any_cast<double>(m["StartTime"]));
    }
    if (m.find("TrackData") != m.end() && !m["TrackData"].empty()) {
      if (typeid(vector<boost::any>) == m["TrackData"].type()) {
        vector<SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TrackData"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trackData = make_shared<vector<SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfosTrackData>>(expect1);
      }
    }
  }


  virtual ~SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfos() = default;
};
class SearchMediaClipByFaceResponseBodyMediaClipList : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> entityId{};
  shared_ptr<string> labelName{};
  shared_ptr<vector<SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfos>> occurrencesInfos{};
  shared_ptr<double> score{};

  SearchMediaClipByFaceResponseBodyMediaClipList() {}

  explicit SearchMediaClipByFaceResponseBodyMediaClipList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (labelName) {
      res["LabelName"] = boost::any(*labelName);
    }
    if (occurrencesInfos) {
      vector<boost::any> temp1;
      for(auto item1:*occurrencesInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OccurrencesInfos"] = boost::any(temp1);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("LabelName") != m.end() && !m["LabelName"].empty()) {
      labelName = make_shared<string>(boost::any_cast<string>(m["LabelName"]));
    }
    if (m.find("OccurrencesInfos") != m.end() && !m["OccurrencesInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["OccurrencesInfos"].type()) {
        vector<SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OccurrencesInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        occurrencesInfos = make_shared<vector<SearchMediaClipByFaceResponseBodyMediaClipListOccurrencesInfos>>(expect1);
      }
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<double>(boost::any_cast<double>(m["Score"]));
    }
  }


  virtual ~SearchMediaClipByFaceResponseBodyMediaClipList() = default;
};
class SearchMediaClipByFaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<SearchMediaClipByFaceResponseBodyMediaClipList>> mediaClipList{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};
  shared_ptr<long> total{};

  SearchMediaClipByFaceResponseBody() {}

  explicit SearchMediaClipByFaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (mediaClipList) {
      vector<boost::any> temp1;
      for(auto item1:*mediaClipList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaClipList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("MediaClipList") != m.end() && !m["MediaClipList"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaClipList"].type()) {
        vector<SearchMediaClipByFaceResponseBodyMediaClipList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaClipList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchMediaClipByFaceResponseBodyMediaClipList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaClipList = make_shared<vector<SearchMediaClipByFaceResponseBodyMediaClipList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~SearchMediaClipByFaceResponseBody() = default;
};
class SearchMediaClipByFaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchMediaClipByFaceResponseBody> body{};

  SearchMediaClipByFaceResponse() {}

  explicit SearchMediaClipByFaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchMediaClipByFaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchMediaClipByFaceResponseBody>(model1);
      }
    }
  }


  virtual ~SearchMediaClipByFaceResponse() = default;
};
class SearchPublicMediaInfoRequest : public Darabonba::Model {
public:
  shared_ptr<bool> authorized{};
  shared_ptr<string> dynamicMetaDataMatchFields{};
  shared_ptr<string> entityId{};
  shared_ptr<bool> favorite{};
  shared_ptr<string> mediaIds{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sortBy{};

  SearchPublicMediaInfoRequest() {}

  explicit SearchPublicMediaInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorized) {
      res["Authorized"] = boost::any(*authorized);
    }
    if (dynamicMetaDataMatchFields) {
      res["DynamicMetaDataMatchFields"] = boost::any(*dynamicMetaDataMatchFields);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (favorite) {
      res["Favorite"] = boost::any(*favorite);
    }
    if (mediaIds) {
      res["MediaIds"] = boost::any(*mediaIds);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sortBy) {
      res["SortBy"] = boost::any(*sortBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Authorized") != m.end() && !m["Authorized"].empty()) {
      authorized = make_shared<bool>(boost::any_cast<bool>(m["Authorized"]));
    }
    if (m.find("DynamicMetaDataMatchFields") != m.end() && !m["DynamicMetaDataMatchFields"].empty()) {
      dynamicMetaDataMatchFields = make_shared<string>(boost::any_cast<string>(m["DynamicMetaDataMatchFields"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("Favorite") != m.end() && !m["Favorite"].empty()) {
      favorite = make_shared<bool>(boost::any_cast<bool>(m["Favorite"]));
    }
    if (m.find("MediaIds") != m.end() && !m["MediaIds"].empty()) {
      mediaIds = make_shared<string>(boost::any_cast<string>(m["MediaIds"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SortBy") != m.end() && !m["SortBy"].empty()) {
      sortBy = make_shared<string>(boost::any_cast<string>(m["SortBy"]));
    }
  }


  virtual ~SearchPublicMediaInfoRequest() = default;
};
class SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> type{};

  SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData() {}

  explicit SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData() = default;
};
class SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> businessType{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deletedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> source{};
  shared_ptr<string> spriteImages{};
  shared_ptr<string> status{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo() {}

  explicit SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deletedTime) {
      res["DeletedTime"] = boost::any(*deletedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (spriteImages) {
      res["SpriteImages"] = boost::any(*spriteImages);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeletedTime") != m.end() && !m["DeletedTime"].empty()) {
      deletedTime = make_shared<string>(boost::any_cast<string>(m["DeletedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SpriteImages") != m.end() && !m["SpriteImages"].empty()) {
      spriteImages = make_shared<string>(boost::any_cast<string>(m["SpriteImages"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo() = default;
};
class SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo : public Darabonba::Model {
public:
  shared_ptr<SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData> dynamicMetaData{};
  shared_ptr<SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo> mediaBasicInfo{};
  shared_ptr<string> mediaId{};

  SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo() {}

  explicit SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicMetaData) {
      res["DynamicMetaData"] = dynamicMetaData ? boost::any(dynamicMetaData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaBasicInfo) {
      res["MediaBasicInfo"] = mediaBasicInfo ? boost::any(mediaBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicMetaData") != m.end() && !m["DynamicMetaData"].empty()) {
      if (typeid(map<string, boost::any>) == m["DynamicMetaData"].type()) {
        SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DynamicMetaData"]));
        dynamicMetaData = make_shared<SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData>(model1);
      }
    }
    if (m.find("MediaBasicInfo") != m.end() && !m["MediaBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaBasicInfo"].type()) {
        SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaBasicInfo"]));
        mediaBasicInfo = make_shared<SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo>(model1);
      }
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo() = default;
};
class SearchPublicMediaInfoResponseBodyPublicMediaInfos : public Darabonba::Model {
public:
  shared_ptr<bool> authorized{};
  shared_ptr<bool> favorite{};
  shared_ptr<SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo> mediaInfo{};
  shared_ptr<string> remainingAuthTime{};

  SearchPublicMediaInfoResponseBodyPublicMediaInfos() {}

  explicit SearchPublicMediaInfoResponseBodyPublicMediaInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorized) {
      res["Authorized"] = boost::any(*authorized);
    }
    if (favorite) {
      res["Favorite"] = boost::any(*favorite);
    }
    if (mediaInfo) {
      res["MediaInfo"] = mediaInfo ? boost::any(mediaInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (remainingAuthTime) {
      res["RemainingAuthTime"] = boost::any(*remainingAuthTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Authorized") != m.end() && !m["Authorized"].empty()) {
      authorized = make_shared<bool>(boost::any_cast<bool>(m["Authorized"]));
    }
    if (m.find("Favorite") != m.end() && !m["Favorite"].empty()) {
      favorite = make_shared<bool>(boost::any_cast<bool>(m["Favorite"]));
    }
    if (m.find("MediaInfo") != m.end() && !m["MediaInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfo"].type()) {
        SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfo"]));
        mediaInfo = make_shared<SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo>(model1);
      }
    }
    if (m.find("RemainingAuthTime") != m.end() && !m["RemainingAuthTime"].empty()) {
      remainingAuthTime = make_shared<string>(boost::any_cast<string>(m["RemainingAuthTime"]));
    }
  }


  virtual ~SearchPublicMediaInfoResponseBodyPublicMediaInfos() = default;
};
class SearchPublicMediaInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<SearchPublicMediaInfoResponseBodyPublicMediaInfos>> publicMediaInfos{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  SearchPublicMediaInfoResponseBody() {}

  explicit SearchPublicMediaInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publicMediaInfos) {
      vector<boost::any> temp1;
      for(auto item1:*publicMediaInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublicMediaInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PublicMediaInfos") != m.end() && !m["PublicMediaInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["PublicMediaInfos"].type()) {
        vector<SearchPublicMediaInfoResponseBodyPublicMediaInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublicMediaInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchPublicMediaInfoResponseBodyPublicMediaInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publicMediaInfos = make_shared<vector<SearchPublicMediaInfoResponseBodyPublicMediaInfos>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~SearchPublicMediaInfoResponseBody() = default;
};
class SearchPublicMediaInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchPublicMediaInfoResponseBody> body{};

  SearchPublicMediaInfoResponse() {}

  explicit SearchPublicMediaInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchPublicMediaInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchPublicMediaInfoResponseBody>(model1);
      }
    }
  }


  virtual ~SearchPublicMediaInfoResponse() = default;
};
class SendAIAgentDataChannelMessageRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> message{};

  SendAIAgentDataChannelMessageRequest() {}

  explicit SendAIAgentDataChannelMessageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~SendAIAgentDataChannelMessageRequest() = default;
};
class SendAIAgentDataChannelMessageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SendAIAgentDataChannelMessageResponseBody() {}

  explicit SendAIAgentDataChannelMessageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendAIAgentDataChannelMessageResponseBody() = default;
};
class SendAIAgentDataChannelMessageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendAIAgentDataChannelMessageResponseBody> body{};

  SendAIAgentDataChannelMessageResponse() {}

  explicit SendAIAgentDataChannelMessageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendAIAgentDataChannelMessageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendAIAgentDataChannelMessageResponseBody>(model1);
      }
    }
  }


  virtual ~SendAIAgentDataChannelMessageResponse() = default;
};
class SendAIAgentSpeechRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableInterrupt{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> text{};

  SendAIAgentSpeechRequest() {}

  explicit SendAIAgentSpeechRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableInterrupt) {
      res["EnableInterrupt"] = boost::any(*enableInterrupt);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableInterrupt") != m.end() && !m["EnableInterrupt"].empty()) {
      enableInterrupt = make_shared<bool>(boost::any_cast<bool>(m["EnableInterrupt"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~SendAIAgentSpeechRequest() = default;
};
class SendAIAgentSpeechResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SendAIAgentSpeechResponseBody() {}

  explicit SendAIAgentSpeechResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendAIAgentSpeechResponseBody() = default;
};
class SendAIAgentSpeechResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendAIAgentSpeechResponseBody> body{};

  SendAIAgentSpeechResponse() {}

  explicit SendAIAgentSpeechResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendAIAgentSpeechResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendAIAgentSpeechResponseBody>(model1);
      }
    }
  }


  virtual ~SendAIAgentSpeechResponse() = default;
};
class SendAIAgentTextRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> text{};

  SendAIAgentTextRequest() {}

  explicit SendAIAgentTextRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~SendAIAgentTextRequest() = default;
};
class SendAIAgentTextResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SendAIAgentTextResponseBody() {}

  explicit SendAIAgentTextResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendAIAgentTextResponseBody() = default;
};
class SendAIAgentTextResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendAIAgentTextResponseBody> body{};

  SendAIAgentTextResponse() {}

  explicit SendAIAgentTextResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendAIAgentTextResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendAIAgentTextResponseBody>(model1);
      }
    }
  }


  virtual ~SendAIAgentTextResponse() = default;
};
class SendLiveSnapshotJobCommandRequest : public Darabonba::Model {
public:
  shared_ptr<string> command{};
  shared_ptr<string> jobId{};

  SendLiveSnapshotJobCommandRequest() {}

  explicit SendLiveSnapshotJobCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SendLiveSnapshotJobCommandRequest() = default;
};
class SendLiveSnapshotJobCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SendLiveSnapshotJobCommandResponseBody() {}

  explicit SendLiveSnapshotJobCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendLiveSnapshotJobCommandResponseBody() = default;
};
class SendLiveSnapshotJobCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendLiveSnapshotJobCommandResponseBody> body{};

  SendLiveSnapshotJobCommandResponse() {}

  explicit SendLiveSnapshotJobCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendLiveSnapshotJobCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendLiveSnapshotJobCommandResponseBody>(model1);
      }
    }
  }


  virtual ~SendLiveSnapshotJobCommandResponse() = default;
};
class SendLiveTranscodeJobCommandRequest : public Darabonba::Model {
public:
  shared_ptr<string> command{};
  shared_ptr<string> jobId{};

  SendLiveTranscodeJobCommandRequest() {}

  explicit SendLiveTranscodeJobCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SendLiveTranscodeJobCommandRequest() = default;
};
class SendLiveTranscodeJobCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SendLiveTranscodeJobCommandResponseBody() {}

  explicit SendLiveTranscodeJobCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendLiveTranscodeJobCommandResponseBody() = default;
};
class SendLiveTranscodeJobCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendLiveTranscodeJobCommandResponseBody> body{};

  SendLiveTranscodeJobCommandResponse() {}

  explicit SendLiveTranscodeJobCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendLiveTranscodeJobCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendLiveTranscodeJobCommandResponseBody>(model1);
      }
    }
  }


  virtual ~SendLiveTranscodeJobCommandResponse() = default;
};
class SendMessageChatTextRequest : public Darabonba::Model {
public:
  shared_ptr<string> AIAgentId{};
  shared_ptr<string> mode{};
  shared_ptr<bool> needArchiving{};
  shared_ptr<string> receiverId{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> text{};
  shared_ptr<string> type{};

  SendMessageChatTextRequest() {}

  explicit SendMessageChatTextRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIAgentId) {
      res["AIAgentId"] = boost::any(*AIAgentId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (needArchiving) {
      res["NeedArchiving"] = boost::any(*needArchiving);
    }
    if (receiverId) {
      res["ReceiverId"] = boost::any(*receiverId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIAgentId") != m.end() && !m["AIAgentId"].empty()) {
      AIAgentId = make_shared<string>(boost::any_cast<string>(m["AIAgentId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("NeedArchiving") != m.end() && !m["NeedArchiving"].empty()) {
      needArchiving = make_shared<bool>(boost::any_cast<bool>(m["NeedArchiving"]));
    }
    if (m.find("ReceiverId") != m.end() && !m["ReceiverId"].empty()) {
      receiverId = make_shared<string>(boost::any_cast<string>(m["ReceiverId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SendMessageChatTextRequest() = default;
};
class SendMessageChatTextResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SendMessageChatTextResponseBody() {}

  explicit SendMessageChatTextResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendMessageChatTextResponseBody() = default;
};
class SendMessageChatTextResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendMessageChatTextResponseBody> body{};

  SendMessageChatTextResponse() {}

  explicit SendMessageChatTextResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendMessageChatTextResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendMessageChatTextResponseBody>(model1);
      }
    }
  }


  virtual ~SendMessageChatTextResponse() = default;
};
class SetContentAnalyzeConfigRequest : public Darabonba::Model {
public:
  shared_ptr<bool> auto_{};
  shared_ptr<string> saveType{};
  shared_ptr<string> templateId{};

  SetContentAnalyzeConfigRequest() {}

  explicit SetContentAnalyzeConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auto_) {
      res["Auto"] = boost::any(*auto_);
    }
    if (saveType) {
      res["SaveType"] = boost::any(*saveType);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Auto") != m.end() && !m["Auto"].empty()) {
      auto_ = make_shared<bool>(boost::any_cast<bool>(m["Auto"]));
    }
    if (m.find("SaveType") != m.end() && !m["SaveType"].empty()) {
      saveType = make_shared<string>(boost::any_cast<string>(m["SaveType"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SetContentAnalyzeConfigRequest() = default;
};
class SetContentAnalyzeConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SetContentAnalyzeConfigResponseBody() {}

  explicit SetContentAnalyzeConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetContentAnalyzeConfigResponseBody() = default;
};
class SetContentAnalyzeConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetContentAnalyzeConfigResponseBody> body{};

  SetContentAnalyzeConfigResponse() {}

  explicit SetContentAnalyzeConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetContentAnalyzeConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetContentAnalyzeConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetContentAnalyzeConfigResponse() = default;
};
class SetDefaultCustomTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> templateId{};

  SetDefaultCustomTemplateRequest() {}

  explicit SetDefaultCustomTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SetDefaultCustomTemplateRequest() = default;
};
class SetDefaultCustomTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SetDefaultCustomTemplateResponseBody() {}

  explicit SetDefaultCustomTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetDefaultCustomTemplateResponseBody() = default;
};
class SetDefaultCustomTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDefaultCustomTemplateResponseBody> body{};

  SetDefaultCustomTemplateResponse() {}

  explicit SetDefaultCustomTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDefaultCustomTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDefaultCustomTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~SetDefaultCustomTemplateResponse() = default;
};
class SetDefaultStorageLocationRequest : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> path{};
  shared_ptr<string> storageType{};

  SetDefaultStorageLocationRequest() {}

  explicit SetDefaultStorageLocationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~SetDefaultStorageLocationRequest() = default;
};
class SetDefaultStorageLocationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SetDefaultStorageLocationResponseBody() {}

  explicit SetDefaultStorageLocationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetDefaultStorageLocationResponseBody() = default;
};
class SetDefaultStorageLocationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDefaultStorageLocationResponseBody> body{};

  SetDefaultStorageLocationResponse() {}

  explicit SetDefaultStorageLocationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDefaultStorageLocationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDefaultStorageLocationResponseBody>(model1);
      }
    }
  }


  virtual ~SetDefaultStorageLocationResponse() = default;
};
class SetEventCallbackRequest : public Darabonba::Model {
public:
  shared_ptr<string> authKey{};
  shared_ptr<string> authSwitch{};
  shared_ptr<string> callbackQueueName{};
  shared_ptr<string> callbackType{};
  shared_ptr<string> callbackURL{};
  shared_ptr<string> eventTypeList{};

  SetEventCallbackRequest() {}

  explicit SetEventCallbackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authKey) {
      res["AuthKey"] = boost::any(*authKey);
    }
    if (authSwitch) {
      res["AuthSwitch"] = boost::any(*authSwitch);
    }
    if (callbackQueueName) {
      res["CallbackQueueName"] = boost::any(*callbackQueueName);
    }
    if (callbackType) {
      res["CallbackType"] = boost::any(*callbackType);
    }
    if (callbackURL) {
      res["CallbackURL"] = boost::any(*callbackURL);
    }
    if (eventTypeList) {
      res["EventTypeList"] = boost::any(*eventTypeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthKey") != m.end() && !m["AuthKey"].empty()) {
      authKey = make_shared<string>(boost::any_cast<string>(m["AuthKey"]));
    }
    if (m.find("AuthSwitch") != m.end() && !m["AuthSwitch"].empty()) {
      authSwitch = make_shared<string>(boost::any_cast<string>(m["AuthSwitch"]));
    }
    if (m.find("CallbackQueueName") != m.end() && !m["CallbackQueueName"].empty()) {
      callbackQueueName = make_shared<string>(boost::any_cast<string>(m["CallbackQueueName"]));
    }
    if (m.find("CallbackType") != m.end() && !m["CallbackType"].empty()) {
      callbackType = make_shared<string>(boost::any_cast<string>(m["CallbackType"]));
    }
    if (m.find("CallbackURL") != m.end() && !m["CallbackURL"].empty()) {
      callbackURL = make_shared<string>(boost::any_cast<string>(m["CallbackURL"]));
    }
    if (m.find("EventTypeList") != m.end() && !m["EventTypeList"].empty()) {
      eventTypeList = make_shared<string>(boost::any_cast<string>(m["EventTypeList"]));
    }
  }


  virtual ~SetEventCallbackRequest() = default;
};
class SetEventCallbackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SetEventCallbackResponseBody() {}

  explicit SetEventCallbackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SetEventCallbackResponseBody() = default;
};
class SetEventCallbackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetEventCallbackResponseBody> body{};

  SetEventCallbackResponse() {}

  explicit SetEventCallbackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetEventCallbackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetEventCallbackResponseBody>(model1);
      }
    }
  }


  virtual ~SetEventCallbackResponse() = default;
};
class SetNotifyConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> AIAgentId{};
  shared_ptr<string> audioOssPath{};
  shared_ptr<string> callbackUrl{};
  shared_ptr<bool> enableAudioRecording{};
  shared_ptr<bool> enableNotify{};
  shared_ptr<string> eventTypes{};
  shared_ptr<string> token{};

  SetNotifyConfigRequest() {}

  explicit SetNotifyConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIAgentId) {
      res["AIAgentId"] = boost::any(*AIAgentId);
    }
    if (audioOssPath) {
      res["AudioOssPath"] = boost::any(*audioOssPath);
    }
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (enableAudioRecording) {
      res["EnableAudioRecording"] = boost::any(*enableAudioRecording);
    }
    if (enableNotify) {
      res["EnableNotify"] = boost::any(*enableNotify);
    }
    if (eventTypes) {
      res["EventTypes"] = boost::any(*eventTypes);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIAgentId") != m.end() && !m["AIAgentId"].empty()) {
      AIAgentId = make_shared<string>(boost::any_cast<string>(m["AIAgentId"]));
    }
    if (m.find("AudioOssPath") != m.end() && !m["AudioOssPath"].empty()) {
      audioOssPath = make_shared<string>(boost::any_cast<string>(m["AudioOssPath"]));
    }
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("EnableAudioRecording") != m.end() && !m["EnableAudioRecording"].empty()) {
      enableAudioRecording = make_shared<bool>(boost::any_cast<bool>(m["EnableAudioRecording"]));
    }
    if (m.find("EnableNotify") != m.end() && !m["EnableNotify"].empty()) {
      enableNotify = make_shared<bool>(boost::any_cast<bool>(m["EnableNotify"]));
    }
    if (m.find("EventTypes") != m.end() && !m["EventTypes"].empty()) {
      eventTypes = make_shared<string>(boost::any_cast<string>(m["EventTypes"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~SetNotifyConfigRequest() = default;
};
class SetNotifyConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetNotifyConfigResponseBody() {}

  explicit SetNotifyConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetNotifyConfigResponseBody() = default;
};
class SetNotifyConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetNotifyConfigResponseBody> body{};

  SetNotifyConfigResponse() {}

  explicit SetNotifyConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetNotifyConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetNotifyConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetNotifyConfigResponse() = default;
};
class StartAIAgentInstanceRequestChatSyncConfig : public Darabonba::Model {
public:
  shared_ptr<string> IMAIAgentId{};
  shared_ptr<string> receiverId{};

  StartAIAgentInstanceRequestChatSyncConfig() {}

  explicit StartAIAgentInstanceRequestChatSyncConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IMAIAgentId) {
      res["IMAIAgentId"] = boost::any(*IMAIAgentId);
    }
    if (receiverId) {
      res["ReceiverId"] = boost::any(*receiverId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IMAIAgentId") != m.end() && !m["IMAIAgentId"].empty()) {
      IMAIAgentId = make_shared<string>(boost::any_cast<string>(m["IMAIAgentId"]));
    }
    if (m.find("ReceiverId") != m.end() && !m["ReceiverId"].empty()) {
      receiverId = make_shared<string>(boost::any_cast<string>(m["ReceiverId"]));
    }
  }


  virtual ~StartAIAgentInstanceRequestChatSyncConfig() = default;
};
class StartAIAgentInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> AIAgentId{};
  shared_ptr<AIAgentConfig> agentConfig{};
  shared_ptr<StartAIAgentInstanceRequestChatSyncConfig> chatSyncConfig{};
  shared_ptr<AIAgentRuntimeConfig> runtimeConfig{};
  shared_ptr<string> sessionId{};
  shared_ptr<AIAgentTemplateConfig> templateConfig{};
  shared_ptr<string> userData{};

  StartAIAgentInstanceRequest() {}

  explicit StartAIAgentInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIAgentId) {
      res["AIAgentId"] = boost::any(*AIAgentId);
    }
    if (agentConfig) {
      res["AgentConfig"] = agentConfig ? boost::any(agentConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (chatSyncConfig) {
      res["ChatSyncConfig"] = chatSyncConfig ? boost::any(chatSyncConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtimeConfig) {
      res["RuntimeConfig"] = runtimeConfig ? boost::any(runtimeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIAgentId") != m.end() && !m["AIAgentId"].empty()) {
      AIAgentId = make_shared<string>(boost::any_cast<string>(m["AIAgentId"]));
    }
    if (m.find("AgentConfig") != m.end() && !m["AgentConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AgentConfig"].type()) {
        AIAgentConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AgentConfig"]));
        agentConfig = make_shared<AIAgentConfig>(model1);
      }
    }
    if (m.find("ChatSyncConfig") != m.end() && !m["ChatSyncConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChatSyncConfig"].type()) {
        StartAIAgentInstanceRequestChatSyncConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChatSyncConfig"]));
        chatSyncConfig = make_shared<StartAIAgentInstanceRequestChatSyncConfig>(model1);
      }
    }
    if (m.find("RuntimeConfig") != m.end() && !m["RuntimeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RuntimeConfig"].type()) {
        AIAgentRuntimeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RuntimeConfig"]));
        runtimeConfig = make_shared<AIAgentRuntimeConfig>(model1);
      }
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        AIAgentTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<AIAgentTemplateConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~StartAIAgentInstanceRequest() = default;
};
class StartAIAgentInstanceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> AIAgentId{};
  shared_ptr<string> agentConfigShrink{};
  shared_ptr<string> chatSyncConfigShrink{};
  shared_ptr<string> runtimeConfigShrink{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> templateConfigShrink{};
  shared_ptr<string> userData{};

  StartAIAgentInstanceShrinkRequest() {}

  explicit StartAIAgentInstanceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIAgentId) {
      res["AIAgentId"] = boost::any(*AIAgentId);
    }
    if (agentConfigShrink) {
      res["AgentConfig"] = boost::any(*agentConfigShrink);
    }
    if (chatSyncConfigShrink) {
      res["ChatSyncConfig"] = boost::any(*chatSyncConfigShrink);
    }
    if (runtimeConfigShrink) {
      res["RuntimeConfig"] = boost::any(*runtimeConfigShrink);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (templateConfigShrink) {
      res["TemplateConfig"] = boost::any(*templateConfigShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIAgentId") != m.end() && !m["AIAgentId"].empty()) {
      AIAgentId = make_shared<string>(boost::any_cast<string>(m["AIAgentId"]));
    }
    if (m.find("AgentConfig") != m.end() && !m["AgentConfig"].empty()) {
      agentConfigShrink = make_shared<string>(boost::any_cast<string>(m["AgentConfig"]));
    }
    if (m.find("ChatSyncConfig") != m.end() && !m["ChatSyncConfig"].empty()) {
      chatSyncConfigShrink = make_shared<string>(boost::any_cast<string>(m["ChatSyncConfig"]));
    }
    if (m.find("RuntimeConfig") != m.end() && !m["RuntimeConfig"].empty()) {
      runtimeConfigShrink = make_shared<string>(boost::any_cast<string>(m["RuntimeConfig"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfigShrink = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~StartAIAgentInstanceShrinkRequest() = default;
};
class StartAIAgentInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};

  StartAIAgentInstanceResponseBody() {}

  explicit StartAIAgentInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartAIAgentInstanceResponseBody() = default;
};
class StartAIAgentInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartAIAgentInstanceResponseBody> body{};

  StartAIAgentInstanceResponse() {}

  explicit StartAIAgentInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartAIAgentInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartAIAgentInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StartAIAgentInstanceResponse() = default;
};
class StartAIAgentOutboundCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> AIAgentId{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> callerNumber{};
  shared_ptr<AIAgentOutboundCallConfig> config{};
  shared_ptr<string> imsAIAgentFreeObCall{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> userData{};

  StartAIAgentOutboundCallRequest() {}

  explicit StartAIAgentOutboundCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIAgentId) {
      res["AIAgentId"] = boost::any(*AIAgentId);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (callerNumber) {
      res["CallerNumber"] = boost::any(*callerNumber);
    }
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imsAIAgentFreeObCall) {
      res["ImsAIAgentFreeObCall"] = boost::any(*imsAIAgentFreeObCall);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIAgentId") != m.end() && !m["AIAgentId"].empty()) {
      AIAgentId = make_shared<string>(boost::any_cast<string>(m["AIAgentId"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CallerNumber") != m.end() && !m["CallerNumber"].empty()) {
      callerNumber = make_shared<string>(boost::any_cast<string>(m["CallerNumber"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        AIAgentOutboundCallConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<AIAgentOutboundCallConfig>(model1);
      }
    }
    if (m.find("ImsAIAgentFreeObCall") != m.end() && !m["ImsAIAgentFreeObCall"].empty()) {
      imsAIAgentFreeObCall = make_shared<string>(boost::any_cast<string>(m["ImsAIAgentFreeObCall"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~StartAIAgentOutboundCallRequest() = default;
};
class StartAIAgentOutboundCallShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> AIAgentId{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> callerNumber{};
  shared_ptr<string> configShrink{};
  shared_ptr<string> imsAIAgentFreeObCall{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> userData{};

  StartAIAgentOutboundCallShrinkRequest() {}

  explicit StartAIAgentOutboundCallShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIAgentId) {
      res["AIAgentId"] = boost::any(*AIAgentId);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (callerNumber) {
      res["CallerNumber"] = boost::any(*callerNumber);
    }
    if (configShrink) {
      res["Config"] = boost::any(*configShrink);
    }
    if (imsAIAgentFreeObCall) {
      res["ImsAIAgentFreeObCall"] = boost::any(*imsAIAgentFreeObCall);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIAgentId") != m.end() && !m["AIAgentId"].empty()) {
      AIAgentId = make_shared<string>(boost::any_cast<string>(m["AIAgentId"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CallerNumber") != m.end() && !m["CallerNumber"].empty()) {
      callerNumber = make_shared<string>(boost::any_cast<string>(m["CallerNumber"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      configShrink = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("ImsAIAgentFreeObCall") != m.end() && !m["ImsAIAgentFreeObCall"].empty()) {
      imsAIAgentFreeObCall = make_shared<string>(boost::any_cast<string>(m["ImsAIAgentFreeObCall"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~StartAIAgentOutboundCallShrinkRequest() = default;
};
class StartAIAgentOutboundCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};

  StartAIAgentOutboundCallResponseBody() {}

  explicit StartAIAgentOutboundCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartAIAgentOutboundCallResponseBody() = default;
};
class StartAIAgentOutboundCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartAIAgentOutboundCallResponseBody> body{};

  StartAIAgentOutboundCallResponse() {}

  explicit StartAIAgentOutboundCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartAIAgentOutboundCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartAIAgentOutboundCallResponseBody>(model1);
      }
    }
  }


  virtual ~StartAIAgentOutboundCallResponse() = default;
};
class StartChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};

  StartChannelRequest() {}

  explicit StartChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
  }


  virtual ~StartChannelRequest() = default;
};
class StartChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StartChannelResponseBody() {}

  explicit StartChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StartChannelResponseBody() = default;
};
class StartChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartChannelResponseBody> body{};

  StartChannelResponse() {}

  explicit StartChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartChannelResponseBody>(model1);
      }
    }
  }


  virtual ~StartChannelResponse() = default;
};
class StartMediaLiveChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};

  StartMediaLiveChannelRequest() {}

  explicit StartMediaLiveChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
  }


  virtual ~StartMediaLiveChannelRequest() = default;
};
class StartMediaLiveChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StartMediaLiveChannelResponseBody() {}

  explicit StartMediaLiveChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartMediaLiveChannelResponseBody() = default;
};
class StartMediaLiveChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartMediaLiveChannelResponseBody> body{};

  StartMediaLiveChannelResponse() {}

  explicit StartMediaLiveChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartMediaLiveChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartMediaLiveChannelResponseBody>(model1);
      }
    }
  }


  virtual ~StartMediaLiveChannelResponse() = default;
};
class StartRtcRobotInstanceRequestConfig : public Darabonba::Model {
public:
  shared_ptr<long> asrMaxSilence{};
  shared_ptr<bool> enableVoiceInterrupt{};
  shared_ptr<string> greeting{};
  shared_ptr<bool> useVoiceprint{};
  shared_ptr<long> userOfflineTimeout{};
  shared_ptr<long> userOnlineTimeout{};
  shared_ptr<string> voiceId{};
  shared_ptr<string> voiceprintId{};
  shared_ptr<long> volume{};

  StartRtcRobotInstanceRequestConfig() {}

  explicit StartRtcRobotInstanceRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asrMaxSilence) {
      res["AsrMaxSilence"] = boost::any(*asrMaxSilence);
    }
    if (enableVoiceInterrupt) {
      res["EnableVoiceInterrupt"] = boost::any(*enableVoiceInterrupt);
    }
    if (greeting) {
      res["Greeting"] = boost::any(*greeting);
    }
    if (useVoiceprint) {
      res["UseVoiceprint"] = boost::any(*useVoiceprint);
    }
    if (userOfflineTimeout) {
      res["UserOfflineTimeout"] = boost::any(*userOfflineTimeout);
    }
    if (userOnlineTimeout) {
      res["UserOnlineTimeout"] = boost::any(*userOnlineTimeout);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    if (voiceprintId) {
      res["VoiceprintId"] = boost::any(*voiceprintId);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsrMaxSilence") != m.end() && !m["AsrMaxSilence"].empty()) {
      asrMaxSilence = make_shared<long>(boost::any_cast<long>(m["AsrMaxSilence"]));
    }
    if (m.find("EnableVoiceInterrupt") != m.end() && !m["EnableVoiceInterrupt"].empty()) {
      enableVoiceInterrupt = make_shared<bool>(boost::any_cast<bool>(m["EnableVoiceInterrupt"]));
    }
    if (m.find("Greeting") != m.end() && !m["Greeting"].empty()) {
      greeting = make_shared<string>(boost::any_cast<string>(m["Greeting"]));
    }
    if (m.find("UseVoiceprint") != m.end() && !m["UseVoiceprint"].empty()) {
      useVoiceprint = make_shared<bool>(boost::any_cast<bool>(m["UseVoiceprint"]));
    }
    if (m.find("UserOfflineTimeout") != m.end() && !m["UserOfflineTimeout"].empty()) {
      userOfflineTimeout = make_shared<long>(boost::any_cast<long>(m["UserOfflineTimeout"]));
    }
    if (m.find("UserOnlineTimeout") != m.end() && !m["UserOnlineTimeout"].empty()) {
      userOnlineTimeout = make_shared<long>(boost::any_cast<long>(m["UserOnlineTimeout"]));
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
    if (m.find("VoiceprintId") != m.end() && !m["VoiceprintId"].empty()) {
      voiceprintId = make_shared<string>(boost::any_cast<string>(m["VoiceprintId"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<long>(boost::any_cast<long>(m["Volume"]));
    }
  }


  virtual ~StartRtcRobotInstanceRequestConfig() = default;
};
class StartRtcRobotInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> authToken{};
  shared_ptr<string> channelId{};
  shared_ptr<StartRtcRobotInstanceRequestConfig> config{};
  shared_ptr<string> robotId{};
  shared_ptr<string> userData{};
  shared_ptr<string> userId{};

  StartRtcRobotInstanceRequest() {}

  explicit StartRtcRobotInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authToken) {
      res["AuthToken"] = boost::any(*authToken);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (robotId) {
      res["RobotId"] = boost::any(*robotId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthToken") != m.end() && !m["AuthToken"].empty()) {
      authToken = make_shared<string>(boost::any_cast<string>(m["AuthToken"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        StartRtcRobotInstanceRequestConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<StartRtcRobotInstanceRequestConfig>(model1);
      }
    }
    if (m.find("RobotId") != m.end() && !m["RobotId"].empty()) {
      robotId = make_shared<string>(boost::any_cast<string>(m["RobotId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~StartRtcRobotInstanceRequest() = default;
};
class StartRtcRobotInstanceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> authToken{};
  shared_ptr<string> channelId{};
  shared_ptr<string> configShrink{};
  shared_ptr<string> robotId{};
  shared_ptr<string> userData{};
  shared_ptr<string> userId{};

  StartRtcRobotInstanceShrinkRequest() {}

  explicit StartRtcRobotInstanceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authToken) {
      res["AuthToken"] = boost::any(*authToken);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (configShrink) {
      res["Config"] = boost::any(*configShrink);
    }
    if (robotId) {
      res["RobotId"] = boost::any(*robotId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthToken") != m.end() && !m["AuthToken"].empty()) {
      authToken = make_shared<string>(boost::any_cast<string>(m["AuthToken"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      configShrink = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("RobotId") != m.end() && !m["RobotId"].empty()) {
      robotId = make_shared<string>(boost::any_cast<string>(m["RobotId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~StartRtcRobotInstanceShrinkRequest() = default;
};
class StartRtcRobotInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};

  StartRtcRobotInstanceResponseBody() {}

  explicit StartRtcRobotInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartRtcRobotInstanceResponseBody() = default;
};
class StartRtcRobotInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartRtcRobotInstanceResponseBody> body{};

  StartRtcRobotInstanceResponse() {}

  explicit StartRtcRobotInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartRtcRobotInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartRtcRobotInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StartRtcRobotInstanceResponse() = default;
};
class StartWorkflowRequest : public Darabonba::Model {
public:
  shared_ptr<bool> skipInputVerification{};
  shared_ptr<string> taskInput{};
  shared_ptr<string> userData{};
  shared_ptr<string> workflowId{};

  StartWorkflowRequest() {}

  explicit StartWorkflowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skipInputVerification) {
      res["SkipInputVerification"] = boost::any(*skipInputVerification);
    }
    if (taskInput) {
      res["TaskInput"] = boost::any(*taskInput);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkipInputVerification") != m.end() && !m["SkipInputVerification"].empty()) {
      skipInputVerification = make_shared<bool>(boost::any_cast<bool>(m["SkipInputVerification"]));
    }
    if (m.find("TaskInput") != m.end() && !m["TaskInput"].empty()) {
      taskInput = make_shared<string>(boost::any_cast<string>(m["TaskInput"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<string>(boost::any_cast<string>(m["WorkflowId"]));
    }
  }


  virtual ~StartWorkflowRequest() = default;
};
class StartWorkflowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  StartWorkflowResponseBody() {}

  explicit StartWorkflowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~StartWorkflowResponseBody() = default;
};
class StartWorkflowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartWorkflowResponseBody> body{};

  StartWorkflowResponse() {}

  explicit StartWorkflowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartWorkflowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartWorkflowResponseBody>(model1);
      }
    }
  }


  virtual ~StartWorkflowResponse() = default;
};
class StopAIAgentInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  StopAIAgentInstanceRequest() {}

  explicit StopAIAgentInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~StopAIAgentInstanceRequest() = default;
};
class StopAIAgentInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopAIAgentInstanceResponseBody() {}

  explicit StopAIAgentInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopAIAgentInstanceResponseBody() = default;
};
class StopAIAgentInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopAIAgentInstanceResponseBody> body{};

  StopAIAgentInstanceResponse() {}

  explicit StopAIAgentInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopAIAgentInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopAIAgentInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StopAIAgentInstanceResponse() = default;
};
class StopChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};

  StopChannelRequest() {}

  explicit StopChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
  }


  virtual ~StopChannelRequest() = default;
};
class StopChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StopChannelResponseBody() {}

  explicit StopChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StopChannelResponseBody() = default;
};
class StopChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopChannelResponseBody> body{};

  StopChannelResponse() {}

  explicit StopChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopChannelResponseBody>(model1);
      }
    }
  }


  virtual ~StopChannelResponse() = default;
};
class StopMediaLiveChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};

  StopMediaLiveChannelRequest() {}

  explicit StopMediaLiveChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
  }


  virtual ~StopMediaLiveChannelRequest() = default;
};
class StopMediaLiveChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopMediaLiveChannelResponseBody() {}

  explicit StopMediaLiveChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopMediaLiveChannelResponseBody() = default;
};
class StopMediaLiveChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopMediaLiveChannelResponseBody> body{};

  StopMediaLiveChannelResponse() {}

  explicit StopMediaLiveChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopMediaLiveChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopMediaLiveChannelResponseBody>(model1);
      }
    }
  }


  virtual ~StopMediaLiveChannelResponse() = default;
};
class StopRtcRobotInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  StopRtcRobotInstanceRequest() {}

  explicit StopRtcRobotInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~StopRtcRobotInstanceRequest() = default;
};
class StopRtcRobotInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  StopRtcRobotInstanceResponseBody() {}

  explicit StopRtcRobotInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StopRtcRobotInstanceResponseBody() = default;
};
class StopRtcRobotInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopRtcRobotInstanceResponseBody> body{};

  StopRtcRobotInstanceResponse() {}

  explicit StopRtcRobotInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopRtcRobotInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopRtcRobotInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~StopRtcRobotInstanceResponse() = default;
};
class SubmitAIAgentVideoAuditTaskRequestCallbackConfig : public Darabonba::Model {
public:
  shared_ptr<string> token{};
  shared_ptr<string> url{};

  SubmitAIAgentVideoAuditTaskRequestCallbackConfig() {}

  explicit SubmitAIAgentVideoAuditTaskRequestCallbackConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~SubmitAIAgentVideoAuditTaskRequestCallbackConfig() = default;
};
class SubmitAIAgentVideoAuditTaskRequestCapturePolicies : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<long> frameCount{};
  shared_ptr<string> prompt{};
  shared_ptr<long> startTime{};

  SubmitAIAgentVideoAuditTaskRequestCapturePolicies() {}

  explicit SubmitAIAgentVideoAuditTaskRequestCapturePolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (frameCount) {
      res["FrameCount"] = boost::any(*frameCount);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("FrameCount") != m.end() && !m["FrameCount"].empty()) {
      frameCount = make_shared<long>(boost::any_cast<long>(m["FrameCount"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~SubmitAIAgentVideoAuditTaskRequestCapturePolicies() = default;
};
class SubmitAIAgentVideoAuditTaskRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitAIAgentVideoAuditTaskRequestInput() {}

  explicit SubmitAIAgentVideoAuditTaskRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitAIAgentVideoAuditTaskRequestInput() = default;
};
class SubmitAIAgentVideoAuditTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> AIAgentId{};
  shared_ptr<long> auditInterval{};
  shared_ptr<SubmitAIAgentVideoAuditTaskRequestCallbackConfig> callbackConfig{};
  shared_ptr<vector<SubmitAIAgentVideoAuditTaskRequestCapturePolicies>> capturePolicies{};
  shared_ptr<SubmitAIAgentVideoAuditTaskRequestInput> input{};
  shared_ptr<string> userData{};

  SubmitAIAgentVideoAuditTaskRequest() {}

  explicit SubmitAIAgentVideoAuditTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIAgentId) {
      res["AIAgentId"] = boost::any(*AIAgentId);
    }
    if (auditInterval) {
      res["AuditInterval"] = boost::any(*auditInterval);
    }
    if (callbackConfig) {
      res["CallbackConfig"] = callbackConfig ? boost::any(callbackConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (capturePolicies) {
      vector<boost::any> temp1;
      for(auto item1:*capturePolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CapturePolicies"] = boost::any(temp1);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIAgentId") != m.end() && !m["AIAgentId"].empty()) {
      AIAgentId = make_shared<string>(boost::any_cast<string>(m["AIAgentId"]));
    }
    if (m.find("AuditInterval") != m.end() && !m["AuditInterval"].empty()) {
      auditInterval = make_shared<long>(boost::any_cast<long>(m["AuditInterval"]));
    }
    if (m.find("CallbackConfig") != m.end() && !m["CallbackConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallbackConfig"].type()) {
        SubmitAIAgentVideoAuditTaskRequestCallbackConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallbackConfig"]));
        callbackConfig = make_shared<SubmitAIAgentVideoAuditTaskRequestCallbackConfig>(model1);
      }
    }
    if (m.find("CapturePolicies") != m.end() && !m["CapturePolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["CapturePolicies"].type()) {
        vector<SubmitAIAgentVideoAuditTaskRequestCapturePolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CapturePolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitAIAgentVideoAuditTaskRequestCapturePolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        capturePolicies = make_shared<vector<SubmitAIAgentVideoAuditTaskRequestCapturePolicies>>(expect1);
      }
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitAIAgentVideoAuditTaskRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitAIAgentVideoAuditTaskRequestInput>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitAIAgentVideoAuditTaskRequest() = default;
};
class SubmitAIAgentVideoAuditTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> AIAgentId{};
  shared_ptr<long> auditInterval{};
  shared_ptr<string> callbackConfigShrink{};
  shared_ptr<string> capturePoliciesShrink{};
  shared_ptr<string> inputShrink{};
  shared_ptr<string> userData{};

  SubmitAIAgentVideoAuditTaskShrinkRequest() {}

  explicit SubmitAIAgentVideoAuditTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (AIAgentId) {
      res["AIAgentId"] = boost::any(*AIAgentId);
    }
    if (auditInterval) {
      res["AuditInterval"] = boost::any(*auditInterval);
    }
    if (callbackConfigShrink) {
      res["CallbackConfig"] = boost::any(*callbackConfigShrink);
    }
    if (capturePoliciesShrink) {
      res["CapturePolicies"] = boost::any(*capturePoliciesShrink);
    }
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AIAgentId") != m.end() && !m["AIAgentId"].empty()) {
      AIAgentId = make_shared<string>(boost::any_cast<string>(m["AIAgentId"]));
    }
    if (m.find("AuditInterval") != m.end() && !m["AuditInterval"].empty()) {
      auditInterval = make_shared<long>(boost::any_cast<long>(m["AuditInterval"]));
    }
    if (m.find("CallbackConfig") != m.end() && !m["CallbackConfig"].empty()) {
      callbackConfigShrink = make_shared<string>(boost::any_cast<string>(m["CallbackConfig"]));
    }
    if (m.find("CapturePolicies") != m.end() && !m["CapturePolicies"].empty()) {
      capturePoliciesShrink = make_shared<string>(boost::any_cast<string>(m["CapturePolicies"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitAIAgentVideoAuditTaskShrinkRequest() = default;
};
class SubmitAIAgentVideoAuditTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitAIAgentVideoAuditTaskResponseBody() {}

  explicit SubmitAIAgentVideoAuditTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitAIAgentVideoAuditTaskResponseBody() = default;
};
class SubmitAIAgentVideoAuditTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitAIAgentVideoAuditTaskResponseBody> body{};

  SubmitAIAgentVideoAuditTaskResponse() {}

  explicit SubmitAIAgentVideoAuditTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitAIAgentVideoAuditTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitAIAgentVideoAuditTaskResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitAIAgentVideoAuditTaskResponse() = default;
};
class SubmitASRJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> duration{};
  shared_ptr<string> editingConfig{};
  shared_ptr<string> inputFile{};
  shared_ptr<string> startTime{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SubmitASRJobRequest() {}

  explicit SubmitASRJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (editingConfig) {
      res["EditingConfig"] = boost::any(*editingConfig);
    }
    if (inputFile) {
      res["InputFile"] = boost::any(*inputFile);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      editingConfig = make_shared<string>(boost::any_cast<string>(m["EditingConfig"]));
    }
    if (m.find("InputFile") != m.end() && !m["InputFile"].empty()) {
      inputFile = make_shared<string>(boost::any_cast<string>(m["InputFile"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitASRJobRequest() = default;
};
class SubmitASRJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  SubmitASRJobResponseBody() {}

  explicit SubmitASRJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~SubmitASRJobResponseBody() = default;
};
class SubmitASRJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitASRJobResponseBody> body{};

  SubmitASRJobResponse() {}

  explicit SubmitASRJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitASRJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitASRJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitASRJobResponse() = default;
};
class SubmitAudioProduceJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> editingConfig{};
  shared_ptr<string> inputConfig{};
  shared_ptr<string> outputConfig{};
  shared_ptr<bool> overwrite{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SubmitAudioProduceJobRequest() {}

  explicit SubmitAudioProduceJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (editingConfig) {
      res["EditingConfig"] = boost::any(*editingConfig);
    }
    if (inputConfig) {
      res["InputConfig"] = boost::any(*inputConfig);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (overwrite) {
      res["Overwrite"] = boost::any(*overwrite);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      editingConfig = make_shared<string>(boost::any_cast<string>(m["EditingConfig"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      inputConfig = make_shared<string>(boost::any_cast<string>(m["InputConfig"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("Overwrite") != m.end() && !m["Overwrite"].empty()) {
      overwrite = make_shared<bool>(boost::any_cast<bool>(m["Overwrite"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitAudioProduceJobRequest() = default;
};
class SubmitAudioProduceJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  SubmitAudioProduceJobResponseBody() {}

  explicit SubmitAudioProduceJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~SubmitAudioProduceJobResponseBody() = default;
};
class SubmitAudioProduceJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitAudioProduceJobResponseBody> body{};

  SubmitAudioProduceJobResponse() {}

  explicit SubmitAudioProduceJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitAudioProduceJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitAudioProduceJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitAudioProduceJobResponse() = default;
};
class SubmitAvatarTrainingJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  SubmitAvatarTrainingJobRequest() {}

  explicit SubmitAvatarTrainingJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitAvatarTrainingJobRequest() = default;
};
class SubmitAvatarTrainingJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  SubmitAvatarTrainingJobResponseBodyData() {}

  explicit SubmitAvatarTrainingJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitAvatarTrainingJobResponseBodyData() = default;
};
class SubmitAvatarTrainingJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitAvatarTrainingJobResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitAvatarTrainingJobResponseBody() {}

  explicit SubmitAvatarTrainingJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitAvatarTrainingJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitAvatarTrainingJobResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitAvatarTrainingJobResponseBody() = default;
};
class SubmitAvatarTrainingJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitAvatarTrainingJobResponseBody> body{};

  SubmitAvatarTrainingJobResponse() {}

  explicit SubmitAvatarTrainingJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitAvatarTrainingJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitAvatarTrainingJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitAvatarTrainingJobResponse() = default;
};
class SubmitAvatarVideoJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> editingConfig{};
  shared_ptr<string> inputConfig{};
  shared_ptr<string> outputConfig{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SubmitAvatarVideoJobRequest() {}

  explicit SubmitAvatarVideoJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (editingConfig) {
      res["EditingConfig"] = boost::any(*editingConfig);
    }
    if (inputConfig) {
      res["InputConfig"] = boost::any(*inputConfig);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      editingConfig = make_shared<string>(boost::any_cast<string>(m["EditingConfig"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      inputConfig = make_shared<string>(boost::any_cast<string>(m["InputConfig"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitAvatarVideoJobRequest() = default;
};
class SubmitAvatarVideoJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};

  SubmitAvatarVideoJobResponseBody() {}

  explicit SubmitAvatarVideoJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitAvatarVideoJobResponseBody() = default;
};
class SubmitAvatarVideoJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitAvatarVideoJobResponseBody> body{};

  SubmitAvatarVideoJobResponse() {}

  explicit SubmitAvatarVideoJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitAvatarVideoJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitAvatarVideoJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitAvatarVideoJobResponse() = default;
};
class SubmitBatchMediaProducingJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> editingConfig{};
  shared_ptr<string> inputConfig{};
  shared_ptr<string> outputConfig{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> userData{};

  SubmitBatchMediaProducingJobRequest() {}

  explicit SubmitBatchMediaProducingJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (editingConfig) {
      res["EditingConfig"] = boost::any(*editingConfig);
    }
    if (inputConfig) {
      res["InputConfig"] = boost::any(*inputConfig);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      editingConfig = make_shared<string>(boost::any_cast<string>(m["EditingConfig"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      inputConfig = make_shared<string>(boost::any_cast<string>(m["InputConfig"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitBatchMediaProducingJobRequest() = default;
};
class SubmitBatchMediaProducingJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitBatchMediaProducingJobResponseBody() {}

  explicit SubmitBatchMediaProducingJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitBatchMediaProducingJobResponseBody() = default;
};
class SubmitBatchMediaProducingJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitBatchMediaProducingJobResponseBody> body{};

  SubmitBatchMediaProducingJobResponse() {}

  explicit SubmitBatchMediaProducingJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitBatchMediaProducingJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitBatchMediaProducingJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitBatchMediaProducingJobResponse() = default;
};
class SubmitCopyrightExtractJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitCopyrightExtractJobRequestInput() {}

  explicit SubmitCopyrightExtractJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitCopyrightExtractJobRequestInput() = default;
};
class SubmitCopyrightExtractJobRequest : public Darabonba::Model {
public:
  shared_ptr<SubmitCopyrightExtractJobRequestInput> input{};
  shared_ptr<string> params{};
  shared_ptr<string> userData{};

  SubmitCopyrightExtractJobRequest() {}

  explicit SubmitCopyrightExtractJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitCopyrightExtractJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitCopyrightExtractJobRequestInput>(model1);
      }
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitCopyrightExtractJobRequest() = default;
};
class SubmitCopyrightExtractJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputShrink{};
  shared_ptr<string> params{};
  shared_ptr<string> userData{};

  SubmitCopyrightExtractJobShrinkRequest() {}

  explicit SubmitCopyrightExtractJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitCopyrightExtractJobShrinkRequest() = default;
};
class SubmitCopyrightExtractJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  SubmitCopyrightExtractJobResponseBodyData() {}

  explicit SubmitCopyrightExtractJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitCopyrightExtractJobResponseBodyData() = default;
};
class SubmitCopyrightExtractJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitCopyrightExtractJobResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> statusCode{};

  SubmitCopyrightExtractJobResponseBody() {}

  explicit SubmitCopyrightExtractJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitCopyrightExtractJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitCopyrightExtractJobResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["StatusCode"]));
    }
  }


  virtual ~SubmitCopyrightExtractJobResponseBody() = default;
};
class SubmitCopyrightExtractJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitCopyrightExtractJobResponseBody> body{};

  SubmitCopyrightExtractJobResponse() {}

  explicit SubmitCopyrightExtractJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitCopyrightExtractJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitCopyrightExtractJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitCopyrightExtractJobResponse() = default;
};
class SubmitCopyrightJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitCopyrightJobRequestInput() {}

  explicit SubmitCopyrightJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitCopyrightJobRequestInput() = default;
};
class SubmitCopyrightJobRequestOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitCopyrightJobRequestOutput() {}

  explicit SubmitCopyrightJobRequestOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitCopyrightJobRequestOutput() = default;
};
class SubmitCopyrightJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<SubmitCopyrightJobRequestInput> input{};
  shared_ptr<long> level{};
  shared_ptr<string> message{};
  shared_ptr<SubmitCopyrightJobRequestOutput> output{};
  shared_ptr<string> params{};
  shared_ptr<long> startTime{};
  shared_ptr<long> totalTime{};
  shared_ptr<string> userData{};

  SubmitCopyrightJobRequest() {}

  explicit SubmitCopyrightJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (totalTime) {
      res["TotalTime"] = boost::any(*totalTime);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitCopyrightJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitCopyrightJobRequestInput>(model1);
      }
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitCopyrightJobRequestOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitCopyrightJobRequestOutput>(model1);
      }
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TotalTime") != m.end() && !m["TotalTime"].empty()) {
      totalTime = make_shared<long>(boost::any_cast<long>(m["TotalTime"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitCopyrightJobRequest() = default;
};
class SubmitCopyrightJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> inputShrink{};
  shared_ptr<long> level{};
  shared_ptr<string> message{};
  shared_ptr<string> outputShrink{};
  shared_ptr<string> params{};
  shared_ptr<long> startTime{};
  shared_ptr<long> totalTime{};
  shared_ptr<string> userData{};

  SubmitCopyrightJobShrinkRequest() {}

  explicit SubmitCopyrightJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (outputShrink) {
      res["Output"] = boost::any(*outputShrink);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (totalTime) {
      res["TotalTime"] = boost::any(*totalTime);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      outputShrink = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TotalTime") != m.end() && !m["TotalTime"].empty()) {
      totalTime = make_shared<long>(boost::any_cast<long>(m["TotalTime"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitCopyrightJobShrinkRequest() = default;
};
class SubmitCopyrightJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  SubmitCopyrightJobResponseBodyData() {}

  explicit SubmitCopyrightJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitCopyrightJobResponseBodyData() = default;
};
class SubmitCopyrightJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitCopyrightJobResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> statusCode{};

  SubmitCopyrightJobResponseBody() {}

  explicit SubmitCopyrightJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitCopyrightJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitCopyrightJobResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["StatusCode"]));
    }
  }


  virtual ~SubmitCopyrightJobResponseBody() = default;
};
class SubmitCopyrightJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitCopyrightJobResponseBody> body{};

  SubmitCopyrightJobResponse() {}

  explicit SubmitCopyrightJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitCopyrightJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitCopyrightJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitCopyrightJobResponse() = default;
};
class SubmitCustomizedVoiceJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> demoAudioMediaURL{};
  shared_ptr<string> voiceId{};

  SubmitCustomizedVoiceJobRequest() {}

  explicit SubmitCustomizedVoiceJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoAudioMediaURL) {
      res["DemoAudioMediaURL"] = boost::any(*demoAudioMediaURL);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoAudioMediaURL") != m.end() && !m["DemoAudioMediaURL"].empty()) {
      demoAudioMediaURL = make_shared<string>(boost::any_cast<string>(m["DemoAudioMediaURL"]));
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
  }


  virtual ~SubmitCustomizedVoiceJobRequest() = default;
};
class SubmitCustomizedVoiceJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> voiceId{};

  SubmitCustomizedVoiceJobResponseBodyData() {}

  explicit SubmitCustomizedVoiceJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
  }


  virtual ~SubmitCustomizedVoiceJobResponseBodyData() = default;
};
class SubmitCustomizedVoiceJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitCustomizedVoiceJobResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitCustomizedVoiceJobResponseBody() {}

  explicit SubmitCustomizedVoiceJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitCustomizedVoiceJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitCustomizedVoiceJobResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitCustomizedVoiceJobResponseBody() = default;
};
class SubmitCustomizedVoiceJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitCustomizedVoiceJobResponseBody> body{};

  SubmitCustomizedVoiceJobResponse() {}

  explicit SubmitCustomizedVoiceJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitCustomizedVoiceJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitCustomizedVoiceJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitCustomizedVoiceJobResponse() = default;
};
class SubmitDNAJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitDNAJobRequestInput() {}

  explicit SubmitDNAJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitDNAJobRequestInput() = default;
};
class SubmitDNAJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> DBId{};
  shared_ptr<SubmitDNAJobRequestInput> input{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> primaryKey{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> userData{};

  SubmitDNAJobRequest() {}

  explicit SubmitDNAJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (DBId) {
      res["DBId"] = boost::any(*DBId);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("DBId") != m.end() && !m["DBId"].empty()) {
      DBId = make_shared<string>(boost::any_cast<string>(m["DBId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitDNAJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitDNAJobRequestInput>(model1);
      }
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitDNAJobRequest() = default;
};
class SubmitDNAJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> DBId{};
  shared_ptr<string> inputShrink{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> primaryKey{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> userData{};

  SubmitDNAJobShrinkRequest() {}

  explicit SubmitDNAJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (DBId) {
      res["DBId"] = boost::any(*DBId);
    }
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("DBId") != m.end() && !m["DBId"].empty()) {
      DBId = make_shared<string>(boost::any_cast<string>(m["DBId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<string>(boost::any_cast<string>(m["PrimaryKey"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitDNAJobShrinkRequest() = default;
};
class SubmitDNAJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitDNAJobResponseBody() {}

  explicit SubmitDNAJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitDNAJobResponseBody() = default;
};
class SubmitDNAJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitDNAJobResponseBody> body{};

  SubmitDNAJobResponse() {}

  explicit SubmitDNAJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitDNAJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitDNAJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitDNAJobResponse() = default;
};
class SubmitDynamicChartJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> axisParams{};
  shared_ptr<string> background{};
  shared_ptr<string> chartConfig{};
  shared_ptr<string> chartTitle{};
  shared_ptr<string> chartType{};
  shared_ptr<string> dataSource{};
  shared_ptr<string> description{};
  shared_ptr<string> input{};
  shared_ptr<string> outputConfig{};
  shared_ptr<string> subtitle{};
  shared_ptr<string> title{};
  shared_ptr<string> unit{};
  shared_ptr<string> userData{};

  SubmitDynamicChartJobRequest() {}

  explicit SubmitDynamicChartJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (axisParams) {
      res["AxisParams"] = boost::any(*axisParams);
    }
    if (background) {
      res["Background"] = boost::any(*background);
    }
    if (chartConfig) {
      res["ChartConfig"] = boost::any(*chartConfig);
    }
    if (chartTitle) {
      res["ChartTitle"] = boost::any(*chartTitle);
    }
    if (chartType) {
      res["ChartType"] = boost::any(*chartType);
    }
    if (dataSource) {
      res["DataSource"] = boost::any(*dataSource);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (subtitle) {
      res["Subtitle"] = boost::any(*subtitle);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AxisParams") != m.end() && !m["AxisParams"].empty()) {
      axisParams = make_shared<string>(boost::any_cast<string>(m["AxisParams"]));
    }
    if (m.find("Background") != m.end() && !m["Background"].empty()) {
      background = make_shared<string>(boost::any_cast<string>(m["Background"]));
    }
    if (m.find("ChartConfig") != m.end() && !m["ChartConfig"].empty()) {
      chartConfig = make_shared<string>(boost::any_cast<string>(m["ChartConfig"]));
    }
    if (m.find("ChartTitle") != m.end() && !m["ChartTitle"].empty()) {
      chartTitle = make_shared<string>(boost::any_cast<string>(m["ChartTitle"]));
    }
    if (m.find("ChartType") != m.end() && !m["ChartType"].empty()) {
      chartType = make_shared<string>(boost::any_cast<string>(m["ChartType"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      dataSource = make_shared<string>(boost::any_cast<string>(m["DataSource"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      subtitle = make_shared<string>(boost::any_cast<string>(m["Subtitle"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitDynamicChartJobRequest() = default;
};
class SubmitDynamicChartJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitDynamicChartJobResponseBody() {}

  explicit SubmitDynamicChartJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitDynamicChartJobResponseBody() = default;
};
class SubmitDynamicChartJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitDynamicChartJobResponseBody> body{};

  SubmitDynamicChartJobResponse() {}

  explicit SubmitDynamicChartJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitDynamicChartJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitDynamicChartJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitDynamicChartJobResponse() = default;
};
class SubmitDynamicImageJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitDynamicImageJobRequestInput() {}

  explicit SubmitDynamicImageJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitDynamicImageJobRequestInput() = default;
};
class SubmitDynamicImageJobRequestOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitDynamicImageJobRequestOutput() {}

  explicit SubmitDynamicImageJobRequestOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitDynamicImageJobRequestOutput() = default;
};
class SubmitDynamicImageJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitDynamicImageJobRequestScheduleConfig() {}

  explicit SubmitDynamicImageJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitDynamicImageJobRequestScheduleConfig() = default;
};
class SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> end{};
  shared_ptr<string> seek{};

  SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan() {}

  explicit SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (seek) {
      res["Seek"] = boost::any(*seek);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
    if (m.find("Seek") != m.end() && !m["Seek"].empty()) {
      seek = make_shared<string>(boost::any_cast<string>(m["Seek"]));
    }
  }


  virtual ~SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan() = default;
};
class SubmitDynamicImageJobRequestTemplateConfigOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<long> fps{};
  shared_ptr<long> height{};
  shared_ptr<bool> longShortMode{};
  shared_ptr<string> scanMode{};
  shared_ptr<SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan> timeSpan{};
  shared_ptr<long> width{};

  SubmitDynamicImageJobRequestTemplateConfigOverwriteParams() {}

  explicit SubmitDynamicImageJobRequestTemplateConfigOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (timeSpan) {
      res["TimeSpan"] = timeSpan ? boost::any(timeSpan->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<long>(boost::any_cast<long>(m["Fps"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<bool>(boost::any_cast<bool>(m["LongShortMode"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("TimeSpan") != m.end() && !m["TimeSpan"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSpan"].type()) {
        SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSpan"]));
        timeSpan = make_shared<SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~SubmitDynamicImageJobRequestTemplateConfigOverwriteParams() = default;
};
class SubmitDynamicImageJobRequestTemplateConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitDynamicImageJobRequestTemplateConfigOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitDynamicImageJobRequestTemplateConfig() {}

  explicit SubmitDynamicImageJobRequestTemplateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitDynamicImageJobRequestTemplateConfigOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitDynamicImageJobRequestTemplateConfigOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitDynamicImageJobRequestTemplateConfig() = default;
};
class SubmitDynamicImageJobRequest : public Darabonba::Model {
public:
  shared_ptr<SubmitDynamicImageJobRequestInput> input{};
  shared_ptr<string> name{};
  shared_ptr<SubmitDynamicImageJobRequestOutput> output{};
  shared_ptr<SubmitDynamicImageJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<SubmitDynamicImageJobRequestTemplateConfig> templateConfig{};
  shared_ptr<string> userData{};

  SubmitDynamicImageJobRequest() {}

  explicit SubmitDynamicImageJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitDynamicImageJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitDynamicImageJobRequestInput>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitDynamicImageJobRequestOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitDynamicImageJobRequestOutput>(model1);
      }
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitDynamicImageJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitDynamicImageJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        SubmitDynamicImageJobRequestTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<SubmitDynamicImageJobRequestTemplateConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitDynamicImageJobRequest() = default;
};
class SubmitDynamicImageJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> outputShrink{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> templateConfigShrink{};
  shared_ptr<string> userData{};

  SubmitDynamicImageJobShrinkRequest() {}

  explicit SubmitDynamicImageJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputShrink) {
      res["Output"] = boost::any(*outputShrink);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (templateConfigShrink) {
      res["TemplateConfig"] = boost::any(*templateConfigShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      outputShrink = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfigShrink = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitDynamicImageJobShrinkRequest() = default;
};
class SubmitDynamicImageJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitDynamicImageJobResponseBody() {}

  explicit SubmitDynamicImageJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitDynamicImageJobResponseBody() = default;
};
class SubmitDynamicImageJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitDynamicImageJobResponseBody> body{};

  SubmitDynamicImageJobResponse() {}

  explicit SubmitDynamicImageJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitDynamicImageJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitDynamicImageJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitDynamicImageJobResponse() = default;
};
class SubmitHighlightExtractionJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> inputConfig{};
  shared_ptr<string> outputConfig{};
  shared_ptr<string> userData{};

  SubmitHighlightExtractionJobRequest() {}

  explicit SubmitHighlightExtractionJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (inputConfig) {
      res["InputConfig"] = boost::any(*inputConfig);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      inputConfig = make_shared<string>(boost::any_cast<string>(m["InputConfig"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitHighlightExtractionJobRequest() = default;
};
class SubmitHighlightExtractionJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitHighlightExtractionJobResponseBody() {}

  explicit SubmitHighlightExtractionJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitHighlightExtractionJobResponseBody() = default;
};
class SubmitHighlightExtractionJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitHighlightExtractionJobResponseBody> body{};

  SubmitHighlightExtractionJobResponse() {}

  explicit SubmitHighlightExtractionJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitHighlightExtractionJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitHighlightExtractionJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitHighlightExtractionJobResponse() = default;
};
class SubmitIProductionJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitIProductionJobRequestInput() {}

  explicit SubmitIProductionJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitIProductionJobRequestInput() = default;
};
class SubmitIProductionJobRequestOutput : public Darabonba::Model {
public:
  shared_ptr<string> biz{};
  shared_ptr<string> media{};
  shared_ptr<string> outputUrl{};
  shared_ptr<string> type{};

  SubmitIProductionJobRequestOutput() {}

  explicit SubmitIProductionJobRequestOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (biz) {
      res["Biz"] = boost::any(*biz);
    }
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (outputUrl) {
      res["OutputUrl"] = boost::any(*outputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Biz") != m.end() && !m["Biz"].empty()) {
      biz = make_shared<string>(boost::any_cast<string>(m["Biz"]));
    }
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("OutputUrl") != m.end() && !m["OutputUrl"].empty()) {
      outputUrl = make_shared<string>(boost::any_cast<string>(m["OutputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitIProductionJobRequestOutput() = default;
};
class SubmitIProductionJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitIProductionJobRequestScheduleConfig() {}

  explicit SubmitIProductionJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitIProductionJobRequestScheduleConfig() = default;
};
class SubmitIProductionJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionName{};
  shared_ptr<SubmitIProductionJobRequestInput> input{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> modelId{};
  shared_ptr<string> name{};
  shared_ptr<SubmitIProductionJobRequestOutput> output{};
  shared_ptr<SubmitIProductionJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> userData{};

  SubmitIProductionJobRequest() {}

  explicit SubmitIProductionJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitIProductionJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitIProductionJobRequestInput>(model1);
      }
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitIProductionJobRequestOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitIProductionJobRequestOutput>(model1);
      }
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitIProductionJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitIProductionJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitIProductionJobRequest() = default;
};
class SubmitIProductionJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> functionName{};
  shared_ptr<string> inputShrink{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> modelId{};
  shared_ptr<string> name{};
  shared_ptr<string> outputShrink{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> templateId{};
  shared_ptr<string> userData{};

  SubmitIProductionJobShrinkRequest() {}

  explicit SubmitIProductionJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputShrink) {
      res["Output"] = boost::any(*outputShrink);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      outputShrink = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitIProductionJobShrinkRequest() = default;
};
class SubmitIProductionJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitIProductionJobResponseBody() {}

  explicit SubmitIProductionJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitIProductionJobResponseBody() = default;
};
class SubmitIProductionJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitIProductionJobResponseBody> body{};

  SubmitIProductionJobResponse() {}

  explicit SubmitIProductionJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitIProductionJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitIProductionJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitIProductionJobResponse() = default;
};
class SubmitLiveEditingJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clips{};
  shared_ptr<string> liveStreamConfig{};
  shared_ptr<string> mediaProduceConfig{};
  shared_ptr<string> outputMediaConfig{};
  shared_ptr<string> outputMediaTarget{};
  shared_ptr<string> projectId{};
  shared_ptr<string> userData{};

  SubmitLiveEditingJobRequest() {}

  explicit SubmitLiveEditingJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clips) {
      res["Clips"] = boost::any(*clips);
    }
    if (liveStreamConfig) {
      res["LiveStreamConfig"] = boost::any(*liveStreamConfig);
    }
    if (mediaProduceConfig) {
      res["MediaProduceConfig"] = boost::any(*mediaProduceConfig);
    }
    if (outputMediaConfig) {
      res["OutputMediaConfig"] = boost::any(*outputMediaConfig);
    }
    if (outputMediaTarget) {
      res["OutputMediaTarget"] = boost::any(*outputMediaTarget);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clips") != m.end() && !m["Clips"].empty()) {
      clips = make_shared<string>(boost::any_cast<string>(m["Clips"]));
    }
    if (m.find("LiveStreamConfig") != m.end() && !m["LiveStreamConfig"].empty()) {
      liveStreamConfig = make_shared<string>(boost::any_cast<string>(m["LiveStreamConfig"]));
    }
    if (m.find("MediaProduceConfig") != m.end() && !m["MediaProduceConfig"].empty()) {
      mediaProduceConfig = make_shared<string>(boost::any_cast<string>(m["MediaProduceConfig"]));
    }
    if (m.find("OutputMediaConfig") != m.end() && !m["OutputMediaConfig"].empty()) {
      outputMediaConfig = make_shared<string>(boost::any_cast<string>(m["OutputMediaConfig"]));
    }
    if (m.find("OutputMediaTarget") != m.end() && !m["OutputMediaTarget"].empty()) {
      outputMediaTarget = make_shared<string>(boost::any_cast<string>(m["OutputMediaTarget"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitLiveEditingJobRequest() = default;
};
class SubmitLiveEditingJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaURL{};
  shared_ptr<string> projectId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vodMediaId{};

  SubmitLiveEditingJobResponseBody() {}

  explicit SubmitLiveEditingJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaURL) {
      res["MediaURL"] = boost::any(*mediaURL);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vodMediaId) {
      res["VodMediaId"] = boost::any(*vodMediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaURL") != m.end() && !m["MediaURL"].empty()) {
      mediaURL = make_shared<string>(boost::any_cast<string>(m["MediaURL"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VodMediaId") != m.end() && !m["VodMediaId"].empty()) {
      vodMediaId = make_shared<string>(boost::any_cast<string>(m["VodMediaId"]));
    }
  }


  virtual ~SubmitLiveEditingJobResponseBody() = default;
};
class SubmitLiveEditingJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitLiveEditingJobResponseBody> body{};

  SubmitLiveEditingJobResponse() {}

  explicit SubmitLiveEditingJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitLiveEditingJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitLiveEditingJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitLiveEditingJobResponse() = default;
};
class SubmitLiveRecordJobRequestRecordOutput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> type{};

  SubmitLiveRecordJobRequestRecordOutput() {}

  explicit SubmitLiveRecordJobRequestRecordOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitLiveRecordJobRequestRecordOutput() = default;
};
class SubmitLiveRecordJobRequestStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  SubmitLiveRecordJobRequestStreamInput() {}

  explicit SubmitLiveRecordJobRequestStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~SubmitLiveRecordJobRequestStreamInput() = default;
};
class SubmitLiveRecordJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<SubmitLiveRecordJobRequestRecordOutput> recordOutput{};
  shared_ptr<SubmitLiveRecordJobRequestStreamInput> streamInput{};
  shared_ptr<string> templateId{};

  SubmitLiveRecordJobRequest() {}

  explicit SubmitLiveRecordJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (recordOutput) {
      res["RecordOutput"] = recordOutput ? boost::any(recordOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("RecordOutput") != m.end() && !m["RecordOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecordOutput"].type()) {
        SubmitLiveRecordJobRequestRecordOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecordOutput"]));
        recordOutput = make_shared<SubmitLiveRecordJobRequestRecordOutput>(model1);
      }
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        SubmitLiveRecordJobRequestStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<SubmitLiveRecordJobRequestStreamInput>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitLiveRecordJobRequest() = default;
};
class SubmitLiveRecordJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> recordOutputShrink{};
  shared_ptr<string> streamInputShrink{};
  shared_ptr<string> templateId{};

  SubmitLiveRecordJobShrinkRequest() {}

  explicit SubmitLiveRecordJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (recordOutputShrink) {
      res["RecordOutput"] = boost::any(*recordOutputShrink);
    }
    if (streamInputShrink) {
      res["StreamInput"] = boost::any(*streamInputShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("RecordOutput") != m.end() && !m["RecordOutput"].empty()) {
      recordOutputShrink = make_shared<string>(boost::any_cast<string>(m["RecordOutput"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      streamInputShrink = make_shared<string>(boost::any_cast<string>(m["StreamInput"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitLiveRecordJobShrinkRequest() = default;
};
class SubmitLiveRecordJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitLiveRecordJobResponseBody() {}

  explicit SubmitLiveRecordJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitLiveRecordJobResponseBody() = default;
};
class SubmitLiveRecordJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitLiveRecordJobResponseBody> body{};

  SubmitLiveRecordJobResponse() {}

  explicit SubmitLiveRecordJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitLiveRecordJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitLiveRecordJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitLiveRecordJobResponse() = default;
};
class SubmitLiveSnapshotJobRequestSnapshotOutput : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> storageType{};

  SubmitLiveSnapshotJobRequestSnapshotOutput() {}

  explicit SubmitLiveSnapshotJobRequestSnapshotOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~SubmitLiveSnapshotJobRequestSnapshotOutput() = default;
};
class SubmitLiveSnapshotJobRequestStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> url{};

  SubmitLiveSnapshotJobRequestStreamInput() {}

  explicit SubmitLiveSnapshotJobRequestStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~SubmitLiveSnapshotJobRequestStreamInput() = default;
};
class SubmitLiveSnapshotJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> jobName{};
  shared_ptr<SubmitLiveSnapshotJobRequestSnapshotOutput> snapshotOutput{};
  shared_ptr<SubmitLiveSnapshotJobRequestStreamInput> streamInput{};
  shared_ptr<string> templateId{};

  SubmitLiveSnapshotJobRequest() {}

  explicit SubmitLiveSnapshotJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (snapshotOutput) {
      res["SnapshotOutput"] = snapshotOutput ? boost::any(snapshotOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("SnapshotOutput") != m.end() && !m["SnapshotOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnapshotOutput"].type()) {
        SubmitLiveSnapshotJobRequestSnapshotOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnapshotOutput"]));
        snapshotOutput = make_shared<SubmitLiveSnapshotJobRequestSnapshotOutput>(model1);
      }
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        SubmitLiveSnapshotJobRequestStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<SubmitLiveSnapshotJobRequestStreamInput>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitLiveSnapshotJobRequest() = default;
};
class SubmitLiveSnapshotJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> jobName{};
  shared_ptr<string> snapshotOutputShrink{};
  shared_ptr<string> streamInputShrink{};
  shared_ptr<string> templateId{};

  SubmitLiveSnapshotJobShrinkRequest() {}

  explicit SubmitLiveSnapshotJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (snapshotOutputShrink) {
      res["SnapshotOutput"] = boost::any(*snapshotOutputShrink);
    }
    if (streamInputShrink) {
      res["StreamInput"] = boost::any(*streamInputShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("SnapshotOutput") != m.end() && !m["SnapshotOutput"].empty()) {
      snapshotOutputShrink = make_shared<string>(boost::any_cast<string>(m["SnapshotOutput"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      streamInputShrink = make_shared<string>(boost::any_cast<string>(m["StreamInput"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitLiveSnapshotJobShrinkRequest() = default;
};
class SubmitLiveSnapshotJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitLiveSnapshotJobResponseBody() {}

  explicit SubmitLiveSnapshotJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitLiveSnapshotJobResponseBody() = default;
};
class SubmitLiveSnapshotJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitLiveSnapshotJobResponseBody> body{};

  SubmitLiveSnapshotJobResponse() {}

  explicit SubmitLiveSnapshotJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitLiveSnapshotJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitLiveSnapshotJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitLiveSnapshotJobResponse() = default;
};
class SubmitLiveTranscodeJobRequestStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> inputUrl{};
  shared_ptr<string> type{};

  SubmitLiveTranscodeJobRequestStreamInput() {}

  explicit SubmitLiveTranscodeJobRequestStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputUrl) {
      res["InputUrl"] = boost::any(*inputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputUrl") != m.end() && !m["InputUrl"].empty()) {
      inputUrl = make_shared<string>(boost::any_cast<string>(m["InputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitLiveTranscodeJobRequestStreamInput() = default;
};
class SubmitLiveTranscodeJobRequestTimedConfig : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  SubmitLiveTranscodeJobRequestTimedConfig() {}

  explicit SubmitLiveTranscodeJobRequestTimedConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~SubmitLiveTranscodeJobRequestTimedConfig() = default;
};
class SubmitLiveTranscodeJobRequestTranscodeOutput : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> type{};

  SubmitLiveTranscodeJobRequestTranscodeOutput() {}

  explicit SubmitLiveTranscodeJobRequestTranscodeOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitLiveTranscodeJobRequestTranscodeOutput() = default;
};
class SubmitLiveTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> startMode{};
  shared_ptr<SubmitLiveTranscodeJobRequestStreamInput> streamInput{};
  shared_ptr<string> templateId{};
  shared_ptr<SubmitLiveTranscodeJobRequestTimedConfig> timedConfig{};
  shared_ptr<SubmitLiveTranscodeJobRequestTranscodeOutput> transcodeOutput{};

  SubmitLiveTranscodeJobRequest() {}

  explicit SubmitLiveTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startMode) {
      res["StartMode"] = boost::any(*startMode);
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (timedConfig) {
      res["TimedConfig"] = timedConfig ? boost::any(timedConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transcodeOutput) {
      res["TranscodeOutput"] = transcodeOutput ? boost::any(transcodeOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartMode") != m.end() && !m["StartMode"].empty()) {
      startMode = make_shared<long>(boost::any_cast<long>(m["StartMode"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        SubmitLiveTranscodeJobRequestStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<SubmitLiveTranscodeJobRequestStreamInput>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TimedConfig") != m.end() && !m["TimedConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimedConfig"].type()) {
        SubmitLiveTranscodeJobRequestTimedConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimedConfig"]));
        timedConfig = make_shared<SubmitLiveTranscodeJobRequestTimedConfig>(model1);
      }
    }
    if (m.find("TranscodeOutput") != m.end() && !m["TranscodeOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeOutput"].type()) {
        SubmitLiveTranscodeJobRequestTranscodeOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeOutput"]));
        transcodeOutput = make_shared<SubmitLiveTranscodeJobRequestTranscodeOutput>(model1);
      }
    }
  }


  virtual ~SubmitLiveTranscodeJobRequest() = default;
};
class SubmitLiveTranscodeJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> startMode{};
  shared_ptr<string> streamInputShrink{};
  shared_ptr<string> templateId{};
  shared_ptr<string> timedConfigShrink{};
  shared_ptr<string> transcodeOutputShrink{};

  SubmitLiveTranscodeJobShrinkRequest() {}

  explicit SubmitLiveTranscodeJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (startMode) {
      res["StartMode"] = boost::any(*startMode);
    }
    if (streamInputShrink) {
      res["StreamInput"] = boost::any(*streamInputShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (timedConfigShrink) {
      res["TimedConfig"] = boost::any(*timedConfigShrink);
    }
    if (transcodeOutputShrink) {
      res["TranscodeOutput"] = boost::any(*transcodeOutputShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StartMode") != m.end() && !m["StartMode"].empty()) {
      startMode = make_shared<long>(boost::any_cast<long>(m["StartMode"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      streamInputShrink = make_shared<string>(boost::any_cast<string>(m["StreamInput"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TimedConfig") != m.end() && !m["TimedConfig"].empty()) {
      timedConfigShrink = make_shared<string>(boost::any_cast<string>(m["TimedConfig"]));
    }
    if (m.find("TranscodeOutput") != m.end() && !m["TranscodeOutput"].empty()) {
      transcodeOutputShrink = make_shared<string>(boost::any_cast<string>(m["TranscodeOutput"]));
    }
  }


  virtual ~SubmitLiveTranscodeJobShrinkRequest() = default;
};
class SubmitLiveTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitLiveTranscodeJobResponseBody() {}

  explicit SubmitLiveTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitLiveTranscodeJobResponseBody() = default;
};
class SubmitLiveTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitLiveTranscodeJobResponseBody> body{};

  SubmitLiveTranscodeJobResponse() {}

  explicit SubmitLiveTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitLiveTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitLiveTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitLiveTranscodeJobResponse() = default;
};
class SubmitMediaAiAnalysisJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> analysisParams{};
  shared_ptr<string> input{};
  shared_ptr<string> userData{};

  SubmitMediaAiAnalysisJobRequest() {}

  explicit SubmitMediaAiAnalysisJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisParams) {
      res["AnalysisParams"] = boost::any(*analysisParams);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisParams") != m.end() && !m["AnalysisParams"].empty()) {
      analysisParams = make_shared<string>(boost::any_cast<string>(m["AnalysisParams"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaAiAnalysisJobRequest() = default;
};
class SubmitMediaAiAnalysisJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};

  SubmitMediaAiAnalysisJobResponseBody() {}

  explicit SubmitMediaAiAnalysisJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitMediaAiAnalysisJobResponseBody() = default;
};
class SubmitMediaAiAnalysisJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitMediaAiAnalysisJobResponseBody> body{};

  SubmitMediaAiAnalysisJobResponse() {}

  explicit SubmitMediaAiAnalysisJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMediaAiAnalysisJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMediaAiAnalysisJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMediaAiAnalysisJobResponse() = default;
};
class SubmitMediaCensorJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitMediaCensorJobRequestInput() {}

  explicit SubmitMediaCensorJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitMediaCensorJobRequestInput() = default;
};
class SubmitMediaCensorJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitMediaCensorJobRequestScheduleConfig() {}

  explicit SubmitMediaCensorJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitMediaCensorJobRequestScheduleConfig() = default;
};
class SubmitMediaCensorJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> barrages{};
  shared_ptr<string> coverImages{};
  shared_ptr<string> description{};
  shared_ptr<SubmitMediaCensorJobRequestInput> input{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> output{};
  shared_ptr<SubmitMediaCensorJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SubmitMediaCensorJobRequest() {}

  explicit SubmitMediaCensorJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (barrages) {
      res["Barrages"] = boost::any(*barrages);
    }
    if (coverImages) {
      res["CoverImages"] = boost::any(*coverImages);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Barrages") != m.end() && !m["Barrages"].empty()) {
      barrages = make_shared<string>(boost::any_cast<string>(m["Barrages"]));
    }
    if (m.find("CoverImages") != m.end() && !m["CoverImages"].empty()) {
      coverImages = make_shared<string>(boost::any_cast<string>(m["CoverImages"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitMediaCensorJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitMediaCensorJobRequestInput>(model1);
      }
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitMediaCensorJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitMediaCensorJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaCensorJobRequest() = default;
};
class SubmitMediaCensorJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> barrages{};
  shared_ptr<string> coverImages{};
  shared_ptr<string> description{};
  shared_ptr<string> inputShrink{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> output{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> templateId{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SubmitMediaCensorJobShrinkRequest() {}

  explicit SubmitMediaCensorJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (barrages) {
      res["Barrages"] = boost::any(*barrages);
    }
    if (coverImages) {
      res["CoverImages"] = boost::any(*coverImages);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Barrages") != m.end() && !m["Barrages"].empty()) {
      barrages = make_shared<string>(boost::any_cast<string>(m["Barrages"]));
    }
    if (m.find("CoverImages") != m.end() && !m["CoverImages"].empty()) {
      coverImages = make_shared<string>(boost::any_cast<string>(m["CoverImages"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaCensorJobShrinkRequest() = default;
};
class SubmitMediaCensorJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitMediaCensorJobResponseBody() {}

  explicit SubmitMediaCensorJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitMediaCensorJobResponseBody() = default;
};
class SubmitMediaCensorJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitMediaCensorJobResponseBody> body{};

  SubmitMediaCensorJobResponse() {}

  explicit SubmitMediaCensorJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMediaCensorJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMediaCensorJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMediaCensorJobResponse() = default;
};
class SubmitMediaConvertJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> config{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> userData{};

  SubmitMediaConvertJobRequest() {}

  explicit SubmitMediaConvertJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaConvertJobRequest() = default;
};
class SubmitMediaConvertJobResponseBodyJobConfig : public Darabonba::Model {
public:
  shared_ptr<vector<MediaConvertInput>> inputs{};
  shared_ptr<string> jobName{};
  shared_ptr<vector<MediaConvertOutputGroup>> outputGroups{};
  shared_ptr<vector<MediaConvertOutput>> outputs{};

  SubmitMediaConvertJobResponseBodyJobConfig() {}

  explicit SubmitMediaConvertJobResponseBodyJobConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputs) {
      vector<boost::any> temp1;
      for(auto item1:*inputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Inputs"] = boost::any(temp1);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (outputGroups) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroups"] = boost::any(temp1);
    }
    if (outputs) {
      vector<boost::any> temp1;
      for(auto item1:*outputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outputs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Inputs"].type()) {
        vector<MediaConvertInput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Inputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertInput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputs = make_shared<vector<MediaConvertInput>>(expect1);
      }
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("OutputGroups") != m.end() && !m["OutputGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroups"].type()) {
        vector<MediaConvertOutputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroups = make_shared<vector<MediaConvertOutputGroup>>(expect1);
      }
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Outputs"].type()) {
        vector<MediaConvertOutput> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutput model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputs = make_shared<vector<MediaConvertOutput>>(expect1);
      }
    }
  }


  virtual ~SubmitMediaConvertJobResponseBodyJobConfig() = default;
};
class SubmitMediaConvertJobResponseBodyJob : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> code{};
  shared_ptr<SubmitMediaConvertJobResponseBodyJobConfig> config{};
  shared_ptr<string> jobId{};
  shared_ptr<string> message{};
  shared_ptr<vector<MediaConvertOutputDetail>> outputDetails{};
  shared_ptr<vector<MediaConvertOutputGroupDetail>> outputGroupDetails{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};
  shared_ptr<string> userData{};

  SubmitMediaConvertJobResponseBodyJob() {}

  explicit SubmitMediaConvertJobResponseBodyJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (outputDetails) {
      vector<boost::any> temp1;
      for(auto item1:*outputDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputDetails"] = boost::any(temp1);
    }
    if (outputGroupDetails) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroupDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroupDetails"] = boost::any(temp1);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        SubmitMediaConvertJobResponseBodyJobConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<SubmitMediaConvertJobResponseBodyJobConfig>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OutputDetails") != m.end() && !m["OutputDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputDetails"].type()) {
        vector<MediaConvertOutputDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutputDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputDetails = make_shared<vector<MediaConvertOutputDetail>>(expect1);
      }
    }
    if (m.find("OutputGroupDetails") != m.end() && !m["OutputGroupDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroupDetails"].type()) {
        vector<MediaConvertOutputGroupDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroupDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MediaConvertOutputGroupDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroupDetails = make_shared<vector<MediaConvertOutputGroupDetail>>(expect1);
      }
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaConvertJobResponseBodyJob() = default;
};
class SubmitMediaConvertJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitMediaConvertJobResponseBodyJob> job{};
  shared_ptr<string> requestId{};

  SubmitMediaConvertJobResponseBody() {}

  explicit SubmitMediaConvertJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (job) {
      res["Job"] = job ? boost::any(job->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(map<string, boost::any>) == m["Job"].type()) {
        SubmitMediaConvertJobResponseBodyJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Job"]));
        job = make_shared<SubmitMediaConvertJobResponseBodyJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitMediaConvertJobResponseBody() = default;
};
class SubmitMediaConvertJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitMediaConvertJobResponseBody> body{};

  SubmitMediaConvertJobResponse() {}

  explicit SubmitMediaConvertJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMediaConvertJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMediaConvertJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMediaConvertJobResponse() = default;
};
class SubmitMediaInfoJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitMediaInfoJobRequestInput() {}

  explicit SubmitMediaInfoJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitMediaInfoJobRequestInput() = default;
};
class SubmitMediaInfoJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitMediaInfoJobRequestScheduleConfig() {}

  explicit SubmitMediaInfoJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitMediaInfoJobRequestScheduleConfig() = default;
};
class SubmitMediaInfoJobRequest : public Darabonba::Model {
public:
  shared_ptr<SubmitMediaInfoJobRequestInput> input{};
  shared_ptr<string> name{};
  shared_ptr<SubmitMediaInfoJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<string> userData{};

  SubmitMediaInfoJobRequest() {}

  explicit SubmitMediaInfoJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitMediaInfoJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitMediaInfoJobRequestInput>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitMediaInfoJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitMediaInfoJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaInfoJobRequest() = default;
};
class SubmitMediaInfoJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> userData{};

  SubmitMediaInfoJobShrinkRequest() {}

  explicit SubmitMediaInfoJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaInfoJobShrinkRequest() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobInput() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobInput() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFps{};
  shared_ptr<string> bitRate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeBase{};
  shared_ptr<string> width{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFps) {
      res["Avg_fps"] = boost::any(*avgFps);
    }
    if (bitRate) {
      res["Bit_rate"] = boost::any(*bitRate);
    }
    if (codecLongName) {
      res["Codec_long_name"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["Codec_name"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["Codec_tag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["Codec_tag_string"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["Codec_time_base"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["Has_b_frames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["Start_time"] = boost::any(*startTime);
    }
    if (timeBase) {
      res["Time_base"] = boost::any(*timeBase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avg_fps") != m.end() && !m["Avg_fps"].empty()) {
      avgFps = make_shared<string>(boost::any_cast<string>(m["Avg_fps"]));
    }
    if (m.find("Bit_rate") != m.end() && !m["Bit_rate"].empty()) {
      bitRate = make_shared<string>(boost::any_cast<string>(m["Bit_rate"]));
    }
    if (m.find("Codec_long_name") != m.end() && !m["Codec_long_name"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["Codec_long_name"]));
    }
    if (m.find("Codec_name") != m.end() && !m["Codec_name"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["Codec_name"]));
    }
    if (m.find("Codec_tag") != m.end() && !m["Codec_tag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["Codec_tag"]));
    }
    if (m.find("Codec_tag_string") != m.end() && !m["Codec_tag_string"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["Codec_tag_string"]));
    }
    if (m.find("Codec_time_base") != m.end() && !m["Codec_time_base"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["Codec_time_base"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Has_b_frames") != m.end() && !m["Has_b_frames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["Has_b_frames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Start_time") != m.end() && !m["Start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["Start_time"]));
    }
    if (m.find("Time_base") != m.end() && !m["Time_base"].empty()) {
      timeBase = make_shared<string>(boost::any_cast<string>(m["Time_base"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList>> videoStreamInfoList{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo>(model1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig() = default;
};
class SubmitMediaInfoJobResponseBodyMediaInfoJob : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> finishTime{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty> mediaInfoProperty{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> submitResultJson{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  SubmitMediaInfoJobResponseBodyMediaInfoJob() {}

  explicit SubmitMediaInfoJobResponseBodyMediaInfoJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaInfoProperty) {
      res["MediaInfoProperty"] = mediaInfoProperty ? boost::any(mediaInfoProperty->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitResultJson) {
      res["SubmitResultJson"] = boost::any(*submitResultJson);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaInfoProperty") != m.end() && !m["MediaInfoProperty"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoProperty"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoProperty"]));
        mediaInfoProperty = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitResultJson") != m.end() && !m["SubmitResultJson"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SubmitResultJson"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      submitResultJson = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBodyMediaInfoJob() = default;
};
class SubmitMediaInfoJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitMediaInfoJobResponseBodyMediaInfoJob> mediaInfoJob{};
  shared_ptr<string> requestId{};

  SubmitMediaInfoJobResponseBody() {}

  explicit SubmitMediaInfoJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfoJob) {
      res["MediaInfoJob"] = mediaInfoJob ? boost::any(mediaInfoJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfoJob") != m.end() && !m["MediaInfoJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoJob"].type()) {
        SubmitMediaInfoJobResponseBodyMediaInfoJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoJob"]));
        mediaInfoJob = make_shared<SubmitMediaInfoJobResponseBodyMediaInfoJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitMediaInfoJobResponseBody() = default;
};
class SubmitMediaInfoJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitMediaInfoJobResponseBody> body{};

  SubmitMediaInfoJobResponse() {}

  explicit SubmitMediaInfoJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMediaInfoJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMediaInfoJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMediaInfoJobResponse() = default;
};
class SubmitMediaProducingJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> clipsParam{};
  shared_ptr<string> editingProduceConfig{};
  shared_ptr<string> mediaMetadata{};
  shared_ptr<string> outputMediaConfig{};
  shared_ptr<string> outputMediaTarget{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectMetadata{};
  shared_ptr<string> source{};
  shared_ptr<string> templateId{};
  shared_ptr<string> timeline{};
  shared_ptr<string> userData{};

  SubmitMediaProducingJobRequest() {}

  explicit SubmitMediaProducingJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (editingProduceConfig) {
      res["EditingProduceConfig"] = boost::any(*editingProduceConfig);
    }
    if (mediaMetadata) {
      res["MediaMetadata"] = boost::any(*mediaMetadata);
    }
    if (outputMediaConfig) {
      res["OutputMediaConfig"] = boost::any(*outputMediaConfig);
    }
    if (outputMediaTarget) {
      res["OutputMediaTarget"] = boost::any(*outputMediaTarget);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectMetadata) {
      res["ProjectMetadata"] = boost::any(*projectMetadata);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("EditingProduceConfig") != m.end() && !m["EditingProduceConfig"].empty()) {
      editingProduceConfig = make_shared<string>(boost::any_cast<string>(m["EditingProduceConfig"]));
    }
    if (m.find("MediaMetadata") != m.end() && !m["MediaMetadata"].empty()) {
      mediaMetadata = make_shared<string>(boost::any_cast<string>(m["MediaMetadata"]));
    }
    if (m.find("OutputMediaConfig") != m.end() && !m["OutputMediaConfig"].empty()) {
      outputMediaConfig = make_shared<string>(boost::any_cast<string>(m["OutputMediaConfig"]));
    }
    if (m.find("OutputMediaTarget") != m.end() && !m["OutputMediaTarget"].empty()) {
      outputMediaTarget = make_shared<string>(boost::any_cast<string>(m["OutputMediaTarget"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectMetadata") != m.end() && !m["ProjectMetadata"].empty()) {
      projectMetadata = make_shared<string>(boost::any_cast<string>(m["ProjectMetadata"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitMediaProducingJobRequest() = default;
};
class SubmitMediaProducingJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> vodMediaId{};

  SubmitMediaProducingJobResponseBody() {}

  explicit SubmitMediaProducingJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vodMediaId) {
      res["VodMediaId"] = boost::any(*vodMediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VodMediaId") != m.end() && !m["VodMediaId"].empty()) {
      vodMediaId = make_shared<string>(boost::any_cast<string>(m["VodMediaId"]));
    }
  }


  virtual ~SubmitMediaProducingJobResponseBody() = default;
};
class SubmitMediaProducingJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitMediaProducingJobResponseBody> body{};

  SubmitMediaProducingJobResponse() {}

  explicit SubmitMediaProducingJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitMediaProducingJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitMediaProducingJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitMediaProducingJobResponse() = default;
};
class SubmitPackageJobRequestInputsInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitPackageJobRequestInputsInput() {}

  explicit SubmitPackageJobRequestInputsInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitPackageJobRequestInputsInput() = default;
};
class SubmitPackageJobRequestInputs : public Darabonba::Model {
public:
  shared_ptr<SubmitPackageJobRequestInputsInput> input{};

  SubmitPackageJobRequestInputs() {}

  explicit SubmitPackageJobRequestInputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitPackageJobRequestInputsInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitPackageJobRequestInputsInput>(model1);
      }
    }
  }


  virtual ~SubmitPackageJobRequestInputs() = default;
};
class SubmitPackageJobRequestOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitPackageJobRequestOutput() {}

  explicit SubmitPackageJobRequestOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitPackageJobRequestOutput() = default;
};
class SubmitPackageJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitPackageJobRequestScheduleConfig() {}

  explicit SubmitPackageJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitPackageJobRequestScheduleConfig() = default;
};
class SubmitPackageJobRequest : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitPackageJobRequestInputs>> inputs{};
  shared_ptr<string> name{};
  shared_ptr<SubmitPackageJobRequestOutput> output{};
  shared_ptr<SubmitPackageJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<string> userData{};

  SubmitPackageJobRequest() {}

  explicit SubmitPackageJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputs) {
      vector<boost::any> temp1;
      for(auto item1:*inputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Inputs"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Inputs"].type()) {
        vector<SubmitPackageJobRequestInputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Inputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitPackageJobRequestInputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputs = make_shared<vector<SubmitPackageJobRequestInputs>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitPackageJobRequestOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitPackageJobRequestOutput>(model1);
      }
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitPackageJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitPackageJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitPackageJobRequest() = default;
};
class SubmitPackageJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> outputShrink{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> userData{};

  SubmitPackageJobShrinkRequest() {}

  explicit SubmitPackageJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputsShrink) {
      res["Inputs"] = boost::any(*inputsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputShrink) {
      res["Output"] = boost::any(*outputShrink);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inputs") != m.end() && !m["Inputs"].empty()) {
      inputsShrink = make_shared<string>(boost::any_cast<string>(m["Inputs"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      outputShrink = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitPackageJobShrinkRequest() = default;
};
class SubmitPackageJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitPackageJobResponseBody() {}

  explicit SubmitPackageJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitPackageJobResponseBody() = default;
};
class SubmitPackageJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitPackageJobResponseBody> body{};

  SubmitPackageJobResponse() {}

  explicit SubmitPackageJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitPackageJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitPackageJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitPackageJobResponse() = default;
};
class SubmitProjectExportJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> exportType{};
  shared_ptr<string> outputMediaConfig{};
  shared_ptr<string> projectId{};
  shared_ptr<string> timeline{};
  shared_ptr<string> userData{};

  SubmitProjectExportJobRequest() {}

  explicit SubmitProjectExportJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exportType) {
      res["ExportType"] = boost::any(*exportType);
    }
    if (outputMediaConfig) {
      res["OutputMediaConfig"] = boost::any(*outputMediaConfig);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExportType") != m.end() && !m["ExportType"].empty()) {
      exportType = make_shared<string>(boost::any_cast<string>(m["ExportType"]));
    }
    if (m.find("OutputMediaConfig") != m.end() && !m["OutputMediaConfig"].empty()) {
      outputMediaConfig = make_shared<string>(boost::any_cast<string>(m["OutputMediaConfig"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitProjectExportJobRequest() = default;
};
class SubmitProjectExportJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitProjectExportJobResponseBody() {}

  explicit SubmitProjectExportJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitProjectExportJobResponseBody() = default;
};
class SubmitProjectExportJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitProjectExportJobResponseBody> body{};

  SubmitProjectExportJobResponse() {}

  explicit SubmitProjectExportJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitProjectExportJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitProjectExportJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitProjectExportJobResponse() = default;
};
class SubmitScreenMediaHighlightsJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> editingConfig{};
  shared_ptr<string> inputConfig{};
  shared_ptr<string> outputConfig{};
  shared_ptr<string> userData{};

  SubmitScreenMediaHighlightsJobRequest() {}

  explicit SubmitScreenMediaHighlightsJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editingConfig) {
      res["EditingConfig"] = boost::any(*editingConfig);
    }
    if (inputConfig) {
      res["InputConfig"] = boost::any(*inputConfig);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      editingConfig = make_shared<string>(boost::any_cast<string>(m["EditingConfig"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      inputConfig = make_shared<string>(boost::any_cast<string>(m["InputConfig"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitScreenMediaHighlightsJobRequest() = default;
};
class SubmitScreenMediaHighlightsJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitScreenMediaHighlightsJobResponseBody() {}

  explicit SubmitScreenMediaHighlightsJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitScreenMediaHighlightsJobResponseBody() = default;
};
class SubmitScreenMediaHighlightsJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitScreenMediaHighlightsJobResponseBody> body{};

  SubmitScreenMediaHighlightsJobResponse() {}

  explicit SubmitScreenMediaHighlightsJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitScreenMediaHighlightsJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitScreenMediaHighlightsJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitScreenMediaHighlightsJobResponse() = default;
};
class SubmitSegmentationJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> inputConfig{};
  shared_ptr<string> jobParams{};
  shared_ptr<string> outputConfig{};
  shared_ptr<string> userData{};

  SubmitSegmentationJobRequest() {}

  explicit SubmitSegmentationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (inputConfig) {
      res["InputConfig"] = boost::any(*inputConfig);
    }
    if (jobParams) {
      res["JobParams"] = boost::any(*jobParams);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      inputConfig = make_shared<string>(boost::any_cast<string>(m["InputConfig"]));
    }
    if (m.find("JobParams") != m.end() && !m["JobParams"].empty()) {
      jobParams = make_shared<string>(boost::any_cast<string>(m["JobParams"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSegmentationJobRequest() = default;
};
class SubmitSegmentationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitSegmentationJobResponseBody() {}

  explicit SubmitSegmentationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitSegmentationJobResponseBody() = default;
};
class SubmitSegmentationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitSegmentationJobResponseBody> body{};

  SubmitSegmentationJobResponse() {}

  explicit SubmitSegmentationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSegmentationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSegmentationJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSegmentationJobResponse() = default;
};
class SubmitSmarttagJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitSmarttagJobRequestInput() {}

  explicit SubmitSmarttagJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitSmarttagJobRequestInput() = default;
};
class SubmitSmarttagJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<string> priority{};

  SubmitSmarttagJobRequestScheduleConfig() {}

  explicit SubmitSmarttagJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
  }


  virtual ~SubmitSmarttagJobRequestScheduleConfig() = default;
};
class SubmitSmarttagJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentAddr{};
  shared_ptr<string> contentType{};
  shared_ptr<SubmitSmarttagJobRequestInput> input{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> params{};
  shared_ptr<SubmitSmarttagJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<string> templateId{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SubmitSmarttagJobRequest() {}

  explicit SubmitSmarttagJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentAddr) {
      res["ContentAddr"] = boost::any(*contentAddr);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentAddr") != m.end() && !m["ContentAddr"].empty()) {
      contentAddr = make_shared<string>(boost::any_cast<string>(m["ContentAddr"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitSmarttagJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitSmarttagJobRequestInput>(model1);
      }
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitSmarttagJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitSmarttagJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSmarttagJobRequest() = default;
};
class SubmitSmarttagJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentAddr{};
  shared_ptr<string> contentType{};
  shared_ptr<string> inputShrink{};
  shared_ptr<string> notifyUrl{};
  shared_ptr<string> params{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> templateId{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SubmitSmarttagJobShrinkRequest() {}

  explicit SubmitSmarttagJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentAddr) {
      res["ContentAddr"] = boost::any(*contentAddr);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (notifyUrl) {
      res["NotifyUrl"] = boost::any(*notifyUrl);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentAddr") != m.end() && !m["ContentAddr"].empty()) {
      contentAddr = make_shared<string>(boost::any_cast<string>(m["ContentAddr"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("NotifyUrl") != m.end() && !m["NotifyUrl"].empty()) {
      notifyUrl = make_shared<string>(boost::any_cast<string>(m["NotifyUrl"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSmarttagJobShrinkRequest() = default;
};
class SubmitSmarttagJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitSmarttagJobResponseBody() {}

  explicit SubmitSmarttagJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitSmarttagJobResponseBody() = default;
};
class SubmitSmarttagJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitSmarttagJobResponseBody> body{};

  SubmitSmarttagJobResponse() {}

  explicit SubmitSmarttagJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSmarttagJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSmarttagJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSmarttagJobResponse() = default;
};
class SubmitSnapshotJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitSnapshotJobRequestInput() {}

  explicit SubmitSnapshotJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitSnapshotJobRequestInput() = default;
};
class SubmitSnapshotJobRequestOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitSnapshotJobRequestOutput() {}

  explicit SubmitSnapshotJobRequestOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitSnapshotJobRequestOutput() = default;
};
class SubmitSnapshotJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};

  SubmitSnapshotJobRequestScheduleConfig() {}

  explicit SubmitSnapshotJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
  }


  virtual ~SubmitSnapshotJobRequestScheduleConfig() = default;
};
class SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig : public Darabonba::Model {
public:
  shared_ptr<long> cellHeight{};
  shared_ptr<long> cellWidth{};
  shared_ptr<string> color{};
  shared_ptr<long> columns{};
  shared_ptr<long> lines{};
  shared_ptr<long> margin{};
  shared_ptr<long> padding{};

  SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig() {}

  explicit SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cellHeight) {
      res["CellHeight"] = boost::any(*cellHeight);
    }
    if (cellWidth) {
      res["CellWidth"] = boost::any(*cellWidth);
    }
    if (color) {
      res["Color"] = boost::any(*color);
    }
    if (columns) {
      res["Columns"] = boost::any(*columns);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (margin) {
      res["Margin"] = boost::any(*margin);
    }
    if (padding) {
      res["Padding"] = boost::any(*padding);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CellHeight") != m.end() && !m["CellHeight"].empty()) {
      cellHeight = make_shared<long>(boost::any_cast<long>(m["CellHeight"]));
    }
    if (m.find("CellWidth") != m.end() && !m["CellWidth"].empty()) {
      cellWidth = make_shared<long>(boost::any_cast<long>(m["CellWidth"]));
    }
    if (m.find("Color") != m.end() && !m["Color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["Color"]));
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      columns = make_shared<long>(boost::any_cast<long>(m["Columns"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<long>(boost::any_cast<long>(m["Lines"]));
    }
    if (m.find("Margin") != m.end() && !m["Margin"].empty()) {
      margin = make_shared<long>(boost::any_cast<long>(m["Margin"]));
    }
    if (m.find("Padding") != m.end() && !m["Padding"].empty()) {
      padding = make_shared<long>(boost::any_cast<long>(m["Padding"]));
    }
  }


  virtual ~SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig() = default;
};
class SubmitSnapshotJobRequestTemplateConfigOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<long> blackLevel{};
  shared_ptr<long> count{};
  shared_ptr<string> frameType{};
  shared_ptr<long> height{};
  shared_ptr<long> interval{};
  shared_ptr<bool> isSptFrag{};
  shared_ptr<long> pixelBlackThreshold{};
  shared_ptr<SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig> spriteSnapshotConfig{};
  shared_ptr<long> time{};
  shared_ptr<string> type{};
  shared_ptr<long> width{};

  SubmitSnapshotJobRequestTemplateConfigOverwriteParams() {}

  explicit SubmitSnapshotJobRequestTemplateConfigOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackLevel) {
      res["BlackLevel"] = boost::any(*blackLevel);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (frameType) {
      res["FrameType"] = boost::any(*frameType);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (isSptFrag) {
      res["IsSptFrag"] = boost::any(*isSptFrag);
    }
    if (pixelBlackThreshold) {
      res["PixelBlackThreshold"] = boost::any(*pixelBlackThreshold);
    }
    if (spriteSnapshotConfig) {
      res["SpriteSnapshotConfig"] = spriteSnapshotConfig ? boost::any(spriteSnapshotConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackLevel") != m.end() && !m["BlackLevel"].empty()) {
      blackLevel = make_shared<long>(boost::any_cast<long>(m["BlackLevel"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("FrameType") != m.end() && !m["FrameType"].empty()) {
      frameType = make_shared<string>(boost::any_cast<string>(m["FrameType"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IsSptFrag") != m.end() && !m["IsSptFrag"].empty()) {
      isSptFrag = make_shared<bool>(boost::any_cast<bool>(m["IsSptFrag"]));
    }
    if (m.find("PixelBlackThreshold") != m.end() && !m["PixelBlackThreshold"].empty()) {
      pixelBlackThreshold = make_shared<long>(boost::any_cast<long>(m["PixelBlackThreshold"]));
    }
    if (m.find("SpriteSnapshotConfig") != m.end() && !m["SpriteSnapshotConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpriteSnapshotConfig"].type()) {
        SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpriteSnapshotConfig"]));
        spriteSnapshotConfig = make_shared<SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig>(model1);
      }
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~SubmitSnapshotJobRequestTemplateConfigOverwriteParams() = default;
};
class SubmitSnapshotJobRequestTemplateConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitSnapshotJobRequestTemplateConfigOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitSnapshotJobRequestTemplateConfig() {}

  explicit SubmitSnapshotJobRequestTemplateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitSnapshotJobRequestTemplateConfigOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitSnapshotJobRequestTemplateConfigOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitSnapshotJobRequestTemplateConfig() = default;
};
class SubmitSnapshotJobRequest : public Darabonba::Model {
public:
  shared_ptr<SubmitSnapshotJobRequestInput> input{};
  shared_ptr<string> name{};
  shared_ptr<SubmitSnapshotJobRequestOutput> output{};
  shared_ptr<SubmitSnapshotJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<SubmitSnapshotJobRequestTemplateConfig> templateConfig{};
  shared_ptr<string> userData{};

  SubmitSnapshotJobRequest() {}

  explicit SubmitSnapshotJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitSnapshotJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitSnapshotJobRequestInput>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitSnapshotJobRequestOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitSnapshotJobRequestOutput>(model1);
      }
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitSnapshotJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitSnapshotJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        SubmitSnapshotJobRequestTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<SubmitSnapshotJobRequestTemplateConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSnapshotJobRequest() = default;
};
class SubmitSnapshotJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> outputShrink{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> templateConfigShrink{};
  shared_ptr<string> userData{};

  SubmitSnapshotJobShrinkRequest() {}

  explicit SubmitSnapshotJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputShrink) {
      res["Output"] = boost::any(*outputShrink);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (templateConfigShrink) {
      res["TemplateConfig"] = boost::any(*templateConfigShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      outputShrink = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfigShrink = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSnapshotJobShrinkRequest() = default;
};
class SubmitSnapshotJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitSnapshotJobResponseBody() {}

  explicit SubmitSnapshotJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitSnapshotJobResponseBody() = default;
};
class SubmitSnapshotJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitSnapshotJobResponseBody> body{};

  SubmitSnapshotJobResponse() {}

  explicit SubmitSnapshotJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSnapshotJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSnapshotJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSnapshotJobResponse() = default;
};
class SubmitSportsHighlightsJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> inputConfig{};
  shared_ptr<string> outputConfig{};
  shared_ptr<string> userData{};

  SubmitSportsHighlightsJobRequest() {}

  explicit SubmitSportsHighlightsJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (inputConfig) {
      res["InputConfig"] = boost::any(*inputConfig);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      inputConfig = make_shared<string>(boost::any_cast<string>(m["InputConfig"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSportsHighlightsJobRequest() = default;
};
class SubmitSportsHighlightsJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitSportsHighlightsJobResponseBody() {}

  explicit SubmitSportsHighlightsJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitSportsHighlightsJobResponseBody() = default;
};
class SubmitSportsHighlightsJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitSportsHighlightsJobResponseBody> body{};

  SubmitSportsHighlightsJobResponse() {}

  explicit SubmitSportsHighlightsJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSportsHighlightsJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSportsHighlightsJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSportsHighlightsJobResponse() = default;
};
class SubmitStandardCustomizedVoiceJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> audios{};
  shared_ptr<string> authentication{};
  shared_ptr<string> demoAudioMediaURL{};
  shared_ptr<string> gender{};
  shared_ptr<string> voiceName{};

  SubmitStandardCustomizedVoiceJobRequest() {}

  explicit SubmitStandardCustomizedVoiceJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audios) {
      res["Audios"] = boost::any(*audios);
    }
    if (authentication) {
      res["Authentication"] = boost::any(*authentication);
    }
    if (demoAudioMediaURL) {
      res["DemoAudioMediaURL"] = boost::any(*demoAudioMediaURL);
    }
    if (gender) {
      res["Gender"] = boost::any(*gender);
    }
    if (voiceName) {
      res["VoiceName"] = boost::any(*voiceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audios") != m.end() && !m["Audios"].empty()) {
      audios = make_shared<string>(boost::any_cast<string>(m["Audios"]));
    }
    if (m.find("Authentication") != m.end() && !m["Authentication"].empty()) {
      authentication = make_shared<string>(boost::any_cast<string>(m["Authentication"]));
    }
    if (m.find("DemoAudioMediaURL") != m.end() && !m["DemoAudioMediaURL"].empty()) {
      demoAudioMediaURL = make_shared<string>(boost::any_cast<string>(m["DemoAudioMediaURL"]));
    }
    if (m.find("Gender") != m.end() && !m["Gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["Gender"]));
    }
    if (m.find("VoiceName") != m.end() && !m["VoiceName"].empty()) {
      voiceName = make_shared<string>(boost::any_cast<string>(m["VoiceName"]));
    }
  }


  virtual ~SubmitStandardCustomizedVoiceJobRequest() = default;
};
class SubmitStandardCustomizedVoiceJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  SubmitStandardCustomizedVoiceJobResponseBodyData() {}

  explicit SubmitStandardCustomizedVoiceJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitStandardCustomizedVoiceJobResponseBodyData() = default;
};
class SubmitStandardCustomizedVoiceJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitStandardCustomizedVoiceJobResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitStandardCustomizedVoiceJobResponseBody() {}

  explicit SubmitStandardCustomizedVoiceJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitStandardCustomizedVoiceJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitStandardCustomizedVoiceJobResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitStandardCustomizedVoiceJobResponseBody() = default;
};
class SubmitStandardCustomizedVoiceJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitStandardCustomizedVoiceJobResponseBody> body{};

  SubmitStandardCustomizedVoiceJobResponse() {}

  explicit SubmitStandardCustomizedVoiceJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitStandardCustomizedVoiceJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitStandardCustomizedVoiceJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitStandardCustomizedVoiceJobResponse() = default;
};
class SubmitSyncMediaInfoJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitSyncMediaInfoJobRequestInput() {}

  explicit SubmitSyncMediaInfoJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobRequestInput() = default;
};
class SubmitSyncMediaInfoJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitSyncMediaInfoJobRequestScheduleConfig() {}

  explicit SubmitSyncMediaInfoJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobRequestScheduleConfig() = default;
};
class SubmitSyncMediaInfoJobRequest : public Darabonba::Model {
public:
  shared_ptr<SubmitSyncMediaInfoJobRequestInput> input{};
  shared_ptr<string> name{};
  shared_ptr<SubmitSyncMediaInfoJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<string> userData{};

  SubmitSyncMediaInfoJobRequest() {}

  explicit SubmitSyncMediaInfoJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitSyncMediaInfoJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitSyncMediaInfoJobRequestInput>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitSyncMediaInfoJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitSyncMediaInfoJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobRequest() = default;
};
class SubmitSyncMediaInfoJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> userData{};

  SubmitSyncMediaInfoJobShrinkRequest() {}

  explicit SubmitSyncMediaInfoJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobShrinkRequest() = default;
};
class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput() {}

  explicit SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput() = default;
};
class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList() {}

  explicit SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList() = default;
};
class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo() {}

  explicit SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo() = default;
};
class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFps{};
  shared_ptr<string> bitRate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeBase{};
  shared_ptr<string> width{};

  SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList() {}

  explicit SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFps) {
      res["Avg_fps"] = boost::any(*avgFps);
    }
    if (bitRate) {
      res["Bit_rate"] = boost::any(*bitRate);
    }
    if (codecLongName) {
      res["Codec_long_name"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["Codec_name"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["Codec_tag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["Codec_tag_string"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["Codec_time_base"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["Has_b_frames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["Start_time"] = boost::any(*startTime);
    }
    if (timeBase) {
      res["Time_base"] = boost::any(*timeBase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avg_fps") != m.end() && !m["Avg_fps"].empty()) {
      avgFps = make_shared<string>(boost::any_cast<string>(m["Avg_fps"]));
    }
    if (m.find("Bit_rate") != m.end() && !m["Bit_rate"].empty()) {
      bitRate = make_shared<string>(boost::any_cast<string>(m["Bit_rate"]));
    }
    if (m.find("Codec_long_name") != m.end() && !m["Codec_long_name"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["Codec_long_name"]));
    }
    if (m.find("Codec_name") != m.end() && !m["Codec_name"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["Codec_name"]));
    }
    if (m.find("Codec_tag") != m.end() && !m["Codec_tag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["Codec_tag"]));
    }
    if (m.find("Codec_tag_string") != m.end() && !m["Codec_tag_string"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["Codec_tag_string"]));
    }
    if (m.find("Codec_time_base") != m.end() && !m["Codec_time_base"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["Codec_time_base"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Has_b_frames") != m.end() && !m["Has_b_frames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["Has_b_frames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Start_time") != m.end() && !m["Start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["Start_time"]));
    }
    if (m.find("Time_base") != m.end() && !m["Time_base"].empty()) {
      timeBase = make_shared<string>(boost::any_cast<string>(m["Time_base"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList() = default;
};
class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList>> videoStreamInfoList{};

  SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty() {}

  explicit SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo>(model1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty() = default;
};
class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig() {}

  explicit SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig() = default;
};
class SubmitSyncMediaInfoJobResponseBodyMediaInfoJob : public Darabonba::Model {
public:
  shared_ptr<bool> async{};
  shared_ptr<string> finishTime{};
  shared_ptr<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput> input{};
  shared_ptr<string> jobId{};
  shared_ptr<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty> mediaInfoProperty{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> submitResultJson{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  SubmitSyncMediaInfoJobResponseBodyMediaInfoJob() {}

  explicit SubmitSyncMediaInfoJobResponseBodyMediaInfoJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (async) {
      res["Async"] = boost::any(*async);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaInfoProperty) {
      res["MediaInfoProperty"] = mediaInfoProperty ? boost::any(mediaInfoProperty->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitResultJson) {
      res["SubmitResultJson"] = boost::any(*submitResultJson);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Async") != m.end() && !m["Async"].empty()) {
      async = make_shared<bool>(boost::any_cast<bool>(m["Async"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaInfoProperty") != m.end() && !m["MediaInfoProperty"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoProperty"].type()) {
        SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoProperty"]));
        mediaInfoProperty = make_shared<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitResultJson") != m.end() && !m["SubmitResultJson"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SubmitResultJson"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      submitResultJson = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponseBodyMediaInfoJob() = default;
};
class SubmitSyncMediaInfoJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitSyncMediaInfoJobResponseBodyMediaInfoJob> mediaInfoJob{};
  shared_ptr<string> requestId{};

  SubmitSyncMediaInfoJobResponseBody() {}

  explicit SubmitSyncMediaInfoJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaInfoJob) {
      res["MediaInfoJob"] = mediaInfoJob ? boost::any(mediaInfoJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaInfoJob") != m.end() && !m["MediaInfoJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaInfoJob"].type()) {
        SubmitSyncMediaInfoJobResponseBodyMediaInfoJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaInfoJob"]));
        mediaInfoJob = make_shared<SubmitSyncMediaInfoJobResponseBodyMediaInfoJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponseBody() = default;
};
class SubmitSyncMediaInfoJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitSyncMediaInfoJobResponseBody> body{};

  SubmitSyncMediaInfoJobResponse() {}

  explicit SubmitSyncMediaInfoJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSyncMediaInfoJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSyncMediaInfoJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSyncMediaInfoJobResponse() = default;
};
class SubmitTextGenerateJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> generateConfig{};
  shared_ptr<string> title{};
  shared_ptr<string> type{};
  shared_ptr<string> userData{};

  SubmitTextGenerateJobRequest() {}

  explicit SubmitTextGenerateJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (generateConfig) {
      res["GenerateConfig"] = boost::any(*generateConfig);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GenerateConfig") != m.end() && !m["GenerateConfig"].empty()) {
      generateConfig = make_shared<string>(boost::any_cast<string>(m["GenerateConfig"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitTextGenerateJobRequest() = default;
};
class SubmitTextGenerateJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> requestId{};

  SubmitTextGenerateJobResponseBody() {}

  explicit SubmitTextGenerateJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitTextGenerateJobResponseBody() = default;
};
class SubmitTextGenerateJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitTextGenerateJobResponseBody> body{};

  SubmitTextGenerateJobResponse() {}

  explicit SubmitTextGenerateJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitTextGenerateJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitTextGenerateJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitTextGenerateJobResponse() = default;
};
class SubmitTraceAbJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTraceAbJobRequestInput() {}

  explicit SubmitTraceAbJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTraceAbJobRequestInput() = default;
};
class SubmitTraceAbJobRequestOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTraceAbJobRequestOutput() {}

  explicit SubmitTraceAbJobRequestOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTraceAbJobRequestOutput() = default;
};
class SubmitTraceAbJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> cipherBase64ed{};
  shared_ptr<SubmitTraceAbJobRequestInput> input{};
  shared_ptr<long> level{};
  shared_ptr<SubmitTraceAbJobRequestOutput> output{};
  shared_ptr<long> startTime{};
  shared_ptr<long> totalTime{};
  shared_ptr<string> userData{};

  SubmitTraceAbJobRequest() {}

  explicit SubmitTraceAbJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cipherBase64ed) {
      res["CipherBase64ed"] = boost::any(*cipherBase64ed);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (totalTime) {
      res["TotalTime"] = boost::any(*totalTime);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CipherBase64ed") != m.end() && !m["CipherBase64ed"].empty()) {
      cipherBase64ed = make_shared<string>(boost::any_cast<string>(m["CipherBase64ed"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitTraceAbJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitTraceAbJobRequestInput>(model1);
      }
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitTraceAbJobRequestOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitTraceAbJobRequestOutput>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TotalTime") != m.end() && !m["TotalTime"].empty()) {
      totalTime = make_shared<long>(boost::any_cast<long>(m["TotalTime"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitTraceAbJobRequest() = default;
};
class SubmitTraceAbJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> cipherBase64ed{};
  shared_ptr<string> inputShrink{};
  shared_ptr<long> level{};
  shared_ptr<string> outputShrink{};
  shared_ptr<long> startTime{};
  shared_ptr<long> totalTime{};
  shared_ptr<string> userData{};

  SubmitTraceAbJobShrinkRequest() {}

  explicit SubmitTraceAbJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cipherBase64ed) {
      res["CipherBase64ed"] = boost::any(*cipherBase64ed);
    }
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (outputShrink) {
      res["Output"] = boost::any(*outputShrink);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (totalTime) {
      res["TotalTime"] = boost::any(*totalTime);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CipherBase64ed") != m.end() && !m["CipherBase64ed"].empty()) {
      cipherBase64ed = make_shared<string>(boost::any_cast<string>(m["CipherBase64ed"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      outputShrink = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TotalTime") != m.end() && !m["TotalTime"].empty()) {
      totalTime = make_shared<long>(boost::any_cast<long>(m["TotalTime"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitTraceAbJobShrinkRequest() = default;
};
class SubmitTraceAbJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> traceMediaId{};

  SubmitTraceAbJobResponseBodyData() {}

  explicit SubmitTraceAbJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (traceMediaId) {
      res["TraceMediaId"] = boost::any(*traceMediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("TraceMediaId") != m.end() && !m["TraceMediaId"].empty()) {
      traceMediaId = make_shared<string>(boost::any_cast<string>(m["TraceMediaId"]));
    }
  }


  virtual ~SubmitTraceAbJobResponseBodyData() = default;
};
class SubmitTraceAbJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitTraceAbJobResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> statusCode{};

  SubmitTraceAbJobResponseBody() {}

  explicit SubmitTraceAbJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitTraceAbJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitTraceAbJobResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["StatusCode"]));
    }
  }


  virtual ~SubmitTraceAbJobResponseBody() = default;
};
class SubmitTraceAbJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitTraceAbJobResponseBody> body{};

  SubmitTraceAbJobResponse() {}

  explicit SubmitTraceAbJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitTraceAbJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitTraceAbJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitTraceAbJobResponse() = default;
};
class SubmitTraceExtractJobRequestInput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTraceExtractJobRequestInput() {}

  explicit SubmitTraceExtractJobRequestInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTraceExtractJobRequestInput() = default;
};
class SubmitTraceExtractJobRequest : public Darabonba::Model {
public:
  shared_ptr<SubmitTraceExtractJobRequestInput> input{};
  shared_ptr<string> params{};
  shared_ptr<string> userData{};

  SubmitTraceExtractJobRequest() {}

  explicit SubmitTraceExtractJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        SubmitTraceExtractJobRequestInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<SubmitTraceExtractJobRequestInput>(model1);
      }
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitTraceExtractJobRequest() = default;
};
class SubmitTraceExtractJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputShrink{};
  shared_ptr<string> params{};
  shared_ptr<string> userData{};

  SubmitTraceExtractJobShrinkRequest() {}

  explicit SubmitTraceExtractJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitTraceExtractJobShrinkRequest() = default;
};
class SubmitTraceExtractJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  SubmitTraceExtractJobResponseBodyData() {}

  explicit SubmitTraceExtractJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitTraceExtractJobResponseBodyData() = default;
};
class SubmitTraceExtractJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitTraceExtractJobResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> statusCode{};

  SubmitTraceExtractJobResponseBody() {}

  explicit SubmitTraceExtractJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitTraceExtractJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitTraceExtractJobResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["StatusCode"]));
    }
  }


  virtual ~SubmitTraceExtractJobResponseBody() = default;
};
class SubmitTraceExtractJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitTraceExtractJobResponseBody> body{};

  SubmitTraceExtractJobResponse() {}

  explicit SubmitTraceExtractJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitTraceExtractJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitTraceExtractJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitTraceExtractJobResponse() = default;
};
class SubmitTraceM3u8JobRequestOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTraceM3u8JobRequestOutput() {}

  explicit SubmitTraceM3u8JobRequestOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTraceM3u8JobRequestOutput() = default;
};
class SubmitTraceM3u8JobRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyUri{};
  shared_ptr<SubmitTraceM3u8JobRequestOutput> output{};
  shared_ptr<string> params{};
  shared_ptr<string> trace{};
  shared_ptr<string> traceMediaId{};

  SubmitTraceM3u8JobRequest() {}

  explicit SubmitTraceM3u8JobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (trace) {
      res["Trace"] = boost::any(*trace);
    }
    if (traceMediaId) {
      res["TraceMediaId"] = boost::any(*traceMediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitTraceM3u8JobRequestOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitTraceM3u8JobRequestOutput>(model1);
      }
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("Trace") != m.end() && !m["Trace"].empty()) {
      trace = make_shared<string>(boost::any_cast<string>(m["Trace"]));
    }
    if (m.find("TraceMediaId") != m.end() && !m["TraceMediaId"].empty()) {
      traceMediaId = make_shared<string>(boost::any_cast<string>(m["TraceMediaId"]));
    }
  }


  virtual ~SubmitTraceM3u8JobRequest() = default;
};
class SubmitTraceM3u8JobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyUri{};
  shared_ptr<string> outputShrink{};
  shared_ptr<string> params{};
  shared_ptr<string> trace{};
  shared_ptr<string> traceMediaId{};

  SubmitTraceM3u8JobShrinkRequest() {}

  explicit SubmitTraceM3u8JobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyUri) {
      res["KeyUri"] = boost::any(*keyUri);
    }
    if (outputShrink) {
      res["Output"] = boost::any(*outputShrink);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (trace) {
      res["Trace"] = boost::any(*trace);
    }
    if (traceMediaId) {
      res["TraceMediaId"] = boost::any(*traceMediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyUri") != m.end() && !m["KeyUri"].empty()) {
      keyUri = make_shared<string>(boost::any_cast<string>(m["KeyUri"]));
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      outputShrink = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("Trace") != m.end() && !m["Trace"].empty()) {
      trace = make_shared<string>(boost::any_cast<string>(m["Trace"]));
    }
    if (m.find("TraceMediaId") != m.end() && !m["TraceMediaId"].empty()) {
      traceMediaId = make_shared<string>(boost::any_cast<string>(m["TraceMediaId"]));
    }
  }


  virtual ~SubmitTraceM3u8JobShrinkRequest() = default;
};
class SubmitTraceM3u8JobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  SubmitTraceM3u8JobResponseBodyData() {}

  explicit SubmitTraceM3u8JobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitTraceM3u8JobResponseBodyData() = default;
};
class SubmitTraceM3u8JobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitTraceM3u8JobResponseBodyData> data{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  SubmitTraceM3u8JobResponseBody() {}

  explicit SubmitTraceM3u8JobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitTraceM3u8JobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitTraceM3u8JobResponseBodyData>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitTraceM3u8JobResponseBody() = default;
};
class SubmitTraceM3u8JobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitTraceM3u8JobResponseBody> body{};

  SubmitTraceM3u8JobResponse() {}

  explicit SubmitTraceM3u8JobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitTraceM3u8JobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitTraceM3u8JobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitTraceM3u8JobResponse() = default;
};
class SubmitTranscodeJobRequestInputGroup : public Darabonba::Model {
public:
  shared_ptr<string> inputUrl{};
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobRequestInputGroup() {}

  explicit SubmitTranscodeJobRequestInputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputUrl) {
      res["InputUrl"] = boost::any(*inputUrl);
    }
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputUrl") != m.end() && !m["InputUrl"].empty()) {
      inputUrl = make_shared<string>(boost::any_cast<string>(m["InputUrl"]));
    }
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestInputGroup() = default;
};
class SubmitTranscodeJobRequestOutputGroupOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> outputUrl{};
  shared_ptr<string> type{};

  SubmitTranscodeJobRequestOutputGroupOutput() {}

  explicit SubmitTranscodeJobRequestOutputGroupOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (outputUrl) {
      res["OutputUrl"] = boost::any(*outputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("OutputUrl") != m.end() && !m["OutputUrl"].empty()) {
      outputUrl = make_shared<string>(boost::any_cast<string>(m["OutputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupOutput() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigCombineConfigs : public Darabonba::Model {
public:
  shared_ptr<string> audioIndex{};
  shared_ptr<double> duration{};
  shared_ptr<double> start{};
  shared_ptr<string> videoIndex{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigCombineConfigs() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigCombineConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioIndex) {
      res["AudioIndex"] = boost::any(*audioIndex);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (videoIndex) {
      res["VideoIndex"] = boost::any(*videoIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioIndex") != m.end() && !m["AudioIndex"].empty()) {
      audioIndex = make_shared<string>(boost::any_cast<string>(m["AudioIndex"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<double>(boost::any_cast<double>(m["Start"]));
    }
    if (m.find("VideoIndex") != m.end() && !m["VideoIndex"].empty()) {
      videoIndex = make_shared<string>(boost::any_cast<string>(m["VideoIndex"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigCombineConfigs() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigEncryption : public Darabonba::Model {
public:
  shared_ptr<string> cipherText{};
  shared_ptr<string> decryptKeyUri{};
  shared_ptr<string> encryptType{};
  shared_ptr<string> keyServiceType{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigEncryption() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cipherText) {
      res["CipherText"] = boost::any(*cipherText);
    }
    if (decryptKeyUri) {
      res["DecryptKeyUri"] = boost::any(*decryptKeyUri);
    }
    if (encryptType) {
      res["EncryptType"] = boost::any(*encryptType);
    }
    if (keyServiceType) {
      res["KeyServiceType"] = boost::any(*keyServiceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CipherText") != m.end() && !m["CipherText"].empty()) {
      cipherText = make_shared<string>(boost::any_cast<string>(m["CipherText"]));
    }
    if (m.find("DecryptKeyUri") != m.end() && !m["DecryptKeyUri"].empty()) {
      decryptKeyUri = make_shared<string>(boost::any_cast<string>(m["DecryptKeyUri"]));
    }
    if (m.find("EncryptType") != m.end() && !m["EncryptType"].empty()) {
      encryptType = make_shared<string>(boost::any_cast<string>(m["EncryptType"]));
    }
    if (m.find("KeyServiceType") != m.end() && !m["KeyServiceType"].empty()) {
      keyServiceType = make_shared<string>(boost::any_cast<string>(m["KeyServiceType"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigEncryption() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile> file{};
  shared_ptr<string> height{};
  shared_ptr<string> referPos{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline> timeline{};
  shared_ptr<string> width{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile> file{};
  shared_ptr<string> format{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> adaptive{};
  shared_ptr<string> borderColor{};
  shared_ptr<long> borderWidth{};
  shared_ptr<string> content{};
  shared_ptr<string> fontAlpha{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<long> fontSize{};
  shared_ptr<string> left{};
  shared_ptr<string> top{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adaptive) {
      res["Adaptive"] = boost::any(*adaptive);
    }
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidth) {
      res["BorderWidth"] = boost::any(*borderWidth);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fontAlpha) {
      res["FontAlpha"] = boost::any(*fontAlpha);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSize) {
      res["FontSize"] = boost::any(*fontSize);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adaptive") != m.end() && !m["Adaptive"].empty()) {
      adaptive = make_shared<string>(boost::any_cast<string>(m["Adaptive"]));
    }
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidth") != m.end() && !m["BorderWidth"].empty()) {
      borderWidth = make_shared<long>(boost::any_cast<long>(m["BorderWidth"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FontAlpha") != m.end() && !m["FontAlpha"].empty()) {
      fontAlpha = make_shared<string>(boost::any_cast<string>(m["FontAlpha"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSize") != m.end() && !m["FontSize"].empty()) {
      fontSize = make_shared<long>(boost::any_cast<long>(m["FontSize"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> integratedLoudnessTarget{};
  shared_ptr<string> loudnessRangeTarget{};
  shared_ptr<string> method{};
  shared_ptr<string> truePeak{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedLoudnessTarget) {
      res["IntegratedLoudnessTarget"] = boost::any(*integratedLoudnessTarget);
    }
    if (loudnessRangeTarget) {
      res["LoudnessRangeTarget"] = boost::any(*loudnessRangeTarget);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (truePeak) {
      res["TruePeak"] = boost::any(*truePeak);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedLoudnessTarget") != m.end() && !m["IntegratedLoudnessTarget"].empty()) {
      integratedLoudnessTarget = make_shared<string>(boost::any_cast<string>(m["IntegratedLoudnessTarget"]));
    }
    if (m.find("LoudnessRangeTarget") != m.end() && !m["LoudnessRangeTarget"].empty()) {
      loudnessRangeTarget = make_shared<string>(boost::any_cast<string>(m["LoudnessRangeTarget"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("TruePeak") != m.end() && !m["TruePeak"].empty()) {
      truePeak = make_shared<string>(boost::any_cast<string>(m["TruePeak"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume> volume{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> forceSegTime{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (forceSegTime) {
      res["ForceSegTime"] = boost::any(*forceSegTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ForceSegTime") != m.end() && !m["ForceSegTime"].empty()) {
      forceSegTime = make_shared<string>(boost::any_cast<string>(m["ForceSegTime"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment> segment{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo : public Darabonba::Model {
public:
  shared_ptr<string> abrMax{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abrMax) {
      res["AbrMax"] = boost::any(*abrMax);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbrMax") != m.end() && !m["AbrMax"].empty()) {
      abrMax = make_shared<string>(boost::any_cast<string>(m["AbrMax"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio> audio{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer> container{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig> muxConfig{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig> transConfig{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo> video{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode() = default;
};
class SubmitTranscodeJobRequestOutputGroupProcessConfig : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitTranscodeJobRequestOutputGroupProcessConfigCombineConfigs>> combineConfigs{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigEncryption> encryption{};
  shared_ptr<vector<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks>> imageWatermarks{};
  shared_ptr<vector<SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles>> subtitles{};
  shared_ptr<vector<SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks>> textWatermarks{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode> transcode{};

  SubmitTranscodeJobRequestOutputGroupProcessConfig() {}

  explicit SubmitTranscodeJobRequestOutputGroupProcessConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (combineConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*combineConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CombineConfigs"] = boost::any(temp1);
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*imageWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageWatermarks"] = boost::any(temp1);
    }
    if (subtitles) {
      vector<boost::any> temp1;
      for(auto item1:*subtitles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitles"] = boost::any(temp1);
    }
    if (textWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*textWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextWatermarks"] = boost::any(temp1);
    }
    if (transcode) {
      res["Transcode"] = transcode ? boost::any(transcode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CombineConfigs") != m.end() && !m["CombineConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["CombineConfigs"].type()) {
        vector<SubmitTranscodeJobRequestOutputGroupProcessConfigCombineConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CombineConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobRequestOutputGroupProcessConfigCombineConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        combineConfigs = make_shared<vector<SubmitTranscodeJobRequestOutputGroupProcessConfigCombineConfigs>>(expect1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigEncryption>(model1);
      }
    }
    if (m.find("ImageWatermarks") != m.end() && !m["ImageWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageWatermarks"].type()) {
        vector<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageWatermarks = make_shared<vector<SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks>>(expect1);
      }
    }
    if (m.find("Subtitles") != m.end() && !m["Subtitles"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitles"].type()) {
        vector<SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitles = make_shared<vector<SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles>>(expect1);
      }
    }
    if (m.find("TextWatermarks") != m.end() && !m["TextWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["TextWatermarks"].type()) {
        vector<SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textWatermarks = make_shared<vector<SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks>>(expect1);
      }
    }
    if (m.find("Transcode") != m.end() && !m["Transcode"].empty()) {
      if (typeid(map<string, boost::any>) == m["Transcode"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Transcode"]));
        transcode = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroupProcessConfig() = default;
};
class SubmitTranscodeJobRequestOutputGroup : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobRequestOutputGroupOutput> output{};
  shared_ptr<SubmitTranscodeJobRequestOutputGroupProcessConfig> processConfig{};

  SubmitTranscodeJobRequestOutputGroup() {}

  explicit SubmitTranscodeJobRequestOutputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (processConfig) {
      res["ProcessConfig"] = processConfig ? boost::any(processConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitTranscodeJobRequestOutputGroupOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitTranscodeJobRequestOutputGroupOutput>(model1);
      }
    }
    if (m.find("ProcessConfig") != m.end() && !m["ProcessConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProcessConfig"].type()) {
        SubmitTranscodeJobRequestOutputGroupProcessConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProcessConfig"]));
        processConfig = make_shared<SubmitTranscodeJobRequestOutputGroupProcessConfig>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobRequestOutputGroup() = default;
};
class SubmitTranscodeJobRequestScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitTranscodeJobRequestScheduleConfig() {}

  explicit SubmitTranscodeJobRequestScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitTranscodeJobRequestScheduleConfig() = default;
};
class SubmitTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<SubmitTranscodeJobRequestInputGroup>> inputGroup{};
  shared_ptr<string> name{};
  shared_ptr<vector<SubmitTranscodeJobRequestOutputGroup>> outputGroup{};
  shared_ptr<SubmitTranscodeJobRequestScheduleConfig> scheduleConfig{};
  shared_ptr<string> userData{};

  SubmitTranscodeJobRequest() {}

  explicit SubmitTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (inputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*inputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputGroup"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroup"] = boost::any(temp1);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InputGroup") != m.end() && !m["InputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["InputGroup"].type()) {
        vector<SubmitTranscodeJobRequestInputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobRequestInputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputGroup = make_shared<vector<SubmitTranscodeJobRequestInputGroup>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputGroup") != m.end() && !m["OutputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroup"].type()) {
        vector<SubmitTranscodeJobRequestOutputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobRequestOutputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroup = make_shared<vector<SubmitTranscodeJobRequestOutputGroup>>(expect1);
      }
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitTranscodeJobRequestScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitTranscodeJobRequestScheduleConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitTranscodeJobRequest() = default;
};
class SubmitTranscodeJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> inputGroupShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> outputGroupShrink{};
  shared_ptr<string> scheduleConfigShrink{};
  shared_ptr<string> userData{};

  SubmitTranscodeJobShrinkRequest() {}

  explicit SubmitTranscodeJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (inputGroupShrink) {
      res["InputGroup"] = boost::any(*inputGroupShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputGroupShrink) {
      res["OutputGroup"] = boost::any(*outputGroupShrink);
    }
    if (scheduleConfigShrink) {
      res["ScheduleConfig"] = boost::any(*scheduleConfigShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InputGroup") != m.end() && !m["InputGroup"].empty()) {
      inputGroupShrink = make_shared<string>(boost::any_cast<string>(m["InputGroup"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputGroup") != m.end() && !m["OutputGroup"].empty()) {
      outputGroupShrink = make_shared<string>(boost::any_cast<string>(m["OutputGroup"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      scheduleConfigShrink = make_shared<string>(boost::any_cast<string>(m["ScheduleConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitTranscodeJobShrinkRequest() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs : public Darabonba::Model {
public:
  shared_ptr<string> audioIndex{};
  shared_ptr<double> duration{};
  shared_ptr<double> start{};
  shared_ptr<string> videoIndex{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioIndex) {
      res["AudioIndex"] = boost::any(*audioIndex);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (videoIndex) {
      res["VideoIndex"] = boost::any(*videoIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioIndex") != m.end() && !m["AudioIndex"].empty()) {
      audioIndex = make_shared<string>(boost::any_cast<string>(m["AudioIndex"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<double>(boost::any_cast<double>(m["Start"]));
    }
    if (m.find("VideoIndex") != m.end() && !m["VideoIndex"].empty()) {
      videoIndex = make_shared<string>(boost::any_cast<string>(m["VideoIndex"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption : public Darabonba::Model {
public:
  shared_ptr<string> cipherText{};
  shared_ptr<string> decryptKeyUri{};
  shared_ptr<string> encryptType{};
  shared_ptr<string> keyServiceType{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cipherText) {
      res["CipherText"] = boost::any(*cipherText);
    }
    if (decryptKeyUri) {
      res["DecryptKeyUri"] = boost::any(*decryptKeyUri);
    }
    if (encryptType) {
      res["EncryptType"] = boost::any(*encryptType);
    }
    if (keyServiceType) {
      res["KeyServiceType"] = boost::any(*keyServiceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CipherText") != m.end() && !m["CipherText"].empty()) {
      cipherText = make_shared<string>(boost::any_cast<string>(m["CipherText"]));
    }
    if (m.find("DecryptKeyUri") != m.end() && !m["DecryptKeyUri"].empty()) {
      decryptKeyUri = make_shared<string>(boost::any_cast<string>(m["DecryptKeyUri"]));
    }
    if (m.find("EncryptType") != m.end() && !m["EncryptType"].empty()) {
      encryptType = make_shared<string>(boost::any_cast<string>(m["EncryptType"]));
    }
    if (m.find("KeyServiceType") != m.end() && !m["KeyServiceType"].empty()) {
      keyServiceType = make_shared<string>(boost::any_cast<string>(m["KeyServiceType"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile> file{};
  shared_ptr<string> height{};
  shared_ptr<string> referPos{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline> timeline{};
  shared_ptr<string> width{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile> file{};
  shared_ptr<string> format{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> adaptive{};
  shared_ptr<string> borderColor{};
  shared_ptr<long> borderWidth{};
  shared_ptr<string> content{};
  shared_ptr<string> fontAlpha{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<long> fontSize{};
  shared_ptr<string> left{};
  shared_ptr<string> top{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adaptive) {
      res["Adaptive"] = boost::any(*adaptive);
    }
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidth) {
      res["BorderWidth"] = boost::any(*borderWidth);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fontAlpha) {
      res["FontAlpha"] = boost::any(*fontAlpha);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSize) {
      res["FontSize"] = boost::any(*fontSize);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adaptive") != m.end() && !m["Adaptive"].empty()) {
      adaptive = make_shared<string>(boost::any_cast<string>(m["Adaptive"]));
    }
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidth") != m.end() && !m["BorderWidth"].empty()) {
      borderWidth = make_shared<long>(boost::any_cast<long>(m["BorderWidth"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FontAlpha") != m.end() && !m["FontAlpha"].empty()) {
      fontAlpha = make_shared<string>(boost::any_cast<string>(m["FontAlpha"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSize") != m.end() && !m["FontSize"].empty()) {
      fontSize = make_shared<long>(boost::any_cast<long>(m["FontSize"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> integratedLoudnessTarget{};
  shared_ptr<string> loudnessRangeTarget{};
  shared_ptr<string> method{};
  shared_ptr<string> truePeak{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedLoudnessTarget) {
      res["IntegratedLoudnessTarget"] = boost::any(*integratedLoudnessTarget);
    }
    if (loudnessRangeTarget) {
      res["LoudnessRangeTarget"] = boost::any(*loudnessRangeTarget);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (truePeak) {
      res["TruePeak"] = boost::any(*truePeak);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedLoudnessTarget") != m.end() && !m["IntegratedLoudnessTarget"].empty()) {
      integratedLoudnessTarget = make_shared<string>(boost::any_cast<string>(m["IntegratedLoudnessTarget"]));
    }
    if (m.find("LoudnessRangeTarget") != m.end() && !m["LoudnessRangeTarget"].empty()) {
      loudnessRangeTarget = make_shared<string>(boost::any_cast<string>(m["LoudnessRangeTarget"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("TruePeak") != m.end() && !m["TruePeak"].empty()) {
      truePeak = make_shared<string>(boost::any_cast<string>(m["TruePeak"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume> volume{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> forceSegTime{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (forceSegTime) {
      res["ForceSegTime"] = boost::any(*forceSegTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ForceSegTime") != m.end() && !m["ForceSegTime"].empty()) {
      forceSegTime = make_shared<string>(boost::any_cast<string>(m["ForceSegTime"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment> segment{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo : public Darabonba::Model {
public:
  shared_ptr<string> abrMax{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abrMax) {
      res["AbrMax"] = boost::any(*abrMax);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbrMax") != m.end() && !m["AbrMax"].empty()) {
      abrMax = make_shared<string>(boost::any_cast<string>(m["AbrMax"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio> audio{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer> container{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig> muxConfig{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig> transConfig{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo> video{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs>> combineConfigs{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption> encryption{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks>> imageWatermarks{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles>> subtitles{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks>> textWatermarks{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode> transcode{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (combineConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*combineConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CombineConfigs"] = boost::any(temp1);
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*imageWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageWatermarks"] = boost::any(temp1);
    }
    if (subtitles) {
      vector<boost::any> temp1;
      for(auto item1:*subtitles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitles"] = boost::any(temp1);
    }
    if (textWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*textWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextWatermarks"] = boost::any(temp1);
    }
    if (transcode) {
      res["Transcode"] = transcode ? boost::any(transcode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CombineConfigs") != m.end() && !m["CombineConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["CombineConfigs"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CombineConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        combineConfigs = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigCombineConfigs>>(expect1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigEncryption>(model1);
      }
    }
    if (m.find("ImageWatermarks") != m.end() && !m["ImageWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageWatermarks"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageWatermarks = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks>>(expect1);
      }
    }
    if (m.find("Subtitles") != m.end() && !m["Subtitles"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitles"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitles = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles>>(expect1);
      }
    }
    if (m.find("TextWatermarks") != m.end() && !m["TextWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["TextWatermarks"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textWatermarks = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks>>(expect1);
      }
    }
    if (m.find("Transcode") != m.end() && !m["Transcode"].empty()) {
      if (typeid(map<string, boost::any>) == m["Transcode"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Transcode"]));
        transcode = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput> output{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig> processConfig{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (processConfig) {
      res["ProcessConfig"] = processConfig ? boost::any(processConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput>(model1);
      }
    }
    if (m.find("ProcessConfig") != m.end() && !m["ProcessConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProcessConfig"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProcessConfig"]));
        processConfig = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup : public Darabonba::Model {
public:
  shared_ptr<string> inputUrl{};
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputUrl) {
      res["InputUrl"] = boost::any(*inputUrl);
    }
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputUrl") != m.end() && !m["InputUrl"].empty()) {
      inputUrl = make_shared<string>(boost::any_cast<string>(m["InputUrl"]));
    }
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<string> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> duration{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> sampleFmt{};
  shared_ptr<string> sampleRate{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timebase{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (sampleFmt) {
      res["SampleFmt"] = boost::any(*sampleFmt);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timebase) {
      res["Timebase"] = boost::any(*timebase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("SampleFmt") != m.end() && !m["SampleFmt"].empty()) {
      sampleFmt = make_shared<string>(boost::any_cast<string>(m["SampleFmt"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<string>(boost::any_cast<string>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Timebase") != m.end() && !m["Timebase"].empty()) {
      timebase = make_shared<string>(boost::any_cast<string>(m["Timebase"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileSize{};
  shared_ptr<string> fileStatus{};
  shared_ptr<string> fileType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> formatName{};
  shared_ptr<string> height{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> region{};
  shared_ptr<string> width{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["FileSize"] = boost::any(*fileSize);
    }
    if (fileStatus) {
      res["FileStatus"] = boost::any(*fileStatus);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileSize") != m.end() && !m["FileSize"].empty()) {
      fileSize = make_shared<string>(boost::any_cast<string>(m["FileSize"]));
    }
    if (m.find("FileStatus") != m.end() && !m["FileStatus"].empty()) {
      fileStatus = make_shared<string>(boost::any_cast<string>(m["FileStatus"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList : public Darabonba::Model {
public:
  shared_ptr<string> avgFps{};
  shared_ptr<string> bitRate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> dar{};
  shared_ptr<string> duration{};
  shared_ptr<string> fps{};
  shared_ptr<string> hasBFrames{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lang{};
  shared_ptr<string> level{};
  shared_ptr<string> numFrames{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sar{};
  shared_ptr<string> startTime{};
  shared_ptr<string> timeBase{};
  shared_ptr<string> width{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgFps) {
      res["Avg_fps"] = boost::any(*avgFps);
    }
    if (bitRate) {
      res["Bit_rate"] = boost::any(*bitRate);
    }
    if (codecLongName) {
      res["Codec_long_name"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["Codec_name"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["Codec_tag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["Codec_tag_string"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["Codec_time_base"] = boost::any(*codecTimeBase);
    }
    if (dar) {
      res["Dar"] = boost::any(*dar);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (hasBFrames) {
      res["Has_b_frames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (numFrames) {
      res["NumFrames"] = boost::any(*numFrames);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sar) {
      res["Sar"] = boost::any(*sar);
    }
    if (startTime) {
      res["Start_time"] = boost::any(*startTime);
    }
    if (timeBase) {
      res["Time_base"] = boost::any(*timeBase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avg_fps") != m.end() && !m["Avg_fps"].empty()) {
      avgFps = make_shared<string>(boost::any_cast<string>(m["Avg_fps"]));
    }
    if (m.find("Bit_rate") != m.end() && !m["Bit_rate"].empty()) {
      bitRate = make_shared<string>(boost::any_cast<string>(m["Bit_rate"]));
    }
    if (m.find("Codec_long_name") != m.end() && !m["Codec_long_name"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["Codec_long_name"]));
    }
    if (m.find("Codec_name") != m.end() && !m["Codec_name"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["Codec_name"]));
    }
    if (m.find("Codec_tag") != m.end() && !m["Codec_tag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["Codec_tag"]));
    }
    if (m.find("Codec_tag_string") != m.end() && !m["Codec_tag_string"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["Codec_tag_string"]));
    }
    if (m.find("Codec_time_base") != m.end() && !m["Codec_time_base"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["Codec_time_base"]));
    }
    if (m.find("Dar") != m.end() && !m["Dar"].empty()) {
      dar = make_shared<string>(boost::any_cast<string>(m["Dar"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Has_b_frames") != m.end() && !m["Has_b_frames"].empty()) {
      hasBFrames = make_shared<string>(boost::any_cast<string>(m["Has_b_frames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("NumFrames") != m.end() && !m["NumFrames"].empty()) {
      numFrames = make_shared<string>(boost::any_cast<string>(m["NumFrames"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("Sar") != m.end() && !m["Sar"].empty()) {
      sar = make_shared<string>(boost::any_cast<string>(m["Sar"]));
    }
    if (m.find("Start_time") != m.end() && !m["Start_time"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["Start_time"]));
    }
    if (m.find("Time_base") != m.end() && !m["Time_base"].empty()) {
      timeBase = make_shared<string>(boost::any_cast<string>(m["Time_base"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList>> audioStreamInfoList{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo> fileBasicInfo{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList>> videoStreamInfoList{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreamInfoList"] = boost::any(temp1);
    }
    if (fileBasicInfo) {
      res["FileBasicInfo"] = fileBasicInfo ? boost::any(fileBasicInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoStreamInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreamInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreamInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioStreamInfoList") != m.end() && !m["AudioStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreamInfoList"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreamInfoList = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList>>(expect1);
      }
    }
    if (m.find("FileBasicInfo") != m.end() && !m["FileBasicInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileBasicInfo"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileBasicInfo"]));
        fileBasicInfo = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo>(model1);
      }
    }
    if (m.find("VideoStreamInfoList") != m.end() && !m["VideoStreamInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreamInfoList"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreamInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreamInfoList = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList>>(expect1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> outputUrl{};
  shared_ptr<string> type{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (outputUrl) {
      res["OutputUrl"] = boost::any(*outputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("OutputUrl") != m.end() && !m["OutputUrl"].empty()) {
      outputUrl = make_shared<string>(boost::any_cast<string>(m["OutputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs : public Darabonba::Model {
public:
  shared_ptr<string> audioIndex{};
  shared_ptr<double> duration{};
  shared_ptr<double> start{};
  shared_ptr<string> videoIndex{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioIndex) {
      res["AudioIndex"] = boost::any(*audioIndex);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (videoIndex) {
      res["VideoIndex"] = boost::any(*videoIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioIndex") != m.end() && !m["AudioIndex"].empty()) {
      audioIndex = make_shared<string>(boost::any_cast<string>(m["AudioIndex"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<double>(boost::any_cast<double>(m["Start"]));
    }
    if (m.find("VideoIndex") != m.end() && !m["VideoIndex"].empty()) {
      videoIndex = make_shared<string>(boost::any_cast<string>(m["VideoIndex"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption : public Darabonba::Model {
public:
  shared_ptr<string> cipherText{};
  shared_ptr<string> decryptKeyUri{};
  shared_ptr<string> encryptType{};
  shared_ptr<string> keyServiceType{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cipherText) {
      res["CipherText"] = boost::any(*cipherText);
    }
    if (decryptKeyUri) {
      res["DecryptKeyUri"] = boost::any(*decryptKeyUri);
    }
    if (encryptType) {
      res["EncryptType"] = boost::any(*encryptType);
    }
    if (keyServiceType) {
      res["KeyServiceType"] = boost::any(*keyServiceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CipherText") != m.end() && !m["CipherText"].empty()) {
      cipherText = make_shared<string>(boost::any_cast<string>(m["CipherText"]));
    }
    if (m.find("DecryptKeyUri") != m.end() && !m["DecryptKeyUri"].empty()) {
      decryptKeyUri = make_shared<string>(boost::any_cast<string>(m["DecryptKeyUri"]));
    }
    if (m.find("EncryptType") != m.end() && !m["EncryptType"].empty()) {
      encryptType = make_shared<string>(boost::any_cast<string>(m["EncryptType"]));
    }
    if (m.find("KeyServiceType") != m.end() && !m["KeyServiceType"].empty()) {
      keyServiceType = make_shared<string>(boost::any_cast<string>(m["KeyServiceType"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> start{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> dx{};
  shared_ptr<string> dy{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile> file{};
  shared_ptr<string> height{};
  shared_ptr<string> referPos{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline> timeline{};
  shared_ptr<string> width{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (timeline) {
      res["Timeline"] = timeline ? boost::any(timeline->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<string>(boost::any_cast<string>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<string>(boost::any_cast<string>(m["Dy"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      if (typeid(map<string, boost::any>) == m["Timeline"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Timeline"]));
        timeline = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile : public Darabonba::Model {
public:
  shared_ptr<string> media{};
  shared_ptr<string> type{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      res["Media"] = boost::any(*media);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      media = make_shared<string>(boost::any_cast<string>(m["Media"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> charEnc{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile> file{};
  shared_ptr<string> format{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charEnc) {
      res["CharEnc"] = boost::any(*charEnc);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CharEnc") != m.end() && !m["CharEnc"].empty()) {
      charEnc = make_shared<string>(boost::any_cast<string>(m["CharEnc"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile>(model1);
      }
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<string> adaptive{};
  shared_ptr<string> borderColor{};
  shared_ptr<long> borderWidth{};
  shared_ptr<string> content{};
  shared_ptr<string> fontAlpha{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<long> fontSize{};
  shared_ptr<string> left{};
  shared_ptr<string> top{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adaptive) {
      res["Adaptive"] = boost::any(*adaptive);
    }
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidth) {
      res["BorderWidth"] = boost::any(*borderWidth);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fontAlpha) {
      res["FontAlpha"] = boost::any(*fontAlpha);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSize) {
      res["FontSize"] = boost::any(*fontSize);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Adaptive") != m.end() && !m["Adaptive"].empty()) {
      adaptive = make_shared<string>(boost::any_cast<string>(m["Adaptive"]));
    }
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidth") != m.end() && !m["BorderWidth"].empty()) {
      borderWidth = make_shared<long>(boost::any_cast<long>(m["BorderWidth"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FontAlpha") != m.end() && !m["FontAlpha"].empty()) {
      fontAlpha = make_shared<string>(boost::any_cast<string>(m["FontAlpha"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSize") != m.end() && !m["FontSize"].empty()) {
      fontSize = make_shared<long>(boost::any_cast<long>(m["FontSize"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<string>(boost::any_cast<string>(m["Left"]));
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<string>(boost::any_cast<string>(m["Top"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume : public Darabonba::Model {
public:
  shared_ptr<string> integratedLoudnessTarget{};
  shared_ptr<string> loudnessRangeTarget{};
  shared_ptr<string> method{};
  shared_ptr<string> truePeak{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integratedLoudnessTarget) {
      res["IntegratedLoudnessTarget"] = boost::any(*integratedLoudnessTarget);
    }
    if (loudnessRangeTarget) {
      res["LoudnessRangeTarget"] = boost::any(*loudnessRangeTarget);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (truePeak) {
      res["TruePeak"] = boost::any(*truePeak);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntegratedLoudnessTarget") != m.end() && !m["IntegratedLoudnessTarget"].empty()) {
      integratedLoudnessTarget = make_shared<string>(boost::any_cast<string>(m["IntegratedLoudnessTarget"]));
    }
    if (m.find("LoudnessRangeTarget") != m.end() && !m["LoudnessRangeTarget"].empty()) {
      loudnessRangeTarget = make_shared<string>(boost::any_cast<string>(m["LoudnessRangeTarget"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("TruePeak") != m.end() && !m["TruePeak"].empty()) {
      truePeak = make_shared<string>(boost::any_cast<string>(m["TruePeak"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> samplerate{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume> volume{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    if (volume) {
      res["Volume"] = volume ? boost::any(volume->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      if (typeid(map<string, boost::any>) == m["Volume"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Volume"]));
        volume = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer : public Darabonba::Model {
public:
  shared_ptr<string> format{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> forceSegTime{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (forceSegTime) {
      res["ForceSegTime"] = boost::any(*forceSegTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("ForceSegTime") != m.end() && !m["ForceSegTime"].empty()) {
      forceSegTime = make_shared<string>(boost::any_cast<string>(m["ForceSegTime"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment> segment{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig : public Darabonba::Model {
public:
  shared_ptr<string> adjDarMethod{};
  shared_ptr<string> isCheckAudioBitrate{};
  shared_ptr<string> isCheckAudioBitrateFail{};
  shared_ptr<string> isCheckReso{};
  shared_ptr<string> isCheckResoFail{};
  shared_ptr<string> isCheckVideoBitrate{};
  shared_ptr<string> isCheckVideoBitrateFail{};
  shared_ptr<string> transMode{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adjDarMethod) {
      res["AdjDarMethod"] = boost::any(*adjDarMethod);
    }
    if (isCheckAudioBitrate) {
      res["IsCheckAudioBitrate"] = boost::any(*isCheckAudioBitrate);
    }
    if (isCheckAudioBitrateFail) {
      res["IsCheckAudioBitrateFail"] = boost::any(*isCheckAudioBitrateFail);
    }
    if (isCheckReso) {
      res["IsCheckReso"] = boost::any(*isCheckReso);
    }
    if (isCheckResoFail) {
      res["IsCheckResoFail"] = boost::any(*isCheckResoFail);
    }
    if (isCheckVideoBitrate) {
      res["IsCheckVideoBitrate"] = boost::any(*isCheckVideoBitrate);
    }
    if (isCheckVideoBitrateFail) {
      res["IsCheckVideoBitrateFail"] = boost::any(*isCheckVideoBitrateFail);
    }
    if (transMode) {
      res["TransMode"] = boost::any(*transMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdjDarMethod") != m.end() && !m["AdjDarMethod"].empty()) {
      adjDarMethod = make_shared<string>(boost::any_cast<string>(m["AdjDarMethod"]));
    }
    if (m.find("IsCheckAudioBitrate") != m.end() && !m["IsCheckAudioBitrate"].empty()) {
      isCheckAudioBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrate"]));
    }
    if (m.find("IsCheckAudioBitrateFail") != m.end() && !m["IsCheckAudioBitrateFail"].empty()) {
      isCheckAudioBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckAudioBitrateFail"]));
    }
    if (m.find("IsCheckReso") != m.end() && !m["IsCheckReso"].empty()) {
      isCheckReso = make_shared<string>(boost::any_cast<string>(m["IsCheckReso"]));
    }
    if (m.find("IsCheckResoFail") != m.end() && !m["IsCheckResoFail"].empty()) {
      isCheckResoFail = make_shared<string>(boost::any_cast<string>(m["IsCheckResoFail"]));
    }
    if (m.find("IsCheckVideoBitrate") != m.end() && !m["IsCheckVideoBitrate"].empty()) {
      isCheckVideoBitrate = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrate"]));
    }
    if (m.find("IsCheckVideoBitrateFail") != m.end() && !m["IsCheckVideoBitrateFail"].empty()) {
      isCheckVideoBitrateFail = make_shared<string>(boost::any_cast<string>(m["IsCheckVideoBitrateFail"]));
    }
    if (m.find("TransMode") != m.end() && !m["TransMode"].empty()) {
      transMode = make_shared<string>(boost::any_cast<string>(m["TransMode"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo : public Darabonba::Model {
public:
  shared_ptr<string> abrMax{};
  shared_ptr<string> bitrate{};
  shared_ptr<string> bufsize{};
  shared_ptr<string> codec{};
  shared_ptr<string> crf{};
  shared_ptr<string> crop{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> longShortMode{};
  shared_ptr<string> maxrate{};
  shared_ptr<string> pad{};
  shared_ptr<string> pixFmt{};
  shared_ptr<string> preset{};
  shared_ptr<string> profile{};
  shared_ptr<string> remove{};
  shared_ptr<string> scanMode{};
  shared_ptr<string> width{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abrMax) {
      res["AbrMax"] = boost::any(*abrMax);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufsize) {
      res["Bufsize"] = boost::any(*bufsize);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (crf) {
      res["Crf"] = boost::any(*crf);
    }
    if (crop) {
      res["Crop"] = boost::any(*crop);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (longShortMode) {
      res["LongShortMode"] = boost::any(*longShortMode);
    }
    if (maxrate) {
      res["Maxrate"] = boost::any(*maxrate);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (pixFmt) {
      res["PixFmt"] = boost::any(*pixFmt);
    }
    if (preset) {
      res["Preset"] = boost::any(*preset);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (remove) {
      res["Remove"] = boost::any(*remove);
    }
    if (scanMode) {
      res["ScanMode"] = boost::any(*scanMode);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbrMax") != m.end() && !m["AbrMax"].empty()) {
      abrMax = make_shared<string>(boost::any_cast<string>(m["AbrMax"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Bufsize") != m.end() && !m["Bufsize"].empty()) {
      bufsize = make_shared<string>(boost::any_cast<string>(m["Bufsize"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Crf") != m.end() && !m["Crf"].empty()) {
      crf = make_shared<string>(boost::any_cast<string>(m["Crf"]));
    }
    if (m.find("Crop") != m.end() && !m["Crop"].empty()) {
      crop = make_shared<string>(boost::any_cast<string>(m["Crop"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("LongShortMode") != m.end() && !m["LongShortMode"].empty()) {
      longShortMode = make_shared<string>(boost::any_cast<string>(m["LongShortMode"]));
    }
    if (m.find("Maxrate") != m.end() && !m["Maxrate"].empty()) {
      maxrate = make_shared<string>(boost::any_cast<string>(m["Maxrate"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<string>(boost::any_cast<string>(m["Pad"]));
    }
    if (m.find("PixFmt") != m.end() && !m["PixFmt"].empty()) {
      pixFmt = make_shared<string>(boost::any_cast<string>(m["PixFmt"]));
    }
    if (m.find("Preset") != m.end() && !m["Preset"].empty()) {
      preset = make_shared<string>(boost::any_cast<string>(m["Preset"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Remove") != m.end() && !m["Remove"].empty()) {
      remove = make_shared<string>(boost::any_cast<string>(m["Remove"]));
    }
    if (m.find("ScanMode") != m.end() && !m["ScanMode"].empty()) {
      scanMode = make_shared<string>(boost::any_cast<string>(m["ScanMode"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio> audio{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer> container{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig> muxConfig{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig> transConfig{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo> video{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = container ? boost::any(container->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (muxConfig) {
      res["MuxConfig"] = muxConfig ? boost::any(muxConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transConfig) {
      res["TransConfig"] = transConfig ? boost::any(transConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      if (typeid(map<string, boost::any>) == m["Container"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Container"]));
        container = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer>(model1);
      }
    }
    if (m.find("MuxConfig") != m.end() && !m["MuxConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MuxConfig"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MuxConfig"]));
        muxConfig = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig>(model1);
      }
    }
    if (m.find("TransConfig") != m.end() && !m["TransConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransConfig"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransConfig"]));
        transConfig = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsTransConfig>(model1);
      }
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode : public Darabonba::Model {
public:
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams> overwriteParams{};
  shared_ptr<string> templateId{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteParams) {
      res["OverwriteParams"] = overwriteParams ? boost::any(overwriteParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteParams") != m.end() && !m["OverwriteParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["OverwriteParams"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OverwriteParams"]));
        overwriteParams = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs>> combineConfigs{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption> encryption{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks>> imageWatermarks{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles>> subtitles{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks>> textWatermarks{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode> transcode{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (combineConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*combineConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CombineConfigs"] = boost::any(temp1);
    }
    if (encryption) {
      res["Encryption"] = encryption ? boost::any(encryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*imageWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageWatermarks"] = boost::any(temp1);
    }
    if (subtitles) {
      vector<boost::any> temp1;
      for(auto item1:*subtitles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitles"] = boost::any(temp1);
    }
    if (textWatermarks) {
      vector<boost::any> temp1;
      for(auto item1:*textWatermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextWatermarks"] = boost::any(temp1);
    }
    if (transcode) {
      res["Transcode"] = transcode ? boost::any(transcode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CombineConfigs") != m.end() && !m["CombineConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["CombineConfigs"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CombineConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        combineConfigs = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigCombineConfigs>>(expect1);
      }
    }
    if (m.find("Encryption") != m.end() && !m["Encryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["Encryption"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Encryption"]));
        encryption = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigEncryption>(model1);
      }
    }
    if (m.find("ImageWatermarks") != m.end() && !m["ImageWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageWatermarks"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageWatermarks = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks>>(expect1);
      }
    }
    if (m.find("Subtitles") != m.end() && !m["Subtitles"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitles"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitles = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles>>(expect1);
      }
    }
    if (m.find("TextWatermarks") != m.end() && !m["TextWatermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["TextWatermarks"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextWatermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textWatermarks = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks>>(expect1);
      }
    }
    if (m.find("Transcode") != m.end() && !m["Transcode"].empty()) {
      if (typeid(map<string, boost::any>) == m["Transcode"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Transcode"]));
        transcode = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup>> inputGroup{};
  shared_ptr<string> jobId{};
  shared_ptr<long> jobIndex{};
  shared_ptr<string> name{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta> outFileMeta{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput> output{};
  shared_ptr<string> parentJobId{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig> processConfig{};
  shared_ptr<string> requestId{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> submitResultJson{};
  shared_ptr<string> submitTime{};
  shared_ptr<string> userData{};

  SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (inputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*inputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputGroup"] = boost::any(temp1);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobIndex) {
      res["JobIndex"] = boost::any(*jobIndex);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outFileMeta) {
      res["OutFileMeta"] = outFileMeta ? boost::any(outFileMeta->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parentJobId) {
      res["ParentJobId"] = boost::any(*parentJobId);
    }
    if (processConfig) {
      res["ProcessConfig"] = processConfig ? boost::any(processConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitResultJson) {
      res["SubmitResultJson"] = boost::any(*submitResultJson);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("InputGroup") != m.end() && !m["InputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["InputGroup"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputGroup = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup>>(expect1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobIndex") != m.end() && !m["JobIndex"].empty()) {
      jobIndex = make_shared<long>(boost::any_cast<long>(m["JobIndex"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutFileMeta") != m.end() && !m["OutFileMeta"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutFileMeta"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutFileMeta"]));
        outFileMeta = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta>(model1);
      }
    }
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput>(model1);
      }
    }
    if (m.find("ParentJobId") != m.end() && !m["ParentJobId"].empty()) {
      parentJobId = make_shared<string>(boost::any_cast<string>(m["ParentJobId"]));
    }
    if (m.find("ProcessConfig") != m.end() && !m["ProcessConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProcessConfig"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProcessConfig"]));
        processConfig = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitResultJson") != m.end() && !m["SubmitResultJson"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["SubmitResultJson"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      submitResultJson = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList() = default;
};
class SubmitTranscodeJobResponseBodyTranscodeParentJob : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup>> inputGroup{};
  shared_ptr<long> jobCount{};
  shared_ptr<string> name{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup>> outputGroup{};
  shared_ptr<string> parentJobId{};
  shared_ptr<long> percent{};
  shared_ptr<string> requestId{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig> scheduleConfig{};
  shared_ptr<string> status{};
  shared_ptr<string> submitTime{};
  shared_ptr<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList>> transcodeJobList{};
  shared_ptr<string> triggerSource{};
  shared_ptr<string> userData{};

  SubmitTranscodeJobResponseBodyTranscodeParentJob() {}

  explicit SubmitTranscodeJobResponseBodyTranscodeParentJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (inputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*inputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputGroup"] = boost::any(temp1);
    }
    if (jobCount) {
      res["JobCount"] = boost::any(*jobCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputGroup) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroup"] = boost::any(temp1);
    }
    if (parentJobId) {
      res["ParentJobId"] = boost::any(*parentJobId);
    }
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (scheduleConfig) {
      res["ScheduleConfig"] = scheduleConfig ? boost::any(scheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (submitTime) {
      res["SubmitTime"] = boost::any(*submitTime);
    }
    if (transcodeJobList) {
      vector<boost::any> temp1;
      for(auto item1:*transcodeJobList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TranscodeJobList"] = boost::any(temp1);
    }
    if (triggerSource) {
      res["TriggerSource"] = boost::any(*triggerSource);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("InputGroup") != m.end() && !m["InputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["InputGroup"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputGroup = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup>>(expect1);
      }
    }
    if (m.find("JobCount") != m.end() && !m["JobCount"].empty()) {
      jobCount = make_shared<long>(boost::any_cast<long>(m["JobCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputGroup") != m.end() && !m["OutputGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroup"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroup = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup>>(expect1);
      }
    }
    if (m.find("ParentJobId") != m.end() && !m["ParentJobId"].empty()) {
      parentJobId = make_shared<string>(boost::any_cast<string>(m["ParentJobId"]));
    }
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ScheduleConfig") != m.end() && !m["ScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScheduleConfig"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScheduleConfig"]));
        scheduleConfig = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubmitTime") != m.end() && !m["SubmitTime"].empty()) {
      submitTime = make_shared<string>(boost::any_cast<string>(m["SubmitTime"]));
    }
    if (m.find("TranscodeJobList") != m.end() && !m["TranscodeJobList"].empty()) {
      if (typeid(vector<boost::any>) == m["TranscodeJobList"].type()) {
        vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TranscodeJobList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transcodeJobList = make_shared<vector<SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList>>(expect1);
      }
    }
    if (m.find("TriggerSource") != m.end() && !m["TriggerSource"].empty()) {
      triggerSource = make_shared<string>(boost::any_cast<string>(m["TriggerSource"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitTranscodeJobResponseBodyTranscodeParentJob() = default;
};
class SubmitTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SubmitTranscodeJobResponseBodyTranscodeParentJob> transcodeParentJob{};

  SubmitTranscodeJobResponseBody() {}

  explicit SubmitTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (transcodeParentJob) {
      res["TranscodeParentJob"] = transcodeParentJob ? boost::any(transcodeParentJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TranscodeParentJob") != m.end() && !m["TranscodeParentJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeParentJob"].type()) {
        SubmitTranscodeJobResponseBodyTranscodeParentJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeParentJob"]));
        transcodeParentJob = make_shared<SubmitTranscodeJobResponseBodyTranscodeParentJob>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponseBody() = default;
};
class SubmitTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitTranscodeJobResponseBody> body{};

  SubmitTranscodeJobResponse() {}

  explicit SubmitTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitTranscodeJobResponse() = default;
};
class SubmitVideoTranslationJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> editingConfig{};
  shared_ptr<string> inputConfig{};
  shared_ptr<string> outputConfig{};
  shared_ptr<string> signature{};
  shared_ptr<string> signatureMehtod{};
  shared_ptr<string> signatureNonce{};
  shared_ptr<string> signatureType{};
  shared_ptr<string> signatureVersion{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  SubmitVideoTranslationJobRequest() {}

  explicit SubmitVideoTranslationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (editingConfig) {
      res["EditingConfig"] = boost::any(*editingConfig);
    }
    if (inputConfig) {
      res["InputConfig"] = boost::any(*inputConfig);
    }
    if (outputConfig) {
      res["OutputConfig"] = boost::any(*outputConfig);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (signatureMehtod) {
      res["SignatureMehtod"] = boost::any(*signatureMehtod);
    }
    if (signatureNonce) {
      res["SignatureNonce"] = boost::any(*signatureNonce);
    }
    if (signatureType) {
      res["SignatureType"] = boost::any(*signatureType);
    }
    if (signatureVersion) {
      res["SignatureVersion"] = boost::any(*signatureVersion);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      editingConfig = make_shared<string>(boost::any_cast<string>(m["EditingConfig"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      inputConfig = make_shared<string>(boost::any_cast<string>(m["InputConfig"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfig = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("SignatureMehtod") != m.end() && !m["SignatureMehtod"].empty()) {
      signatureMehtod = make_shared<string>(boost::any_cast<string>(m["SignatureMehtod"]));
    }
    if (m.find("SignatureNonce") != m.end() && !m["SignatureNonce"].empty()) {
      signatureNonce = make_shared<string>(boost::any_cast<string>(m["SignatureNonce"]));
    }
    if (m.find("SignatureType") != m.end() && !m["SignatureType"].empty()) {
      signatureType = make_shared<string>(boost::any_cast<string>(m["SignatureType"]));
    }
    if (m.find("SignatureVersion") != m.end() && !m["SignatureVersion"].empty()) {
      signatureVersion = make_shared<string>(boost::any_cast<string>(m["SignatureVersion"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~SubmitVideoTranslationJobRequest() = default;
};
class SubmitVideoTranslationJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  SubmitVideoTranslationJobResponseBodyData() {}

  explicit SubmitVideoTranslationJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SubmitVideoTranslationJobResponseBodyData() = default;
};
class SubmitVideoTranslationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<SubmitVideoTranslationJobResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitVideoTranslationJobResponseBody() {}

  explicit SubmitVideoTranslationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitVideoTranslationJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitVideoTranslationJobResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitVideoTranslationJobResponseBody() = default;
};
class SubmitVideoTranslationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitVideoTranslationJobResponseBody> body{};

  SubmitVideoTranslationJobResponse() {}

  explicit SubmitVideoTranslationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitVideoTranslationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitVideoTranslationJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitVideoTranslationJobResponse() = default;
};
class TakeoverAIAgentCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> humanAgentUserId{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> requireToken{};

  TakeoverAIAgentCallRequest() {}

  explicit TakeoverAIAgentCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (humanAgentUserId) {
      res["HumanAgentUserId"] = boost::any(*humanAgentUserId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requireToken) {
      res["RequireToken"] = boost::any(*requireToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HumanAgentUserId") != m.end() && !m["HumanAgentUserId"].empty()) {
      humanAgentUserId = make_shared<string>(boost::any_cast<string>(m["HumanAgentUserId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequireToken") != m.end() && !m["RequireToken"].empty()) {
      requireToken = make_shared<bool>(boost::any_cast<bool>(m["RequireToken"]));
    }
  }


  virtual ~TakeoverAIAgentCallRequest() = default;
};
class TakeoverAIAgentCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> humanAgentUserId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> token{};

  TakeoverAIAgentCallResponseBody() {}

  explicit TakeoverAIAgentCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (humanAgentUserId) {
      res["HumanAgentUserId"] = boost::any(*humanAgentUserId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("HumanAgentUserId") != m.end() && !m["HumanAgentUserId"].empty()) {
      humanAgentUserId = make_shared<string>(boost::any_cast<string>(m["HumanAgentUserId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~TakeoverAIAgentCallResponseBody() = default;
};
class TakeoverAIAgentCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TakeoverAIAgentCallResponseBody> body{};

  TakeoverAIAgentCallResponse() {}

  explicit TakeoverAIAgentCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TakeoverAIAgentCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TakeoverAIAgentCallResponseBody>(model1);
      }
    }
  }


  virtual ~TakeoverAIAgentCallResponse() = default;
};
class UpdateAIAgentInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<AIAgentConfig> agentConfig{};
  shared_ptr<string> instanceId{};
  shared_ptr<AIAgentTemplateConfig> templateConfig{};
  shared_ptr<string> userData{};

  UpdateAIAgentInstanceRequest() {}

  explicit UpdateAIAgentInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentConfig) {
      res["AgentConfig"] = agentConfig ? boost::any(agentConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentConfig") != m.end() && !m["AgentConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AgentConfig"].type()) {
        AIAgentConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AgentConfig"]));
        agentConfig = make_shared<AIAgentConfig>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        AIAgentTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<AIAgentTemplateConfig>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~UpdateAIAgentInstanceRequest() = default;
};
class UpdateAIAgentInstanceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentConfigShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> templateConfigShrink{};
  shared_ptr<string> userData{};

  UpdateAIAgentInstanceShrinkRequest() {}

  explicit UpdateAIAgentInstanceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentConfigShrink) {
      res["AgentConfig"] = boost::any(*agentConfigShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (templateConfigShrink) {
      res["TemplateConfig"] = boost::any(*templateConfigShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentConfig") != m.end() && !m["AgentConfig"].empty()) {
      agentConfigShrink = make_shared<string>(boost::any_cast<string>(m["AgentConfig"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfigShrink = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~UpdateAIAgentInstanceShrinkRequest() = default;
};
class UpdateAIAgentInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateAIAgentInstanceResponseBody() {}

  explicit UpdateAIAgentInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAIAgentInstanceResponseBody() = default;
};
class UpdateAIAgentInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAIAgentInstanceResponseBody> body{};

  UpdateAIAgentInstanceResponse() {}

  explicit UpdateAIAgentInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAIAgentInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAIAgentInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAIAgentInstanceResponse() = default;
};
class UpdateAdInsertionRequest : public Darabonba::Model {
public:
  shared_ptr<string> adMarkerPassthrough{};
  shared_ptr<string> adsUrl{};
  shared_ptr<string> cdnAdSegmentUrlPrefix{};
  shared_ptr<string> cdnContentSegmentUrlPrefix{};
  shared_ptr<string> configAliases{};
  shared_ptr<string> contentUrlPrefix{};
  shared_ptr<string> name{};
  shared_ptr<long> personalizationThreshold{};
  shared_ptr<string> slateAdUrl{};

  UpdateAdInsertionRequest() {}

  explicit UpdateAdInsertionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adMarkerPassthrough) {
      res["AdMarkerPassthrough"] = boost::any(*adMarkerPassthrough);
    }
    if (adsUrl) {
      res["AdsUrl"] = boost::any(*adsUrl);
    }
    if (cdnAdSegmentUrlPrefix) {
      res["CdnAdSegmentUrlPrefix"] = boost::any(*cdnAdSegmentUrlPrefix);
    }
    if (cdnContentSegmentUrlPrefix) {
      res["CdnContentSegmentUrlPrefix"] = boost::any(*cdnContentSegmentUrlPrefix);
    }
    if (configAliases) {
      res["ConfigAliases"] = boost::any(*configAliases);
    }
    if (contentUrlPrefix) {
      res["ContentUrlPrefix"] = boost::any(*contentUrlPrefix);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (personalizationThreshold) {
      res["PersonalizationThreshold"] = boost::any(*personalizationThreshold);
    }
    if (slateAdUrl) {
      res["SlateAdUrl"] = boost::any(*slateAdUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdMarkerPassthrough") != m.end() && !m["AdMarkerPassthrough"].empty()) {
      adMarkerPassthrough = make_shared<string>(boost::any_cast<string>(m["AdMarkerPassthrough"]));
    }
    if (m.find("AdsUrl") != m.end() && !m["AdsUrl"].empty()) {
      adsUrl = make_shared<string>(boost::any_cast<string>(m["AdsUrl"]));
    }
    if (m.find("CdnAdSegmentUrlPrefix") != m.end() && !m["CdnAdSegmentUrlPrefix"].empty()) {
      cdnAdSegmentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["CdnAdSegmentUrlPrefix"]));
    }
    if (m.find("CdnContentSegmentUrlPrefix") != m.end() && !m["CdnContentSegmentUrlPrefix"].empty()) {
      cdnContentSegmentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["CdnContentSegmentUrlPrefix"]));
    }
    if (m.find("ConfigAliases") != m.end() && !m["ConfigAliases"].empty()) {
      configAliases = make_shared<string>(boost::any_cast<string>(m["ConfigAliases"]));
    }
    if (m.find("ContentUrlPrefix") != m.end() && !m["ContentUrlPrefix"].empty()) {
      contentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["ContentUrlPrefix"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PersonalizationThreshold") != m.end() && !m["PersonalizationThreshold"].empty()) {
      personalizationThreshold = make_shared<long>(boost::any_cast<long>(m["PersonalizationThreshold"]));
    }
    if (m.find("SlateAdUrl") != m.end() && !m["SlateAdUrl"].empty()) {
      slateAdUrl = make_shared<string>(boost::any_cast<string>(m["SlateAdUrl"]));
    }
  }


  virtual ~UpdateAdInsertionRequest() = default;
};
class UpdateAdInsertionResponseBodyConfigCdnConfig : public Darabonba::Model {
public:
  shared_ptr<string> adSegmentUrlPrefix{};
  shared_ptr<string> contentSegmentUrlPrefix{};

  UpdateAdInsertionResponseBodyConfigCdnConfig() {}

  explicit UpdateAdInsertionResponseBodyConfigCdnConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adSegmentUrlPrefix) {
      res["AdSegmentUrlPrefix"] = boost::any(*adSegmentUrlPrefix);
    }
    if (contentSegmentUrlPrefix) {
      res["ContentSegmentUrlPrefix"] = boost::any(*contentSegmentUrlPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdSegmentUrlPrefix") != m.end() && !m["AdSegmentUrlPrefix"].empty()) {
      adSegmentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["AdSegmentUrlPrefix"]));
    }
    if (m.find("ContentSegmentUrlPrefix") != m.end() && !m["ContentSegmentUrlPrefix"].empty()) {
      contentSegmentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["ContentSegmentUrlPrefix"]));
    }
  }


  virtual ~UpdateAdInsertionResponseBodyConfigCdnConfig() = default;
};
class UpdateAdInsertionResponseBodyConfigManifestEndpointConfig : public Darabonba::Model {
public:
  shared_ptr<string> dashPrefix{};
  shared_ptr<string> hlsPrefix{};

  UpdateAdInsertionResponseBodyConfigManifestEndpointConfig() {}

  explicit UpdateAdInsertionResponseBodyConfigManifestEndpointConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dashPrefix) {
      res["DashPrefix"] = boost::any(*dashPrefix);
    }
    if (hlsPrefix) {
      res["HlsPrefix"] = boost::any(*hlsPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DashPrefix") != m.end() && !m["DashPrefix"].empty()) {
      dashPrefix = make_shared<string>(boost::any_cast<string>(m["DashPrefix"]));
    }
    if (m.find("HlsPrefix") != m.end() && !m["HlsPrefix"].empty()) {
      hlsPrefix = make_shared<string>(boost::any_cast<string>(m["HlsPrefix"]));
    }
  }


  virtual ~UpdateAdInsertionResponseBodyConfigManifestEndpointConfig() = default;
};
class UpdateAdInsertionResponseBodyConfig : public Darabonba::Model {
public:
  shared_ptr<string> adMarkerPassthrough{};
  shared_ptr<string> adsUrl{};
  shared_ptr<UpdateAdInsertionResponseBodyConfigCdnConfig> cdnConfig{};
  shared_ptr<string> configAliases{};
  shared_ptr<string> contentUrlPrefix{};
  shared_ptr<string> createTime{};
  shared_ptr<string> lastModified{};
  shared_ptr<UpdateAdInsertionResponseBodyConfigManifestEndpointConfig> manifestEndpointConfig{};
  shared_ptr<string> name{};
  shared_ptr<long> personalizationThreshold{};
  shared_ptr<string> slateAdUrl{};

  UpdateAdInsertionResponseBodyConfig() {}

  explicit UpdateAdInsertionResponseBodyConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adMarkerPassthrough) {
      res["AdMarkerPassthrough"] = boost::any(*adMarkerPassthrough);
    }
    if (adsUrl) {
      res["AdsUrl"] = boost::any(*adsUrl);
    }
    if (cdnConfig) {
      res["CdnConfig"] = cdnConfig ? boost::any(cdnConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configAliases) {
      res["ConfigAliases"] = boost::any(*configAliases);
    }
    if (contentUrlPrefix) {
      res["ContentUrlPrefix"] = boost::any(*contentUrlPrefix);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (manifestEndpointConfig) {
      res["ManifestEndpointConfig"] = manifestEndpointConfig ? boost::any(manifestEndpointConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (personalizationThreshold) {
      res["PersonalizationThreshold"] = boost::any(*personalizationThreshold);
    }
    if (slateAdUrl) {
      res["SlateAdUrl"] = boost::any(*slateAdUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdMarkerPassthrough") != m.end() && !m["AdMarkerPassthrough"].empty()) {
      adMarkerPassthrough = make_shared<string>(boost::any_cast<string>(m["AdMarkerPassthrough"]));
    }
    if (m.find("AdsUrl") != m.end() && !m["AdsUrl"].empty()) {
      adsUrl = make_shared<string>(boost::any_cast<string>(m["AdsUrl"]));
    }
    if (m.find("CdnConfig") != m.end() && !m["CdnConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CdnConfig"].type()) {
        UpdateAdInsertionResponseBodyConfigCdnConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CdnConfig"]));
        cdnConfig = make_shared<UpdateAdInsertionResponseBodyConfigCdnConfig>(model1);
      }
    }
    if (m.find("ConfigAliases") != m.end() && !m["ConfigAliases"].empty()) {
      configAliases = make_shared<string>(boost::any_cast<string>(m["ConfigAliases"]));
    }
    if (m.find("ContentUrlPrefix") != m.end() && !m["ContentUrlPrefix"].empty()) {
      contentUrlPrefix = make_shared<string>(boost::any_cast<string>(m["ContentUrlPrefix"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("ManifestEndpointConfig") != m.end() && !m["ManifestEndpointConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ManifestEndpointConfig"].type()) {
        UpdateAdInsertionResponseBodyConfigManifestEndpointConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ManifestEndpointConfig"]));
        manifestEndpointConfig = make_shared<UpdateAdInsertionResponseBodyConfigManifestEndpointConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PersonalizationThreshold") != m.end() && !m["PersonalizationThreshold"].empty()) {
      personalizationThreshold = make_shared<long>(boost::any_cast<long>(m["PersonalizationThreshold"]));
    }
    if (m.find("SlateAdUrl") != m.end() && !m["SlateAdUrl"].empty()) {
      slateAdUrl = make_shared<string>(boost::any_cast<string>(m["SlateAdUrl"]));
    }
  }


  virtual ~UpdateAdInsertionResponseBodyConfig() = default;
};
class UpdateAdInsertionResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateAdInsertionResponseBodyConfig> config{};
  shared_ptr<string> requestId{};

  UpdateAdInsertionResponseBody() {}

  explicit UpdateAdInsertionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        UpdateAdInsertionResponseBodyConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<UpdateAdInsertionResponseBodyConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAdInsertionResponseBody() = default;
};
class UpdateAdInsertionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAdInsertionResponseBody> body{};

  UpdateAdInsertionResponse() {}

  explicit UpdateAdInsertionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAdInsertionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAdInsertionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAdInsertionResponse() = default;
};
class UpdateAvatarTrainingJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> avatarDescription{};
  shared_ptr<string> avatarName{};
  shared_ptr<string> jobId{};
  shared_ptr<string> portrait{};
  shared_ptr<string> thumbnail{};
  shared_ptr<bool> transparent{};
  shared_ptr<string> video{};

  UpdateAvatarTrainingJobRequest() {}

  explicit UpdateAvatarTrainingJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatarDescription) {
      res["AvatarDescription"] = boost::any(*avatarDescription);
    }
    if (avatarName) {
      res["AvatarName"] = boost::any(*avatarName);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (portrait) {
      res["Portrait"] = boost::any(*portrait);
    }
    if (thumbnail) {
      res["Thumbnail"] = boost::any(*thumbnail);
    }
    if (transparent) {
      res["Transparent"] = boost::any(*transparent);
    }
    if (video) {
      res["Video"] = boost::any(*video);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvatarDescription") != m.end() && !m["AvatarDescription"].empty()) {
      avatarDescription = make_shared<string>(boost::any_cast<string>(m["AvatarDescription"]));
    }
    if (m.find("AvatarName") != m.end() && !m["AvatarName"].empty()) {
      avatarName = make_shared<string>(boost::any_cast<string>(m["AvatarName"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Portrait") != m.end() && !m["Portrait"].empty()) {
      portrait = make_shared<string>(boost::any_cast<string>(m["Portrait"]));
    }
    if (m.find("Thumbnail") != m.end() && !m["Thumbnail"].empty()) {
      thumbnail = make_shared<string>(boost::any_cast<string>(m["Thumbnail"]));
    }
    if (m.find("Transparent") != m.end() && !m["Transparent"].empty()) {
      transparent = make_shared<bool>(boost::any_cast<bool>(m["Transparent"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      video = make_shared<string>(boost::any_cast<string>(m["Video"]));
    }
  }


  virtual ~UpdateAvatarTrainingJobRequest() = default;
};
class UpdateAvatarTrainingJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  UpdateAvatarTrainingJobResponseBodyData() {}

  explicit UpdateAvatarTrainingJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~UpdateAvatarTrainingJobResponseBodyData() = default;
};
class UpdateAvatarTrainingJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateAvatarTrainingJobResponseBodyData> data{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateAvatarTrainingJobResponseBody() {}

  explicit UpdateAvatarTrainingJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateAvatarTrainingJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateAvatarTrainingJobResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateAvatarTrainingJobResponseBody() = default;
};
class UpdateAvatarTrainingJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAvatarTrainingJobResponseBody> body{};

  UpdateAvatarTrainingJobResponse() {}

  explicit UpdateAvatarTrainingJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAvatarTrainingJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAvatarTrainingJobResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAvatarTrainingJobResponse() = default;
};
class UpdateCategoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> cateId{};
  shared_ptr<string> cateName{};

  UpdateCategoryRequest() {}

  explicit UpdateCategoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (cateName) {
      res["CateName"] = boost::any(*cateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("CateName") != m.end() && !m["CateName"].empty()) {
      cateName = make_shared<string>(boost::any_cast<string>(m["CateName"]));
    }
  }


  virtual ~UpdateCategoryRequest() = default;
};
class UpdateCategoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCategoryResponseBody() {}

  explicit UpdateCategoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCategoryResponseBody() = default;
};
class UpdateCategoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCategoryResponseBody> body{};

  UpdateCategoryResponse() {}

  explicit UpdateCategoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCategoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCategoryResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCategoryResponse() = default;
};
class UpdateChannelRequest : public Darabonba::Model {
public:
  shared_ptr<bool> accessPolicy{};
  shared_ptr<string> accessToken{};
  shared_ptr<string> channelName{};
  shared_ptr<string> fillerSourceLocationName{};
  shared_ptr<string> fillerSourceName{};
  shared_ptr<string> outPutConfigList{};

  UpdateChannelRequest() {}

  explicit UpdateChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPolicy) {
      res["AccessPolicy"] = boost::any(*accessPolicy);
    }
    if (accessToken) {
      res["AccessToken"] = boost::any(*accessToken);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (fillerSourceLocationName) {
      res["FillerSourceLocationName"] = boost::any(*fillerSourceLocationName);
    }
    if (fillerSourceName) {
      res["FillerSourceName"] = boost::any(*fillerSourceName);
    }
    if (outPutConfigList) {
      res["OutPutConfigList"] = boost::any(*outPutConfigList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPolicy") != m.end() && !m["AccessPolicy"].empty()) {
      accessPolicy = make_shared<bool>(boost::any_cast<bool>(m["AccessPolicy"]));
    }
    if (m.find("AccessToken") != m.end() && !m["AccessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["AccessToken"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("FillerSourceLocationName") != m.end() && !m["FillerSourceLocationName"].empty()) {
      fillerSourceLocationName = make_shared<string>(boost::any_cast<string>(m["FillerSourceLocationName"]));
    }
    if (m.find("FillerSourceName") != m.end() && !m["FillerSourceName"].empty()) {
      fillerSourceName = make_shared<string>(boost::any_cast<string>(m["FillerSourceName"]));
    }
    if (m.find("OutPutConfigList") != m.end() && !m["OutPutConfigList"].empty()) {
      outPutConfigList = make_shared<string>(boost::any_cast<string>(m["OutPutConfigList"]));
    }
  }


  virtual ~UpdateChannelRequest() = default;
};
class UpdateChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<ChannelAssemblyChannel> channel{};
  shared_ptr<string> requestId{};

  UpdateChannelResponseBody() {}

  explicit UpdateChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["Channel"] = channel ? boost::any(channel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      if (typeid(map<string, boost::any>) == m["Channel"].type()) {
        ChannelAssemblyChannel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Channel"]));
        channel = make_shared<ChannelAssemblyChannel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateChannelResponseBody() = default;
};
class UpdateChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateChannelResponseBody> body{};

  UpdateChannelResponse() {}

  explicit UpdateChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateChannelResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateChannelResponse() = default;
};
class UpdateCustomTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> templateConfig{};
  shared_ptr<string> templateId{};

  UpdateCustomTemplateRequest() {}

  explicit UpdateCustomTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfig) {
      res["TemplateConfig"] = boost::any(*templateConfig);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfig = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateCustomTemplateRequest() = default;
};
class UpdateCustomTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCustomTemplateResponseBody() {}

  explicit UpdateCustomTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCustomTemplateResponseBody() = default;
};
class UpdateCustomTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCustomTemplateResponseBody> body{};

  UpdateCustomTemplateResponse() {}

  explicit UpdateCustomTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCustomTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCustomTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCustomTemplateResponse() = default;
};
class UpdateCustomizedVoiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> demoAudioMediaId{};
  shared_ptr<string> voiceId{};

  UpdateCustomizedVoiceRequest() {}

  explicit UpdateCustomizedVoiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoAudioMediaId) {
      res["DemoAudioMediaId"] = boost::any(*demoAudioMediaId);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoAudioMediaId") != m.end() && !m["DemoAudioMediaId"].empty()) {
      demoAudioMediaId = make_shared<string>(boost::any_cast<string>(m["DemoAudioMediaId"]));
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
  }


  virtual ~UpdateCustomizedVoiceRequest() = default;
};
class UpdateCustomizedVoiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCustomizedVoiceResponseBody() {}

  explicit UpdateCustomizedVoiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCustomizedVoiceResponseBody() = default;
};
class UpdateCustomizedVoiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCustomizedVoiceResponseBody> body{};

  UpdateCustomizedVoiceResponse() {}

  explicit UpdateCustomizedVoiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCustomizedVoiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCustomizedVoiceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCustomizedVoiceResponse() = default;
};
class UpdateEditingProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> businessStatus{};
  shared_ptr<string> clipsParam{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> projectId{};
  shared_ptr<string> templateId{};
  shared_ptr<string> timeline{};
  shared_ptr<string> title{};

  UpdateEditingProjectRequest() {}

  explicit UpdateEditingProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (businessStatus) {
      res["BusinessStatus"] = boost::any(*businessStatus);
    }
    if (clipsParam) {
      res["ClipsParam"] = boost::any(*clipsParam);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (timeline) {
      res["Timeline"] = boost::any(*timeline);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BusinessStatus") != m.end() && !m["BusinessStatus"].empty()) {
      businessStatus = make_shared<string>(boost::any_cast<string>(m["BusinessStatus"]));
    }
    if (m.find("ClipsParam") != m.end() && !m["ClipsParam"].empty()) {
      clipsParam = make_shared<string>(boost::any_cast<string>(m["ClipsParam"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Timeline") != m.end() && !m["Timeline"].empty()) {
      timeline = make_shared<string>(boost::any_cast<string>(m["Timeline"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateEditingProjectRequest() = default;
};
class UpdateEditingProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateEditingProjectResponseBody() {}

  explicit UpdateEditingProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateEditingProjectResponseBody() = default;
};
class UpdateEditingProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEditingProjectResponseBody> body{};

  UpdateEditingProjectResponse() {}

  explicit UpdateEditingProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEditingProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEditingProjectResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEditingProjectResponse() = default;
};
class UpdateHotwordLibraryRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> hotwordLibraryId{};
  shared_ptr<vector<Hotword>> hotwords{};
  shared_ptr<string> name{};

  UpdateHotwordLibraryRequest() {}

  explicit UpdateHotwordLibraryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hotwordLibraryId) {
      res["HotwordLibraryId"] = boost::any(*hotwordLibraryId);
    }
    if (hotwords) {
      vector<boost::any> temp1;
      for(auto item1:*hotwords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Hotwords"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HotwordLibraryId") != m.end() && !m["HotwordLibraryId"].empty()) {
      hotwordLibraryId = make_shared<string>(boost::any_cast<string>(m["HotwordLibraryId"]));
    }
    if (m.find("Hotwords") != m.end() && !m["Hotwords"].empty()) {
      if (typeid(vector<boost::any>) == m["Hotwords"].type()) {
        vector<Hotword> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Hotwords"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Hotword model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        hotwords = make_shared<vector<Hotword>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateHotwordLibraryRequest() = default;
};
class UpdateHotwordLibraryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> hotwordLibraryId{};
  shared_ptr<string> hotwordsShrink{};
  shared_ptr<string> name{};

  UpdateHotwordLibraryShrinkRequest() {}

  explicit UpdateHotwordLibraryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hotwordLibraryId) {
      res["HotwordLibraryId"] = boost::any(*hotwordLibraryId);
    }
    if (hotwordsShrink) {
      res["Hotwords"] = boost::any(*hotwordsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HotwordLibraryId") != m.end() && !m["HotwordLibraryId"].empty()) {
      hotwordLibraryId = make_shared<string>(boost::any_cast<string>(m["HotwordLibraryId"]));
    }
    if (m.find("Hotwords") != m.end() && !m["Hotwords"].empty()) {
      hotwordsShrink = make_shared<string>(boost::any_cast<string>(m["Hotwords"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateHotwordLibraryShrinkRequest() = default;
};
class UpdateHotwordLibraryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  UpdateHotwordLibraryResponseBody() {}

  explicit UpdateHotwordLibraryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~UpdateHotwordLibraryResponseBody() = default;
};
class UpdateHotwordLibraryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateHotwordLibraryResponseBody> body{};

  UpdateHotwordLibraryResponse() {}

  explicit UpdateHotwordLibraryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateHotwordLibraryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateHotwordLibraryResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateHotwordLibraryResponse() = default;
};
class UpdateLivePackageChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<string> protocol{};
  shared_ptr<long> segmentCount{};
  shared_ptr<long> segmentDuration{};

  UpdateLivePackageChannelRequest() {}

  explicit UpdateLivePackageChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (segmentCount) {
      res["SegmentCount"] = boost::any(*segmentCount);
    }
    if (segmentDuration) {
      res["SegmentDuration"] = boost::any(*segmentDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SegmentCount") != m.end() && !m["SegmentCount"].empty()) {
      segmentCount = make_shared<long>(boost::any_cast<long>(m["SegmentCount"]));
    }
    if (m.find("SegmentDuration") != m.end() && !m["SegmentDuration"].empty()) {
      segmentDuration = make_shared<long>(boost::any_cast<long>(m["SegmentDuration"]));
    }
  }


  virtual ~UpdateLivePackageChannelRequest() = default;
};
class UpdateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> password{};
  shared_ptr<string> url{};
  shared_ptr<string> username{};

  UpdateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints() {}

  explicit UpdateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~UpdateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints() = default;
};
class UpdateLivePackageChannelResponseBodyLivePackageChannel : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<vector<UpdateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints>> ingestEndpoints{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> protocol{};
  shared_ptr<long> segmentCount{};
  shared_ptr<long> segmentDuration{};

  UpdateLivePackageChannelResponseBodyLivePackageChannel() {}

  explicit UpdateLivePackageChannelResponseBodyLivePackageChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (ingestEndpoints) {
      vector<boost::any> temp1;
      for(auto item1:*ingestEndpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngestEndpoints"] = boost::any(temp1);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (segmentCount) {
      res["SegmentCount"] = boost::any(*segmentCount);
    }
    if (segmentDuration) {
      res["SegmentDuration"] = boost::any(*segmentDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IngestEndpoints") != m.end() && !m["IngestEndpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["IngestEndpoints"].type()) {
        vector<UpdateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngestEndpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingestEndpoints = make_shared<vector<UpdateLivePackageChannelResponseBodyLivePackageChannelIngestEndpoints>>(expect1);
      }
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SegmentCount") != m.end() && !m["SegmentCount"].empty()) {
      segmentCount = make_shared<long>(boost::any_cast<long>(m["SegmentCount"]));
    }
    if (m.find("SegmentDuration") != m.end() && !m["SegmentDuration"].empty()) {
      segmentDuration = make_shared<long>(boost::any_cast<long>(m["SegmentDuration"]));
    }
  }


  virtual ~UpdateLivePackageChannelResponseBodyLivePackageChannel() = default;
};
class UpdateLivePackageChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateLivePackageChannelResponseBodyLivePackageChannel> livePackageChannel{};
  shared_ptr<string> requestId{};

  UpdateLivePackageChannelResponseBody() {}

  explicit UpdateLivePackageChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livePackageChannel) {
      res["LivePackageChannel"] = livePackageChannel ? boost::any(livePackageChannel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivePackageChannel") != m.end() && !m["LivePackageChannel"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivePackageChannel"].type()) {
        UpdateLivePackageChannelResponseBodyLivePackageChannel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivePackageChannel"]));
        livePackageChannel = make_shared<UpdateLivePackageChannelResponseBodyLivePackageChannel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLivePackageChannelResponseBody() = default;
};
class UpdateLivePackageChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLivePackageChannelResponseBody> body{};

  UpdateLivePackageChannelResponse() {}

  explicit UpdateLivePackageChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLivePackageChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLivePackageChannelResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLivePackageChannelResponse() = default;
};
class UpdateLivePackageChannelCredentialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> groupName{};
  shared_ptr<long> rotateCredentials{};

  UpdateLivePackageChannelCredentialsRequest() {}

  explicit UpdateLivePackageChannelCredentialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (rotateCredentials) {
      res["RotateCredentials"] = boost::any(*rotateCredentials);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RotateCredentials") != m.end() && !m["RotateCredentials"].empty()) {
      rotateCredentials = make_shared<long>(boost::any_cast<long>(m["RotateCredentials"]));
    }
  }


  virtual ~UpdateLivePackageChannelCredentialsRequest() = default;
};
class UpdateLivePackageChannelCredentialsResponseBodyIngestEndpoints : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> password{};
  shared_ptr<string> url{};
  shared_ptr<string> username{};

  UpdateLivePackageChannelCredentialsResponseBodyIngestEndpoints() {}

  explicit UpdateLivePackageChannelCredentialsResponseBodyIngestEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~UpdateLivePackageChannelCredentialsResponseBodyIngestEndpoints() = default;
};
class UpdateLivePackageChannelCredentialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateLivePackageChannelCredentialsResponseBodyIngestEndpoints>> ingestEndpoints{};
  shared_ptr<string> requestId{};

  UpdateLivePackageChannelCredentialsResponseBody() {}

  explicit UpdateLivePackageChannelCredentialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ingestEndpoints) {
      vector<boost::any> temp1;
      for(auto item1:*ingestEndpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IngestEndpoints"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IngestEndpoints") != m.end() && !m["IngestEndpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["IngestEndpoints"].type()) {
        vector<UpdateLivePackageChannelCredentialsResponseBodyIngestEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IngestEndpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateLivePackageChannelCredentialsResponseBodyIngestEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ingestEndpoints = make_shared<vector<UpdateLivePackageChannelCredentialsResponseBodyIngestEndpoints>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLivePackageChannelCredentialsResponseBody() = default;
};
class UpdateLivePackageChannelCredentialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLivePackageChannelCredentialsResponseBody> body{};

  UpdateLivePackageChannelCredentialsResponse() {}

  explicit UpdateLivePackageChannelCredentialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLivePackageChannelCredentialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLivePackageChannelCredentialsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLivePackageChannelCredentialsResponse() = default;
};
class UpdateLivePackageChannelGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};

  UpdateLivePackageChannelGroupRequest() {}

  explicit UpdateLivePackageChannelGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~UpdateLivePackageChannelGroupRequest() = default;
};
class UpdateLivePackageChannelGroupResponseBodyLivePackageChannelGroup : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> originDomain{};

  UpdateLivePackageChannelGroupResponseBodyLivePackageChannelGroup() {}

  explicit UpdateLivePackageChannelGroupResponseBodyLivePackageChannelGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (originDomain) {
      res["OriginDomain"] = boost::any(*originDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("OriginDomain") != m.end() && !m["OriginDomain"].empty()) {
      originDomain = make_shared<string>(boost::any_cast<string>(m["OriginDomain"]));
    }
  }


  virtual ~UpdateLivePackageChannelGroupResponseBodyLivePackageChannelGroup() = default;
};
class UpdateLivePackageChannelGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateLivePackageChannelGroupResponseBodyLivePackageChannelGroup> livePackageChannelGroup{};
  shared_ptr<string> requestId{};

  UpdateLivePackageChannelGroupResponseBody() {}

  explicit UpdateLivePackageChannelGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livePackageChannelGroup) {
      res["LivePackageChannelGroup"] = livePackageChannelGroup ? boost::any(livePackageChannelGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivePackageChannelGroup") != m.end() && !m["LivePackageChannelGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivePackageChannelGroup"].type()) {
        UpdateLivePackageChannelGroupResponseBodyLivePackageChannelGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivePackageChannelGroup"]));
        livePackageChannelGroup = make_shared<UpdateLivePackageChannelGroupResponseBodyLivePackageChannelGroup>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLivePackageChannelGroupResponseBody() = default;
};
class UpdateLivePackageChannelGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLivePackageChannelGroupResponseBody> body{};

  UpdateLivePackageChannelGroupResponse() {}

  explicit UpdateLivePackageChannelGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLivePackageChannelGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLivePackageChannelGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLivePackageChannelGroupResponse() = default;
};
class UpdateLivePackageOriginEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> authorizationCode{};
  shared_ptr<string> channelName{};
  shared_ptr<string> description{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> groupName{};
  shared_ptr<string> ipBlacklist{};
  shared_ptr<string> ipWhitelist{};
  shared_ptr<LivePackagingConfig> livePackagingConfig{};
  shared_ptr<string> manifestName{};
  shared_ptr<string> protocol{};
  shared_ptr<long> timeshiftVision{};

  UpdateLivePackageOriginEndpointRequest() {}

  explicit UpdateLivePackageOriginEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizationCode) {
      res["AuthorizationCode"] = boost::any(*authorizationCode);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (ipBlacklist) {
      res["IpBlacklist"] = boost::any(*ipBlacklist);
    }
    if (ipWhitelist) {
      res["IpWhitelist"] = boost::any(*ipWhitelist);
    }
    if (livePackagingConfig) {
      res["LivePackagingConfig"] = livePackagingConfig ? boost::any(livePackagingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (manifestName) {
      res["ManifestName"] = boost::any(*manifestName);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (timeshiftVision) {
      res["TimeshiftVision"] = boost::any(*timeshiftVision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizationCode") != m.end() && !m["AuthorizationCode"].empty()) {
      authorizationCode = make_shared<string>(boost::any_cast<string>(m["AuthorizationCode"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IpBlacklist") != m.end() && !m["IpBlacklist"].empty()) {
      ipBlacklist = make_shared<string>(boost::any_cast<string>(m["IpBlacklist"]));
    }
    if (m.find("IpWhitelist") != m.end() && !m["IpWhitelist"].empty()) {
      ipWhitelist = make_shared<string>(boost::any_cast<string>(m["IpWhitelist"]));
    }
    if (m.find("LivePackagingConfig") != m.end() && !m["LivePackagingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivePackagingConfig"].type()) {
        LivePackagingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivePackagingConfig"]));
        livePackagingConfig = make_shared<LivePackagingConfig>(model1);
      }
    }
    if (m.find("ManifestName") != m.end() && !m["ManifestName"].empty()) {
      manifestName = make_shared<string>(boost::any_cast<string>(m["ManifestName"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("TimeshiftVision") != m.end() && !m["TimeshiftVision"].empty()) {
      timeshiftVision = make_shared<long>(boost::any_cast<long>(m["TimeshiftVision"]));
    }
  }


  virtual ~UpdateLivePackageOriginEndpointRequest() = default;
};
class UpdateLivePackageOriginEndpointShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> authorizationCode{};
  shared_ptr<string> channelName{};
  shared_ptr<string> description{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> groupName{};
  shared_ptr<string> ipBlacklist{};
  shared_ptr<string> ipWhitelist{};
  shared_ptr<string> livePackagingConfigShrink{};
  shared_ptr<string> manifestName{};
  shared_ptr<string> protocol{};
  shared_ptr<long> timeshiftVision{};

  UpdateLivePackageOriginEndpointShrinkRequest() {}

  explicit UpdateLivePackageOriginEndpointShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizationCode) {
      res["AuthorizationCode"] = boost::any(*authorizationCode);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (ipBlacklist) {
      res["IpBlacklist"] = boost::any(*ipBlacklist);
    }
    if (ipWhitelist) {
      res["IpWhitelist"] = boost::any(*ipWhitelist);
    }
    if (livePackagingConfigShrink) {
      res["LivePackagingConfig"] = boost::any(*livePackagingConfigShrink);
    }
    if (manifestName) {
      res["ManifestName"] = boost::any(*manifestName);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (timeshiftVision) {
      res["TimeshiftVision"] = boost::any(*timeshiftVision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizationCode") != m.end() && !m["AuthorizationCode"].empty()) {
      authorizationCode = make_shared<string>(boost::any_cast<string>(m["AuthorizationCode"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IpBlacklist") != m.end() && !m["IpBlacklist"].empty()) {
      ipBlacklist = make_shared<string>(boost::any_cast<string>(m["IpBlacklist"]));
    }
    if (m.find("IpWhitelist") != m.end() && !m["IpWhitelist"].empty()) {
      ipWhitelist = make_shared<string>(boost::any_cast<string>(m["IpWhitelist"]));
    }
    if (m.find("LivePackagingConfig") != m.end() && !m["LivePackagingConfig"].empty()) {
      livePackagingConfigShrink = make_shared<string>(boost::any_cast<string>(m["LivePackagingConfig"]));
    }
    if (m.find("ManifestName") != m.end() && !m["ManifestName"].empty()) {
      manifestName = make_shared<string>(boost::any_cast<string>(m["ManifestName"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("TimeshiftVision") != m.end() && !m["TimeshiftVision"].empty()) {
      timeshiftVision = make_shared<long>(boost::any_cast<long>(m["TimeshiftVision"]));
    }
  }


  virtual ~UpdateLivePackageOriginEndpointShrinkRequest() = default;
};
class UpdateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> authorizationCode{};
  shared_ptr<string> channelName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> endpointUrl{};
  shared_ptr<string> groupName{};
  shared_ptr<string> ipBlacklist{};
  shared_ptr<string> ipWhitelist{};
  shared_ptr<string> lastModified{};
  shared_ptr<LivePackagingConfig> livePackagingConfig{};
  shared_ptr<string> manifestName{};
  shared_ptr<string> protocol{};
  shared_ptr<long> timeshiftVision{};

  UpdateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint() {}

  explicit UpdateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizationCode) {
      res["AuthorizationCode"] = boost::any(*authorizationCode);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (endpointUrl) {
      res["EndpointUrl"] = boost::any(*endpointUrl);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (ipBlacklist) {
      res["IpBlacklist"] = boost::any(*ipBlacklist);
    }
    if (ipWhitelist) {
      res["IpWhitelist"] = boost::any(*ipWhitelist);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (livePackagingConfig) {
      res["LivePackagingConfig"] = livePackagingConfig ? boost::any(livePackagingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (manifestName) {
      res["ManifestName"] = boost::any(*manifestName);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (timeshiftVision) {
      res["TimeshiftVision"] = boost::any(*timeshiftVision);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizationCode") != m.end() && !m["AuthorizationCode"].empty()) {
      authorizationCode = make_shared<string>(boost::any_cast<string>(m["AuthorizationCode"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("EndpointUrl") != m.end() && !m["EndpointUrl"].empty()) {
      endpointUrl = make_shared<string>(boost::any_cast<string>(m["EndpointUrl"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("IpBlacklist") != m.end() && !m["IpBlacklist"].empty()) {
      ipBlacklist = make_shared<string>(boost::any_cast<string>(m["IpBlacklist"]));
    }
    if (m.find("IpWhitelist") != m.end() && !m["IpWhitelist"].empty()) {
      ipWhitelist = make_shared<string>(boost::any_cast<string>(m["IpWhitelist"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("LivePackagingConfig") != m.end() && !m["LivePackagingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivePackagingConfig"].type()) {
        LivePackagingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivePackagingConfig"]));
        livePackagingConfig = make_shared<LivePackagingConfig>(model1);
      }
    }
    if (m.find("ManifestName") != m.end() && !m["ManifestName"].empty()) {
      manifestName = make_shared<string>(boost::any_cast<string>(m["ManifestName"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("TimeshiftVision") != m.end() && !m["TimeshiftVision"].empty()) {
      timeshiftVision = make_shared<long>(boost::any_cast<long>(m["TimeshiftVision"]));
    }
  }


  virtual ~UpdateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint() = default;
};
class UpdateLivePackageOriginEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint> livePackageOriginEndpoint{};
  shared_ptr<string> requestId{};

  UpdateLivePackageOriginEndpointResponseBody() {}

  explicit UpdateLivePackageOriginEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (livePackageOriginEndpoint) {
      res["LivePackageOriginEndpoint"] = livePackageOriginEndpoint ? boost::any(livePackageOriginEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LivePackageOriginEndpoint") != m.end() && !m["LivePackageOriginEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["LivePackageOriginEndpoint"].type()) {
        UpdateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LivePackageOriginEndpoint"]));
        livePackageOriginEndpoint = make_shared<UpdateLivePackageOriginEndpointResponseBodyLivePackageOriginEndpoint>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLivePackageOriginEndpointResponseBody() = default;
};
class UpdateLivePackageOriginEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLivePackageOriginEndpointResponseBody> body{};

  UpdateLivePackageOriginEndpointResponse() {}

  explicit UpdateLivePackageOriginEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLivePackageOriginEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLivePackageOriginEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLivePackageOriginEndpointResponse() = default;
};
class UpdateLiveRecordTemplateRequestRecordFormat : public Darabonba::Model {
public:
  shared_ptr<long> cycleDuration{};
  shared_ptr<string> format{};
  shared_ptr<string> ossObjectPrefix{};
  shared_ptr<long> sliceDuration{};
  shared_ptr<string> sliceOssObjectPrefix{};

  UpdateLiveRecordTemplateRequestRecordFormat() {}

  explicit UpdateLiveRecordTemplateRequestRecordFormat(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleDuration) {
      res["CycleDuration"] = boost::any(*cycleDuration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (ossObjectPrefix) {
      res["OssObjectPrefix"] = boost::any(*ossObjectPrefix);
    }
    if (sliceDuration) {
      res["SliceDuration"] = boost::any(*sliceDuration);
    }
    if (sliceOssObjectPrefix) {
      res["SliceOssObjectPrefix"] = boost::any(*sliceOssObjectPrefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CycleDuration") != m.end() && !m["CycleDuration"].empty()) {
      cycleDuration = make_shared<long>(boost::any_cast<long>(m["CycleDuration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("OssObjectPrefix") != m.end() && !m["OssObjectPrefix"].empty()) {
      ossObjectPrefix = make_shared<string>(boost::any_cast<string>(m["OssObjectPrefix"]));
    }
    if (m.find("SliceDuration") != m.end() && !m["SliceDuration"].empty()) {
      sliceDuration = make_shared<long>(boost::any_cast<long>(m["SliceDuration"]));
    }
    if (m.find("SliceOssObjectPrefix") != m.end() && !m["SliceOssObjectPrefix"].empty()) {
      sliceOssObjectPrefix = make_shared<string>(boost::any_cast<string>(m["SliceOssObjectPrefix"]));
    }
  }


  virtual ~UpdateLiveRecordTemplateRequestRecordFormat() = default;
};
class UpdateLiveRecordTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<vector<UpdateLiveRecordTemplateRequestRecordFormat>> recordFormat{};
  shared_ptr<string> templateId{};

  UpdateLiveRecordTemplateRequest() {}

  explicit UpdateLiveRecordTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordFormat) {
      vector<boost::any> temp1;
      for(auto item1:*recordFormat){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordFormat"] = boost::any(temp1);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordFormat"].type()) {
        vector<UpdateLiveRecordTemplateRequestRecordFormat> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordFormat"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateLiveRecordTemplateRequestRecordFormat model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordFormat = make_shared<vector<UpdateLiveRecordTemplateRequestRecordFormat>>(expect1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateLiveRecordTemplateRequest() = default;
};
class UpdateLiveRecordTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> recordFormatShrink{};
  shared_ptr<string> templateId{};

  UpdateLiveRecordTemplateShrinkRequest() {}

  explicit UpdateLiveRecordTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (recordFormatShrink) {
      res["RecordFormat"] = boost::any(*recordFormatShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RecordFormat") != m.end() && !m["RecordFormat"].empty()) {
      recordFormatShrink = make_shared<string>(boost::any_cast<string>(m["RecordFormat"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateLiveRecordTemplateShrinkRequest() = default;
};
class UpdateLiveRecordTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveRecordTemplateResponseBody() {}

  explicit UpdateLiveRecordTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveRecordTemplateResponseBody() = default;
};
class UpdateLiveRecordTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveRecordTemplateResponseBody> body{};

  UpdateLiveRecordTemplateResponse() {}

  explicit UpdateLiveRecordTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveRecordTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveRecordTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveRecordTemplateResponse() = default;
};
class UpdateLiveSnapshotTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> overwriteFormat{};
  shared_ptr<string> sequenceFormat{};
  shared_ptr<string> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<long> timeInterval{};

  UpdateLiveSnapshotTemplateRequest() {}

  explicit UpdateLiveSnapshotTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overwriteFormat) {
      res["OverwriteFormat"] = boost::any(*overwriteFormat);
    }
    if (sequenceFormat) {
      res["SequenceFormat"] = boost::any(*sequenceFormat);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (timeInterval) {
      res["TimeInterval"] = boost::any(*timeInterval);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverwriteFormat") != m.end() && !m["OverwriteFormat"].empty()) {
      overwriteFormat = make_shared<string>(boost::any_cast<string>(m["OverwriteFormat"]));
    }
    if (m.find("SequenceFormat") != m.end() && !m["SequenceFormat"].empty()) {
      sequenceFormat = make_shared<string>(boost::any_cast<string>(m["SequenceFormat"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TimeInterval") != m.end() && !m["TimeInterval"].empty()) {
      timeInterval = make_shared<long>(boost::any_cast<long>(m["TimeInterval"]));
    }
  }


  virtual ~UpdateLiveSnapshotTemplateRequest() = default;
};
class UpdateLiveSnapshotTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveSnapshotTemplateResponseBody() {}

  explicit UpdateLiveSnapshotTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveSnapshotTemplateResponseBody() = default;
};
class UpdateLiveSnapshotTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveSnapshotTemplateResponseBody> body{};

  UpdateLiveSnapshotTemplateResponse() {}

  explicit UpdateLiveSnapshotTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveSnapshotTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveSnapshotTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveSnapshotTemplateResponse() = default;
};
class UpdateLiveTranscodeJobRequestStreamInput : public Darabonba::Model {
public:
  shared_ptr<string> inputUrl{};
  shared_ptr<string> type{};

  UpdateLiveTranscodeJobRequestStreamInput() {}

  explicit UpdateLiveTranscodeJobRequestStreamInput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputUrl) {
      res["InputUrl"] = boost::any(*inputUrl);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputUrl") != m.end() && !m["InputUrl"].empty()) {
      inputUrl = make_shared<string>(boost::any_cast<string>(m["InputUrl"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateLiveTranscodeJobRequestStreamInput() = default;
};
class UpdateLiveTranscodeJobRequestTimedConfig : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  UpdateLiveTranscodeJobRequestTimedConfig() {}

  explicit UpdateLiveTranscodeJobRequestTimedConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~UpdateLiveTranscodeJobRequestTimedConfig() = default;
};
class UpdateLiveTranscodeJobRequestTranscodeOutput : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> type{};

  UpdateLiveTranscodeJobRequestTranscodeOutput() {}

  explicit UpdateLiveTranscodeJobRequestTranscodeOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateLiveTranscodeJobRequestTranscodeOutput() = default;
};
class UpdateLiveTranscodeJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<UpdateLiveTranscodeJobRequestStreamInput> streamInput{};
  shared_ptr<UpdateLiveTranscodeJobRequestTimedConfig> timedConfig{};
  shared_ptr<UpdateLiveTranscodeJobRequestTranscodeOutput> transcodeOutput{};

  UpdateLiveTranscodeJobRequest() {}

  explicit UpdateLiveTranscodeJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (streamInput) {
      res["StreamInput"] = streamInput ? boost::any(streamInput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timedConfig) {
      res["TimedConfig"] = timedConfig ? boost::any(timedConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transcodeOutput) {
      res["TranscodeOutput"] = transcodeOutput ? boost::any(transcodeOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamInput"].type()) {
        UpdateLiveTranscodeJobRequestStreamInput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamInput"]));
        streamInput = make_shared<UpdateLiveTranscodeJobRequestStreamInput>(model1);
      }
    }
    if (m.find("TimedConfig") != m.end() && !m["TimedConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimedConfig"].type()) {
        UpdateLiveTranscodeJobRequestTimedConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimedConfig"]));
        timedConfig = make_shared<UpdateLiveTranscodeJobRequestTimedConfig>(model1);
      }
    }
    if (m.find("TranscodeOutput") != m.end() && !m["TranscodeOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeOutput"].type()) {
        UpdateLiveTranscodeJobRequestTranscodeOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeOutput"]));
        transcodeOutput = make_shared<UpdateLiveTranscodeJobRequestTranscodeOutput>(model1);
      }
    }
  }


  virtual ~UpdateLiveTranscodeJobRequest() = default;
};
class UpdateLiveTranscodeJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<string> streamInputShrink{};
  shared_ptr<string> timedConfigShrink{};
  shared_ptr<string> transcodeOutputShrink{};

  UpdateLiveTranscodeJobShrinkRequest() {}

  explicit UpdateLiveTranscodeJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (streamInputShrink) {
      res["StreamInput"] = boost::any(*streamInputShrink);
    }
    if (timedConfigShrink) {
      res["TimedConfig"] = boost::any(*timedConfigShrink);
    }
    if (transcodeOutputShrink) {
      res["TranscodeOutput"] = boost::any(*transcodeOutputShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("StreamInput") != m.end() && !m["StreamInput"].empty()) {
      streamInputShrink = make_shared<string>(boost::any_cast<string>(m["StreamInput"]));
    }
    if (m.find("TimedConfig") != m.end() && !m["TimedConfig"].empty()) {
      timedConfigShrink = make_shared<string>(boost::any_cast<string>(m["TimedConfig"]));
    }
    if (m.find("TranscodeOutput") != m.end() && !m["TranscodeOutput"].empty()) {
      transcodeOutputShrink = make_shared<string>(boost::any_cast<string>(m["TranscodeOutput"]));
    }
  }


  virtual ~UpdateLiveTranscodeJobShrinkRequest() = default;
};
class UpdateLiveTranscodeJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveTranscodeJobResponseBody() {}

  explicit UpdateLiveTranscodeJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveTranscodeJobResponseBody() = default;
};
class UpdateLiveTranscodeJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveTranscodeJobResponseBody> body{};

  UpdateLiveTranscodeJobResponse() {}

  explicit UpdateLiveTranscodeJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveTranscodeJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveTranscodeJobResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveTranscodeJobResponse() = default;
};
class UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> channels{};
  shared_ptr<string> codec{};
  shared_ptr<string> profile{};
  shared_ptr<string> samplerate{};

  UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams() {}

  explicit UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (samplerate) {
      res["Samplerate"] = boost::any(*samplerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["Channels"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Samplerate") != m.end() && !m["Samplerate"].empty()) {
      samplerate = make_shared<string>(boost::any_cast<string>(m["Samplerate"]));
    }
  }


  virtual ~UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams() = default;
};
class UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams : public Darabonba::Model {
public:
  shared_ptr<string> bitrate{};
  shared_ptr<string> codec{};
  shared_ptr<string> fps{};
  shared_ptr<string> gop{};
  shared_ptr<string> height{};
  shared_ptr<string> profile{};
  shared_ptr<string> width{};

  UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams() {}

  explicit UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (fps) {
      res["Fps"] = boost::any(*fps);
    }
    if (gop) {
      res["Gop"] = boost::any(*gop);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<string>(boost::any_cast<string>(m["Bitrate"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Fps") != m.end() && !m["Fps"].empty()) {
      fps = make_shared<string>(boost::any_cast<string>(m["Fps"]));
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      gop = make_shared<string>(boost::any_cast<string>(m["Gop"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<string>(boost::any_cast<string>(m["Width"]));
    }
  }


  virtual ~UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams() = default;
};
class UpdateLiveTranscodeTemplateRequestTemplateConfig : public Darabonba::Model {
public:
  shared_ptr<UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams> audioParams{};
  shared_ptr<UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams> videoParams{};

  UpdateLiveTranscodeTemplateRequestTemplateConfig() {}

  explicit UpdateLiveTranscodeTemplateRequestTemplateConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioParams) {
      res["AudioParams"] = audioParams ? boost::any(audioParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoParams) {
      res["VideoParams"] = videoParams ? boost::any(videoParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioParams") != m.end() && !m["AudioParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioParams"].type()) {
        UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioParams"]));
        audioParams = make_shared<UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams>(model1);
      }
    }
    if (m.find("VideoParams") != m.end() && !m["VideoParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoParams"].type()) {
        UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoParams"]));
        videoParams = make_shared<UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams>(model1);
      }
    }
  }


  virtual ~UpdateLiveTranscodeTemplateRequestTemplateConfig() = default;
};
class UpdateLiveTranscodeTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<UpdateLiveTranscodeTemplateRequestTemplateConfig> templateConfig{};
  shared_ptr<string> templateId{};

  UpdateLiveTranscodeTemplateRequest() {}

  explicit UpdateLiveTranscodeTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfig) {
      res["TemplateConfig"] = templateConfig ? boost::any(templateConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TemplateConfig"].type()) {
        UpdateLiveTranscodeTemplateRequestTemplateConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TemplateConfig"]));
        templateConfig = make_shared<UpdateLiveTranscodeTemplateRequestTemplateConfig>(model1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateLiveTranscodeTemplateRequest() = default;
};
class UpdateLiveTranscodeTemplateShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> templateConfigShrink{};
  shared_ptr<string> templateId{};

  UpdateLiveTranscodeTemplateShrinkRequest() {}

  explicit UpdateLiveTranscodeTemplateShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (templateConfigShrink) {
      res["TemplateConfig"] = boost::any(*templateConfigShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TemplateConfig") != m.end() && !m["TemplateConfig"].empty()) {
      templateConfigShrink = make_shared<string>(boost::any_cast<string>(m["TemplateConfig"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateLiveTranscodeTemplateShrinkRequest() = default;
};
class UpdateLiveTranscodeTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLiveTranscodeTemplateResponseBody() {}

  explicit UpdateLiveTranscodeTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLiveTranscodeTemplateResponseBody() = default;
};
class UpdateLiveTranscodeTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLiveTranscodeTemplateResponseBody> body{};

  UpdateLiveTranscodeTemplateResponse() {}

  explicit UpdateLiveTranscodeTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLiveTranscodeTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLiveTranscodeTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLiveTranscodeTemplateResponse() = default;
};
class UpdateMediaConnectFlowInputRequest : public Darabonba::Model {
public:
  shared_ptr<string> cidrs{};
  shared_ptr<string> flowId{};
  shared_ptr<string> inputFromUrl{};
  shared_ptr<string> inputName{};
  shared_ptr<long> maxBitrate{};
  shared_ptr<long> srtLatency{};
  shared_ptr<string> srtPassphrase{};
  shared_ptr<long> srtPbkeyLen{};

  UpdateMediaConnectFlowInputRequest() {}

  explicit UpdateMediaConnectFlowInputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrs) {
      res["Cidrs"] = boost::any(*cidrs);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (inputFromUrl) {
      res["InputFromUrl"] = boost::any(*inputFromUrl);
    }
    if (inputName) {
      res["InputName"] = boost::any(*inputName);
    }
    if (maxBitrate) {
      res["MaxBitrate"] = boost::any(*maxBitrate);
    }
    if (srtLatency) {
      res["SrtLatency"] = boost::any(*srtLatency);
    }
    if (srtPassphrase) {
      res["SrtPassphrase"] = boost::any(*srtPassphrase);
    }
    if (srtPbkeyLen) {
      res["SrtPbkeyLen"] = boost::any(*srtPbkeyLen);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cidrs") != m.end() && !m["Cidrs"].empty()) {
      cidrs = make_shared<string>(boost::any_cast<string>(m["Cidrs"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("InputFromUrl") != m.end() && !m["InputFromUrl"].empty()) {
      inputFromUrl = make_shared<string>(boost::any_cast<string>(m["InputFromUrl"]));
    }
    if (m.find("InputName") != m.end() && !m["InputName"].empty()) {
      inputName = make_shared<string>(boost::any_cast<string>(m["InputName"]));
    }
    if (m.find("MaxBitrate") != m.end() && !m["MaxBitrate"].empty()) {
      maxBitrate = make_shared<long>(boost::any_cast<long>(m["MaxBitrate"]));
    }
    if (m.find("SrtLatency") != m.end() && !m["SrtLatency"].empty()) {
      srtLatency = make_shared<long>(boost::any_cast<long>(m["SrtLatency"]));
    }
    if (m.find("SrtPassphrase") != m.end() && !m["SrtPassphrase"].empty()) {
      srtPassphrase = make_shared<string>(boost::any_cast<string>(m["SrtPassphrase"]));
    }
    if (m.find("SrtPbkeyLen") != m.end() && !m["SrtPbkeyLen"].empty()) {
      srtPbkeyLen = make_shared<long>(boost::any_cast<long>(m["SrtPbkeyLen"]));
    }
  }


  virtual ~UpdateMediaConnectFlowInputRequest() = default;
};
class UpdateMediaConnectFlowInputResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};

  UpdateMediaConnectFlowInputResponseBody() {}

  explicit UpdateMediaConnectFlowInputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
  }


  virtual ~UpdateMediaConnectFlowInputResponseBody() = default;
};
class UpdateMediaConnectFlowInputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaConnectFlowInputResponseBody> body{};

  UpdateMediaConnectFlowInputResponse() {}

  explicit UpdateMediaConnectFlowInputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaConnectFlowInputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaConnectFlowInputResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaConnectFlowInputResponse() = default;
};
class UpdateMediaConnectFlowOutputRequest : public Darabonba::Model {
public:
  shared_ptr<string> cidrs{};
  shared_ptr<string> flowId{};
  shared_ptr<string> outputName{};
  shared_ptr<string> outputToUrl{};
  shared_ptr<string> playerLimit{};
  shared_ptr<string> srtLatency{};
  shared_ptr<string> srtPassphrase{};
  shared_ptr<string> srtPbkeyLen{};

  UpdateMediaConnectFlowOutputRequest() {}

  explicit UpdateMediaConnectFlowOutputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrs) {
      res["Cidrs"] = boost::any(*cidrs);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (outputName) {
      res["OutputName"] = boost::any(*outputName);
    }
    if (outputToUrl) {
      res["OutputToUrl"] = boost::any(*outputToUrl);
    }
    if (playerLimit) {
      res["PlayerLimit"] = boost::any(*playerLimit);
    }
    if (srtLatency) {
      res["SrtLatency"] = boost::any(*srtLatency);
    }
    if (srtPassphrase) {
      res["SrtPassphrase"] = boost::any(*srtPassphrase);
    }
    if (srtPbkeyLen) {
      res["SrtPbkeyLen"] = boost::any(*srtPbkeyLen);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cidrs") != m.end() && !m["Cidrs"].empty()) {
      cidrs = make_shared<string>(boost::any_cast<string>(m["Cidrs"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("OutputName") != m.end() && !m["OutputName"].empty()) {
      outputName = make_shared<string>(boost::any_cast<string>(m["OutputName"]));
    }
    if (m.find("OutputToUrl") != m.end() && !m["OutputToUrl"].empty()) {
      outputToUrl = make_shared<string>(boost::any_cast<string>(m["OutputToUrl"]));
    }
    if (m.find("PlayerLimit") != m.end() && !m["PlayerLimit"].empty()) {
      playerLimit = make_shared<string>(boost::any_cast<string>(m["PlayerLimit"]));
    }
    if (m.find("SrtLatency") != m.end() && !m["SrtLatency"].empty()) {
      srtLatency = make_shared<string>(boost::any_cast<string>(m["SrtLatency"]));
    }
    if (m.find("SrtPassphrase") != m.end() && !m["SrtPassphrase"].empty()) {
      srtPassphrase = make_shared<string>(boost::any_cast<string>(m["SrtPassphrase"]));
    }
    if (m.find("SrtPbkeyLen") != m.end() && !m["SrtPbkeyLen"].empty()) {
      srtPbkeyLen = make_shared<string>(boost::any_cast<string>(m["SrtPbkeyLen"]));
    }
  }


  virtual ~UpdateMediaConnectFlowOutputRequest() = default;
};
class UpdateMediaConnectFlowOutputResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};

  UpdateMediaConnectFlowOutputResponseBody() {}

  explicit UpdateMediaConnectFlowOutputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
  }


  virtual ~UpdateMediaConnectFlowOutputResponseBody() = default;
};
class UpdateMediaConnectFlowOutputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaConnectFlowOutputResponseBody> body{};

  UpdateMediaConnectFlowOutputResponse() {}

  explicit UpdateMediaConnectFlowOutputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaConnectFlowOutputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaConnectFlowOutputResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaConnectFlowOutputResponse() = default;
};
class UpdateMediaConnectFlowStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};
  shared_ptr<string> status{};

  UpdateMediaConnectFlowStatusRequest() {}

  explicit UpdateMediaConnectFlowStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateMediaConnectFlowStatusRequest() = default;
};
class UpdateMediaConnectFlowStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<long> retCode{};

  UpdateMediaConnectFlowStatusResponseBody() {}

  explicit UpdateMediaConnectFlowStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<long>(boost::any_cast<long>(m["RetCode"]));
    }
  }


  virtual ~UpdateMediaConnectFlowStatusResponseBody() = default;
};
class UpdateMediaConnectFlowStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaConnectFlowStatusResponseBody> body{};

  UpdateMediaConnectFlowStatusResponse() {}

  explicit UpdateMediaConnectFlowStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaConnectFlowStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaConnectFlowStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaConnectFlowStatusResponse() = default;
};
class UpdateMediaInfoRequest : public Darabonba::Model {
public:
  shared_ptr<bool> appendTags{};
  shared_ptr<string> businessType{};
  shared_ptr<long> cateId{};
  shared_ptr<string> category{};
  shared_ptr<string> coverURL{};
  shared_ptr<string> description{};
  shared_ptr<string> inputURL{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaTags{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> title{};
  shared_ptr<string> userData{};

  UpdateMediaInfoRequest() {}

  explicit UpdateMediaInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appendTags) {
      res["AppendTags"] = boost::any(*appendTags);
    }
    if (businessType) {
      res["BusinessType"] = boost::any(*businessType);
    }
    if (cateId) {
      res["CateId"] = boost::any(*cateId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (coverURL) {
      res["CoverURL"] = boost::any(*coverURL);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (inputURL) {
      res["InputURL"] = boost::any(*inputURL);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaTags) {
      res["MediaTags"] = boost::any(*mediaTags);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppendTags") != m.end() && !m["AppendTags"].empty()) {
      appendTags = make_shared<bool>(boost::any_cast<bool>(m["AppendTags"]));
    }
    if (m.find("BusinessType") != m.end() && !m["BusinessType"].empty()) {
      businessType = make_shared<string>(boost::any_cast<string>(m["BusinessType"]));
    }
    if (m.find("CateId") != m.end() && !m["CateId"].empty()) {
      cateId = make_shared<long>(boost::any_cast<long>(m["CateId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CoverURL") != m.end() && !m["CoverURL"].empty()) {
      coverURL = make_shared<string>(boost::any_cast<string>(m["CoverURL"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InputURL") != m.end() && !m["InputURL"].empty()) {
      inputURL = make_shared<string>(boost::any_cast<string>(m["InputURL"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaTags") != m.end() && !m["MediaTags"].empty()) {
      mediaTags = make_shared<string>(boost::any_cast<string>(m["MediaTags"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~UpdateMediaInfoRequest() = default;
};
class UpdateMediaInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};

  UpdateMediaInfoResponseBody() {}

  explicit UpdateMediaInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaInfoResponseBody() = default;
};
class UpdateMediaInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaInfoResponseBody> body{};

  UpdateMediaInfoResponse() {}

  explicit UpdateMediaInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaInfoResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaInfoResponse() = default;
};
class UpdateMediaLiveChannelRequestAudioSettingsAudioCodecSetting : public Darabonba::Model {
public:
  shared_ptr<long> bitrate{};
  shared_ptr<string> profile{};
  shared_ptr<long> sampleRate{};

  UpdateMediaLiveChannelRequestAudioSettingsAudioCodecSetting() {}

  explicit UpdateMediaLiveChannelRequestAudioSettingsAudioCodecSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<long>(boost::any_cast<long>(m["SampleRate"]));
    }
  }


  virtual ~UpdateMediaLiveChannelRequestAudioSettingsAudioCodecSetting() = default;
};
class UpdateMediaLiveChannelRequestAudioSettings : public Darabonba::Model {
public:
  shared_ptr<string> audioCodec{};
  shared_ptr<UpdateMediaLiveChannelRequestAudioSettingsAudioCodecSetting> audioCodecSetting{};
  shared_ptr<string> audioSelectorName{};
  shared_ptr<string> languageCode{};
  shared_ptr<string> languageName{};
  shared_ptr<string> name{};

  UpdateMediaLiveChannelRequestAudioSettings() {}

  explicit UpdateMediaLiveChannelRequestAudioSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioCodec) {
      res["AudioCodec"] = boost::any(*audioCodec);
    }
    if (audioCodecSetting) {
      res["AudioCodecSetting"] = audioCodecSetting ? boost::any(audioCodecSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioSelectorName) {
      res["AudioSelectorName"] = boost::any(*audioSelectorName);
    }
    if (languageCode) {
      res["LanguageCode"] = boost::any(*languageCode);
    }
    if (languageName) {
      res["LanguageName"] = boost::any(*languageName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioCodec") != m.end() && !m["AudioCodec"].empty()) {
      audioCodec = make_shared<string>(boost::any_cast<string>(m["AudioCodec"]));
    }
    if (m.find("AudioCodecSetting") != m.end() && !m["AudioCodecSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioCodecSetting"].type()) {
        UpdateMediaLiveChannelRequestAudioSettingsAudioCodecSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioCodecSetting"]));
        audioCodecSetting = make_shared<UpdateMediaLiveChannelRequestAudioSettingsAudioCodecSetting>(model1);
      }
    }
    if (m.find("AudioSelectorName") != m.end() && !m["AudioSelectorName"].empty()) {
      audioSelectorName = make_shared<string>(boost::any_cast<string>(m["AudioSelectorName"]));
    }
    if (m.find("LanguageCode") != m.end() && !m["LanguageCode"].empty()) {
      languageCode = make_shared<string>(boost::any_cast<string>(m["LanguageCode"]));
    }
    if (m.find("LanguageName") != m.end() && !m["LanguageName"].empty()) {
      languageName = make_shared<string>(boost::any_cast<string>(m["LanguageName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateMediaLiveChannelRequestAudioSettings() = default;
};
class UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection : public Darabonba::Model {
public:
  shared_ptr<string> languageCode{};

  UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection() {}

  explicit UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (languageCode) {
      res["LanguageCode"] = boost::any(*languageCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LanguageCode") != m.end() && !m["LanguageCode"].empty()) {
      languageCode = make_shared<string>(boost::any_cast<string>(m["LanguageCode"]));
    }
  }


  virtual ~UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection() = default;
};
class UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection : public Darabonba::Model {
public:
  shared_ptr<long> pid{};

  UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection() {}

  explicit UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<long>(boost::any_cast<long>(m["Pid"]));
    }
  }


  virtual ~UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection() = default;
};
class UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection : public Darabonba::Model {
public:
  shared_ptr<long> trackId{};

  UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection() {}

  explicit UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trackId) {
      res["TrackId"] = boost::any(*trackId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrackId") != m.end() && !m["TrackId"].empty()) {
      trackId = make_shared<long>(boost::any_cast<long>(m["TrackId"]));
    }
  }


  virtual ~UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection() = default;
};
class UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectors : public Darabonba::Model {
public:
  shared_ptr<UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection> audioLanguageSelection{};
  shared_ptr<UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection> audioPidSelection{};
  shared_ptr<vector<UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection>> audioTrackSelection{};
  shared_ptr<string> name{};

  UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectors() {}

  explicit UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioLanguageSelection) {
      res["AudioLanguageSelection"] = audioLanguageSelection ? boost::any(audioLanguageSelection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioPidSelection) {
      res["AudioPidSelection"] = audioPidSelection ? boost::any(audioPidSelection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (audioTrackSelection) {
      vector<boost::any> temp1;
      for(auto item1:*audioTrackSelection){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioTrackSelection"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioLanguageSelection") != m.end() && !m["AudioLanguageSelection"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioLanguageSelection"].type()) {
        UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioLanguageSelection"]));
        audioLanguageSelection = make_shared<UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioLanguageSelection>(model1);
      }
    }
    if (m.find("AudioPidSelection") != m.end() && !m["AudioPidSelection"].empty()) {
      if (typeid(map<string, boost::any>) == m["AudioPidSelection"].type()) {
        UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AudioPidSelection"]));
        audioPidSelection = make_shared<UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioPidSelection>(model1);
      }
    }
    if (m.find("AudioTrackSelection") != m.end() && !m["AudioTrackSelection"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioTrackSelection"].type()) {
        vector<UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioTrackSelection"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioTrackSelection = make_shared<vector<UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectorsAudioTrackSelection>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectors() = default;
};
class UpdateMediaLiveChannelRequestInputAttachments : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectors>> audioSelectors{};
  shared_ptr<string> inputId{};
  shared_ptr<string> languageName{};

  UpdateMediaLiveChannelRequestInputAttachments() {}

  explicit UpdateMediaLiveChannelRequestInputAttachments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSelectors) {
      vector<boost::any> temp1;
      for(auto item1:*audioSelectors){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioSelectors"] = boost::any(temp1);
    }
    if (inputId) {
      res["InputId"] = boost::any(*inputId);
    }
    if (languageName) {
      res["LanguageName"] = boost::any(*languageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSelectors") != m.end() && !m["AudioSelectors"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioSelectors"].type()) {
        vector<UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectors> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioSelectors"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectors model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioSelectors = make_shared<vector<UpdateMediaLiveChannelRequestInputAttachmentsAudioSelectors>>(expect1);
      }
    }
    if (m.find("InputId") != m.end() && !m["InputId"].empty()) {
      inputId = make_shared<string>(boost::any_cast<string>(m["InputId"]));
    }
    if (m.find("LanguageName") != m.end() && !m["LanguageName"].empty()) {
      languageName = make_shared<string>(boost::any_cast<string>(m["LanguageName"]));
    }
  }


  virtual ~UpdateMediaLiveChannelRequestInputAttachments() = default;
};
class UpdateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<string> groupName{};

  UpdateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting() {}

  explicit UpdateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~UpdateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting() = default;
};
class UpdateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting : public Darabonba::Model {
public:
  shared_ptr<string> audioGroupId{};
  shared_ptr<string> nameModifier{};

  UpdateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting() {}

  explicit UpdateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioGroupId) {
      res["AudioGroupId"] = boost::any(*audioGroupId);
    }
    if (nameModifier) {
      res["NameModifier"] = boost::any(*nameModifier);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioGroupId") != m.end() && !m["AudioGroupId"].empty()) {
      audioGroupId = make_shared<string>(boost::any_cast<string>(m["AudioGroupId"]));
    }
    if (m.find("NameModifier") != m.end() && !m["NameModifier"].empty()) {
      nameModifier = make_shared<string>(boost::any_cast<string>(m["NameModifier"]));
    }
  }


  virtual ~UpdateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting() = default;
};
class UpdateMediaLiveChannelRequestOutputGroupsOutputs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> audioSettingNames{};
  shared_ptr<UpdateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting> mediaPackageOutputSetting{};
  shared_ptr<long> mediaType{};
  shared_ptr<string> name{};
  shared_ptr<string> videoSettingName{};

  UpdateMediaLiveChannelRequestOutputGroupsOutputs() {}

  explicit UpdateMediaLiveChannelRequestOutputGroupsOutputs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSettingNames) {
      res["AudioSettingNames"] = boost::any(*audioSettingNames);
    }
    if (mediaPackageOutputSetting) {
      res["MediaPackageOutputSetting"] = mediaPackageOutputSetting ? boost::any(mediaPackageOutputSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (videoSettingName) {
      res["VideoSettingName"] = boost::any(*videoSettingName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSettingNames") != m.end() && !m["AudioSettingNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AudioSettingNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AudioSettingNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      audioSettingNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MediaPackageOutputSetting") != m.end() && !m["MediaPackageOutputSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaPackageOutputSetting"].type()) {
        UpdateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaPackageOutputSetting"]));
        mediaPackageOutputSetting = make_shared<UpdateMediaLiveChannelRequestOutputGroupsOutputsMediaPackageOutputSetting>(model1);
      }
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<long>(boost::any_cast<long>(m["MediaType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("VideoSettingName") != m.end() && !m["VideoSettingName"].empty()) {
      videoSettingName = make_shared<string>(boost::any_cast<string>(m["VideoSettingName"]));
    }
  }


  virtual ~UpdateMediaLiveChannelRequestOutputGroupsOutputs() = default;
};
class UpdateMediaLiveChannelRequestOutputGroups : public Darabonba::Model {
public:
  shared_ptr<UpdateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting> mediaPackageGroupSetting{};
  shared_ptr<string> name{};
  shared_ptr<vector<UpdateMediaLiveChannelRequestOutputGroupsOutputs>> outputs{};
  shared_ptr<string> type{};

  UpdateMediaLiveChannelRequestOutputGroups() {}

  explicit UpdateMediaLiveChannelRequestOutputGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaPackageGroupSetting) {
      res["MediaPackageGroupSetting"] = mediaPackageGroupSetting ? boost::any(mediaPackageGroupSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputs) {
      vector<boost::any> temp1;
      for(auto item1:*outputs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outputs"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaPackageGroupSetting") != m.end() && !m["MediaPackageGroupSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaPackageGroupSetting"].type()) {
        UpdateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaPackageGroupSetting"]));
        mediaPackageGroupSetting = make_shared<UpdateMediaLiveChannelRequestOutputGroupsMediaPackageGroupSetting>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Outputs") != m.end() && !m["Outputs"].empty()) {
      if (typeid(vector<boost::any>) == m["Outputs"].type()) {
        vector<UpdateMediaLiveChannelRequestOutputGroupsOutputs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outputs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateMediaLiveChannelRequestOutputGroupsOutputs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputs = make_shared<vector<UpdateMediaLiveChannelRequestOutputGroupsOutputs>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateMediaLiveChannelRequestOutputGroups() = default;
};
class UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail : public Darabonba::Model {
public:
  shared_ptr<string> level{};
  shared_ptr<string> profile{};

  UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail() {}

  explicit UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
  }


  virtual ~UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail() = default;
};
class UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate : public Darabonba::Model {
public:
  shared_ptr<string> framerateControl{};
  shared_ptr<long> framerateDenominator{};
  shared_ptr<long> framerateNumerator{};

  UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate() {}

  explicit UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (framerateControl) {
      res["FramerateControl"] = boost::any(*framerateControl);
    }
    if (framerateDenominator) {
      res["FramerateDenominator"] = boost::any(*framerateDenominator);
    }
    if (framerateNumerator) {
      res["FramerateNumerator"] = boost::any(*framerateNumerator);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FramerateControl") != m.end() && !m["FramerateControl"].empty()) {
      framerateControl = make_shared<string>(boost::any_cast<string>(m["FramerateControl"]));
    }
    if (m.find("FramerateDenominator") != m.end() && !m["FramerateDenominator"].empty()) {
      framerateDenominator = make_shared<long>(boost::any_cast<long>(m["FramerateDenominator"]));
    }
    if (m.find("FramerateNumerator") != m.end() && !m["FramerateNumerator"].empty()) {
      framerateNumerator = make_shared<long>(boost::any_cast<long>(m["FramerateNumerator"]));
    }
  }


  virtual ~UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate() = default;
};
class UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop : public Darabonba::Model {
public:
  shared_ptr<long> bframesNum{};
  shared_ptr<long> gopSize{};
  shared_ptr<string> gopSizeUnits{};

  UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop() {}

  explicit UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bframesNum) {
      res["BframesNum"] = boost::any(*bframesNum);
    }
    if (gopSize) {
      res["GopSize"] = boost::any(*gopSize);
    }
    if (gopSizeUnits) {
      res["GopSizeUnits"] = boost::any(*gopSizeUnits);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BframesNum") != m.end() && !m["BframesNum"].empty()) {
      bframesNum = make_shared<long>(boost::any_cast<long>(m["BframesNum"]));
    }
    if (m.find("GopSize") != m.end() && !m["GopSize"].empty()) {
      gopSize = make_shared<long>(boost::any_cast<long>(m["GopSize"]));
    }
    if (m.find("GopSizeUnits") != m.end() && !m["GopSizeUnits"].empty()) {
      gopSizeUnits = make_shared<string>(boost::any_cast<string>(m["GopSizeUnits"]));
    }
  }


  virtual ~UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop() = default;
};
class UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate : public Darabonba::Model {
public:
  shared_ptr<long> bitrate{};
  shared_ptr<long> bufferSize{};
  shared_ptr<long> maxBitrate{};
  shared_ptr<string> rateControlMode{};

  UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate() {}

  explicit UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bufferSize) {
      res["BufferSize"] = boost::any(*bufferSize);
    }
    if (maxBitrate) {
      res["MaxBitrate"] = boost::any(*maxBitrate);
    }
    if (rateControlMode) {
      res["RateControlMode"] = boost::any(*rateControlMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("BufferSize") != m.end() && !m["BufferSize"].empty()) {
      bufferSize = make_shared<long>(boost::any_cast<long>(m["BufferSize"]));
    }
    if (m.find("MaxBitrate") != m.end() && !m["MaxBitrate"].empty()) {
      maxBitrate = make_shared<long>(boost::any_cast<long>(m["MaxBitrate"]));
    }
    if (m.find("RateControlMode") != m.end() && !m["RateControlMode"].empty()) {
      rateControlMode = make_shared<string>(boost::any_cast<string>(m["RateControlMode"]));
    }
  }


  virtual ~UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate() = default;
};
class UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSetting : public Darabonba::Model {
public:
  shared_ptr<UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail> codecDetail{};
  shared_ptr<UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate> framerate{};
  shared_ptr<UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop> gop{};
  shared_ptr<UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate> rate{};

  UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSetting() {}

  explicit UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codecDetail) {
      res["CodecDetail"] = codecDetail ? boost::any(codecDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (framerate) {
      res["Framerate"] = framerate ? boost::any(framerate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gop) {
      res["Gop"] = gop ? boost::any(gop->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rate) {
      res["Rate"] = rate ? boost::any(rate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodecDetail") != m.end() && !m["CodecDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["CodecDetail"].type()) {
        UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CodecDetail"]));
        codecDetail = make_shared<UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingCodecDetail>(model1);
      }
    }
    if (m.find("Framerate") != m.end() && !m["Framerate"].empty()) {
      if (typeid(map<string, boost::any>) == m["Framerate"].type()) {
        UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Framerate"]));
        framerate = make_shared<UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingFramerate>(model1);
      }
    }
    if (m.find("Gop") != m.end() && !m["Gop"].empty()) {
      if (typeid(map<string, boost::any>) == m["Gop"].type()) {
        UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Gop"]));
        gop = make_shared<UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingGop>(model1);
      }
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rate"].type()) {
        UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rate"]));
        rate = make_shared<UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSettingRate>(model1);
      }
    }
  }


  virtual ~UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSetting() = default;
};
class UpdateMediaLiveChannelRequestVideoSettings : public Darabonba::Model {
public:
  shared_ptr<long> height{};
  shared_ptr<string> name{};
  shared_ptr<string> videoCodec{};
  shared_ptr<UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSetting> videoCodecSetting{};
  shared_ptr<string> videoCodecType{};
  shared_ptr<long> width{};

  UpdateMediaLiveChannelRequestVideoSettings() {}

  explicit UpdateMediaLiveChannelRequestVideoSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (videoCodec) {
      res["VideoCodec"] = boost::any(*videoCodec);
    }
    if (videoCodecSetting) {
      res["VideoCodecSetting"] = videoCodecSetting ? boost::any(videoCodecSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoCodecType) {
      res["VideoCodecType"] = boost::any(*videoCodecType);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("VideoCodec") != m.end() && !m["VideoCodec"].empty()) {
      videoCodec = make_shared<string>(boost::any_cast<string>(m["VideoCodec"]));
    }
    if (m.find("VideoCodecSetting") != m.end() && !m["VideoCodecSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoCodecSetting"].type()) {
        UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoCodecSetting"]));
        videoCodecSetting = make_shared<UpdateMediaLiveChannelRequestVideoSettingsVideoCodecSetting>(model1);
      }
    }
    if (m.find("VideoCodecType") != m.end() && !m["VideoCodecType"].empty()) {
      videoCodecType = make_shared<string>(boost::any_cast<string>(m["VideoCodecType"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~UpdateMediaLiveChannelRequestVideoSettings() = default;
};
class UpdateMediaLiveChannelRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateMediaLiveChannelRequestAudioSettings>> audioSettings{};
  shared_ptr<string> channelId{};
  shared_ptr<vector<UpdateMediaLiveChannelRequestInputAttachments>> inputAttachments{};
  shared_ptr<string> name{};
  shared_ptr<vector<UpdateMediaLiveChannelRequestOutputGroups>> outputGroups{};
  shared_ptr<vector<UpdateMediaLiveChannelRequestVideoSettings>> videoSettings{};

  UpdateMediaLiveChannelRequest() {}

  explicit UpdateMediaLiveChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSettings) {
      vector<boost::any> temp1;
      for(auto item1:*audioSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioSettings"] = boost::any(temp1);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (inputAttachments) {
      vector<boost::any> temp1;
      for(auto item1:*inputAttachments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputAttachments"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputGroups) {
      vector<boost::any> temp1;
      for(auto item1:*outputGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputGroups"] = boost::any(temp1);
    }
    if (videoSettings) {
      vector<boost::any> temp1;
      for(auto item1:*videoSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoSettings"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSettings") != m.end() && !m["AudioSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioSettings"].type()) {
        vector<UpdateMediaLiveChannelRequestAudioSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateMediaLiveChannelRequestAudioSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioSettings = make_shared<vector<UpdateMediaLiveChannelRequestAudioSettings>>(expect1);
      }
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("InputAttachments") != m.end() && !m["InputAttachments"].empty()) {
      if (typeid(vector<boost::any>) == m["InputAttachments"].type()) {
        vector<UpdateMediaLiveChannelRequestInputAttachments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputAttachments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateMediaLiveChannelRequestInputAttachments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputAttachments = make_shared<vector<UpdateMediaLiveChannelRequestInputAttachments>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputGroups") != m.end() && !m["OutputGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputGroups"].type()) {
        vector<UpdateMediaLiveChannelRequestOutputGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateMediaLiveChannelRequestOutputGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputGroups = make_shared<vector<UpdateMediaLiveChannelRequestOutputGroups>>(expect1);
      }
    }
    if (m.find("VideoSettings") != m.end() && !m["VideoSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoSettings"].type()) {
        vector<UpdateMediaLiveChannelRequestVideoSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateMediaLiveChannelRequestVideoSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoSettings = make_shared<vector<UpdateMediaLiveChannelRequestVideoSettings>>(expect1);
      }
    }
  }


  virtual ~UpdateMediaLiveChannelRequest() = default;
};
class UpdateMediaLiveChannelShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioSettingsShrink{};
  shared_ptr<string> channelId{};
  shared_ptr<string> inputAttachmentsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> outputGroupsShrink{};
  shared_ptr<string> videoSettingsShrink{};

  UpdateMediaLiveChannelShrinkRequest() {}

  explicit UpdateMediaLiveChannelShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioSettingsShrink) {
      res["AudioSettings"] = boost::any(*audioSettingsShrink);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (inputAttachmentsShrink) {
      res["InputAttachments"] = boost::any(*inputAttachmentsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (outputGroupsShrink) {
      res["OutputGroups"] = boost::any(*outputGroupsShrink);
    }
    if (videoSettingsShrink) {
      res["VideoSettings"] = boost::any(*videoSettingsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioSettings") != m.end() && !m["AudioSettings"].empty()) {
      audioSettingsShrink = make_shared<string>(boost::any_cast<string>(m["AudioSettings"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("InputAttachments") != m.end() && !m["InputAttachments"].empty()) {
      inputAttachmentsShrink = make_shared<string>(boost::any_cast<string>(m["InputAttachments"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OutputGroups") != m.end() && !m["OutputGroups"].empty()) {
      outputGroupsShrink = make_shared<string>(boost::any_cast<string>(m["OutputGroups"]));
    }
    if (m.find("VideoSettings") != m.end() && !m["VideoSettings"].empty()) {
      videoSettingsShrink = make_shared<string>(boost::any_cast<string>(m["VideoSettings"]));
    }
  }


  virtual ~UpdateMediaLiveChannelShrinkRequest() = default;
};
class UpdateMediaLiveChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateMediaLiveChannelResponseBody() {}

  explicit UpdateMediaLiveChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaLiveChannelResponseBody() = default;
};
class UpdateMediaLiveChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaLiveChannelResponseBody> body{};

  UpdateMediaLiveChannelResponse() {}

  explicit UpdateMediaLiveChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaLiveChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaLiveChannelResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaLiveChannelResponse() = default;
};
class UpdateMediaLiveInputRequestInputSettings : public Darabonba::Model {
public:
  shared_ptr<string> flowId{};
  shared_ptr<string> flowOutputName{};
  shared_ptr<string> sourceUrl{};
  shared_ptr<string> streamName{};

  UpdateMediaLiveInputRequestInputSettings() {}

  explicit UpdateMediaLiveInputRequestInputSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowOutputName) {
      res["FlowOutputName"] = boost::any(*flowOutputName);
    }
    if (sourceUrl) {
      res["SourceUrl"] = boost::any(*sourceUrl);
    }
    if (streamName) {
      res["StreamName"] = boost::any(*streamName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowOutputName") != m.end() && !m["FlowOutputName"].empty()) {
      flowOutputName = make_shared<string>(boost::any_cast<string>(m["FlowOutputName"]));
    }
    if (m.find("SourceUrl") != m.end() && !m["SourceUrl"].empty()) {
      sourceUrl = make_shared<string>(boost::any_cast<string>(m["SourceUrl"]));
    }
    if (m.find("StreamName") != m.end() && !m["StreamName"].empty()) {
      streamName = make_shared<string>(boost::any_cast<string>(m["StreamName"]));
    }
  }


  virtual ~UpdateMediaLiveInputRequestInputSettings() = default;
};
class UpdateMediaLiveInputRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputId{};
  shared_ptr<vector<UpdateMediaLiveInputRequestInputSettings>> inputSettings{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> securityGroupIds{};

  UpdateMediaLiveInputRequest() {}

  explicit UpdateMediaLiveInputRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputId) {
      res["InputId"] = boost::any(*inputId);
    }
    if (inputSettings) {
      vector<boost::any> temp1;
      for(auto item1:*inputSettings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputSettings"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (securityGroupIds) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputId") != m.end() && !m["InputId"].empty()) {
      inputId = make_shared<string>(boost::any_cast<string>(m["InputId"]));
    }
    if (m.find("InputSettings") != m.end() && !m["InputSettings"].empty()) {
      if (typeid(vector<boost::any>) == m["InputSettings"].type()) {
        vector<UpdateMediaLiveInputRequestInputSettings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputSettings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateMediaLiveInputRequestInputSettings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputSettings = make_shared<vector<UpdateMediaLiveInputRequestInputSettings>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      securityGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateMediaLiveInputRequest() = default;
};
class UpdateMediaLiveInputShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> inputId{};
  shared_ptr<string> inputSettingsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> securityGroupIdsShrink{};

  UpdateMediaLiveInputShrinkRequest() {}

  explicit UpdateMediaLiveInputShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputId) {
      res["InputId"] = boost::any(*inputId);
    }
    if (inputSettingsShrink) {
      res["InputSettings"] = boost::any(*inputSettingsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (securityGroupIdsShrink) {
      res["SecurityGroupIds"] = boost::any(*securityGroupIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputId") != m.end() && !m["InputId"].empty()) {
      inputId = make_shared<string>(boost::any_cast<string>(m["InputId"]));
    }
    if (m.find("InputSettings") != m.end() && !m["InputSettings"].empty()) {
      inputSettingsShrink = make_shared<string>(boost::any_cast<string>(m["InputSettings"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SecurityGroupIds") != m.end() && !m["SecurityGroupIds"].empty()) {
      securityGroupIdsShrink = make_shared<string>(boost::any_cast<string>(m["SecurityGroupIds"]));
    }
  }


  virtual ~UpdateMediaLiveInputShrinkRequest() = default;
};
class UpdateMediaLiveInputResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateMediaLiveInputResponseBody() {}

  explicit UpdateMediaLiveInputResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaLiveInputResponseBody() = default;
};
class UpdateMediaLiveInputResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaLiveInputResponseBody> body{};

  UpdateMediaLiveInputResponse() {}

  explicit UpdateMediaLiveInputResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaLiveInputResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaLiveInputResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaLiveInputResponse() = default;
};
class UpdateMediaLiveInputSecurityGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<vector<string>> whitelistRules{};

  UpdateMediaLiveInputSecurityGroupRequest() {}

  explicit UpdateMediaLiveInputSecurityGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (whitelistRules) {
      res["WhitelistRules"] = boost::any(*whitelistRules);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("WhitelistRules") != m.end() && !m["WhitelistRules"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WhitelistRules"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WhitelistRules"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      whitelistRules = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateMediaLiveInputSecurityGroupRequest() = default;
};
class UpdateMediaLiveInputSecurityGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> whitelistRulesShrink{};

  UpdateMediaLiveInputSecurityGroupShrinkRequest() {}

  explicit UpdateMediaLiveInputSecurityGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (whitelistRulesShrink) {
      res["WhitelistRules"] = boost::any(*whitelistRulesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("WhitelistRules") != m.end() && !m["WhitelistRules"].empty()) {
      whitelistRulesShrink = make_shared<string>(boost::any_cast<string>(m["WhitelistRules"]));
    }
  }


  virtual ~UpdateMediaLiveInputSecurityGroupShrinkRequest() = default;
};
class UpdateMediaLiveInputSecurityGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateMediaLiveInputSecurityGroupResponseBody() {}

  explicit UpdateMediaLiveInputSecurityGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaLiveInputSecurityGroupResponseBody() = default;
};
class UpdateMediaLiveInputSecurityGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaLiveInputSecurityGroupResponseBody> body{};

  UpdateMediaLiveInputSecurityGroupResponse() {}

  explicit UpdateMediaLiveInputSecurityGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaLiveInputSecurityGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaLiveInputSecurityGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaLiveInputSecurityGroupResponse() = default;
};
class UpdateMediaMarksRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaMarks{};

  UpdateMediaMarksRequest() {}

  explicit UpdateMediaMarksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaMarks) {
      res["MediaMarks"] = boost::any(*mediaMarks);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaMarks") != m.end() && !m["MediaMarks"].empty()) {
      mediaMarks = make_shared<string>(boost::any_cast<string>(m["MediaMarks"]));
    }
  }


  virtual ~UpdateMediaMarksRequest() = default;
};
class UpdateMediaMarksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaMarkIds{};
  shared_ptr<string> requestId{};

  UpdateMediaMarksResponseBody() {}

  explicit UpdateMediaMarksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaMarkIds) {
      res["MediaMarkIds"] = boost::any(*mediaMarkIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaMarkIds") != m.end() && !m["MediaMarkIds"].empty()) {
      mediaMarkIds = make_shared<string>(boost::any_cast<string>(m["MediaMarkIds"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateMediaMarksResponseBody() = default;
};
class UpdateMediaMarksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaMarksResponseBody> body{};

  UpdateMediaMarksResponse() {}

  explicit UpdateMediaMarksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaMarksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaMarksResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaMarksResponse() = default;
};
class UpdateMediaToSearchLibRequest : public Darabonba::Model {
public:
  shared_ptr<string> mediaId{};
  shared_ptr<string> msgBody{};
  shared_ptr<string> searchLibName{};

  UpdateMediaToSearchLibRequest() {}

  explicit UpdateMediaToSearchLibRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (msgBody) {
      res["MsgBody"] = boost::any(*msgBody);
    }
    if (searchLibName) {
      res["SearchLibName"] = boost::any(*searchLibName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MsgBody") != m.end() && !m["MsgBody"].empty()) {
      msgBody = make_shared<string>(boost::any_cast<string>(m["MsgBody"]));
    }
    if (m.find("SearchLibName") != m.end() && !m["SearchLibName"].empty()) {
      searchLibName = make_shared<string>(boost::any_cast<string>(m["SearchLibName"]));
    }
  }


  virtual ~UpdateMediaToSearchLibRequest() = default;
};
class UpdateMediaToSearchLibResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> success{};

  UpdateMediaToSearchLibResponseBody() {}

  explicit UpdateMediaToSearchLibResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<string>(boost::any_cast<string>(m["Success"]));
    }
  }


  virtual ~UpdateMediaToSearchLibResponseBody() = default;
};
class UpdateMediaToSearchLibResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMediaToSearchLibResponseBody> body{};

  UpdateMediaToSearchLibResponse() {}

  explicit UpdateMediaToSearchLibResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMediaToSearchLibResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMediaToSearchLibResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMediaToSearchLibResponse() = default;
};
class UpdatePipelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> pipelineId{};
  shared_ptr<long> priority{};
  shared_ptr<string> status{};

  UpdatePipelineRequest() {}

  explicit UpdatePipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["PipelineId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdatePipelineRequest() = default;
};
class UpdatePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdatePipelineResponseBody() {}

  explicit UpdatePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdatePipelineResponseBody() = default;
};
class UpdatePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePipelineResponseBody> body{};

  UpdatePipelineResponse() {}

  explicit UpdatePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePipelineResponse() = default;
};
class UpdateProgramRequest : public Darabonba::Model {
public:
  shared_ptr<string> adBreaks{};
  shared_ptr<string> channelName{};
  shared_ptr<string> clipRange{};
  shared_ptr<string> programName{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> transition{};

  UpdateProgramRequest() {}

  explicit UpdateProgramRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adBreaks) {
      res["AdBreaks"] = boost::any(*adBreaks);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (clipRange) {
      res["ClipRange"] = boost::any(*clipRange);
    }
    if (programName) {
      res["ProgramName"] = boost::any(*programName);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (transition) {
      res["Transition"] = boost::any(*transition);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdBreaks") != m.end() && !m["AdBreaks"].empty()) {
      adBreaks = make_shared<string>(boost::any_cast<string>(m["AdBreaks"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ClipRange") != m.end() && !m["ClipRange"].empty()) {
      clipRange = make_shared<string>(boost::any_cast<string>(m["ClipRange"]));
    }
    if (m.find("ProgramName") != m.end() && !m["ProgramName"].empty()) {
      programName = make_shared<string>(boost::any_cast<string>(m["ProgramName"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Transition") != m.end() && !m["Transition"].empty()) {
      transition = make_shared<string>(boost::any_cast<string>(m["Transition"]));
    }
  }


  virtual ~UpdateProgramRequest() = default;
};
class UpdateProgramResponseBody : public Darabonba::Model {
public:
  shared_ptr<ChannelAssemblyProgram> program{};
  shared_ptr<string> requestId{};

  UpdateProgramResponseBody() {}

  explicit UpdateProgramResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (program) {
      res["Program"] = program ? boost::any(program->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Program") != m.end() && !m["Program"].empty()) {
      if (typeid(map<string, boost::any>) == m["Program"].type()) {
        ChannelAssemblyProgram model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Program"]));
        program = make_shared<ChannelAssemblyProgram>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateProgramResponseBody() = default;
};
class UpdateProgramResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProgramResponseBody> body{};

  UpdateProgramResponse() {}

  explicit UpdateProgramResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProgramResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProgramResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProgramResponse() = default;
};
class UpdateRtcRobotInstanceRequestConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableVoiceInterrupt{};
  shared_ptr<string> greeting{};
  shared_ptr<string> voiceId{};

  UpdateRtcRobotInstanceRequestConfig() {}

  explicit UpdateRtcRobotInstanceRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableVoiceInterrupt) {
      res["EnableVoiceInterrupt"] = boost::any(*enableVoiceInterrupt);
    }
    if (greeting) {
      res["Greeting"] = boost::any(*greeting);
    }
    if (voiceId) {
      res["VoiceId"] = boost::any(*voiceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableVoiceInterrupt") != m.end() && !m["EnableVoiceInterrupt"].empty()) {
      enableVoiceInterrupt = make_shared<bool>(boost::any_cast<bool>(m["EnableVoiceInterrupt"]));
    }
    if (m.find("Greeting") != m.end() && !m["Greeting"].empty()) {
      greeting = make_shared<string>(boost::any_cast<string>(m["Greeting"]));
    }
    if (m.find("VoiceId") != m.end() && !m["VoiceId"].empty()) {
      voiceId = make_shared<string>(boost::any_cast<string>(m["VoiceId"]));
    }
  }


  virtual ~UpdateRtcRobotInstanceRequestConfig() = default;
};
class UpdateRtcRobotInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<UpdateRtcRobotInstanceRequestConfig> config{};
  shared_ptr<string> instanceId{};

  UpdateRtcRobotInstanceRequest() {}

  explicit UpdateRtcRobotInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = config ? boost::any(config->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      if (typeid(map<string, boost::any>) == m["Config"].type()) {
        UpdateRtcRobotInstanceRequestConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Config"]));
        config = make_shared<UpdateRtcRobotInstanceRequestConfig>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateRtcRobotInstanceRequest() = default;
};
class UpdateRtcRobotInstanceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> configShrink{};
  shared_ptr<string> instanceId{};

  UpdateRtcRobotInstanceShrinkRequest() {}

  explicit UpdateRtcRobotInstanceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configShrink) {
      res["Config"] = boost::any(*configShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      configShrink = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateRtcRobotInstanceShrinkRequest() = default;
};
class UpdateRtcRobotInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateRtcRobotInstanceResponseBody() {}

  explicit UpdateRtcRobotInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateRtcRobotInstanceResponseBody() = default;
};
class UpdateRtcRobotInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRtcRobotInstanceResponseBody> body{};

  UpdateRtcRobotInstanceResponse() {}

  explicit UpdateRtcRobotInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRtcRobotInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRtcRobotInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRtcRobotInstanceResponse() = default;
};
class UpdateSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> httpPackageConfigurations{};
  shared_ptr<string> sourceLocationName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceType{};

  UpdateSourceRequest() {}

  explicit UpdateSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpPackageConfigurations) {
      res["HttpPackageConfigurations"] = boost::any(*httpPackageConfigurations);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpPackageConfigurations") != m.end() && !m["HttpPackageConfigurations"].empty()) {
      httpPackageConfigurations = make_shared<string>(boost::any_cast<string>(m["HttpPackageConfigurations"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~UpdateSourceRequest() = default;
};
class UpdateSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ChannelAssemblySource> source{};

  UpdateSourceResponseBody() {}

  explicit UpdateSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (source) {
      res["Source"] = source ? boost::any(source->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(map<string, boost::any>) == m["Source"].type()) {
        ChannelAssemblySource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Source"]));
        source = make_shared<ChannelAssemblySource>(model1);
      }
    }
  }


  virtual ~UpdateSourceResponseBody() = default;
};
class UpdateSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSourceResponseBody> body{};

  UpdateSourceResponse() {}

  explicit UpdateSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSourceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSourceResponse() = default;
};
class UpdateSourceLocationRequest : public Darabonba::Model {
public:
  shared_ptr<string> baseUrl{};
  shared_ptr<bool> enableSegmentDelivery{};
  shared_ptr<string> segmentDeliveryUrl{};
  shared_ptr<string> sourceLocationName{};

  UpdateSourceLocationRequest() {}

  explicit UpdateSourceLocationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (baseUrl) {
      res["BaseUrl"] = boost::any(*baseUrl);
    }
    if (enableSegmentDelivery) {
      res["EnableSegmentDelivery"] = boost::any(*enableSegmentDelivery);
    }
    if (segmentDeliveryUrl) {
      res["SegmentDeliveryUrl"] = boost::any(*segmentDeliveryUrl);
    }
    if (sourceLocationName) {
      res["SourceLocationName"] = boost::any(*sourceLocationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BaseUrl") != m.end() && !m["BaseUrl"].empty()) {
      baseUrl = make_shared<string>(boost::any_cast<string>(m["BaseUrl"]));
    }
    if (m.find("EnableSegmentDelivery") != m.end() && !m["EnableSegmentDelivery"].empty()) {
      enableSegmentDelivery = make_shared<bool>(boost::any_cast<bool>(m["EnableSegmentDelivery"]));
    }
    if (m.find("SegmentDeliveryUrl") != m.end() && !m["SegmentDeliveryUrl"].empty()) {
      segmentDeliveryUrl = make_shared<string>(boost::any_cast<string>(m["SegmentDeliveryUrl"]));
    }
    if (m.find("SourceLocationName") != m.end() && !m["SourceLocationName"].empty()) {
      sourceLocationName = make_shared<string>(boost::any_cast<string>(m["SourceLocationName"]));
    }
  }


  virtual ~UpdateSourceLocationRequest() = default;
};
class UpdateSourceLocationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ChannelAssemblySourceLocation> sourceLocation{};

  UpdateSourceLocationResponseBody() {}

  explicit UpdateSourceLocationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceLocation) {
      res["SourceLocation"] = sourceLocation ? boost::any(sourceLocation->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceLocation") != m.end() && !m["SourceLocation"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceLocation"].type()) {
        ChannelAssemblySourceLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceLocation"]));
        sourceLocation = make_shared<ChannelAssemblySourceLocation>(model1);
      }
    }
  }


  virtual ~UpdateSourceLocationResponseBody() = default;
};
class UpdateSourceLocationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSourceLocationResponseBody> body{};

  UpdateSourceLocationResponse() {}

  explicit UpdateSourceLocationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSourceLocationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSourceLocationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSourceLocationResponse() = default;
};
class UpdateTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> coverUrl{};
  shared_ptr<string> name{};
  shared_ptr<string> previewMedia{};
  shared_ptr<string> relatedMediaids{};
  shared_ptr<string> source{};
  shared_ptr<string> status{};
  shared_ptr<string> templateId{};

  UpdateTemplateRequest() {}

  explicit UpdateTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (coverUrl) {
      res["CoverUrl"] = boost::any(*coverUrl);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (previewMedia) {
      res["PreviewMedia"] = boost::any(*previewMedia);
    }
    if (relatedMediaids) {
      res["RelatedMediaids"] = boost::any(*relatedMediaids);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("CoverUrl") != m.end() && !m["CoverUrl"].empty()) {
      coverUrl = make_shared<string>(boost::any_cast<string>(m["CoverUrl"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PreviewMedia") != m.end() && !m["PreviewMedia"].empty()) {
      previewMedia = make_shared<string>(boost::any_cast<string>(m["PreviewMedia"]));
    }
    if (m.find("RelatedMediaids") != m.end() && !m["RelatedMediaids"].empty()) {
      relatedMediaids = make_shared<string>(boost::any_cast<string>(m["RelatedMediaids"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateTemplateRequest() = default;
};
class UpdateTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateTemplateResponseBody() {}

  explicit UpdateTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateTemplateResponseBody() = default;
};
class UpdateTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTemplateResponseBody> body{};

  UpdateTemplateResponse() {}

  explicit UpdateTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTemplateResponse() = default;
};
class UploadMediaByURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> entityId{};
  shared_ptr<string> mediaMetaData{};
  shared_ptr<string> postProcessConfig{};
  shared_ptr<string> uploadTargetConfig{};
  shared_ptr<string> uploadURLs{};
  shared_ptr<string> userData{};

  UploadMediaByURLRequest() {}

  explicit UploadMediaByURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (entityId) {
      res["EntityId"] = boost::any(*entityId);
    }
    if (mediaMetaData) {
      res["MediaMetaData"] = boost::any(*mediaMetaData);
    }
    if (postProcessConfig) {
      res["PostProcessConfig"] = boost::any(*postProcessConfig);
    }
    if (uploadTargetConfig) {
      res["UploadTargetConfig"] = boost::any(*uploadTargetConfig);
    }
    if (uploadURLs) {
      res["UploadURLs"] = boost::any(*uploadURLs);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("EntityId") != m.end() && !m["EntityId"].empty()) {
      entityId = make_shared<string>(boost::any_cast<string>(m["EntityId"]));
    }
    if (m.find("MediaMetaData") != m.end() && !m["MediaMetaData"].empty()) {
      mediaMetaData = make_shared<string>(boost::any_cast<string>(m["MediaMetaData"]));
    }
    if (m.find("PostProcessConfig") != m.end() && !m["PostProcessConfig"].empty()) {
      postProcessConfig = make_shared<string>(boost::any_cast<string>(m["PostProcessConfig"]));
    }
    if (m.find("UploadTargetConfig") != m.end() && !m["UploadTargetConfig"].empty()) {
      uploadTargetConfig = make_shared<string>(boost::any_cast<string>(m["UploadTargetConfig"]));
    }
    if (m.find("UploadURLs") != m.end() && !m["UploadURLs"].empty()) {
      uploadURLs = make_shared<string>(boost::any_cast<string>(m["UploadURLs"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~UploadMediaByURLRequest() = default;
};
class UploadMediaByURLResponseBodyUploadJobs : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> sourceURL{};

  UploadMediaByURLResponseBodyUploadJobs() {}

  explicit UploadMediaByURLResponseBodyUploadJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (sourceURL) {
      res["SourceURL"] = boost::any(*sourceURL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("SourceURL") != m.end() && !m["SourceURL"].empty()) {
      sourceURL = make_shared<string>(boost::any_cast<string>(m["SourceURL"]));
    }
  }


  virtual ~UploadMediaByURLResponseBodyUploadJobs() = default;
};
class UploadMediaByURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<UploadMediaByURLResponseBodyUploadJobs>> uploadJobs{};

  UploadMediaByURLResponseBody() {}

  explicit UploadMediaByURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadJobs) {
      vector<boost::any> temp1;
      for(auto item1:*uploadJobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UploadJobs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadJobs") != m.end() && !m["UploadJobs"].empty()) {
      if (typeid(vector<boost::any>) == m["UploadJobs"].type()) {
        vector<UploadMediaByURLResponseBodyUploadJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UploadJobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UploadMediaByURLResponseBodyUploadJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        uploadJobs = make_shared<vector<UploadMediaByURLResponseBodyUploadJobs>>(expect1);
      }
    }
  }


  virtual ~UploadMediaByURLResponseBody() = default;
};
class UploadMediaByURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadMediaByURLResponseBody> body{};

  UploadMediaByURLResponse() {}

  explicit UploadMediaByURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadMediaByURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadMediaByURLResponseBody>(model1);
      }
    }
  }


  virtual ~UploadMediaByURLResponse() = default;
};
class UploadStreamByURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> definition{};
  shared_ptr<string> fileExtension{};
  shared_ptr<string> HDRType{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> streamURL{};
  shared_ptr<string> userData{};

  UploadStreamByURLRequest() {}

  explicit UploadStreamByURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (fileExtension) {
      res["FileExtension"] = boost::any(*fileExtension);
    }
    if (HDRType) {
      res["HDRType"] = boost::any(*HDRType);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (streamURL) {
      res["StreamURL"] = boost::any(*streamURL);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("FileExtension") != m.end() && !m["FileExtension"].empty()) {
      fileExtension = make_shared<string>(boost::any_cast<string>(m["FileExtension"]));
    }
    if (m.find("HDRType") != m.end() && !m["HDRType"].empty()) {
      HDRType = make_shared<string>(boost::any_cast<string>(m["HDRType"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("StreamURL") != m.end() && !m["StreamURL"].empty()) {
      streamURL = make_shared<string>(boost::any_cast<string>(m["StreamURL"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~UploadStreamByURLRequest() = default;
};
class UploadStreamByURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fileURL{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sourceURL{};

  UploadStreamByURLResponseBody() {}

  explicit UploadStreamByURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileURL) {
      res["FileURL"] = boost::any(*fileURL);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourceURL) {
      res["SourceURL"] = boost::any(*sourceURL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileURL") != m.end() && !m["FileURL"].empty()) {
      fileURL = make_shared<string>(boost::any_cast<string>(m["FileURL"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourceURL") != m.end() && !m["SourceURL"].empty()) {
      sourceURL = make_shared<string>(boost::any_cast<string>(m["SourceURL"]));
    }
  }


  virtual ~UploadStreamByURLResponseBody() = default;
};
class UploadStreamByURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadStreamByURLResponseBody> body{};

  UploadStreamByURLResponse() {}

  explicit UploadStreamByURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadStreamByURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadStreamByURLResponseBody>(model1);
      }
    }
  }


  virtual ~UploadStreamByURLResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddAdInsertionResponse addAdInsertionWithOptions(shared_ptr<AddAdInsertionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddAdInsertionResponse addAdInsertion(shared_ptr<AddAdInsertionRequest> request);
  AddCategoryResponse addCategoryWithOptions(shared_ptr<AddCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCategoryResponse addCategory(shared_ptr<AddCategoryRequest> request);
  AddEditingProjectMaterialsResponse addEditingProjectMaterialsWithOptions(shared_ptr<AddEditingProjectMaterialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddEditingProjectMaterialsResponse addEditingProjectMaterials(shared_ptr<AddEditingProjectMaterialsRequest> request);
  AddFavoritePublicMediaResponse addFavoritePublicMediaWithOptions(shared_ptr<AddFavoritePublicMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddFavoritePublicMediaResponse addFavoritePublicMedia(shared_ptr<AddFavoritePublicMediaRequest> request);
  AddMediaConnectFlowInputResponse addMediaConnectFlowInputWithOptions(shared_ptr<AddMediaConnectFlowInputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMediaConnectFlowInputResponse addMediaConnectFlowInput(shared_ptr<AddMediaConnectFlowInputRequest> request);
  AddMediaConnectFlowOutputResponse addMediaConnectFlowOutputWithOptions(shared_ptr<AddMediaConnectFlowOutputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMediaConnectFlowOutputResponse addMediaConnectFlowOutput(shared_ptr<AddMediaConnectFlowOutputRequest> request);
  AddMediaMarksResponse addMediaMarksWithOptions(shared_ptr<AddMediaMarksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddMediaMarksResponse addMediaMarks(shared_ptr<AddMediaMarksRequest> request);
  AddTemplateResponse addTemplateWithOptions(shared_ptr<AddTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTemplateResponse addTemplate(shared_ptr<AddTemplateRequest> request);
  AlterSearchIndexResponse alterSearchIndexWithOptions(shared_ptr<AlterSearchIndexRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AlterSearchIndexResponse alterSearchIndex(shared_ptr<AlterSearchIndexRequest> request);
  BatchCreateVodPackagingAssetResponse batchCreateVodPackagingAssetWithOptions(shared_ptr<BatchCreateVodPackagingAssetRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchCreateVodPackagingAssetResponse batchCreateVodPackagingAsset(shared_ptr<BatchCreateVodPackagingAssetRequest> request);
  BatchGetMediaInfosResponse batchGetMediaInfosWithOptions(shared_ptr<BatchGetMediaInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetMediaInfosResponse batchGetMediaInfos(shared_ptr<BatchGetMediaInfosRequest> request);
  CancelDNAJobResponse cancelDNAJobWithOptions(shared_ptr<CancelDNAJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelDNAJobResponse cancelDNAJob(shared_ptr<CancelDNAJobRequest> request);
  CancelFavoritePublicMediaResponse cancelFavoritePublicMediaWithOptions(shared_ptr<CancelFavoritePublicMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelFavoritePublicMediaResponse cancelFavoritePublicMedia(shared_ptr<CancelFavoritePublicMediaRequest> request);
  CreateAuditResponse createAuditWithOptions(shared_ptr<CreateAuditRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAuditResponse createAudit(shared_ptr<CreateAuditRequest> request);
  CreateAvatarTrainingJobResponse createAvatarTrainingJobWithOptions(shared_ptr<CreateAvatarTrainingJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAvatarTrainingJobResponse createAvatarTrainingJob(shared_ptr<CreateAvatarTrainingJobRequest> request);
  CreateChannelResponse createChannelWithOptions(shared_ptr<CreateChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateChannelResponse createChannel(shared_ptr<CreateChannelRequest> request);
  CreateCustomTemplateResponse createCustomTemplateWithOptions(shared_ptr<CreateCustomTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomTemplateResponse createCustomTemplate(shared_ptr<CreateCustomTemplateRequest> request);
  CreateCustomizedVoiceJobResponse createCustomizedVoiceJobWithOptions(shared_ptr<CreateCustomizedVoiceJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomizedVoiceJobResponse createCustomizedVoiceJob(shared_ptr<CreateCustomizedVoiceJobRequest> request);
  CreateDNADBResponse createDNADBWithOptions(shared_ptr<CreateDNADBRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDNADBResponse createDNADB(shared_ptr<CreateDNADBRequest> request);
  CreateEditingProjectResponse createEditingProjectWithOptions(shared_ptr<CreateEditingProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEditingProjectResponse createEditingProject(shared_ptr<CreateEditingProjectRequest> request);
  CreateHotwordLibraryResponse createHotwordLibraryWithOptions(shared_ptr<CreateHotwordLibraryRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHotwordLibraryResponse createHotwordLibrary(shared_ptr<CreateHotwordLibraryRequest> request);
  CreateLivePackageChannelResponse createLivePackageChannelWithOptions(shared_ptr<CreateLivePackageChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLivePackageChannelResponse createLivePackageChannel(shared_ptr<CreateLivePackageChannelRequest> request);
  CreateLivePackageChannelGroupResponse createLivePackageChannelGroupWithOptions(shared_ptr<CreateLivePackageChannelGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLivePackageChannelGroupResponse createLivePackageChannelGroup(shared_ptr<CreateLivePackageChannelGroupRequest> request);
  CreateLivePackageOriginEndpointResponse createLivePackageOriginEndpointWithOptions(shared_ptr<CreateLivePackageOriginEndpointRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLivePackageOriginEndpointResponse createLivePackageOriginEndpoint(shared_ptr<CreateLivePackageOriginEndpointRequest> request);
  CreateLiveRecordTemplateResponse createLiveRecordTemplateWithOptions(shared_ptr<CreateLiveRecordTemplateRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveRecordTemplateResponse createLiveRecordTemplate(shared_ptr<CreateLiveRecordTemplateRequest> request);
  CreateLiveSnapshotTemplateResponse createLiveSnapshotTemplateWithOptions(shared_ptr<CreateLiveSnapshotTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveSnapshotTemplateResponse createLiveSnapshotTemplate(shared_ptr<CreateLiveSnapshotTemplateRequest> request);
  CreateLiveTranscodeTemplateResponse createLiveTranscodeTemplateWithOptions(shared_ptr<CreateLiveTranscodeTemplateRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLiveTranscodeTemplateResponse createLiveTranscodeTemplate(shared_ptr<CreateLiveTranscodeTemplateRequest> request);
  CreateMediaConnectFlowResponse createMediaConnectFlowWithOptions(shared_ptr<CreateMediaConnectFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMediaConnectFlowResponse createMediaConnectFlow(shared_ptr<CreateMediaConnectFlowRequest> request);
  CreateMediaLiveChannelResponse createMediaLiveChannelWithOptions(shared_ptr<CreateMediaLiveChannelRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMediaLiveChannelResponse createMediaLiveChannel(shared_ptr<CreateMediaLiveChannelRequest> request);
  CreateMediaLiveInputResponse createMediaLiveInputWithOptions(shared_ptr<CreateMediaLiveInputRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMediaLiveInputResponse createMediaLiveInput(shared_ptr<CreateMediaLiveInputRequest> request);
  CreateMediaLiveInputSecurityGroupResponse createMediaLiveInputSecurityGroupWithOptions(shared_ptr<CreateMediaLiveInputSecurityGroupRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMediaLiveInputSecurityGroupResponse createMediaLiveInputSecurityGroup(shared_ptr<CreateMediaLiveInputSecurityGroupRequest> request);
  CreatePipelineResponse createPipelineWithOptions(shared_ptr<CreatePipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePipelineResponse createPipeline(shared_ptr<CreatePipelineRequest> request);
  CreateProgramResponse createProgramWithOptions(shared_ptr<CreateProgramRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProgramResponse createProgram(shared_ptr<CreateProgramRequest> request);
  CreateRecognitionEntityResponse createRecognitionEntityWithOptions(shared_ptr<CreateRecognitionEntityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRecognitionEntityResponse createRecognitionEntity(shared_ptr<CreateRecognitionEntityRequest> request);
  CreateRecognitionLibResponse createRecognitionLibWithOptions(shared_ptr<CreateRecognitionLibRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRecognitionLibResponse createRecognitionLib(shared_ptr<CreateRecognitionLibRequest> request);
  CreateRecognitionSampleResponse createRecognitionSampleWithOptions(shared_ptr<CreateRecognitionSampleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRecognitionSampleResponse createRecognitionSample(shared_ptr<CreateRecognitionSampleRequest> request);
  CreateSearchIndexResponse createSearchIndexWithOptions(shared_ptr<CreateSearchIndexRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSearchIndexResponse createSearchIndex(shared_ptr<CreateSearchIndexRequest> request);
  CreateSearchLibResponse createSearchLibWithOptions(shared_ptr<CreateSearchLibRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSearchLibResponse createSearchLib(shared_ptr<CreateSearchLibRequest> request);
  CreateSourceResponse createSourceWithOptions(shared_ptr<CreateSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSourceResponse createSource(shared_ptr<CreateSourceRequest> request);
  CreateSourceLocationResponse createSourceLocationWithOptions(shared_ptr<CreateSourceLocationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSourceLocationResponse createSourceLocation(shared_ptr<CreateSourceLocationRequest> request);
  CreateUploadMediaResponse createUploadMediaWithOptions(shared_ptr<CreateUploadMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUploadMediaResponse createUploadMedia(shared_ptr<CreateUploadMediaRequest> request);
  CreateUploadStreamResponse createUploadStreamWithOptions(shared_ptr<CreateUploadStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUploadStreamResponse createUploadStream(shared_ptr<CreateUploadStreamRequest> request);
  CreateVodPackagingAssetResponse createVodPackagingAssetWithOptions(shared_ptr<CreateVodPackagingAssetRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVodPackagingAssetResponse createVodPackagingAsset(shared_ptr<CreateVodPackagingAssetRequest> request);
  CreateVodPackagingConfigurationResponse createVodPackagingConfigurationWithOptions(shared_ptr<CreateVodPackagingConfigurationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVodPackagingConfigurationResponse createVodPackagingConfiguration(shared_ptr<CreateVodPackagingConfigurationRequest> request);
  CreateVodPackagingGroupResponse createVodPackagingGroupWithOptions(shared_ptr<CreateVodPackagingGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVodPackagingGroupResponse createVodPackagingGroup(shared_ptr<CreateVodPackagingGroupRequest> request);
  DecryptKMSDataKeyResponse decryptKMSDataKeyWithOptions(shared_ptr<DecryptKMSDataKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DecryptKMSDataKeyResponse decryptKMSDataKey(shared_ptr<DecryptKMSDataKeyRequest> request);
  DeleteAIAgentDialogueResponse deleteAIAgentDialogueWithOptions(shared_ptr<DeleteAIAgentDialogueRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAIAgentDialogueResponse deleteAIAgentDialogue(shared_ptr<DeleteAIAgentDialogueRequest> request);
  DeleteAdInsertionResponse deleteAdInsertionWithOptions(shared_ptr<DeleteAdInsertionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAdInsertionResponse deleteAdInsertion(shared_ptr<DeleteAdInsertionRequest> request);
  DeleteAvatarTrainingJobResponse deleteAvatarTrainingJobWithOptions(shared_ptr<DeleteAvatarTrainingJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAvatarTrainingJobResponse deleteAvatarTrainingJob(shared_ptr<DeleteAvatarTrainingJobRequest> request);
  DeleteCategoryResponse deleteCategoryWithOptions(shared_ptr<DeleteCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCategoryResponse deleteCategory(shared_ptr<DeleteCategoryRequest> request);
  DeleteChannelResponse deleteChannelWithOptions(shared_ptr<DeleteChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteChannelResponse deleteChannel(shared_ptr<DeleteChannelRequest> request);
  DeleteCustomTemplateResponse deleteCustomTemplateWithOptions(shared_ptr<DeleteCustomTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomTemplateResponse deleteCustomTemplate(shared_ptr<DeleteCustomTemplateRequest> request);
  DeleteCustomizedVoiceJobResponse deleteCustomizedVoiceJobWithOptions(shared_ptr<DeleteCustomizedVoiceJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomizedVoiceJobResponse deleteCustomizedVoiceJob(shared_ptr<DeleteCustomizedVoiceJobRequest> request);
  DeleteDNADBResponse deleteDNADBWithOptions(shared_ptr<DeleteDNADBRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDNADBResponse deleteDNADB(shared_ptr<DeleteDNADBRequest> request);
  DeleteDNAFilesResponse deleteDNAFilesWithOptions(shared_ptr<DeleteDNAFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDNAFilesResponse deleteDNAFiles(shared_ptr<DeleteDNAFilesRequest> request);
  DeleteEditingProjectMaterialsResponse deleteEditingProjectMaterialsWithOptions(shared_ptr<DeleteEditingProjectMaterialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEditingProjectMaterialsResponse deleteEditingProjectMaterials(shared_ptr<DeleteEditingProjectMaterialsRequest> request);
  DeleteEditingProjectsResponse deleteEditingProjectsWithOptions(shared_ptr<DeleteEditingProjectsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEditingProjectsResponse deleteEditingProjects(shared_ptr<DeleteEditingProjectsRequest> request);
  DeleteHotwordLibraryResponse deleteHotwordLibraryWithOptions(shared_ptr<DeleteHotwordLibraryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHotwordLibraryResponse deleteHotwordLibrary(shared_ptr<DeleteHotwordLibraryRequest> request);
  DeleteLivePackageChannelResponse deleteLivePackageChannelWithOptions(shared_ptr<DeleteLivePackageChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLivePackageChannelResponse deleteLivePackageChannel(shared_ptr<DeleteLivePackageChannelRequest> request);
  DeleteLivePackageChannelGroupResponse deleteLivePackageChannelGroupWithOptions(shared_ptr<DeleteLivePackageChannelGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLivePackageChannelGroupResponse deleteLivePackageChannelGroup(shared_ptr<DeleteLivePackageChannelGroupRequest> request);
  DeleteLivePackageOriginEndpointResponse deleteLivePackageOriginEndpointWithOptions(shared_ptr<DeleteLivePackageOriginEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLivePackageOriginEndpointResponse deleteLivePackageOriginEndpoint(shared_ptr<DeleteLivePackageOriginEndpointRequest> request);
  DeleteLiveRecordFilesResponse deleteLiveRecordFilesWithOptions(shared_ptr<DeleteLiveRecordFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveRecordFilesResponse deleteLiveRecordFiles(shared_ptr<DeleteLiveRecordFilesRequest> request);
  DeleteLiveRecordTemplateResponse deleteLiveRecordTemplateWithOptions(shared_ptr<DeleteLiveRecordTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveRecordTemplateResponse deleteLiveRecordTemplate(shared_ptr<DeleteLiveRecordTemplateRequest> request);
  DeleteLiveSnapshotFilesResponse deleteLiveSnapshotFilesWithOptions(shared_ptr<DeleteLiveSnapshotFilesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveSnapshotFilesResponse deleteLiveSnapshotFiles(shared_ptr<DeleteLiveSnapshotFilesRequest> request);
  DeleteLiveSnapshotTemplateResponse deleteLiveSnapshotTemplateWithOptions(shared_ptr<DeleteLiveSnapshotTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveSnapshotTemplateResponse deleteLiveSnapshotTemplate(shared_ptr<DeleteLiveSnapshotTemplateRequest> request);
  DeleteLiveTranscodeJobResponse deleteLiveTranscodeJobWithOptions(shared_ptr<DeleteLiveTranscodeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveTranscodeJobResponse deleteLiveTranscodeJob(shared_ptr<DeleteLiveTranscodeJobRequest> request);
  DeleteLiveTranscodeTemplateResponse deleteLiveTranscodeTemplateWithOptions(shared_ptr<DeleteLiveTranscodeTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLiveTranscodeTemplateResponse deleteLiveTranscodeTemplate(shared_ptr<DeleteLiveTranscodeTemplateRequest> request);
  DeleteMediaConnectFlowResponse deleteMediaConnectFlowWithOptions(shared_ptr<DeleteMediaConnectFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaConnectFlowResponse deleteMediaConnectFlow(shared_ptr<DeleteMediaConnectFlowRequest> request);
  DeleteMediaConnectFlowInputResponse deleteMediaConnectFlowInputWithOptions(shared_ptr<DeleteMediaConnectFlowInputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaConnectFlowInputResponse deleteMediaConnectFlowInput(shared_ptr<DeleteMediaConnectFlowInputRequest> request);
  DeleteMediaConnectFlowOutputResponse deleteMediaConnectFlowOutputWithOptions(shared_ptr<DeleteMediaConnectFlowOutputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaConnectFlowOutputResponse deleteMediaConnectFlowOutput(shared_ptr<DeleteMediaConnectFlowOutputRequest> request);
  DeleteMediaFromSearchLibResponse deleteMediaFromSearchLibWithOptions(shared_ptr<DeleteMediaFromSearchLibRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaFromSearchLibResponse deleteMediaFromSearchLib(shared_ptr<DeleteMediaFromSearchLibRequest> request);
  DeleteMediaInfosResponse deleteMediaInfosWithOptions(shared_ptr<DeleteMediaInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaInfosResponse deleteMediaInfos(shared_ptr<DeleteMediaInfosRequest> request);
  DeleteMediaLiveChannelResponse deleteMediaLiveChannelWithOptions(shared_ptr<DeleteMediaLiveChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaLiveChannelResponse deleteMediaLiveChannel(shared_ptr<DeleteMediaLiveChannelRequest> request);
  DeleteMediaLiveInputResponse deleteMediaLiveInputWithOptions(shared_ptr<DeleteMediaLiveInputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaLiveInputResponse deleteMediaLiveInput(shared_ptr<DeleteMediaLiveInputRequest> request);
  DeleteMediaLiveInputSecurityGroupResponse deleteMediaLiveInputSecurityGroupWithOptions(shared_ptr<DeleteMediaLiveInputSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaLiveInputSecurityGroupResponse deleteMediaLiveInputSecurityGroup(shared_ptr<DeleteMediaLiveInputSecurityGroupRequest> request);
  DeleteMediaMarksResponse deleteMediaMarksWithOptions(shared_ptr<DeleteMediaMarksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaMarksResponse deleteMediaMarks(shared_ptr<DeleteMediaMarksRequest> request);
  DeletePipelineResponse deletePipelineWithOptions(shared_ptr<DeletePipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePipelineResponse deletePipeline(shared_ptr<DeletePipelineRequest> request);
  DeletePlayInfoResponse deletePlayInfoWithOptions(shared_ptr<DeletePlayInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePlayInfoResponse deletePlayInfo(shared_ptr<DeletePlayInfoRequest> request);
  DeleteProgramResponse deleteProgramWithOptions(shared_ptr<DeleteProgramRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProgramResponse deleteProgram(shared_ptr<DeleteProgramRequest> request);
  DeleteRecognitionEntityResponse deleteRecognitionEntityWithOptions(shared_ptr<DeleteRecognitionEntityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRecognitionEntityResponse deleteRecognitionEntity(shared_ptr<DeleteRecognitionEntityRequest> request);
  DeleteRecognitionLibResponse deleteRecognitionLibWithOptions(shared_ptr<DeleteRecognitionLibRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRecognitionLibResponse deleteRecognitionLib(shared_ptr<DeleteRecognitionLibRequest> request);
  DeleteRecognitionSampleResponse deleteRecognitionSampleWithOptions(shared_ptr<DeleteRecognitionSampleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRecognitionSampleResponse deleteRecognitionSample(shared_ptr<DeleteRecognitionSampleRequest> request);
  DeleteSmartJobResponse deleteSmartJobWithOptions(shared_ptr<DeleteSmartJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSmartJobResponse deleteSmartJob(shared_ptr<DeleteSmartJobRequest> request);
  DeleteSourceResponse deleteSourceWithOptions(shared_ptr<DeleteSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSourceResponse deleteSource(shared_ptr<DeleteSourceRequest> request);
  DeleteSourceLocationResponse deleteSourceLocationWithOptions(shared_ptr<DeleteSourceLocationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSourceLocationResponse deleteSourceLocation(shared_ptr<DeleteSourceLocationRequest> request);
  DeleteTemplateResponse deleteTemplateWithOptions(shared_ptr<DeleteTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTemplateResponse deleteTemplate(shared_ptr<DeleteTemplateRequest> request);
  DeleteVodPackagingAssetResponse deleteVodPackagingAssetWithOptions(shared_ptr<DeleteVodPackagingAssetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVodPackagingAssetResponse deleteVodPackagingAsset(shared_ptr<DeleteVodPackagingAssetRequest> request);
  DeleteVodPackagingConfigurationResponse deleteVodPackagingConfigurationWithOptions(shared_ptr<DeleteVodPackagingConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVodPackagingConfigurationResponse deleteVodPackagingConfiguration(shared_ptr<DeleteVodPackagingConfigurationRequest> request);
  DeleteVodPackagingGroupResponse deleteVodPackagingGroupWithOptions(shared_ptr<DeleteVodPackagingGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVodPackagingGroupResponse deleteVodPackagingGroup(shared_ptr<DeleteVodPackagingGroupRequest> request);
  DescribeAIAgentInstanceResponse describeAIAgentInstanceWithOptions(shared_ptr<DescribeAIAgentInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAIAgentInstanceResponse describeAIAgentInstance(shared_ptr<DescribeAIAgentInstanceRequest> request);
  DescribeMeterImsEditUsageResponse describeMeterImsEditUsageWithOptions(shared_ptr<DescribeMeterImsEditUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterImsEditUsageResponse describeMeterImsEditUsage(shared_ptr<DescribeMeterImsEditUsageRequest> request);
  DescribeMeterImsMediaConvertUHDUsageResponse describeMeterImsMediaConvertUHDUsageWithOptions(shared_ptr<DescribeMeterImsMediaConvertUHDUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterImsMediaConvertUHDUsageResponse describeMeterImsMediaConvertUHDUsage(shared_ptr<DescribeMeterImsMediaConvertUHDUsageRequest> request);
  DescribeMeterImsMediaConvertUsageResponse describeMeterImsMediaConvertUsageWithOptions(shared_ptr<DescribeMeterImsMediaConvertUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterImsMediaConvertUsageResponse describeMeterImsMediaConvertUsage(shared_ptr<DescribeMeterImsMediaConvertUsageRequest> request);
  DescribeMeterImsMpsAiUsageResponse describeMeterImsMpsAiUsageWithOptions(shared_ptr<DescribeMeterImsMpsAiUsageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterImsMpsAiUsageResponse describeMeterImsMpsAiUsage(shared_ptr<DescribeMeterImsMpsAiUsageRequest> request);
  DescribeMeterImsSummaryResponse describeMeterImsSummaryWithOptions(shared_ptr<DescribeMeterImsSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMeterImsSummaryResponse describeMeterImsSummary(shared_ptr<DescribeMeterImsSummaryRequest> request);
  DescribeNotifyConfigResponse describeNotifyConfigWithOptions(shared_ptr<DescribeNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNotifyConfigResponse describeNotifyConfig(shared_ptr<DescribeNotifyConfigRequest> request);
  DescribePlayListResponse describePlayListWithOptions(shared_ptr<DescribePlayListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePlayListResponse describePlayList(shared_ptr<DescribePlayListRequest> request);
  DescribeRtcRobotInstanceResponse describeRtcRobotInstanceWithOptions(shared_ptr<DescribeRtcRobotInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRtcRobotInstanceResponse describeRtcRobotInstance(shared_ptr<DescribeRtcRobotInstanceRequest> request);
  DetectAudioForCustomizedVoiceJobResponse detectAudioForCustomizedVoiceJobWithOptions(shared_ptr<DetectAudioForCustomizedVoiceJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetectAudioForCustomizedVoiceJobResponse detectAudioForCustomizedVoiceJob(shared_ptr<DetectAudioForCustomizedVoiceJobRequest> request);
  DropSearchIndexResponse dropSearchIndexWithOptions(shared_ptr<DropSearchIndexRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DropSearchIndexResponse dropSearchIndex(shared_ptr<DropSearchIndexRequest> request);
  DropSearchLibResponse dropSearchLibWithOptions(shared_ptr<DropSearchLibRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DropSearchLibResponse dropSearchLib(shared_ptr<DropSearchLibRequest> request);
  GenerateAIAgentCallResponse generateAIAgentCallWithOptions(shared_ptr<GenerateAIAgentCallRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateAIAgentCallResponse generateAIAgentCall(shared_ptr<GenerateAIAgentCallRequest> request);
  GenerateKMSDataKeyResponse generateKMSDataKeyWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateKMSDataKeyResponse generateKMSDataKey();
  GenerateMessageChatTokenResponse generateMessageChatTokenWithOptions(shared_ptr<GenerateMessageChatTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateMessageChatTokenResponse generateMessageChatToken(shared_ptr<GenerateMessageChatTokenRequest> request);
  GetAdInsertionResponse getAdInsertionWithOptions(shared_ptr<GetAdInsertionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAdInsertionResponse getAdInsertion(shared_ptr<GetAdInsertionRequest> request);
  GetAvatarResponse getAvatarWithOptions(shared_ptr<GetAvatarRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAvatarResponse getAvatar(shared_ptr<GetAvatarRequest> request);
  GetAvatarTrainingJobResponse getAvatarTrainingJobWithOptions(shared_ptr<GetAvatarTrainingJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAvatarTrainingJobResponse getAvatarTrainingJob(shared_ptr<GetAvatarTrainingJobRequest> request);
  GetBatchMediaProducingJobResponse getBatchMediaProducingJobWithOptions(shared_ptr<GetBatchMediaProducingJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBatchMediaProducingJobResponse getBatchMediaProducingJob(shared_ptr<GetBatchMediaProducingJobRequest> request);
  GetCategoriesResponse getCategoriesWithOptions(shared_ptr<GetCategoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCategoriesResponse getCategories(shared_ptr<GetCategoriesRequest> request);
  GetChannelResponse getChannelWithOptions(shared_ptr<GetChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetChannelResponse getChannel(shared_ptr<GetChannelRequest> request);
  GetContentAnalyzeConfigResponse getContentAnalyzeConfigWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetContentAnalyzeConfigResponse getContentAnalyzeConfig();
  GetCustomTemplateResponse getCustomTemplateWithOptions(shared_ptr<GetCustomTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCustomTemplateResponse getCustomTemplate(shared_ptr<GetCustomTemplateRequest> request);
  GetCustomizedVoiceResponse getCustomizedVoiceWithOptions(shared_ptr<GetCustomizedVoiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCustomizedVoiceResponse getCustomizedVoice(shared_ptr<GetCustomizedVoiceRequest> request);
  GetCustomizedVoiceJobResponse getCustomizedVoiceJobWithOptions(shared_ptr<GetCustomizedVoiceJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCustomizedVoiceJobResponse getCustomizedVoiceJob(shared_ptr<GetCustomizedVoiceJobRequest> request);
  GetDefaultStorageLocationResponse getDefaultStorageLocationWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDefaultStorageLocationResponse getDefaultStorageLocation();
  GetDemonstrationForCustomizedVoiceJobResponse getDemonstrationForCustomizedVoiceJobWithOptions(shared_ptr<GetDemonstrationForCustomizedVoiceJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDemonstrationForCustomizedVoiceJobResponse getDemonstrationForCustomizedVoiceJob(shared_ptr<GetDemonstrationForCustomizedVoiceJobRequest> request);
  GetDynamicImageJobResponse getDynamicImageJobWithOptions(shared_ptr<GetDynamicImageJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDynamicImageJobResponse getDynamicImageJob(shared_ptr<GetDynamicImageJobRequest> request);
  GetEditingProjectResponse getEditingProjectWithOptions(shared_ptr<GetEditingProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEditingProjectResponse getEditingProject(shared_ptr<GetEditingProjectRequest> request);
  GetEditingProjectMaterialsResponse getEditingProjectMaterialsWithOptions(shared_ptr<GetEditingProjectMaterialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEditingProjectMaterialsResponse getEditingProjectMaterials(shared_ptr<GetEditingProjectMaterialsRequest> request);
  GetEventCallbackResponse getEventCallbackWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEventCallbackResponse getEventCallback();
  GetHotwordLibraryResponse getHotwordLibraryWithOptions(shared_ptr<GetHotwordLibraryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHotwordLibraryResponse getHotwordLibrary(shared_ptr<GetHotwordLibraryRequest> request);
  GetLiveEditingIndexFileResponse getLiveEditingIndexFileWithOptions(shared_ptr<GetLiveEditingIndexFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveEditingIndexFileResponse getLiveEditingIndexFile(shared_ptr<GetLiveEditingIndexFileRequest> request);
  GetLiveEditingJobResponse getLiveEditingJobWithOptions(shared_ptr<GetLiveEditingJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveEditingJobResponse getLiveEditingJob(shared_ptr<GetLiveEditingJobRequest> request);
  GetLivePackageChannelResponse getLivePackageChannelWithOptions(shared_ptr<GetLivePackageChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLivePackageChannelResponse getLivePackageChannel(shared_ptr<GetLivePackageChannelRequest> request);
  GetLivePackageChannelGroupResponse getLivePackageChannelGroupWithOptions(shared_ptr<GetLivePackageChannelGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLivePackageChannelGroupResponse getLivePackageChannelGroup(shared_ptr<GetLivePackageChannelGroupRequest> request);
  GetLivePackageOriginEndpointResponse getLivePackageOriginEndpointWithOptions(shared_ptr<GetLivePackageOriginEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLivePackageOriginEndpointResponse getLivePackageOriginEndpoint(shared_ptr<GetLivePackageOriginEndpointRequest> request);
  GetLiveRecordJobResponse getLiveRecordJobWithOptions(shared_ptr<GetLiveRecordJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveRecordJobResponse getLiveRecordJob(shared_ptr<GetLiveRecordJobRequest> request);
  GetLiveRecordTemplateResponse getLiveRecordTemplateWithOptions(shared_ptr<GetLiveRecordTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveRecordTemplateResponse getLiveRecordTemplate(shared_ptr<GetLiveRecordTemplateRequest> request);
  GetLiveSnapshotJobResponse getLiveSnapshotJobWithOptions(shared_ptr<GetLiveSnapshotJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveSnapshotJobResponse getLiveSnapshotJob(shared_ptr<GetLiveSnapshotJobRequest> request);
  GetLiveSnapshotTemplateResponse getLiveSnapshotTemplateWithOptions(shared_ptr<GetLiveSnapshotTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveSnapshotTemplateResponse getLiveSnapshotTemplate(shared_ptr<GetLiveSnapshotTemplateRequest> request);
  GetLiveTranscodeJobResponse getLiveTranscodeJobWithOptions(shared_ptr<GetLiveTranscodeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveTranscodeJobResponse getLiveTranscodeJob(shared_ptr<GetLiveTranscodeJobRequest> request);
  GetLiveTranscodeTemplateResponse getLiveTranscodeTemplateWithOptions(shared_ptr<GetLiveTranscodeTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLiveTranscodeTemplateResponse getLiveTranscodeTemplate(shared_ptr<GetLiveTranscodeTemplateRequest> request);
  GetMediaConnectFlowResponse getMediaConnectFlowWithOptions(shared_ptr<GetMediaConnectFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaConnectFlowResponse getMediaConnectFlow(shared_ptr<GetMediaConnectFlowRequest> request);
  GetMediaConnectFlowInputResponse getMediaConnectFlowInputWithOptions(shared_ptr<GetMediaConnectFlowInputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaConnectFlowInputResponse getMediaConnectFlowInput(shared_ptr<GetMediaConnectFlowInputRequest> request);
  GetMediaConnectFlowOutputResponse getMediaConnectFlowOutputWithOptions(shared_ptr<GetMediaConnectFlowOutputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaConnectFlowOutputResponse getMediaConnectFlowOutput(shared_ptr<GetMediaConnectFlowOutputRequest> request);
  GetMediaConvertJobResponse getMediaConvertJobWithOptions(shared_ptr<GetMediaConvertJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaConvertJobResponse getMediaConvertJob(shared_ptr<GetMediaConvertJobRequest> request);
  GetMediaInfoResponse getMediaInfoWithOptions(shared_ptr<GetMediaInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaInfoResponse getMediaInfo(shared_ptr<GetMediaInfoRequest> request);
  GetMediaInfoJobResponse getMediaInfoJobWithOptions(shared_ptr<GetMediaInfoJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaInfoJobResponse getMediaInfoJob(shared_ptr<GetMediaInfoJobRequest> request);
  GetMediaLiveChannelResponse getMediaLiveChannelWithOptions(shared_ptr<GetMediaLiveChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaLiveChannelResponse getMediaLiveChannel(shared_ptr<GetMediaLiveChannelRequest> request);
  GetMediaLiveInputResponse getMediaLiveInputWithOptions(shared_ptr<GetMediaLiveInputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaLiveInputResponse getMediaLiveInput(shared_ptr<GetMediaLiveInputRequest> request);
  GetMediaLiveInputSecurityGroupResponse getMediaLiveInputSecurityGroupWithOptions(shared_ptr<GetMediaLiveInputSecurityGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaLiveInputSecurityGroupResponse getMediaLiveInputSecurityGroup(shared_ptr<GetMediaLiveInputSecurityGroupRequest> request);
  GetMediaMarksResponse getMediaMarksWithOptions(shared_ptr<GetMediaMarksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaMarksResponse getMediaMarks(shared_ptr<GetMediaMarksRequest> request);
  GetMediaProducingJobResponse getMediaProducingJobWithOptions(shared_ptr<GetMediaProducingJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMediaProducingJobResponse getMediaProducingJob(shared_ptr<GetMediaProducingJobRequest> request);
  GetPackageJobResponse getPackageJobWithOptions(shared_ptr<GetPackageJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPackageJobResponse getPackageJob(shared_ptr<GetPackageJobRequest> request);
  GetPipelineResponse getPipelineWithOptions(shared_ptr<GetPipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPipelineResponse getPipeline(shared_ptr<GetPipelineRequest> request);
  GetPlayInfoResponse getPlayInfoWithOptions(shared_ptr<GetPlayInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPlayInfoResponse getPlayInfo(shared_ptr<GetPlayInfoRequest> request);
  GetProgramResponse getProgramWithOptions(shared_ptr<GetProgramRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProgramResponse getProgram(shared_ptr<GetProgramRequest> request);
  GetProjectExportJobResponse getProjectExportJobWithOptions(shared_ptr<GetProjectExportJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProjectExportJobResponse getProjectExportJob(shared_ptr<GetProjectExportJobRequest> request);
  GetPublicMediaInfoResponse getPublicMediaInfoWithOptions(shared_ptr<GetPublicMediaInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPublicMediaInfoResponse getPublicMediaInfo(shared_ptr<GetPublicMediaInfoRequest> request);
  GetSmartHandleJobResponse getSmartHandleJobWithOptions(shared_ptr<GetSmartHandleJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSmartHandleJobResponse getSmartHandleJob(shared_ptr<GetSmartHandleJobRequest> request);
  GetSnapshotJobResponse getSnapshotJobWithOptions(shared_ptr<GetSnapshotJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSnapshotJobResponse getSnapshotJob(shared_ptr<GetSnapshotJobRequest> request);
  GetSnapshotUrlsResponse getSnapshotUrlsWithOptions(shared_ptr<GetSnapshotUrlsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSnapshotUrlsResponse getSnapshotUrls(shared_ptr<GetSnapshotUrlsRequest> request);
  GetSourceResponse getSourceWithOptions(shared_ptr<GetSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSourceResponse getSource(shared_ptr<GetSourceRequest> request);
  GetSourceLocationResponse getSourceLocationWithOptions(shared_ptr<GetSourceLocationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSourceLocationResponse getSourceLocation(shared_ptr<GetSourceLocationRequest> request);
  GetStorageListResponse getStorageListWithOptions(shared_ptr<GetStorageListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetStorageListResponse getStorageList(shared_ptr<GetStorageListRequest> request);
  GetSystemTemplateResponse getSystemTemplateWithOptions(shared_ptr<GetSystemTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSystemTemplateResponse getSystemTemplate(shared_ptr<GetSystemTemplateRequest> request);
  GetTemplateResponse getTemplateWithOptions(shared_ptr<GetTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTemplateResponse getTemplate(shared_ptr<GetTemplateRequest> request);
  GetTemplateMaterialsResponse getTemplateMaterialsWithOptions(shared_ptr<GetTemplateMaterialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTemplateMaterialsResponse getTemplateMaterials(shared_ptr<GetTemplateMaterialsRequest> request);
  GetTemplateParamsResponse getTemplateParamsWithOptions(shared_ptr<GetTemplateParamsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTemplateParamsResponse getTemplateParams(shared_ptr<GetTemplateParamsRequest> request);
  GetTranscodeJobResponse getTranscodeJobWithOptions(shared_ptr<GetTranscodeJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTranscodeJobResponse getTranscodeJob(shared_ptr<GetTranscodeJobRequest> request);
  GetUrlUploadInfosResponse getUrlUploadInfosWithOptions(shared_ptr<GetUrlUploadInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUrlUploadInfosResponse getUrlUploadInfos(shared_ptr<GetUrlUploadInfosRequest> request);
  GetVideoListResponse getVideoListWithOptions(shared_ptr<GetVideoListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVideoListResponse getVideoList(shared_ptr<GetVideoListRequest> request);
  GetVodPackagingAssetResponse getVodPackagingAssetWithOptions(shared_ptr<GetVodPackagingAssetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVodPackagingAssetResponse getVodPackagingAsset(shared_ptr<GetVodPackagingAssetRequest> request);
  GetVodPackagingConfigurationResponse getVodPackagingConfigurationWithOptions(shared_ptr<GetVodPackagingConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVodPackagingConfigurationResponse getVodPackagingConfiguration(shared_ptr<GetVodPackagingConfigurationRequest> request);
  GetVodPackagingGroupResponse getVodPackagingGroupWithOptions(shared_ptr<GetVodPackagingGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVodPackagingGroupResponse getVodPackagingGroup(shared_ptr<GetVodPackagingGroupRequest> request);
  GetWorkflowTaskResponse getWorkflowTaskWithOptions(shared_ptr<GetWorkflowTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetWorkflowTaskResponse getWorkflowTask(shared_ptr<GetWorkflowTaskRequest> request);
  InsertMediaToSearchLibResponse insertMediaToSearchLibWithOptions(shared_ptr<InsertMediaToSearchLibRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertMediaToSearchLibResponse insertMediaToSearchLib(shared_ptr<InsertMediaToSearchLibRequest> request);
  ListAIAgentDialoguesResponse listAIAgentDialoguesWithOptions(shared_ptr<ListAIAgentDialoguesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAIAgentDialoguesResponse listAIAgentDialogues(shared_ptr<ListAIAgentDialoguesRequest> request);
  ListAIAgentInstanceResponse listAIAgentInstanceWithOptions(shared_ptr<ListAIAgentInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAIAgentInstanceResponse listAIAgentInstance(shared_ptr<ListAIAgentInstanceRequest> request);
  ListAIAgentPhoneNumberResponse listAIAgentPhoneNumberWithOptions(shared_ptr<ListAIAgentPhoneNumberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAIAgentPhoneNumberResponse listAIAgentPhoneNumber(shared_ptr<ListAIAgentPhoneNumberRequest> request);
  ListAdInsertionsResponse listAdInsertionsWithOptions(shared_ptr<ListAdInsertionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAdInsertionsResponse listAdInsertions(shared_ptr<ListAdInsertionsRequest> request);
  ListAlertsResponse listAlertsWithOptions(shared_ptr<ListAlertsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAlertsResponse listAlerts(shared_ptr<ListAlertsRequest> request);
  ListAllPublicMediaTagsResponse listAllPublicMediaTagsWithOptions(shared_ptr<ListAllPublicMediaTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAllPublicMediaTagsResponse listAllPublicMediaTags(shared_ptr<ListAllPublicMediaTagsRequest> request);
  ListAvatarTrainingJobsResponse listAvatarTrainingJobsWithOptions(shared_ptr<ListAvatarTrainingJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAvatarTrainingJobsResponse listAvatarTrainingJobs(shared_ptr<ListAvatarTrainingJobsRequest> request);
  ListAvatarsResponse listAvatarsWithOptions(shared_ptr<ListAvatarsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAvatarsResponse listAvatars(shared_ptr<ListAvatarsRequest> request);
  ListBatchMediaProducingJobsResponse listBatchMediaProducingJobsWithOptions(shared_ptr<ListBatchMediaProducingJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBatchMediaProducingJobsResponse listBatchMediaProducingJobs(shared_ptr<ListBatchMediaProducingJobsRequest> request);
  ListChannelAlertsResponse listChannelAlertsWithOptions(shared_ptr<ListChannelAlertsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListChannelAlertsResponse listChannelAlerts(shared_ptr<ListChannelAlertsRequest> request);
  ListChannelsResponse listChannelsWithOptions(shared_ptr<ListChannelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListChannelsResponse listChannels(shared_ptr<ListChannelsRequest> request);
  ListCustomTemplatesResponse listCustomTemplatesWithOptions(shared_ptr<ListCustomTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomTemplatesResponse listCustomTemplates(shared_ptr<ListCustomTemplatesRequest> request);
  ListCustomizedVoiceJobsResponse listCustomizedVoiceJobsWithOptions(shared_ptr<ListCustomizedVoiceJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomizedVoiceJobsResponse listCustomizedVoiceJobs(shared_ptr<ListCustomizedVoiceJobsRequest> request);
  ListCustomizedVoicesResponse listCustomizedVoicesWithOptions(shared_ptr<ListCustomizedVoicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomizedVoicesResponse listCustomizedVoices(shared_ptr<ListCustomizedVoicesRequest> request);
  ListDNADBResponse listDNADBWithOptions(shared_ptr<ListDNADBRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDNADBResponse listDNADB(shared_ptr<ListDNADBRequest> request);
  ListDNAFilesResponse listDNAFilesWithOptions(shared_ptr<ListDNAFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDNAFilesResponse listDNAFiles(shared_ptr<ListDNAFilesRequest> request);
  ListDynamicImageJobsResponse listDynamicImageJobsWithOptions(shared_ptr<ListDynamicImageJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDynamicImageJobsResponse listDynamicImageJobs(shared_ptr<ListDynamicImageJobsRequest> request);
  ListEditingProjectsResponse listEditingProjectsWithOptions(shared_ptr<ListEditingProjectsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEditingProjectsResponse listEditingProjects(shared_ptr<ListEditingProjectsRequest> request);
  ListHotwordLibrariesResponse listHotwordLibrariesWithOptions(shared_ptr<ListHotwordLibrariesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHotwordLibrariesResponse listHotwordLibraries(shared_ptr<ListHotwordLibrariesRequest> request);
  ListLivePackageChannelGroupsResponse listLivePackageChannelGroupsWithOptions(shared_ptr<ListLivePackageChannelGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLivePackageChannelGroupsResponse listLivePackageChannelGroups(shared_ptr<ListLivePackageChannelGroupsRequest> request);
  ListLivePackageChannelsResponse listLivePackageChannelsWithOptions(shared_ptr<ListLivePackageChannelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLivePackageChannelsResponse listLivePackageChannels(shared_ptr<ListLivePackageChannelsRequest> request);
  ListLivePackageOriginEndpointsResponse listLivePackageOriginEndpointsWithOptions(shared_ptr<ListLivePackageOriginEndpointsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLivePackageOriginEndpointsResponse listLivePackageOriginEndpoints(shared_ptr<ListLivePackageOriginEndpointsRequest> request);
  ListLiveRecordFilesResponse listLiveRecordFilesWithOptions(shared_ptr<ListLiveRecordFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveRecordFilesResponse listLiveRecordFiles(shared_ptr<ListLiveRecordFilesRequest> request);
  ListLiveRecordJobsResponse listLiveRecordJobsWithOptions(shared_ptr<ListLiveRecordJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveRecordJobsResponse listLiveRecordJobs(shared_ptr<ListLiveRecordJobsRequest> request);
  ListLiveRecordTemplatesResponse listLiveRecordTemplatesWithOptions(shared_ptr<ListLiveRecordTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveRecordTemplatesResponse listLiveRecordTemplates(shared_ptr<ListLiveRecordTemplatesRequest> request);
  ListLiveSnapshotFilesResponse listLiveSnapshotFilesWithOptions(shared_ptr<ListLiveSnapshotFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveSnapshotFilesResponse listLiveSnapshotFiles(shared_ptr<ListLiveSnapshotFilesRequest> request);
  ListLiveSnapshotJobsResponse listLiveSnapshotJobsWithOptions(shared_ptr<ListLiveSnapshotJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveSnapshotJobsResponse listLiveSnapshotJobs(shared_ptr<ListLiveSnapshotJobsRequest> request);
  ListLiveSnapshotTemplatesResponse listLiveSnapshotTemplatesWithOptions(shared_ptr<ListLiveSnapshotTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveSnapshotTemplatesResponse listLiveSnapshotTemplates(shared_ptr<ListLiveSnapshotTemplatesRequest> request);
  ListLiveTranscodeJobsResponse listLiveTranscodeJobsWithOptions(shared_ptr<ListLiveTranscodeJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveTranscodeJobsResponse listLiveTranscodeJobs(shared_ptr<ListLiveTranscodeJobsRequest> request);
  ListLiveTranscodeTemplatesResponse listLiveTranscodeTemplatesWithOptions(shared_ptr<ListLiveTranscodeTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLiveTranscodeTemplatesResponse listLiveTranscodeTemplates(shared_ptr<ListLiveTranscodeTemplatesRequest> request);
  ListMediaBasicInfosResponse listMediaBasicInfosWithOptions(shared_ptr<ListMediaBasicInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMediaBasicInfosResponse listMediaBasicInfos(shared_ptr<ListMediaBasicInfosRequest> request);
  ListMediaConvertJobsResponse listMediaConvertJobsWithOptions(shared_ptr<ListMediaConvertJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMediaConvertJobsResponse listMediaConvertJobs(shared_ptr<ListMediaConvertJobsRequest> request);
  ListMediaInfoJobsResponse listMediaInfoJobsWithOptions(shared_ptr<ListMediaInfoJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMediaInfoJobsResponse listMediaInfoJobs(shared_ptr<ListMediaInfoJobsRequest> request);
  ListMediaLiveChannelsResponse listMediaLiveChannelsWithOptions(shared_ptr<ListMediaLiveChannelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMediaLiveChannelsResponse listMediaLiveChannels(shared_ptr<ListMediaLiveChannelsRequest> request);
  ListMediaLiveInputSecurityGroupsResponse listMediaLiveInputSecurityGroupsWithOptions(shared_ptr<ListMediaLiveInputSecurityGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMediaLiveInputSecurityGroupsResponse listMediaLiveInputSecurityGroups(shared_ptr<ListMediaLiveInputSecurityGroupsRequest> request);
  ListMediaLiveInputsResponse listMediaLiveInputsWithOptions(shared_ptr<ListMediaLiveInputsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMediaLiveInputsResponse listMediaLiveInputs(shared_ptr<ListMediaLiveInputsRequest> request);
  ListMediaMarksResponse listMediaMarksWithOptions(shared_ptr<ListMediaMarksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMediaMarksResponse listMediaMarks(shared_ptr<ListMediaMarksRequest> request);
  ListMediaProducingJobsResponse listMediaProducingJobsWithOptions(shared_ptr<ListMediaProducingJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMediaProducingJobsResponse listMediaProducingJobs(shared_ptr<ListMediaProducingJobsRequest> request);
  ListPackageJobsResponse listPackageJobsWithOptions(shared_ptr<ListPackageJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPackageJobsResponse listPackageJobs(shared_ptr<ListPackageJobsRequest> request);
  ListPipelinesResponse listPipelinesWithOptions(shared_ptr<ListPipelinesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPipelinesResponse listPipelines(shared_ptr<ListPipelinesRequest> request);
  ListProgramsResponse listProgramsWithOptions(shared_ptr<ListProgramsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProgramsResponse listPrograms(shared_ptr<ListProgramsRequest> request);
  ListPublicMediaBasicInfosResponse listPublicMediaBasicInfosWithOptions(shared_ptr<ListPublicMediaBasicInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPublicMediaBasicInfosResponse listPublicMediaBasicInfos(shared_ptr<ListPublicMediaBasicInfosRequest> request);
  ListRecognitionEntitiesResponse listRecognitionEntitiesWithOptions(shared_ptr<ListRecognitionEntitiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRecognitionEntitiesResponse listRecognitionEntities(shared_ptr<ListRecognitionEntitiesRequest> request);
  ListRecognitionLibsResponse listRecognitionLibsWithOptions(shared_ptr<ListRecognitionLibsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRecognitionLibsResponse listRecognitionLibs(shared_ptr<ListRecognitionLibsRequest> request);
  ListRecognitionSamplesResponse listRecognitionSamplesWithOptions(shared_ptr<ListRecognitionSamplesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRecognitionSamplesResponse listRecognitionSamples(shared_ptr<ListRecognitionSamplesRequest> request);
  ListSchedulesResponse listSchedulesWithOptions(shared_ptr<ListSchedulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSchedulesResponse listSchedules(shared_ptr<ListSchedulesRequest> request);
  ListSearchLibResponse listSearchLibWithOptions(shared_ptr<ListSearchLibRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSearchLibResponse listSearchLib(shared_ptr<ListSearchLibRequest> request);
  ListSmartJobsResponse listSmartJobsWithOptions(shared_ptr<ListSmartJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSmartJobsResponse listSmartJobs(shared_ptr<ListSmartJobsRequest> request);
  ListSmartSysAvatarModelsResponse listSmartSysAvatarModelsWithOptions(shared_ptr<ListSmartSysAvatarModelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSmartSysAvatarModelsResponse listSmartSysAvatarModels(shared_ptr<ListSmartSysAvatarModelsRequest> request);
  ListSmartVoiceGroupsResponse listSmartVoiceGroupsWithOptions(shared_ptr<ListSmartVoiceGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSmartVoiceGroupsResponse listSmartVoiceGroups(shared_ptr<ListSmartVoiceGroupsRequest> request);
  ListSnapshotJobsResponse listSnapshotJobsWithOptions(shared_ptr<ListSnapshotJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSnapshotJobsResponse listSnapshotJobs(shared_ptr<ListSnapshotJobsRequest> request);
  ListSourceLocationsResponse listSourceLocationsWithOptions(shared_ptr<ListSourceLocationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSourceLocationsResponse listSourceLocations(shared_ptr<ListSourceLocationsRequest> request);
  ListSourcesResponse listSourcesWithOptions(shared_ptr<ListSourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSourcesResponse listSources(shared_ptr<ListSourcesRequest> request);
  ListSystemTemplatesResponse listSystemTemplatesWithOptions(shared_ptr<ListSystemTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSystemTemplatesResponse listSystemTemplates(shared_ptr<ListSystemTemplatesRequest> request);
  ListTemplatesResponse listTemplatesWithOptions(shared_ptr<ListTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTemplatesResponse listTemplates(shared_ptr<ListTemplatesRequest> request);
  ListTranscodeJobsResponse listTranscodeJobsWithOptions(shared_ptr<ListTranscodeJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTranscodeJobsResponse listTranscodeJobs(shared_ptr<ListTranscodeJobsRequest> request);
  ListVodPackagingAssetsResponse listVodPackagingAssetsWithOptions(shared_ptr<ListVodPackagingAssetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVodPackagingAssetsResponse listVodPackagingAssets(shared_ptr<ListVodPackagingAssetsRequest> request);
  ListVodPackagingConfigurationsResponse listVodPackagingConfigurationsWithOptions(shared_ptr<ListVodPackagingConfigurationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVodPackagingConfigurationsResponse listVodPackagingConfigurations(shared_ptr<ListVodPackagingConfigurationsRequest> request);
  ListVodPackagingGroupsResponse listVodPackagingGroupsWithOptions(shared_ptr<ListVodPackagingGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVodPackagingGroupsResponse listVodPackagingGroups(shared_ptr<ListVodPackagingGroupsRequest> request);
  QueryCopyrightExtractJobResponse queryCopyrightExtractJobWithOptions(shared_ptr<QueryCopyrightExtractJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCopyrightExtractJobResponse queryCopyrightExtractJob(shared_ptr<QueryCopyrightExtractJobRequest> request);
  QueryCopyrightJobListResponse queryCopyrightJobListWithOptions(shared_ptr<QueryCopyrightJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryCopyrightJobListResponse queryCopyrightJobList(shared_ptr<QueryCopyrightJobListRequest> request);
  QueryDNAJobListResponse queryDNAJobListWithOptions(shared_ptr<QueryDNAJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryDNAJobListResponse queryDNAJobList(shared_ptr<QueryDNAJobListRequest> request);
  QueryIProductionJobResponse queryIProductionJobWithOptions(shared_ptr<QueryIProductionJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryIProductionJobResponse queryIProductionJob(shared_ptr<QueryIProductionJobRequest> request);
  QueryMediaCensorJobDetailResponse queryMediaCensorJobDetailWithOptions(shared_ptr<QueryMediaCensorJobDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaCensorJobDetailResponse queryMediaCensorJobDetail(shared_ptr<QueryMediaCensorJobDetailRequest> request);
  QueryMediaCensorJobListResponse queryMediaCensorJobListWithOptions(shared_ptr<QueryMediaCensorJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaCensorJobListResponse queryMediaCensorJobList(shared_ptr<QueryMediaCensorJobListRequest> request);
  QueryMediaIndexJobResponse queryMediaIndexJobWithOptions(shared_ptr<QueryMediaIndexJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMediaIndexJobResponse queryMediaIndexJob(shared_ptr<QueryMediaIndexJobRequest> request);
  QuerySearchIndexResponse querySearchIndexWithOptions(shared_ptr<QuerySearchIndexRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySearchIndexResponse querySearchIndex(shared_ptr<QuerySearchIndexRequest> request);
  QuerySearchLibResponse querySearchLibWithOptions(shared_ptr<QuerySearchLibRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySearchLibResponse querySearchLib(shared_ptr<QuerySearchLibRequest> request);
  QuerySmarttagJobResponse querySmarttagJobWithOptions(shared_ptr<QuerySmarttagJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySmarttagJobResponse querySmarttagJob(shared_ptr<QuerySmarttagJobRequest> request);
  QueryTraceAbJobListResponse queryTraceAbJobListWithOptions(shared_ptr<QueryTraceAbJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTraceAbJobListResponse queryTraceAbJobList(shared_ptr<QueryTraceAbJobListRequest> request);
  QueryTraceExtractJobResponse queryTraceExtractJobWithOptions(shared_ptr<QueryTraceExtractJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTraceExtractJobResponse queryTraceExtractJob(shared_ptr<QueryTraceExtractJobRequest> request);
  QueryTraceM3u8JobListResponse queryTraceM3u8JobListWithOptions(shared_ptr<QueryTraceM3u8JobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTraceM3u8JobListResponse queryTraceM3u8JobList(shared_ptr<QueryTraceM3u8JobListRequest> request);
  RefreshUploadMediaResponse refreshUploadMediaWithOptions(shared_ptr<RefreshUploadMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshUploadMediaResponse refreshUploadMedia(shared_ptr<RefreshUploadMediaRequest> request);
  RegisterMediaInfoResponse registerMediaInfoWithOptions(shared_ptr<RegisterMediaInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterMediaInfoResponse registerMediaInfo(shared_ptr<RegisterMediaInfoRequest> request);
  RegisterMediaStreamResponse registerMediaStreamWithOptions(shared_ptr<RegisterMediaStreamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterMediaStreamResponse registerMediaStream(shared_ptr<RegisterMediaStreamRequest> request);
  SearchEditingProjectResponse searchEditingProjectWithOptions(shared_ptr<SearchEditingProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchEditingProjectResponse searchEditingProject(shared_ptr<SearchEditingProjectRequest> request);
  SearchIndexJobRerunResponse searchIndexJobRerunWithOptions(shared_ptr<SearchIndexJobRerunRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchIndexJobRerunResponse searchIndexJobRerun(shared_ptr<SearchIndexJobRerunRequest> request);
  SearchMediaResponse searchMediaWithOptions(shared_ptr<SearchMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchMediaResponse searchMedia(shared_ptr<SearchMediaRequest> request);
  SearchMediaByAILabelResponse searchMediaByAILabelWithOptions(shared_ptr<SearchMediaByAILabelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchMediaByAILabelResponse searchMediaByAILabel(shared_ptr<SearchMediaByAILabelRequest> request);
  SearchMediaByFaceResponse searchMediaByFaceWithOptions(shared_ptr<SearchMediaByFaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchMediaByFaceResponse searchMediaByFace(shared_ptr<SearchMediaByFaceRequest> request);
  SearchMediaByHybridResponse searchMediaByHybridWithOptions(shared_ptr<SearchMediaByHybridRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchMediaByHybridResponse searchMediaByHybrid(shared_ptr<SearchMediaByHybridRequest> request);
  SearchMediaByMultimodalResponse searchMediaByMultimodalWithOptions(shared_ptr<SearchMediaByMultimodalRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchMediaByMultimodalResponse searchMediaByMultimodal(shared_ptr<SearchMediaByMultimodalRequest> request);
  SearchMediaClipByFaceResponse searchMediaClipByFaceWithOptions(shared_ptr<SearchMediaClipByFaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchMediaClipByFaceResponse searchMediaClipByFace(shared_ptr<SearchMediaClipByFaceRequest> request);
  SearchPublicMediaInfoResponse searchPublicMediaInfoWithOptions(shared_ptr<SearchPublicMediaInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchPublicMediaInfoResponse searchPublicMediaInfo(shared_ptr<SearchPublicMediaInfoRequest> request);
  SendAIAgentDataChannelMessageResponse sendAIAgentDataChannelMessageWithOptions(shared_ptr<SendAIAgentDataChannelMessageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendAIAgentDataChannelMessageResponse sendAIAgentDataChannelMessage(shared_ptr<SendAIAgentDataChannelMessageRequest> request);
  SendAIAgentSpeechResponse sendAIAgentSpeechWithOptions(shared_ptr<SendAIAgentSpeechRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendAIAgentSpeechResponse sendAIAgentSpeech(shared_ptr<SendAIAgentSpeechRequest> request);
  SendAIAgentTextResponse sendAIAgentTextWithOptions(shared_ptr<SendAIAgentTextRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendAIAgentTextResponse sendAIAgentText(shared_ptr<SendAIAgentTextRequest> request);
  SendLiveSnapshotJobCommandResponse sendLiveSnapshotJobCommandWithOptions(shared_ptr<SendLiveSnapshotJobCommandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendLiveSnapshotJobCommandResponse sendLiveSnapshotJobCommand(shared_ptr<SendLiveSnapshotJobCommandRequest> request);
  SendLiveTranscodeJobCommandResponse sendLiveTranscodeJobCommandWithOptions(shared_ptr<SendLiveTranscodeJobCommandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendLiveTranscodeJobCommandResponse sendLiveTranscodeJobCommand(shared_ptr<SendLiveTranscodeJobCommandRequest> request);
  SendMessageChatTextResponse sendMessageChatTextWithOptions(shared_ptr<SendMessageChatTextRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendMessageChatTextResponse sendMessageChatText(shared_ptr<SendMessageChatTextRequest> request);
  SetContentAnalyzeConfigResponse setContentAnalyzeConfigWithOptions(shared_ptr<SetContentAnalyzeConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetContentAnalyzeConfigResponse setContentAnalyzeConfig(shared_ptr<SetContentAnalyzeConfigRequest> request);
  SetDefaultCustomTemplateResponse setDefaultCustomTemplateWithOptions(shared_ptr<SetDefaultCustomTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDefaultCustomTemplateResponse setDefaultCustomTemplate(shared_ptr<SetDefaultCustomTemplateRequest> request);
  SetDefaultStorageLocationResponse setDefaultStorageLocationWithOptions(shared_ptr<SetDefaultStorageLocationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDefaultStorageLocationResponse setDefaultStorageLocation(shared_ptr<SetDefaultStorageLocationRequest> request);
  SetEventCallbackResponse setEventCallbackWithOptions(shared_ptr<SetEventCallbackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetEventCallbackResponse setEventCallback(shared_ptr<SetEventCallbackRequest> request);
  SetNotifyConfigResponse setNotifyConfigWithOptions(shared_ptr<SetNotifyConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetNotifyConfigResponse setNotifyConfig(shared_ptr<SetNotifyConfigRequest> request);
  StartAIAgentInstanceResponse startAIAgentInstanceWithOptions(shared_ptr<StartAIAgentInstanceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartAIAgentInstanceResponse startAIAgentInstance(shared_ptr<StartAIAgentInstanceRequest> request);
  StartAIAgentOutboundCallResponse startAIAgentOutboundCallWithOptions(shared_ptr<StartAIAgentOutboundCallRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartAIAgentOutboundCallResponse startAIAgentOutboundCall(shared_ptr<StartAIAgentOutboundCallRequest> request);
  StartChannelResponse startChannelWithOptions(shared_ptr<StartChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartChannelResponse startChannel(shared_ptr<StartChannelRequest> request);
  StartMediaLiveChannelResponse startMediaLiveChannelWithOptions(shared_ptr<StartMediaLiveChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartMediaLiveChannelResponse startMediaLiveChannel(shared_ptr<StartMediaLiveChannelRequest> request);
  StartRtcRobotInstanceResponse startRtcRobotInstanceWithOptions(shared_ptr<StartRtcRobotInstanceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartRtcRobotInstanceResponse startRtcRobotInstance(shared_ptr<StartRtcRobotInstanceRequest> request);
  StartWorkflowResponse startWorkflowWithOptions(shared_ptr<StartWorkflowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartWorkflowResponse startWorkflow(shared_ptr<StartWorkflowRequest> request);
  StopAIAgentInstanceResponse stopAIAgentInstanceWithOptions(shared_ptr<StopAIAgentInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopAIAgentInstanceResponse stopAIAgentInstance(shared_ptr<StopAIAgentInstanceRequest> request);
  StopChannelResponse stopChannelWithOptions(shared_ptr<StopChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopChannelResponse stopChannel(shared_ptr<StopChannelRequest> request);
  StopMediaLiveChannelResponse stopMediaLiveChannelWithOptions(shared_ptr<StopMediaLiveChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopMediaLiveChannelResponse stopMediaLiveChannel(shared_ptr<StopMediaLiveChannelRequest> request);
  StopRtcRobotInstanceResponse stopRtcRobotInstanceWithOptions(shared_ptr<StopRtcRobotInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopRtcRobotInstanceResponse stopRtcRobotInstance(shared_ptr<StopRtcRobotInstanceRequest> request);
  SubmitAIAgentVideoAuditTaskResponse submitAIAgentVideoAuditTaskWithOptions(shared_ptr<SubmitAIAgentVideoAuditTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitAIAgentVideoAuditTaskResponse submitAIAgentVideoAuditTask(shared_ptr<SubmitAIAgentVideoAuditTaskRequest> request);
  SubmitASRJobResponse submitASRJobWithOptions(shared_ptr<SubmitASRJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitASRJobResponse submitASRJob(shared_ptr<SubmitASRJobRequest> request);
  SubmitAudioProduceJobResponse submitAudioProduceJobWithOptions(shared_ptr<SubmitAudioProduceJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitAudioProduceJobResponse submitAudioProduceJob(shared_ptr<SubmitAudioProduceJobRequest> request);
  SubmitAvatarTrainingJobResponse submitAvatarTrainingJobWithOptions(shared_ptr<SubmitAvatarTrainingJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitAvatarTrainingJobResponse submitAvatarTrainingJob(shared_ptr<SubmitAvatarTrainingJobRequest> request);
  SubmitAvatarVideoJobResponse submitAvatarVideoJobWithOptions(shared_ptr<SubmitAvatarVideoJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitAvatarVideoJobResponse submitAvatarVideoJob(shared_ptr<SubmitAvatarVideoJobRequest> request);
  SubmitBatchMediaProducingJobResponse submitBatchMediaProducingJobWithOptions(shared_ptr<SubmitBatchMediaProducingJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitBatchMediaProducingJobResponse submitBatchMediaProducingJob(shared_ptr<SubmitBatchMediaProducingJobRequest> request);
  SubmitCopyrightExtractJobResponse submitCopyrightExtractJobWithOptions(shared_ptr<SubmitCopyrightExtractJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitCopyrightExtractJobResponse submitCopyrightExtractJob(shared_ptr<SubmitCopyrightExtractJobRequest> request);
  SubmitCopyrightJobResponse submitCopyrightJobWithOptions(shared_ptr<SubmitCopyrightJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitCopyrightJobResponse submitCopyrightJob(shared_ptr<SubmitCopyrightJobRequest> request);
  SubmitCustomizedVoiceJobResponse submitCustomizedVoiceJobWithOptions(shared_ptr<SubmitCustomizedVoiceJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitCustomizedVoiceJobResponse submitCustomizedVoiceJob(shared_ptr<SubmitCustomizedVoiceJobRequest> request);
  SubmitDNAJobResponse submitDNAJobWithOptions(shared_ptr<SubmitDNAJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitDNAJobResponse submitDNAJob(shared_ptr<SubmitDNAJobRequest> request);
  SubmitDynamicChartJobResponse submitDynamicChartJobWithOptions(shared_ptr<SubmitDynamicChartJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitDynamicChartJobResponse submitDynamicChartJob(shared_ptr<SubmitDynamicChartJobRequest> request);
  SubmitDynamicImageJobResponse submitDynamicImageJobWithOptions(shared_ptr<SubmitDynamicImageJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitDynamicImageJobResponse submitDynamicImageJob(shared_ptr<SubmitDynamicImageJobRequest> request);
  SubmitHighlightExtractionJobResponse submitHighlightExtractionJobWithOptions(shared_ptr<SubmitHighlightExtractionJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitHighlightExtractionJobResponse submitHighlightExtractionJob(shared_ptr<SubmitHighlightExtractionJobRequest> request);
  SubmitIProductionJobResponse submitIProductionJobWithOptions(shared_ptr<SubmitIProductionJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitIProductionJobResponse submitIProductionJob(shared_ptr<SubmitIProductionJobRequest> request);
  SubmitLiveEditingJobResponse submitLiveEditingJobWithOptions(shared_ptr<SubmitLiveEditingJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitLiveEditingJobResponse submitLiveEditingJob(shared_ptr<SubmitLiveEditingJobRequest> request);
  SubmitLiveRecordJobResponse submitLiveRecordJobWithOptions(shared_ptr<SubmitLiveRecordJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitLiveRecordJobResponse submitLiveRecordJob(shared_ptr<SubmitLiveRecordJobRequest> request);
  SubmitLiveSnapshotJobResponse submitLiveSnapshotJobWithOptions(shared_ptr<SubmitLiveSnapshotJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitLiveSnapshotJobResponse submitLiveSnapshotJob(shared_ptr<SubmitLiveSnapshotJobRequest> request);
  SubmitLiveTranscodeJobResponse submitLiveTranscodeJobWithOptions(shared_ptr<SubmitLiveTranscodeJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitLiveTranscodeJobResponse submitLiveTranscodeJob(shared_ptr<SubmitLiveTranscodeJobRequest> request);
  SubmitMediaAiAnalysisJobResponse submitMediaAiAnalysisJobWithOptions(shared_ptr<SubmitMediaAiAnalysisJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMediaAiAnalysisJobResponse submitMediaAiAnalysisJob(shared_ptr<SubmitMediaAiAnalysisJobRequest> request);
  SubmitMediaCensorJobResponse submitMediaCensorJobWithOptions(shared_ptr<SubmitMediaCensorJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMediaCensorJobResponse submitMediaCensorJob(shared_ptr<SubmitMediaCensorJobRequest> request);
  SubmitMediaConvertJobResponse submitMediaConvertJobWithOptions(shared_ptr<SubmitMediaConvertJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMediaConvertJobResponse submitMediaConvertJob(shared_ptr<SubmitMediaConvertJobRequest> request);
  SubmitMediaInfoJobResponse submitMediaInfoJobWithOptions(shared_ptr<SubmitMediaInfoJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMediaInfoJobResponse submitMediaInfoJob(shared_ptr<SubmitMediaInfoJobRequest> request);
  SubmitMediaProducingJobResponse submitMediaProducingJobWithOptions(shared_ptr<SubmitMediaProducingJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitMediaProducingJobResponse submitMediaProducingJob(shared_ptr<SubmitMediaProducingJobRequest> request);
  SubmitPackageJobResponse submitPackageJobWithOptions(shared_ptr<SubmitPackageJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitPackageJobResponse submitPackageJob(shared_ptr<SubmitPackageJobRequest> request);
  SubmitProjectExportJobResponse submitProjectExportJobWithOptions(shared_ptr<SubmitProjectExportJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitProjectExportJobResponse submitProjectExportJob(shared_ptr<SubmitProjectExportJobRequest> request);
  SubmitScreenMediaHighlightsJobResponse submitScreenMediaHighlightsJobWithOptions(shared_ptr<SubmitScreenMediaHighlightsJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitScreenMediaHighlightsJobResponse submitScreenMediaHighlightsJob(shared_ptr<SubmitScreenMediaHighlightsJobRequest> request);
  SubmitSegmentationJobResponse submitSegmentationJobWithOptions(shared_ptr<SubmitSegmentationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSegmentationJobResponse submitSegmentationJob(shared_ptr<SubmitSegmentationJobRequest> request);
  SubmitSmarttagJobResponse submitSmarttagJobWithOptions(shared_ptr<SubmitSmarttagJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSmarttagJobResponse submitSmarttagJob(shared_ptr<SubmitSmarttagJobRequest> request);
  SubmitSnapshotJobResponse submitSnapshotJobWithOptions(shared_ptr<SubmitSnapshotJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSnapshotJobResponse submitSnapshotJob(shared_ptr<SubmitSnapshotJobRequest> request);
  SubmitSportsHighlightsJobResponse submitSportsHighlightsJobWithOptions(shared_ptr<SubmitSportsHighlightsJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSportsHighlightsJobResponse submitSportsHighlightsJob(shared_ptr<SubmitSportsHighlightsJobRequest> request);
  SubmitStandardCustomizedVoiceJobResponse submitStandardCustomizedVoiceJobWithOptions(shared_ptr<SubmitStandardCustomizedVoiceJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitStandardCustomizedVoiceJobResponse submitStandardCustomizedVoiceJob(shared_ptr<SubmitStandardCustomizedVoiceJobRequest> request);
  SubmitSyncMediaInfoJobResponse submitSyncMediaInfoJobWithOptions(shared_ptr<SubmitSyncMediaInfoJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSyncMediaInfoJobResponse submitSyncMediaInfoJob(shared_ptr<SubmitSyncMediaInfoJobRequest> request);
  SubmitTextGenerateJobResponse submitTextGenerateJobWithOptions(shared_ptr<SubmitTextGenerateJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitTextGenerateJobResponse submitTextGenerateJob(shared_ptr<SubmitTextGenerateJobRequest> request);
  SubmitTraceAbJobResponse submitTraceAbJobWithOptions(shared_ptr<SubmitTraceAbJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitTraceAbJobResponse submitTraceAbJob(shared_ptr<SubmitTraceAbJobRequest> request);
  SubmitTraceExtractJobResponse submitTraceExtractJobWithOptions(shared_ptr<SubmitTraceExtractJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitTraceExtractJobResponse submitTraceExtractJob(shared_ptr<SubmitTraceExtractJobRequest> request);
  SubmitTraceM3u8JobResponse submitTraceM3u8JobWithOptions(shared_ptr<SubmitTraceM3u8JobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitTraceM3u8JobResponse submitTraceM3u8Job(shared_ptr<SubmitTraceM3u8JobRequest> request);
  SubmitTranscodeJobResponse submitTranscodeJobWithOptions(shared_ptr<SubmitTranscodeJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitTranscodeJobResponse submitTranscodeJob(shared_ptr<SubmitTranscodeJobRequest> request);
  SubmitVideoTranslationJobResponse submitVideoTranslationJobWithOptions(shared_ptr<SubmitVideoTranslationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitVideoTranslationJobResponse submitVideoTranslationJob(shared_ptr<SubmitVideoTranslationJobRequest> request);
  TakeoverAIAgentCallResponse takeoverAIAgentCallWithOptions(shared_ptr<TakeoverAIAgentCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TakeoverAIAgentCallResponse takeoverAIAgentCall(shared_ptr<TakeoverAIAgentCallRequest> request);
  UpdateAIAgentInstanceResponse updateAIAgentInstanceWithOptions(shared_ptr<UpdateAIAgentInstanceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAIAgentInstanceResponse updateAIAgentInstance(shared_ptr<UpdateAIAgentInstanceRequest> request);
  UpdateAdInsertionResponse updateAdInsertionWithOptions(shared_ptr<UpdateAdInsertionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAdInsertionResponse updateAdInsertion(shared_ptr<UpdateAdInsertionRequest> request);
  UpdateAvatarTrainingJobResponse updateAvatarTrainingJobWithOptions(shared_ptr<UpdateAvatarTrainingJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAvatarTrainingJobResponse updateAvatarTrainingJob(shared_ptr<UpdateAvatarTrainingJobRequest> request);
  UpdateCategoryResponse updateCategoryWithOptions(shared_ptr<UpdateCategoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCategoryResponse updateCategory(shared_ptr<UpdateCategoryRequest> request);
  UpdateChannelResponse updateChannelWithOptions(shared_ptr<UpdateChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateChannelResponse updateChannel(shared_ptr<UpdateChannelRequest> request);
  UpdateCustomTemplateResponse updateCustomTemplateWithOptions(shared_ptr<UpdateCustomTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCustomTemplateResponse updateCustomTemplate(shared_ptr<UpdateCustomTemplateRequest> request);
  UpdateCustomizedVoiceResponse updateCustomizedVoiceWithOptions(shared_ptr<UpdateCustomizedVoiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCustomizedVoiceResponse updateCustomizedVoice(shared_ptr<UpdateCustomizedVoiceRequest> request);
  UpdateEditingProjectResponse updateEditingProjectWithOptions(shared_ptr<UpdateEditingProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEditingProjectResponse updateEditingProject(shared_ptr<UpdateEditingProjectRequest> request);
  UpdateHotwordLibraryResponse updateHotwordLibraryWithOptions(shared_ptr<UpdateHotwordLibraryRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateHotwordLibraryResponse updateHotwordLibrary(shared_ptr<UpdateHotwordLibraryRequest> request);
  UpdateLivePackageChannelResponse updateLivePackageChannelWithOptions(shared_ptr<UpdateLivePackageChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLivePackageChannelResponse updateLivePackageChannel(shared_ptr<UpdateLivePackageChannelRequest> request);
  UpdateLivePackageChannelCredentialsResponse updateLivePackageChannelCredentialsWithOptions(shared_ptr<UpdateLivePackageChannelCredentialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLivePackageChannelCredentialsResponse updateLivePackageChannelCredentials(shared_ptr<UpdateLivePackageChannelCredentialsRequest> request);
  UpdateLivePackageChannelGroupResponse updateLivePackageChannelGroupWithOptions(shared_ptr<UpdateLivePackageChannelGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLivePackageChannelGroupResponse updateLivePackageChannelGroup(shared_ptr<UpdateLivePackageChannelGroupRequest> request);
  UpdateLivePackageOriginEndpointResponse updateLivePackageOriginEndpointWithOptions(shared_ptr<UpdateLivePackageOriginEndpointRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLivePackageOriginEndpointResponse updateLivePackageOriginEndpoint(shared_ptr<UpdateLivePackageOriginEndpointRequest> request);
  UpdateLiveRecordTemplateResponse updateLiveRecordTemplateWithOptions(shared_ptr<UpdateLiveRecordTemplateRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveRecordTemplateResponse updateLiveRecordTemplate(shared_ptr<UpdateLiveRecordTemplateRequest> request);
  UpdateLiveSnapshotTemplateResponse updateLiveSnapshotTemplateWithOptions(shared_ptr<UpdateLiveSnapshotTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveSnapshotTemplateResponse updateLiveSnapshotTemplate(shared_ptr<UpdateLiveSnapshotTemplateRequest> request);
  UpdateLiveTranscodeJobResponse updateLiveTranscodeJobWithOptions(shared_ptr<UpdateLiveTranscodeJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveTranscodeJobResponse updateLiveTranscodeJob(shared_ptr<UpdateLiveTranscodeJobRequest> request);
  UpdateLiveTranscodeTemplateResponse updateLiveTranscodeTemplateWithOptions(shared_ptr<UpdateLiveTranscodeTemplateRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLiveTranscodeTemplateResponse updateLiveTranscodeTemplate(shared_ptr<UpdateLiveTranscodeTemplateRequest> request);
  UpdateMediaConnectFlowInputResponse updateMediaConnectFlowInputWithOptions(shared_ptr<UpdateMediaConnectFlowInputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaConnectFlowInputResponse updateMediaConnectFlowInput(shared_ptr<UpdateMediaConnectFlowInputRequest> request);
  UpdateMediaConnectFlowOutputResponse updateMediaConnectFlowOutputWithOptions(shared_ptr<UpdateMediaConnectFlowOutputRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaConnectFlowOutputResponse updateMediaConnectFlowOutput(shared_ptr<UpdateMediaConnectFlowOutputRequest> request);
  UpdateMediaConnectFlowStatusResponse updateMediaConnectFlowStatusWithOptions(shared_ptr<UpdateMediaConnectFlowStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaConnectFlowStatusResponse updateMediaConnectFlowStatus(shared_ptr<UpdateMediaConnectFlowStatusRequest> request);
  UpdateMediaInfoResponse updateMediaInfoWithOptions(shared_ptr<UpdateMediaInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaInfoResponse updateMediaInfo(shared_ptr<UpdateMediaInfoRequest> request);
  UpdateMediaLiveChannelResponse updateMediaLiveChannelWithOptions(shared_ptr<UpdateMediaLiveChannelRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaLiveChannelResponse updateMediaLiveChannel(shared_ptr<UpdateMediaLiveChannelRequest> request);
  UpdateMediaLiveInputResponse updateMediaLiveInputWithOptions(shared_ptr<UpdateMediaLiveInputRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaLiveInputResponse updateMediaLiveInput(shared_ptr<UpdateMediaLiveInputRequest> request);
  UpdateMediaLiveInputSecurityGroupResponse updateMediaLiveInputSecurityGroupWithOptions(shared_ptr<UpdateMediaLiveInputSecurityGroupRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaLiveInputSecurityGroupResponse updateMediaLiveInputSecurityGroup(shared_ptr<UpdateMediaLiveInputSecurityGroupRequest> request);
  UpdateMediaMarksResponse updateMediaMarksWithOptions(shared_ptr<UpdateMediaMarksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaMarksResponse updateMediaMarks(shared_ptr<UpdateMediaMarksRequest> request);
  UpdateMediaToSearchLibResponse updateMediaToSearchLibWithOptions(shared_ptr<UpdateMediaToSearchLibRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMediaToSearchLibResponse updateMediaToSearchLib(shared_ptr<UpdateMediaToSearchLibRequest> request);
  UpdatePipelineResponse updatePipelineWithOptions(shared_ptr<UpdatePipelineRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePipelineResponse updatePipeline(shared_ptr<UpdatePipelineRequest> request);
  UpdateProgramResponse updateProgramWithOptions(shared_ptr<UpdateProgramRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProgramResponse updateProgram(shared_ptr<UpdateProgramRequest> request);
  UpdateRtcRobotInstanceResponse updateRtcRobotInstanceWithOptions(shared_ptr<UpdateRtcRobotInstanceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRtcRobotInstanceResponse updateRtcRobotInstance(shared_ptr<UpdateRtcRobotInstanceRequest> request);
  UpdateSourceResponse updateSourceWithOptions(shared_ptr<UpdateSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSourceResponse updateSource(shared_ptr<UpdateSourceRequest> request);
  UpdateSourceLocationResponse updateSourceLocationWithOptions(shared_ptr<UpdateSourceLocationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSourceLocationResponse updateSourceLocation(shared_ptr<UpdateSourceLocationRequest> request);
  UpdateTemplateResponse updateTemplateWithOptions(shared_ptr<UpdateTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTemplateResponse updateTemplate(shared_ptr<UpdateTemplateRequest> request);
  UploadMediaByURLResponse uploadMediaByURLWithOptions(shared_ptr<UploadMediaByURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadMediaByURLResponse uploadMediaByURL(shared_ptr<UploadMediaByURLRequest> request);
  UploadStreamByURLResponse uploadStreamByURLWithOptions(shared_ptr<UploadStreamByURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadStreamByURLResponse uploadStreamByURL(shared_ptr<UploadStreamByURLRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_ICE20201109

#endif
